<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c70304d7b52b8f4e76c37fd1e35de0928f9619c7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680547" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>프레임워크별 속성 시스템 특성을 구체적으로 추가하여 종속성 속성에 대한 메타데이터를 보고하거나 적용합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스에서 파생 <xref:System.Windows.PropertyMetadata> (통해 <xref:System.Windows.UIPropertyMetadata>). 대부분의 WPF 프레임 워크 수준 응용 프로그램 개발 목적에 대 한 <xref:System.Windows.FrameworkPropertyMetadata> 는 기본 메타 데이터 형식인 것이 아니라 종속성 속성 메타 데이터에 사용 된 형식을 <xref:System.Windows.PropertyMetadata> 또는 <xref:System.Windows.UIPropertyMetadata>합니다. 이 대부분의 사용자 지정 종속성 속성이 시나리오와 기존 종속성 속성에 적용 합니다.  
  
 이 선언 된 멤버 보완 하는 클래스는 <xref:System.Windows.PropertyMetadata> 지정 하거나 속성 상속, 데이터 바인딩 및 레이아웃 WPF 프레임 워크 수준 속성 시스템 문제를 보고 하는 다양 한 부울 속성을 포함 하는 기본 클래스입니다.  
  
 만들기 위한 몇 가지 생성자 시그니처는 <xref:System.Windows.FrameworkPropertyMetadata> 인스턴스 take는 <xref:System.Windows.FrameworkPropertyMetadataOptions> 매개 변수입니다. <xref:System.Windows.FrameworkPropertyMetadataOptions> 열거형 생성자에 초기 동작을 지정 하는 데에 사용 되 고 후 노출 되지 않는 <xref:System.Windows.FrameworkPropertyMetadata> 생성 됩니다. 생성 된 인스턴스에서 있습니다 수 가져오거나 생성자 호출에 사용 되는 열거형 값의 이름을 공유 하는 다양 한 속성을 통해 해당 정보를 설정 합니다.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스에 사용 되는 것은 일반적으로 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 메타 데이터를 가져옵니다는 종속성 속성에 대 한 특정 소유자의 초기도 기본 <xref:System.Windows.PropertyMetadata> 유형입니다. 해당 메타 데이터는 <xref:System.Windows.FrameworkPropertyMetadata>합니다. 유효한 반환 되 면 <xref:System.Windows.FrameworkPropertyMetadata>, 다양 한 다음 <xref:System.Windows.FrameworkPropertyMetadata> (표시 되지 않음) 하는 간단한 UI를 통해 속성 값을 보고 합니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 값을 초기화 하는이 서명을 <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> 속성 기본값으로 합니다. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 됩니다 `null`, 및 다양 한 <xref:System.Windows.FrameworkPropertyMetadata> 부울 속성이 됩니다 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</param>
        <summary>지정된 기본값을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 됩니다. 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 일치 하지 않습니다 컴파일하는 동안 불일치를 감지할 수 없기 때문에 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 특별 한 의미가 있으며는 종속성 속성의 기본 값으로 사용할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <summary>지정된 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 콜백을 사용하여 <see cref="T:System.Windows.PropertyChangedCallback" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</param>
        <param name="flags">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다. 이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</param>
        <summary>제공된 기본값과 프레임워크 수준 메타데이터 옵션을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 됩니다. 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 일치 하지 않습니다 컴파일하는 동안 불일치를 감지할 수 없기 때문에 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 특별 한 의미가 있으며는 종속성 속성의 기본 값으로 사용할 수 없습니다.  
  
 값에 플래그를 설정으로 표시는 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`합니다. 특정 속성 시스템 작업에 적용 된 이후에 메타 데이터에서 속성의 값을 변경할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <summary>제공된 기본값 및 지정된 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 콜백을 사용하여 <see cref="T:System.Windows.PropertyChangedCallback" />의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 됩니다. 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 일치 하지 않습니다 컴파일하는 동안 불일치를 감지할 수 없기 때문에 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 특별 한 의미가 있으며는 종속성 속성의 기본 값으로 사용할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <param name="coerceValueCallback">속성 시스템에서 이 종속성 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</param>
        <summary>지정된 콜백을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 구현은 기본 이니셜라이저를 호출 하 고 다음 추가 `coerceValueCallback` 기본 인스턴스에서 속성을 설정 합니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</param>
        <param name="flags">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다. 이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <summary>제공된 기본값, 프레임워크 메타데이터 옵션 및 지정된 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 콜백을 사용하여 <see cref="T:System.Windows.PropertyChangedCallback" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 됩니다. 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 일치 하지 않습니다 컴파일하는 동안 불일치를 감지할 수 없기 때문에 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 특별 한 의미가 있으며는 종속성 속성의 기본 값으로 사용할 수 없습니다.  
  
 값에 플래그를 설정으로 표시는 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`합니다. 특정 속성 시스템 작업에 적용 된 상태로 계속 메타 데이터에서 속성의 값을 변경할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <param name="coerceValueCallback">속성 시스템에서 이 종속성 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</param>
        <summary>제공된 기본값 및 지정된 콜백을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" />의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 됩니다. 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 일치 하지 않습니다 컴파일하는 동안 불일치를 감지할 수 없기 때문에 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 특별 한 의미가 있으며는 종속성 속성의 기본 값으로 사용할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</param>
        <param name="flags">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다. 이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <param name="coerceValueCallback">속성 시스템에서 이 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</param>
        <summary>제공된 기본값, 프레임워크 메타데이터 옵션 및 지정된 콜백을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 됩니다. 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 일치 하지 않습니다 컴파일하는 동안 불일치를 감지할 수 없기 때문에 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 특별 한 의미가 있으며는 종속성 속성의 기본 값으로 사용할 수 없습니다.  
  
 값에 플래그를 설정으로 표시는 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`합니다. 특정 속성 시스템 작업에 적용 된 상태로 계속 메타 데이터에서 속성의 값을 변경할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</param>
        <param name="flags">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다. 이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <param name="coerceValueCallback">속성 시스템에서 이 종속성 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</param>
        <param name="isAnimationProhibited">
          속성 시스템에서 이 메타데이터가 적용되는 속성에 애니메이션을 사용하지 않게 하려면 <see langword="true" />입니다. 이러한 속성에 애니메이션을 적용하려고 하면 속성 시스템에서 런타임 예외가 발생합니다. 속성에 애니메이션을 적용할 수 있게 하려면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</param>
        <summary>제공된 기본값, 프레임워크 메타데이터 옵션, 지정된 콜백 및 속성 애니메이션을 금지할 수 있는 부울 값을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 됩니다. 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 일치 하지 않습니다 컴파일하는 동안 불일치를 감지할 수 없기 때문에 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 특별 한 의미가 있으며는 종속성 속성의 기본 값으로 사용할 수 없습니다.  
  
 `isAnimationProhibited` 의 초기 값을 설정 하는 매개 변수는 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 는 직접 기본 속성 선언 <xref:System.Windows.UIPropertyMetadata> 클래스입니다.  
  
 값에 플래그를 설정으로 표시는 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`합니다. 특정 속성 시스템 작업에 적용 된 상태로 계속 메타 데이터에서 속성의 값을 변경할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</param>
        <param name="flags">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다. 이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <param name="coerceValueCallback">속성 시스템에서 이 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</param>
        <param name="isAnimationProhibited">
          속성 시스템에서 이 메타데이터가 적용되는 속성에 애니메이션을 사용하지 않게 하려면 <see langword="true" />입니다. 이러한 속성에 애니메이션을 적용하려고 하면 속성 시스템에서 런타임 예외가 발생합니다. 기본값은 <see langword="false" />입니다.</param>
        <param name="defaultUpdateSourceTrigger">
          <see cref="T:System.Windows.Data.UpdateSourceTrigger" />가 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />로 설정된 경우 이 속성에 대한 바인딩이 적용될 때 사용할 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />입니다.</param>
        <summary>제공된 기본값, 프레임워크 메타데이터 옵션, 지정된 콜백, 속성 애니메이션을 금지할 수 있는 부울 값 및 데이터 바인딩 업데이트 트리거 기본값을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 됩니다. 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 일치 하지 않습니다 컴파일하는 동안 불일치를 감지할 수 없기 때문에 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 특별 한 의미가 있으며는 종속성 속성의 기본 값으로 사용할 수 없습니다.  
  
 `isAnimationProhibited` 의 초기 값을 설정 하는 매개 변수는 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 는 직접 기본 속성 선언 <xref:System.Windows.UIPropertyMetadata> 클래스입니다.  
  
 바인딩 소스 업데이트 동작에 대 한 자세한 내용은 참조 [데이터 바인딩 개요](~/docs/framework/wpf/data/data-binding-overview.md)합니다.  
  
 값에 플래그를 설정으로 표시는 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`합니다. 특정 속성 시스템 작업에 적용 된 상태로 계속 메타 데이터에서 속성의 값을 변경할 수 있습니다.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>레이아웃 엔진 작업 중 종속성 속성이 정렬 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          이 메타데이터가 있는 종속성 속성이 정렬 단계에 잠재적으로 영향을 주면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 존재 하는 모든 종속성 속성의 유효 값 변경 내용을 모니터링 하는입니다. 이 논리의 일부로, 적용을 변경 하는 종속성 속성 값 한 메타 데이터와 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 로 설정 `true` 해당 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다 (에 대 한 호출 <xref:System.Windows.UIElement.InvalidateArrange%2A>). WPF 프레임 워크 수준 구현에이 위치에 이미 이기 때문에 일반적으로 불필요 종속성 속성을 보려는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 대체로 교체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.  
  
 사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현 종속성 속성이 변경에 대 한 유사한 동작을 선택할 수 있습니다 위치 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 은 `true`합니다.  
  
 속성의 파생된 클래스에서 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 후 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버는 대개 사용 되지에서 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드에서 다양 한 종속성 기본 메타 데이터를 가져오며, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성, "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 하 고 있습니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>레이아웃 엔진 작업 중 종속성 속성이 측정 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          이 메타데이터가 있는 종속성 속성이 측정 단계에 잠재적으로 영향을 주면 <see langword="true" />이고, 영향을 주지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 존재 하는 모든 종속성 속성의 유효 값 변경 내용을 모니터링 하는입니다. 이 논리의 일부로, 적용을 변경 하는 종속성 속성 값 한 메타 데이터와 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 로 설정 `true` 해당 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다. WPF 프레임 워크 수준 구현에이 위치에 이미 이기 때문에 일반적으로 불필요 종속성 속성을 보려는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 대체로 교체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.  
  
 사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현 종속성 속성이 변경에 대 한 유사한 동작을 선택할 수 있습니다 위치 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 은 `true`합니다.  
  
 속성의 파생된 클래스에서 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 후 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드에서 다양 한 종속성 기본 메타 데이터를 가져오며, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성, "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 하 고 있습니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>레이아웃 엔진 작업 중 종속성 속성이 부모 요소 레이아웃의 정렬 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          이 메타데이터가 적용되는 종속성 속성에 따라 특히 부모 요소의 정렬 처리 단계가 영향을 받을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 존재 하는 모든 종속성 속성의 유효 값 변경 내용을 모니터링 하는입니다. 이 논리의 일부로, 적용을 변경 하는 종속성 속성 값 한 메타 데이터와 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 로 설정 `true` 부모 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다.  
  
 일반적으로 불필요의 <xref:System.Windows.FrameworkElement> 속성을 사용 하 여 부모 요소 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 이미 있기 때문에 요소 자체는 고유한 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 으로 `true`합니다. 일반적으로 즉, 부모 적절 한 경우 정렬 된 자식 요소에 대 한 변경 내용을 일반적으로 시작 하므로 합니다. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 에 사용 되는 경우가 <xref:System.Windows.FrameworkContentElement> 클래스를 파생 합니다. 이 경우, 자식 요소 집합 속성을 제외 하 고 <xref:System.Windows.FrameworkContentElement> 파생된 클래스는 자체 렌더링을 제어 하지 않습니다. 렌더링 하 여 처리 되는 <xref:System.Windows.FrameworkElement> 콘텐츠 호스트 역할을 하는 부모 요소입니다. 예를 들어,의 값을 변경은 <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 자식 요소에서 연결 된 속성을 무효화 부모에서는 자식 요소의 위치를 변경 해야 하기 때문에 부모를 정렬 합니다. 따라서는 <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 연결 된 속성에 메타 데이터 위치 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 은 `true`합니다. 또 다른 예로 <xref:System.Windows.Controls.Control.Padding%2A>때가이 속성 변경 내용을 상위 변경 될 수 있습니다 사용 가능한 공간에 따라 자식 위치를 지정 합니다.  
  
 WPF 프레임 워크 수준 구현에이 위치에 이미 이기 때문에 일반적으로 불필요 종속성 속성을 보려는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 대체로 교체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.  
  
 사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현 종속성 속성이 변경에 대 한 유사한 동작을 선택할 수 있습니다 위치 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 은 `true`합니다.  
  
 에 대 한 속성의 파생 클래스 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 후 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>레이아웃 엔진 작업 중 종속성 속성이 부모 요소 레이아웃의 측정 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          이 메타데이터가 적용되는 종속성 속성에 따라 특히 부모 요소의 측정 처리 단계가 영향을 받을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 존재 하는 모든 종속성 속성의 유효 값 변경 내용을 모니터링 하는입니다. 이 논리의 일부로, 적용을 변경 하는 종속성 속성 값 한 메타 데이터와 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 로 설정 `true` 부모 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다. WPF 프레임 워크 수준 구현에이 위치에 이미 이기 때문에 일반적으로 불필요 종속성 속성을 보려는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 대체로 교체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.  
  
 일반적으로 불필요의 <xref:System.Windows.FrameworkElement> 속성을 사용 하 여 부모 요소 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 이미 있기 때문에 요소 자체는 고유한 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 으로 `true`합니다. 적절 한 경우 부모 측정 단계를 일반적으로 시작 하는 자식 요소가 변경 때문 충분입니다. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 에 사용 되는 경우가 <xref:System.Windows.FrameworkContentElement> 클래스를 파생 합니다. 이 경우, 자식 요소 집합 속성을 제외 하 고 <xref:System.Windows.FrameworkContentElement> 파생된 클래스는 자체 렌더링을 제어 하지 않습니다. 렌더링 하 여 처리 되는 <xref:System.Windows.FrameworkElement> 콘텐츠 호스트 역할을 하는 부모 요소입니다. 예를 들어,의 값을 변경은 <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> 단락 상대 간격이 될 수 있습니다 변경 및 수를 늘리거나 콘텐츠 호스트 크기 때문에 자식 요소에서 속성 부모의 측정을 무효화 합니다. 따라서는 <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> 속성 메타 데이터에는 여기서 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 은 `true`합니다.  
  
 콘텐츠 호스트 요소 종속성 속성의 변경 내용을 자주 확인 여기서 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 은 `true`, 콘텐츠 호스트 렌더링 논리의 일부로 합니다. 예를 들어,는 <xref:System.Windows.Controls.TextBox> 의 경계 상자 요소는 필요할 수 있는 텍스트 내에서 특정 변경 내용에 응답 해야는 <xref:System.Windows.Controls.TextBox> 자체를 변경할 수 있습니다.  
  
 사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현 종속성 속성이 변경에 대 한 유사한 동작을 선택할 수 있습니다 위치 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 은 `true`합니다.  
  
 에 대 한 속성의 파생 클래스 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 후 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>종속성 속성은 정렬이나 측정에 특별히 영향을 주지 않는 어떤 방식으로 일반 레이아웃에 잠재적으로 영향을 주는지 여부를 나타내지만 다시 그리기를 필요로 하는 값을 가져오거나 설정합니다.</summary>
        <value>
          이 메타데이터가 적용되는 종속성 속성이 렌더링에 영향을 줄 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 존재 하는 모든 종속성 속성의 유효 값 변경 내용을 모니터링 하는입니다. 이 논리의 일부로, 적용을 변경 하는 종속성 속성 값 한 메타 데이터와 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 로 설정 `true` 해당 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다. WPF 프레임 워크 수준 구현에이 위치에 이미 이기 때문에 일반적으로 불필요 종속성 속성을 보려는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 대체로 교체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.  
  
 사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현 종속성 속성이 변경에 대 한 유사한 동작을 선택할 수 있습니다 위치 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 은 `true`합니다.  
  
 에 대 한 속성의 파생 클래스 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 후 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드에서 다양 한 종속성 기본 메타 데이터를 가져오며, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성, "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 하 고 있습니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>속성이 기본적으로 양방향으로 바인드하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          이 메타데이터가 존재하는 종속성 속성이 기본적으로 양방향으로 바인드하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 없는 경우이 속성의 `true`, 바인딩 업데이트는 기본적으로의 기본 동작에 따라 단방향는 <xref:System.Windows.Data.Binding> 생성자 또는 이와 동등한 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문입니다.  
  
 기존 요소를 찾을 수 있습니다 일반적으로이 속성을 설정 `true` 모두 상태 보고 및 예를 들어 사용자 작업을 통해 수정할 수는 종속성 속성에 대 한 메타 데이터에 <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>합니다.  
  
 이 속성만 종속성 속성의 기본 바인딩 업데이트 특성은 일반적 보고 합니다. 인스턴스에서이 속성으로 설정 하는 바인딩 로컬로 설정 수는 <xref:System.Windows.Data.Binding.Mode%2A> 바인딩의 속성을이 기본값을 변경 합니다.  
  
 에 대 한 속성의 파생 클래스 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 후 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드에서 다양 한 종속성 기본 메타 데이터를 가져오며, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성, "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 하 고 있습니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Data.UpdateSourceTrigger" />가 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />로 설정된 경우 이 메타데이터가 있는 속성에 바인딩이 적용될 때 사용할 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />의 기본값을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />를 제외한 열거형 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성의 파생된 클래스에서 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 후 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">이 속성이 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />로 설정된 경우. 이 속성에 설정하는 값은 바인딩에서 요청할 때 기본값이 되어야 합니다.</exception>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>종속성 속성의 값이 상속되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          속성 값을 상속할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 값 상속의 기능은 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 그에 따라 특정 종속성 속성이 로컬로에 설정 될 수는 요소 또는 그 직전의 루트에 WPF 프레임 워크 수준 속성 시스템은 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 요소 트리를 상속 하 여 순서 값이 해당 값 해당 속성을 공유 하는 자식 요소의 논리적 트리 내에서 모든 요소입니다. 속성 값 상속 기본적으로 사용 되지 않습니다 있고 설정 되어 있으므로 일부 성능 영향을 줍니다. 자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하십시오.  
  
> [!NOTE]
>  속성 값 상속 나타날 수 있지만 연결 되지 않은 종속성 속성에 대해 작동 하도록를 통해 특정 개체 간 구역 런타임 트리의 연결 되지 않은 속성에 대 한 상속 동작이 정의 되지 않습니다. 항상 사용 하 여 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 지정 하는 속성을 등록 하려면 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 메타 데이터에 있습니다.  
  
 속성의 파생된 클래스에서 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 후 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드에서 다양 한 종속성 기본 메타 데이터를 가져오며, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성, "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 하 고 있습니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>종속성 속성에 대한 데이터 바인딩을 지원하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          이 메타데이터가 적용되는 종속성 속성에 데이터 바인딩이 지원되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 보고 `false` 가능한 두 조건 중 하나에 대 한: 종속성 속성에 데이터 바인딩 중 하나는 종속성 속성 (으로, 보고 된 종속성 속성 식별자로 메타 데이터가 아니라) 읽기 전용 이므로 사용할 수 없습니다은 또는의 값 다른 메타 데이터 속성 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>로 설정 된 `true` 이 메타 데이터에 있습니다. 이 속성은 편의 위해 둘 다 확인할 호출자가 보유 하지 않는 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 및 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>합니다.  
  
 플래그를 지정 하는 경우는 그렇지 않으면 읽기/쓰기 속성이 데이터 바인딩을 지원 하지 않도록 지정 하는 메타 데이터를 만들려면, <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (참고는 약간의 가능 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드에서 다양 한 종속성 기본 메타 데이터를 가져오며, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성, "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 하 고 있습니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>종속성 속성이 데이터 바인딩을 지원하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          속성에서 데이터 바인딩이 지원되지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참고로이 메타 데이터 속성이 설정 되어 있는지 `true` 특히 속성에는 데이터 바인딩, 읽기 / 쓰기 가능 속성을 지원 하지 않아야 합니다. 예상이는 대부분의 경우 종속성 속성 선언 된 데이터 바인딩, 데이터 바인딩이 종속성 속성은 유용한 주요 시나리오 중 하나 이므로 합니다. 와 달리 <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>,이 단순히 특정 바인딩에서 이후에 변경 될 수 있는 기본값을 변경 하지 않습니다. 이 속성을 설정할 `true` 메타 데이터 종속성 속성에 대 한 메타 데이터에서 해당 종속성 속성에 식을 통해 값을 적용 하는의 모든 바인딩 해제 됩니다.  
  
 읽기 전용 종속성 속성 데이터 바인딩 (했기 때문에 변경 된 값을 적용할 수 있는 setter) 지원 하지 않지만 여전히 보고서 `false` 에 대 한 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>합니다. 에 해당 하는 속성 때문에 이것이 <xref:System.Windows.FrameworkPropertyMetadataOptions> 값 메타 데이터를 실제로 설정 방법, 항상 의미 하는 속성의 이름을 지정 하는 최종 결과 동작을 보고 하는 대신 따라 패리티를 보고 합니다. 지정된 된 종속성 속성에 데이터 바인딩에서 허용 되는지 여부를 확인 하려면 일반적으로 확인해 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 대신 합니다. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 둘 다 검사에 대 한 편리한 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 및 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> 를 단일 작업으로 예상된 결과 생성 합니다.  
  
 속성의 파생된 클래스에서 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 후 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성이 응용 프로그램에서 저널링 구현의 일부로 저장할 수 있거나 저장해야 하는 저널링 정보를 포함하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          <see langword="true" /> 이 메타 데이터가;에 적용 되는 종속성 속성에 저널링을 수행 해야 하는 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성의 파생된 클래스에서 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 후 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">병합할 기본 메타데이터입니다.</param>
        <param name="dp">이 메타데이터가 적용되는 종속성 속성입니다.</param>
        <summary>기본 메타데이터와 원본 메타 데이터의 병합을 사용하도록 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 메타 데이터 재정의 될 때 내부적으로 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>파생 된 클래스 <see cref="T:System.Windows.PropertyMetadata" /> (또는 특히 클래스가) 구현에서 추가한 모든 메타 데이터 속성을 설명 하기 위해이 메서드를 재정의 해야 합니다. 예를 들어, 구현 추가 했을 수는 새 플래그 열거형 값 및 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 구현을 올바르게 이러한 플래그를 결합 할 수 있어야 합니다.  
  
 계층의 이전 형식을에 이미 정의 된 모든 속성을 병합 해 주므로 때문에 사용자 고유의 구현 하기 전에 기본 구현을 항상 호출 합니다.  
  
 추가 하는 동작은 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 구현이 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 특정 WPF 프레임 워크 수준 속성은와 같은 메타 데이터에 <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> 에 비트 결합 됩니다 또는 작업입니다.  
  
 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 호출 하 여 기존 종속성 속성의 속성 메타 데이터를 재정의 하면도 동작을 구현 동작 <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />., 재정의 된 메타 데이터를 사용 하 여 <see cref="T:System.Windows.FrameworkPropertyMetadata" />합니다.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">메타데이터를 적용한 종속성 속성입니다.</param>
        <param name="targetType">형식별 메타데이터인 경우 이 메타데이터에 연결된 형식입니다. 기본 메타데이터인 경우에는 이 값이 <see langword="null" />일 수 있습니다.</param>
        <summary>이 메타데이터가 속성에 적용되어 메타데이터가 봉인될 때 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어떠한 방법으로의 데이터 구조는 <xref:System.Windows.FrameworkPropertyMetadata> 인스턴스 표시 해야 변경할 수 없는 것이 메서드가 호출 되 면입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 구현이 메서드의 기본 구현을 호출 하기만 해도 메시지를 표시 합니다.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>속성 값 상속 평가가 요소의 논리적 트리에서 특정 콘텐츠 경계를 넘을지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          특정 콘텐츠 경계에 걸쳐 속성 값이 상속되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메타 데이터는 특정 부모 요소의 자식 요소 경계를 넘어 수정 된 속성 값 상속 동작을 보고합니다. 이러한 경계는 정규 예제는의 내용을 <xref:System.Windows.Controls.Frame>, 여기서는 <xref:System.Windows.Controls.Frame> 의 존재 여부와 독립적으로 콘텐츠를 다시 로드 얻을 수 있습니다는 <xref:System.Windows.Controls.Frame>합니다. 원하는 속성 시스템 동작은의 내용에 속성 값 상속을 통과 해야 하지는 <xref:System.Windows.Controls.Frame>이므로 이러한 콘텐츠 요소일 수도 프레임을 호스팅하는 응용 프로그램을 소유 하거나 제어 하지 않습니다. 메타 데이터를 지정 하 <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> 로 설정 `true`지정, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 으로 `true`, 걸쳐 상속할 수 있도록 메타 데이터 적용 되는 속성은 <xref:System.Windows.Controls.Frame> 경계 또는 이와 유사한 경계입니다.  
  
 속성의 파생된 클래스에서 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 후 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>종속성 속성의 하위 속성이 포함하는 개체의 렌더링에 영향을 주지 않는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          하위 속성 값이 변경되어도 렌더링에 영향이 없으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메타 데이터 옵션은 종속성 속성에는 참조 형식이 해당 형식 자체의 속성 값에 대해 관련 있습니다. 일반적으로 레이아웃 시스템 논리는 종속성 속성 하위 속성에는 영향을 받을 레이아웃, 다른 렌더링 패스 변경에 대 한 모든 하위 속성을 확인 하는 것은 실제로 실행 중인 보다 더 많은 시간이 소요 되므로 생각 하는 것입니다. 이 옵션을 설정 `true` WPF 프레임 워크 수준 레이아웃 시스템 구현의 성능을 최적화 하는 데 유용 합니다.  
  
 속성의 파생된 클래스에서 <xref:System.Windows.PropertyMetadata> 는 일반적으로 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다. 이므로 인스턴스의 초기화 된 후 조정 될 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 된 경우 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 메타 데이터의 고유 정보를 제공 하는 현재 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하는 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>