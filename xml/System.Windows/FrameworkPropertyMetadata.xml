<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50e37bc8286c8ba1961d7a1c298161a3c9e3100c" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37492940" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="93ecf-101">프레임워크별 속성 시스템 특성을 구체적으로 추가하여 종속성 속성에 대한 메타데이터를 보고하거나 적용합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="93ecf-101">Reports or applies metadata for a dependency property, specifically adding framework-specific property system characteristics.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-102">이 클래스에서 파생 됩니다 <xref:System.Windows.PropertyMetadata> (통해 <xref:System.Windows.UIPropertyMetadata>).</span><span class="sxs-lookup"><span data-stu-id="93ecf-102">This class derives from <xref:System.Windows.PropertyMetadata> (through <xref:System.Windows.UIPropertyMetadata>) .</span></span> <span data-ttu-id="93ecf-103">대부분의 WPF 프레임 워크 수준 응용 프로그램 개발을 위해 <xref:System.Windows.FrameworkPropertyMetadata> 는 기본 메타 데이터 형식인 것이 아니라 종속성 속성 메타 데이터에 사용 된 형식과 <xref:System.Windows.PropertyMetadata> 또는 <xref:System.Windows.UIPropertyMetadata>합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-103">For most WPF framework-level application development purposes, <xref:System.Windows.FrameworkPropertyMetadata> is the type used for dependency property metadata, rather than the base metadata types <xref:System.Windows.PropertyMetadata> or <xref:System.Windows.UIPropertyMetadata>.</span></span> <span data-ttu-id="93ecf-104">기존 종속성 속성 및 대부분의 사용자 지정 종속성 속성 시나리오에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-104">This is true both for existing dependency properties and for most custom dependency property scenarios.</span></span>  
  
 <span data-ttu-id="93ecf-105">이 선언 된 멤버 보완 하는 클래스는 <xref:System.Windows.PropertyMetadata> 속성 상속, 데이터 바인딩 및 레이아웃과 같은 WPF 프레임 워크 수준 속성 시스템 동작을 보고 하거나 지정 하는 다양 한 부울 속성을 포함 하는 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-105">The members declared by this class that supplement the <xref:System.Windows.PropertyMetadata> base class include various Boolean properties that specify or report WPF framework-level property system behavior such as property inheritance, data binding, and layout.</span></span>  
  
 <span data-ttu-id="93ecf-106">만들기 위한 몇 가지 생성자 시그니처를 <xref:System.Windows.FrameworkPropertyMetadata> 인스턴스 사용을 <xref:System.Windows.FrameworkPropertyMetadataOptions> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-106">Several constructor signatures for creating a <xref:System.Windows.FrameworkPropertyMetadata> instance take a <xref:System.Windows.FrameworkPropertyMetadataOptions> parameter.</span></span> <span data-ttu-id="93ecf-107">합니다 <xref:System.Windows.FrameworkPropertyMetadataOptions> 열거형 생성자에서 초기 동작을 지정 하기 위해서만 사용 되 고 후 노출 되지 않는 <xref:System.Windows.FrameworkPropertyMetadata> 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-107">The <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeration is used only to specify initial behavior in the constructor, and is not otherwise exposed after <xref:System.Windows.FrameworkPropertyMetadata> is constructed.</span></span> <span data-ttu-id="93ecf-108">생성된 된 인스턴스를 가져올 수도 있고 생성자 호출에서 사용 되는 열거형 값의 이름을 공유 하는 다양 한 속성을 통해 해당 정보를 설정 키를 누릅니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-108">From a constructed instance, you can get or set the corresponding information through various properties that share the name of the enumeration values used in the constructor call.</span></span>  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-109">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-109">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-110">이 클래스는 일반적으로 사용 되지 않습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-110">This class is not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-111">다음 예제에서는 종속성 속성 메타 데이터를 특정 소유자의 초기도 기본 <xref:System.Windows.PropertyMetadata> 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-111">The following example gets metadata for a dependency property on a particular owner as the initial base <xref:System.Windows.PropertyMetadata> type.</span></span> <span data-ttu-id="93ecf-112">해당 메타 데이터는 <xref:System.Windows.FrameworkPropertyMetadata>합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-112">That metadata is cast to <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="93ecf-113">유효한 반환 되 면 <xref:System.Windows.FrameworkPropertyMetadata>, 다음 다양 한 <xref:System.Windows.FrameworkPropertyMetadata> 속성 값 (표시 되지 않음) 간단한 UI를 통해 보고 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-113">If the cast returned a valid <xref:System.Windows.FrameworkPropertyMetadata>, then various <xref:System.Windows.FrameworkPropertyMetadata> property values are reported through a simple UI (not shown).</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-114">
            <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-114">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class.</span>
          </span>
        </summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-115">
            <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-115">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-116">모든 값을 초기화 하는이 서명을 <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> 속성 기본값으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-116">This signature initializes all values of <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> to their property defaults.</span></span> <span data-ttu-id="93ecf-117"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> 됩니다 `null`, 및 다양 한 <xref:System.Windows.FrameworkPropertyMetadata> Boolean 속성 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-117"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> will be `null`, and the various <xref:System.Windows.FrameworkPropertyMetadata> Boolean properties will be `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="93ecf-118">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-118">The default value of the dependency property, usually provided as a value of a specific type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-119">지정된 기본값을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-119">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified default value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-120">제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-120">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="93ecf-121">컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-121">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="93ecf-122">속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-122">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="93ecf-123">값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-123">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-124">다음 예제에서는이 생성자 시그니처를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-124">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="93ecf-125">
            <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-125">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">
          <span data-ttu-id="93ecf-126">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-126">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-127">지정된 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 콜백을 사용하여 <see cref="T:System.Windows.PropertyChangedCallback" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-127">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="93ecf-128">다음 예제에서는이 생성자 시그니처를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-128">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="93ecf-129">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-129">The default value of the dependency property, usually provided as a value of a specific type.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="93ecf-130">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-130">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span>
          </span>
          <span data-ttu-id="93ecf-131">이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-131">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-132">제공된 기본값과 프레임워크 수준 메타데이터 옵션을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-132">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework-level metadata options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-133">제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-133">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="93ecf-134">컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-134">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="93ecf-135">속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-135">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="93ecf-136">값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-136">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="93ecf-137">값 집합 flags에서 플래그로 표시 된 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-137">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="93ecf-138">이후에 특정 속성 시스템 작업에 적용 된 메타 데이터에서 속성의 값을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-138">You can subsequently change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-139">다음 예제에서는이 생성자 시그니처를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-139">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="93ecf-140">
            <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-140">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="93ecf-141">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-141">The default value of the dependency property, usually provided as a value of a specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="93ecf-142">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-142">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-143">제공된 기본값 및 지정된 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 콜백을 사용하여 <see cref="T:System.Windows.PropertyChangedCallback" />의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-143">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-144">제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-144">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="93ecf-145">컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-145">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="93ecf-146">속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-146">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="93ecf-147">값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-147">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-148">다음 예제에서는이 생성자 시그니처를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-148">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="93ecf-149">
            <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-149">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">
          <span data-ttu-id="93ecf-150">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-150">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="93ecf-151">속성 시스템에서 이 종속성 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-151">A reference to a handler implementation will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> for this dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-152">지정된 콜백을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-152">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified callbacks.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-153">이 구현은 기본 이니셜라이저를 호출 하 고 다음 추가 `coerceValueCallback` 기본 인스턴스에서 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-153">This implementation calls a base initializer and then adds the `coerceValueCallback` by setting the property on the base instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-154">다음 예제에서는이 생성자 시그니처를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-154">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="93ecf-155">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-155">The default value of the dependency property, usually provided as a value of a specific type.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="93ecf-156">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-156">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span>
          </span>
          <span data-ttu-id="93ecf-157">이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-157">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="93ecf-158">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-158">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-159">제공된 기본값, 프레임워크 메타데이터 옵션 및 지정된 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 콜백을 사용하여 <see cref="T:System.Windows.PropertyChangedCallback" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-159">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, and specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-160">제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-160">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="93ecf-161">컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-161">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="93ecf-162">속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-162">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="93ecf-163">값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-163">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="93ecf-164">값 집합 flags에서 플래그로 표시 된 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-164">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="93ecf-165">특정 속성 시스템 작업에 적용 된 메타 데이터에서 속성의 값을 여전히 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-165">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-166">다음 예제에서는이 생성자 시그니처를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-166">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="93ecf-167">
            <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-167">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="93ecf-168">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-168">The default value of the dependency property, usually provided as a specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="93ecf-169">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-169">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="93ecf-170">속성 시스템에서 이 종속성 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-170">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> for this dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-171">제공된 기본값 및 지정된 콜백을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" />의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-171">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and specified callbacks.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-172">제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-172">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="93ecf-173">컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-173">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="93ecf-174">속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-174">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="93ecf-175">값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-175">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-176">다음 예제에서는이 생성자 시그니처를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-176">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="93ecf-177">
            <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-177">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="93ecf-178">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-178">The default value of the dependency property, usually provided as a specific type.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="93ecf-179">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-179">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span>
          </span>
          <span data-ttu-id="93ecf-180">이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-180">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="93ecf-181">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-181">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="93ecf-182">속성 시스템에서 이 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-182">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-183">제공된 기본값, 프레임워크 메타데이터 옵션 및 지정된 콜백을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-183">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, and specified callbacks.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-184">제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-184">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="93ecf-185">컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-185">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="93ecf-186">속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-186">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="93ecf-187">값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-187">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="93ecf-188">값 집합 flags에서 플래그로 표시 된 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-188">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="93ecf-189">특정 속성 시스템 작업에 적용 된 메타 데이터에서 속성의 값을 여전히 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-189">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-190">다음 예제에서는이 생성자 시그니처를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-190">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="93ecf-191">
            <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-191">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="93ecf-192">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-192">The default value of the dependency property, usually provided as a specific type.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="93ecf-193">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-193">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span>
          </span>
          <span data-ttu-id="93ecf-194">이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-194">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="93ecf-195">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-195">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="93ecf-196">속성 시스템에서 이 종속성 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-196">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> on this dependency property.</span>
          </span>
        </param>
        <param name="isAnimationProhibited">
          <span data-ttu-id="93ecf-197">속성 시스템에서 이 메타데이터가 적용되는 속성에 애니메이션을 사용하지 않게 하려면 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-197">
              <see langword="true" /> to prevent the property system from animating the property that this metadata is applied to.</span>
          </span>
          <span data-ttu-id="93ecf-198">이러한 속성에 애니메이션을 적용하려고 하면 속성 시스템에서 런타임 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-198">Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</span>
          </span>
          <span data-ttu-id="93ecf-199">속성에 애니메이션을 적용할 수 있게 하려면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-199">
              <see langword="false" /> to permit animating the property.</span>
          </span>
          <span data-ttu-id="93ecf-200">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-200">The default is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-201">제공된 기본값, 프레임워크 메타데이터 옵션, 지정된 콜백 및 속성 애니메이션을 금지할 수 있는 부울 값을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-201">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, specified callbacks, and a Boolean that can be used to prevent animation of the property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-202">제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-202">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="93ecf-203">컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-203">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="93ecf-204">속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-204">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="93ecf-205">값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-205">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="93ecf-206">합니다 `isAnimationProhibited` 의 초기 값을 설정 하는 매개 변수를 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 즉시 기본 속성 선언 <xref:System.Windows.UIPropertyMetadata> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-206">The `isAnimationProhibited` parameter sets the initial value of the <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> property declared by the immediate base <xref:System.Windows.UIPropertyMetadata> class.</span></span>  
  
 <span data-ttu-id="93ecf-207">값 집합 flags에서 플래그로 표시 된 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-207">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="93ecf-208">특정 속성 시스템 작업에 적용 된 메타 데이터에서 속성의 값을 여전히 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-208">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-209">다음 예제에서는이 생성자 시그니처를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-209">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="93ecf-210">
            <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-210">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="93ecf-211">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-211">The default value of the dependency property, usually provided as a specific type.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="93ecf-212">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-212">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span>
          </span>
          <span data-ttu-id="93ecf-213">이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-213">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="93ecf-214">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-214">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="93ecf-215">속성 시스템에서 이 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-215">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span>
          </span>
        </param>
        <param name="isAnimationProhibited">
          <span data-ttu-id="93ecf-216">속성 시스템에서 이 메타데이터가 적용되는 속성에 애니메이션을 사용하지 않게 하려면 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-216">
              <see langword="true" /> to prevent the property system from animating the property that this metadata is applied to.</span>
          </span>
          <span data-ttu-id="93ecf-217">이러한 속성에 애니메이션을 적용하려고 하면 속성 시스템에서 런타임 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-217">Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</span>
          </span>
          <span data-ttu-id="93ecf-218">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-218">The default is <see langword="false" />.</span>
          </span>
        </param>
        <param name="defaultUpdateSourceTrigger">
          <span data-ttu-id="93ecf-219">
            <see cref="T:System.Windows.Data.UpdateSourceTrigger" />가 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />로 설정된 경우 이 속성에 대한 바인딩이 적용될 때 사용할 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-219">The <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> to use when bindings for this property are applied that have their <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-220">제공된 기본값, 프레임워크 메타데이터 옵션, 지정된 콜백, 속성 애니메이션을 금지할 수 있는 부울 값 및 데이터 바인딩 업데이트 트리거 기본값을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-220">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, specified callbacks, a Boolean that can be used to prevent animation of the property, and a data-binding update trigger default.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-221">제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-221">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="93ecf-222">컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-222">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="93ecf-223">속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-223">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="93ecf-224">값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-224">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="93ecf-225">합니다 `isAnimationProhibited` 의 초기 값을 설정 하는 매개 변수를 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 즉시 기본 속성 선언 <xref:System.Windows.UIPropertyMetadata> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-225">The `isAnimationProhibited` parameter sets the initial value of the <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> property declared by the immediate base <xref:System.Windows.UIPropertyMetadata> class.</span></span>  
  
 <span data-ttu-id="93ecf-226">바인딩 소스 업데이트 동작에 대 한 자세한 내용은 참조 하세요. [데이터 바인딩 개요](~/docs/framework/wpf/data/data-binding-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-226">For more information about the update source behavior for bindings, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
 <span data-ttu-id="93ecf-227">값 집합 flags에서 플래그로 표시 된 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-227">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="93ecf-228">특정 속성 시스템 작업에 적용 된 메타 데이터에서 속성의 값을 여전히 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-228">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="93ecf-229">
            <paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-229">
              <paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-230">레이아웃 엔진 작업 중 종속성 속성이 정렬 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-230">Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass during layout engine operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-231">이 메타데이터가 있는 종속성 속성이 정렬 단계에 잠재적으로 영향을 주면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-231">
              <see langword="true" /> if the dependency property on which this metadata exists potentially affects the arrange pass; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="93ecf-232">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-232">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-233"><xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 있는 모든 종속성 속성 유효 값 변경 내용을 모니터링 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-233"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="93ecf-234">논리의 일부로, 적용을 변경 하는 종속성 속성 값 및 사용 하 여 메타 데이터를 가져야 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 로 설정 `true` 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다 (호출 <xref:System.Windows.UIElement.InvalidateArrange%2A>).</span><span class="sxs-lookup"><span data-stu-id="93ecf-234">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element (a call to <xref:System.Windows.UIElement.InvalidateArrange%2A>).</span></span> <span data-ttu-id="93ecf-235">이 WPF 프레임 워크 수준 구현 되어에서 이미 이기 때문에 일반적으로 필요가 없습니다 사용 하 여 종속성 속성에 대 한 검색할 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 대체로 대체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-235">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="93ecf-236">사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현이 종속성 속성 변경에 대 한 비슷한 동작을 선택할 수 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 는 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-236">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> is `true`.</span></span>  
  
 <span data-ttu-id="93ecf-237">파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-237">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-238">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-238">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-239">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-239">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-240">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-240">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-241">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-241">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-242">이 클래스의 멤버는 일반적으로 없습니다에서 사용 하거나 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-242">Members of this class are either not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-243">다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-243">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-244">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-244">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-245">레이아웃 엔진 작업 중 종속성 속성이 측정 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-245">Gets or sets a value that indicates whether a dependency property potentially affects the measure pass during layout engine operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-246">이 메타데이터가 있는 종속성 속성이 측정 단계에 잠재적으로 영향을 주면 <see langword="true" />이고, 영향을 주지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-246">
              <see langword="true" /> if the dependency property on which this metadata exists potentially affects the measure pass; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="93ecf-247">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-247">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-248"><xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 있는 모든 종속성 속성 유효 값 변경 내용을 모니터링 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-248"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="93ecf-249">논리의 일부로, 적용을 변경 하는 종속성 속성 값 및 사용 하 여 메타 데이터를 가져야 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 로 `true` 해당 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-249">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element.</span></span> <span data-ttu-id="93ecf-250">이 WPF 프레임 워크 수준 구현 되어에서 이미 이기 때문에 일반적으로 필요가 없습니다 사용 하 여 종속성 속성에 대 한 검색할 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 대체로 대체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-250">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="93ecf-251">사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현이 종속성 속성 변경에 대 한 비슷한 동작을 선택할 수 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 는 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-251">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="93ecf-252">파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-252">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-253">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-253">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-254">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-254">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-255">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-255">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-256">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-256">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-257">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-257">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-258">다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-258">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-259">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-259">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-260">레이아웃 엔진 작업 중 종속성 속성이 부모 요소 레이아웃의 정렬 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-260">Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass of its parent element's layout during layout engine operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-261">이 메타데이터가 적용되는 종속성 속성에 따라 특히 부모 요소의 정렬 처리 단계가 영향을 받을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-261">
              <see langword="true" /> if the dependency property on which this metadata exists potentially affects the arrange pass specifically on its parent element; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="93ecf-262">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-262">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-263"><xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 있는 모든 종속성 속성 유효 값 변경 내용을 모니터링 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-263"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="93ecf-264">논리의 일부로, 적용을 변경 하는 종속성 속성 값 및 사용 하 여 메타 데이터를 가져야 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 로 `true` 부모 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-264">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> set to `true` will initiate a deferred request to invalidate the visuals for the parent element.</span></span>  
  
 <span data-ttu-id="93ecf-265">일반적으로 않아도의 변경 내용을 보고 하는 <xref:System.Windows.FrameworkElement> 속성을 사용 하 여 부모 요소 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 요소 자체는 이미 있으므로 자체 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 으로 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-265">Generally, you do not need to report changes of a <xref:System.Windows.FrameworkElement> property to a parent element using <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> because the element itself would already have its own <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true`.</span></span> <span data-ttu-id="93ecf-266">일반적으로 이것으로 충분, 해당 하는 경우 부모 정렬 하므로 변경 된 자식 요소에 일반적으로 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-266">That is usually sufficient, because changes in the child element generally initiate a parent arrange when appropriate.</span></span> <span data-ttu-id="93ecf-267"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 에 사용 되기도 <xref:System.Windows.FrameworkContentElement> 클래스를 파생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-267"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is sometimes used for a <xref:System.Windows.FrameworkContentElement> derived class.</span></span> <span data-ttu-id="93ecf-268">이 경우 속성, 하지만 자식 요소 집합 <xref:System.Windows.FrameworkContentElement> 파생된 클래스는 자체 렌더링을 제어 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-268">In this case, the child element sets a property, but a <xref:System.Windows.FrameworkContentElement> derived class does not control its own rendering.</span></span> <span data-ttu-id="93ecf-269">렌더링 하 여 처리 되는 <xref:System.Windows.FrameworkElement> 콘텐츠 호스트 역할을 하는 부모 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-269">The rendering is handled by a <xref:System.Windows.FrameworkElement> parent element that serves as the content host.</span></span> <span data-ttu-id="93ecf-270">예를 들어 값으로 변경 합니다 <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 자식 요소에서 연결 된 속성 무효화 부모에서 자식 위치를 변경 해야 하기 때문에 부모를 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-270">For instance, a change to the value of the <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> attached property by a child element invalidates arrange of the parent, because the position of the child in the parent must be changed.</span></span> <span data-ttu-id="93ecf-271">따라서 합니다 <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 연결 된 속성 메타 데이터에 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 는 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-271">Therefore, the <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> attached property has metadata where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is `true`.</span></span> <span data-ttu-id="93ecf-272">또 다른 예로 <xref:System.Windows.Controls.Control.Padding%2A>이 속성 변경 내용을 상위 변경 될 수 있습니다 사용 가능한 공간에 따라 자식 위치를 지정 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="93ecf-272">Another example is <xref:System.Windows.Controls.Control.Padding%2A>; when this property changes, the parent might change the positioning of the child, depending on available space.</span></span>  
  
 <span data-ttu-id="93ecf-273">이 WPF 프레임 워크 수준 구현 되어에서 이미 이기 때문에 일반적으로 필요가 없습니다 사용 하 여 종속성 속성에 대 한 검색할 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 대체로 대체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-273">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="93ecf-274">사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현이 종속성 속성 변경에 대 한 비슷한 동작을 선택할 수 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 는 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-274">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is `true`.</span></span>  
  
 <span data-ttu-id="93ecf-275">에 대 한 속성의 파생 클래스인 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-275">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-276">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-276">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-277">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-277">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-278">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-278">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-279">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-279">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-280">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-280">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-281">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-281">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-282">레이아웃 엔진 작업 중 종속성 속성이 부모 요소 레이아웃의 측정 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-282">Gets or sets a value that indicates whether a dependency property potentially affects the measure pass of its parent element's layout during layout engine operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-283">이 메타데이터가 적용되는 종속성 속성에 따라 특히 부모 요소의 측정 처리 단계가 영향을 받을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-283">
              <see langword="true" /> if the dependency property on which this metadata exists potentially affects the measure pass specifically on its parent element; otherwise, <see langword="false" />.The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-284"><xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 있는 모든 종속성 속성 유효 값 변경 내용을 모니터링 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-284"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="93ecf-285">논리의 일부로, 적용을 변경 하는 종속성 속성 값 및 사용 하 여 메타 데이터를 가져야 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 로 `true` 부모 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-285">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> set to `true` will initiate a deferred request to invalidate the visuals for the parent element.</span></span> <span data-ttu-id="93ecf-286">이 WPF 프레임 워크 수준 구현 되어에서 이미 이기 때문에 일반적으로 필요가 없습니다 사용 하 여 종속성 속성에 대 한 검색할 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 대체로 대체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-286">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="93ecf-287">일반적으로 않아도의 변경 내용을 보고 하는 <xref:System.Windows.FrameworkElement> 속성을 사용 하 여 부모 요소 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 요소 자체는 이미 있으므로 자체 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 으로 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-287">Generally, you do not need to report changes of a <xref:System.Windows.FrameworkElement> property to a parent element using <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> because the element itself would already have its own <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> as `true`.</span></span> <span data-ttu-id="93ecf-288">변경 된 자식 요소에 일반적으로 해당 하는 경우 부모 측정 단계를 시작 하기 때문에 이것이 충분입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-288">That is usually sufficient, because changes in the child element generally initiate a parent measure pass when appropriate.</span></span> <span data-ttu-id="93ecf-289"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 에 사용 되기도 <xref:System.Windows.FrameworkContentElement> 클래스를 파생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-289"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is sometimes used for a <xref:System.Windows.FrameworkContentElement> derived class.</span></span> <span data-ttu-id="93ecf-290">이 경우 속성, 하지만 자식 요소 집합 <xref:System.Windows.FrameworkContentElement> 파생된 클래스는 자체 렌더링을 제어 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-290">In this case, the child element sets a property, but a <xref:System.Windows.FrameworkContentElement> derived class does not control its own rendering.</span></span> <span data-ttu-id="93ecf-291">렌더링 하 여 처리 되는 <xref:System.Windows.FrameworkElement> 콘텐츠 호스트 역할을 하는 부모 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-291">The rendering is handled by a <xref:System.Windows.FrameworkElement> parent element that serves as the content host.</span></span> <span data-ttu-id="93ecf-292">예를 들어 값으로 변경 합니다 <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> 단락의 상대 간격 수 변경 될 수 있습니다 늘리거나 콘텐츠 호스트 크기 때문에 속성 자식 요소에서 부모의 측정을 무효화 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-292">For instance, a change to the value of the <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> property by a child element invalidates measure of the parent, because the relative spacing of paragraphs might change and might increase or decrease the content host size.</span></span> <span data-ttu-id="93ecf-293">따라서 합니다 <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> 속성이 메타 데이터 위치 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 는 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-293">Therefore, the <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> property has metadata where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="93ecf-294">종속성 속성의 변경에 대 한 콘텐츠 호스트 요소 에서도 자주 표시 위치 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 는 `true`, 콘텐츠 호스트 렌더링 논리의 일부로.</span><span class="sxs-lookup"><span data-stu-id="93ecf-294">Content host elements also frequently look for changes in dependency properties where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`, as part of content host rendering logic.</span></span> <span data-ttu-id="93ecf-295">예를 들어를 <xref:System.Windows.Controls.TextBox> 의 경계 상자 요소는 필요할 수 있는 텍스트 내에서 특정 변경에 응답 해야 합니다는 <xref:System.Windows.Controls.TextBox> 자체를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-295">For instance, the <xref:System.Windows.Controls.TextBox> element must respond to certain changes within text that might require that the bounding box of the <xref:System.Windows.Controls.TextBox> itself be changed.</span></span>  
  
 <span data-ttu-id="93ecf-296">사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현이 종속성 속성 변경에 대 한 비슷한 동작을 선택할 수 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 는 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-296">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="93ecf-297">에 대 한 속성의 파생 클래스인 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-297">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-298">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-298">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-299">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-299">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-300">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-300">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-301">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-301">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-302">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-302">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-303">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-303">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-304">종속성 속성은 정렬이나 측정에 특별히 영향을 주지 않는 어떤 방식으로 일반 레이아웃에 잠재적으로 영향을 주는지 여부를 나타내지만 다시 그리기를 필요로 하는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-304">Gets or sets a value that indicates whether a dependency property potentially affects the general layout in some way that does not specifically influence arrangement or measurement, but would require a redraw.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-305">이 메타데이터가 적용되는 종속성 속성이 렌더링에 영향을 줄 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-305">
              <see langword="true" /> if the dependency property on which this metadata exists affects rendering; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="93ecf-306">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-306">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-307"><xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 있는 모든 종속성 속성 유효 값 변경 내용을 모니터링 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-307"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="93ecf-308">논리의 일부로, 적용을 변경 하는 종속성 속성 값 및 사용 하 여 메타 데이터를 가져야 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 로 `true` 해당 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-308">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element.</span></span> <span data-ttu-id="93ecf-309">이 WPF 프레임 워크 수준 구현 되어에서 이미 이기 때문에 일반적으로 필요가 없습니다 사용 하 여 종속성 속성에 대 한 검색할 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 대체로 대체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-309">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="93ecf-310">사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현이 종속성 속성 변경에 대 한 비슷한 동작을 선택할 수 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 는 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-310">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> is `true`.</span></span>  
  
 <span data-ttu-id="93ecf-311">에 대 한 속성의 파생 클래스인 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-311">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-312">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-312">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-313">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-313">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-314">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-314">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-315">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-315">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-316">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-316">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-317">다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-317">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-318">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-318">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-319">속성이 기본적으로 양방향으로 바인드하는지 여부를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-319">Gets or sets a value that indicates whether the property binds two-way by default.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-320">이 메타데이터가 존재하는 종속성 속성이 기본적으로 양방향으로 바인드하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-320">
              <see langword="true" /> if the dependency property on which this metadata exists binds two-way by default; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="93ecf-321">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-321">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-322">없을 경우이 속성의 `true`, 바인딩 업데이트는 기본적으로의 기본 동작에 따라 단방향 합니다 <xref:System.Windows.Data.Binding> 생성자 또는 이와 동등한 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-322">In absence of this property being `true`, binding updates are one-way by default, based on the default behavior of the <xref:System.Windows.Data.Binding> constructors or equivalent [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="93ecf-323">기존 요소를 찾을 수 있습니다 일반적으로이 속성을 설정 `true` 상태를 보고 하 고는 예를 들어 사용자 작업을 통해 수정할 수는 종속성 속성에 대 한 메타 데이터에서 <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-323">In existing elements, you will usually find this property set to `true` in metadata for dependency properties that both report state and are modifiable by user action, for example <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="93ecf-324">이 속성 보고할 종속성 속성의 기본 바인딩 업데이트 특징을 뿐 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-324">This property only reports the default binding update characteristics of the dependency property in general.</span></span> <span data-ttu-id="93ecf-325">인스턴스에서이 속성을 설정 하는 모든 바인딩 로컬로 설정할 수는 <xref:System.Windows.Data.Binding.Mode%2A> 바인딩의 속성이이 기본값을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-325">Any binding set to this property on an instance can locally set the <xref:System.Windows.Data.Binding.Mode%2A> property of the binding and change this default.</span></span>  
  
 <span data-ttu-id="93ecf-326">에 대 한 속성의 파생 클래스인 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-326">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-327">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-327">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-328">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-328">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-329">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-329">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-330">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-330">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-331">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-331">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-332">다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-332">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-333">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-333">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-334">
            <see cref="T:System.Windows.Data.UpdateSourceTrigger" />가 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />로 설정된 경우 이 메타데이터가 있는 속성에 바인딩이 적용될 때 사용할 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />의 기본값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-334">Gets or sets the default for <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> to use when bindings for the property with this metadata are applied, which have their <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-335">
            <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />를 제외한 열거형 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-335">A value of the enumeration, other than <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-336">파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-336">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-337">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-337">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-338">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-338">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-339">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-339">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-340">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-340">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-341">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-341">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="93ecf-342">이 속성이 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />로 설정된 경우. 이 속성에 설정하는 값은 바인딩에서 요청할 때 기본값이 되어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-342">This property is set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; the value you set is supposed to become the default when requested by bindings.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-343">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-343">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-344">종속성 속성의 값이 상속되는지 여부를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-344">Gets or sets a value that indicates whether the value of the dependency property is inheritable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-345">속성 값을 상속할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-345">
              <see langword="true" /> if the property value is inheritable; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="93ecf-346">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-346">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-347">속성 값 상속의 기능은 합니다 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 가능해 집니다 특정 종속성 속성을 설정할 수 있습니다 로컬로 끝났거나 곧의 루트 요소에 WPF 프레임 워크 수준 속성 시스템을 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 요소 트리와 연결한 다음 해당 값에서 상속 또한 해당 속성을 소유 하는 자식 요소의 논리 트리 내에서 모든 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-347">Property value inheritance is a feature of the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system at the WPF framework level, whereby certain dependency properties can be locally set on an element at or near the root of a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element tree and then have their value inherited by all elements within the logical tree of child elements that also possess that property.</span></span> <span data-ttu-id="93ecf-348">기본적으로 속성 값 상속 가능 하지 없고 있도록 몇 가지 성능에 미치는 영향입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-348">Property value inheritance is not enabled by default, and enabling it does have some performance implications.</span></span> <span data-ttu-id="93ecf-349">자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="93ecf-349">For details, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93ecf-350">속성 값 상속은 연결 되지 않은 종속성 속성에 대 한 작업에 표시 될 수 있지만 런타임 트리의 특정-개체 부분을 통해 연결 되지 않은 속성에 대 한 상속 동작은 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-350">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain object-object divisions in the runtime tree is undefined.</span></span> <span data-ttu-id="93ecf-351">항상 사용 하 여 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 지정 하는 속성을 등록 하려면 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 메타 데이터에서입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-351">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span>  
  
 <span data-ttu-id="93ecf-352">파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-352">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-353">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-353">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-354">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-354">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-355">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-355">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-356">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-356">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-357">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-357">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-358">다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-358">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-359">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-359">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-360">종속성 속성에 대한 데이터 바인딩을 지원하는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-360">Gets a value that indicates whether data binding is supported for the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-361">이 메타데이터가 적용되는 종속성 속성에 데이터 바인딩이 지원되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-361">
              <see langword="true" /> if data binding is supported on the dependency property to which this metadata applies; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="93ecf-362">기본값은 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-362">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-363">이 속성을 보고 `false` 두 상황 중 하나에 대해: 종속성 속성에 데이터 바인딩 중 하나 (보고 되는 종속성 속성 식별자 메타 데이터가 아니라에), 읽기 전용 종속성 속성 이므로 되지 또는 값 다른 메타 데이터 속성 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>로 설정 된 `true` 이 메타 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-363">This property reports `false` for one of two possible conditions: either data binding to a dependency property is not allowed because the dependency property is read-only (as reported in the dependency property identifier, not the metadata), or the value of another metadata property, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, is set to `true` in this metadata.</span></span> <span data-ttu-id="93ecf-364">이 속성은 편의 위해 호출자가 모두 선택 하지 않아도 되도록 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 고 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-364">This property is exposed as a convenience so that callers do not have to check both <xref:System.Windows.DependencyProperty.ReadOnly%2A> and <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</span></span>  
  
 <span data-ttu-id="93ecf-365">그렇지 않은 경우 읽기/쓰기 속성을 데이터 바인딩을 지원 하지 않도록 지정 하는 메타 데이터를 생성 하려는 경우이 플래그를 지정 <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (및 약간의 명명 규칙 차이가 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).</span><span class="sxs-lookup"><span data-stu-id="93ecf-365">If you are attempting to create metadata that specifies that an otherwise read/write property should not support data binding, specify the flag <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (note the slight naming convention difference versus <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).</span></span>  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-366">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-366">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-367">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-367">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93ecf-368">다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-368">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-369">종속성 속성이 데이터 바인딩을 지원하는지 여부를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-369">Gets or sets a value that indicates whether the dependency property supports data binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-370">속성에서 데이터 바인딩이 지원되지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-370">
              <see langword="true" /> if the property does not support data binding; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="93ecf-371">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-371">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-372">이 메타 데이터 속성에 `true` 특히 읽기 / 쓰기 속성 불구 하 고 데이터 바인딩을 지원 하지 않아야 하는 속성에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-372">Note that this metadata property is set to `true` specifically for properties that should not support data binding, despite being read-write properties.</span></span> <span data-ttu-id="93ecf-373">예상이는 종속성 속성이 선언 되어 있는 대부분의 경우에서 데이터 바인딩, 데이터 바인딩 종속성 속성을 유용 하는 주요 시나리오 중 하나 이므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-373">The expectation is that in most cases where a dependency property is declared, data binding is desired, because data binding is one of the key scenarios where a dependency property is useful.</span></span> <span data-ttu-id="93ecf-374">와 달리 <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, 단순히 특정 바인딩에서 이후에 변경 될 수 있는 기본값을 변경 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-374">Unlike <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, this does not merely change a default that can later be changed on a specific binding.</span></span> <span data-ttu-id="93ecf-375">이 속성을 설정할 `true` 종속성 속성에 대 한 메타 데이터의 메타 데이터는 종속성 속성에 식을 통해 값을 적용 하는 모든 바인딩에서 비활성화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-375">Setting this property `true` in the metadata for a dependency property metadata will disable all bindings from applying their values through expressions to that dependency property.</span></span>  
  
 <span data-ttu-id="93ecf-376">읽기 전용 종속성 속성 데이터 바인딩 (있기 때문에 변경 된 값을 적용할 수 있는 setter) 지원 하지 않지만 보고서는 여전히 `false` 에 대 한 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-376">Read-only dependency properties do not support data binding (because they have no setter that can apply changed values), but will still report `false` for <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</span></span> <span data-ttu-id="93ecf-377">이므로이에 해당 하는 속성을 <xref:System.Windows.FrameworkPropertyMetadataOptions> 값 메타 데이터를 실제로 설정 방법, 항상 의미 하는 속성의 이름을 지정 하는 최종 결과 동작을 보고 하는 대신 사용 하 여 패리티를 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-377">This is because properties that correspond to a <xref:System.Windows.FrameworkPropertyMetadataOptions> values will report parity with how the metadata was actually established, rather than always reporting the end result behavior that the naming of the property might imply.</span></span> <span data-ttu-id="93ecf-378">지정 된 종속성 속성이 데이터 바인딩을 허용 하는지 여부를 확인, 일반적으로 확인 해야 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-378">To determine whether a given dependency property permits data binding, you should usually check <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> instead.</span></span> <span data-ttu-id="93ecf-379"><xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 둘 다 검사 편리 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 및 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> 를 단일 작업으로 예상 되는 결과 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-379"><xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> is a convenience for checking both <xref:System.Windows.DependencyProperty.ReadOnly%2A> and <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> as a single operation, yielding the expected result.</span></span>  
  
 <span data-ttu-id="93ecf-380">파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-380">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-381">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-381">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-382">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-382">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-383">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-383">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-384">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-384">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-385">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-385">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-386">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-386">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-387">이 속성이 응용 프로그램에서 저널링 구현의 일부로 저장할 수 있거나 저장해야 하는 저널링 정보를 포함하는지 여부를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-387">Gets or sets a value that indicates whether this property contains journaling information that applications can or should store as part of a journaling implementation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-388">
            <see langword="true" /> 이 메타 데이터;에 적용 되는 종속성 속성에 저널링을 수행 해야 하는 경우 그렇지 않으면 <see langword="false" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-388">
              <see langword="true" /> if journaling should be performed on the dependency property that this metadata is applied to; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="93ecf-389">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-389">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-390">파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-390">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-391">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-391">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-392">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-392">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-393">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-393">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-394">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-394">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-395">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-395">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-396">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-396">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">
          <span data-ttu-id="93ecf-397">병합할 기본 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-397">The base metadata to merge.</span>
          </span>
        </param>
        <param name="dp">
          <span data-ttu-id="93ecf-398">이 메타데이터가 적용되는 종속성 속성입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-398">The dependency property this metadata is being applied to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-399">기본 메타데이터와 원본 메타 데이터의 병합을 사용하도록 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-399">Enables a merge of the source metadata with base metadata.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-400">이 메서드는 메타 데이터 재정의 될 때 내부적으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-400">This method is used internally when metadata is being overridden.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="93ecf-401">
            <para>파생 된 클래스 <see cref="T:System.Windows.PropertyMetadata" /> (또는이 특히 클래스)는 구현에 추가한 모든 메타 데이터 속성에 대 한 계정에이 메서드를 재정의 해야 합니다. 예를 들어, 구현 추가 했을 수는 새 플래그 열거형 값 및 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 구현 이러한 플래그를 올바르게 결합 수 있어야 합니다.  이전 형식 계층 구조에 이미 정의 된 모든 속성을 병합의 기본 구현을 담당 하기 때문에 항상 기본 구현을 개발자 고유의 구현 하기 전에 호출 합니다.  하 여 추가 동작을 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 에서 구현 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 특정 WPF 프레임 워크 수준 속성은와 같은 메타 데이터에 <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> 비트 결합 됩니다 또는 작업 합니다.  합니다 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 동작 구현 동작을 호출 하 여 기존 종속성 속성의 속성 메타 데이터를 재정의 하는 경우 <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />., 재정의 메타 데이터를 사용 하 여 <see cref="T:System.Windows.FrameworkPropertyMetadata" />입니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-401">
              <para>Classes that derive from <see cref="T:System.Windows.PropertyMetadata" /> (or this class particularly) should override this method to account for any metadata properties they have added in their implementations. For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.  Always call the base implementation prior to your own implementation, because the base implementation takes care of merging all the properties already defined on previous types in the hierarchy.  The behavior added by the <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation in <see cref="T:System.Windows.FrameworkPropertyMetadata" /> is that specific WPF framework-level properties in the metadata such as <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> are combined in a bitwise or operation.  The <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> behavior also implements the behavior when you override the property metadata on an existing dependency property by calling <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />., using override metadata that is <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="93ecf-402">메타데이터를 적용한 종속성 속성입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-402">The dependency property to which the metadata has been applied.</span>
          </span>
        </param>
        <param name="targetType">
          <span data-ttu-id="93ecf-403">형식별 메타데이터인 경우 이 메타데이터에 연결된 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-403">The type associated with this metadata if this is type-specific metadata.</span>
          </span>
          <span data-ttu-id="93ecf-404">기본 메타데이터인 경우에는 이 값이 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-404">If this is default metadata, this value can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="93ecf-405">이 메타데이터가 속성에 적용되어 메타데이터가 봉인될 때 호출됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-405">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-406">어떠한 방법으로의 데이터 구조를 <xref:System.Windows.FrameworkPropertyMetadata> 인스턴스 표시 해야 변경할 수 없는 것이 메서드가 호출 되 면 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-406">Any mutability of the data structure of a <xref:System.Windows.FrameworkPropertyMetadata> instance should be marked as immutable when this method is invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="93ecf-407">
            <para>
              <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 이 메서드의 구현에서는 기본 구현을 호출 하기만 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-407">
              <para>The <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implementation of this method does nothing beyond calling the base implementation.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-408">속성 값 상속 평가가 요소의 논리적 트리에서 특정 콘텐츠 경계를 넘을지 여부를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-408">Gets or sets a value that indicates whether the property value inheritance evaluation should span across certain content boundaries in the logical tree of elements.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-409">특정 콘텐츠 경계에 걸쳐 속성 값이 상속되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-409">
              <see langword="true" /> if the property value inheritance should span across certain content boundaries; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="93ecf-410">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-410">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-411">이 메타 데이터에서 특수 부모 요소 자식 요소의 경계를 넘어 속성 값 상속 동작은 거의 적용 수정을 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-411">This metadata reports a seldom-applied modification to property value inheritance behavior across special parent element-child element boundaries.</span></span> <span data-ttu-id="93ecf-412">이러한 경계 방식의 전형적인 예는 내용의 <xref:System.Windows.Controls.Frame>여기서는 <xref:System.Windows.Controls.Frame> 의 존재 여부와 독립적으로 콘텐츠를 다시 로드 가져올 수 있습니다는 <xref:System.Windows.Controls.Frame>합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-412">The canonical example of such a boundary is the contents of a <xref:System.Windows.Controls.Frame>, where the <xref:System.Windows.Controls.Frame> content might get reloaded independently of the existence of the <xref:System.Windows.Controls.Frame>.</span></span> <span data-ttu-id="93ecf-413">Desired 속성 시스템 동작은의 내용을 속성 값 상속을 트래버스 하지 해야는 <xref:System.Windows.Controls.Frame>이므로 이러한 콘텐츠 요소일 수도 프레임을 호스팅하는 응용 프로그램을 소유 하거나 제어 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-413">The desired property system behavior is that property value inheritance should not traverse into the contents of the <xref:System.Windows.Controls.Frame>, because these contents might be elements that the application hosting the frame does not own or control.</span></span> <span data-ttu-id="93ecf-414">메타 데이터를 지정 하 <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> 로 설정 `true`지정, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 으로 `true`, 에서도 상속할 수에 적용 되는 메타 데이터는 속성을 <xref:System.Windows.Controls.Frame> 경계 또는 이와 유사한 경계입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-414">Specifying metadata with <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> set to `true`, as well as specifying <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> as `true`, will cause the property on which the metadata is applied to be inheritable even across the <xref:System.Windows.Controls.Frame> boundary or similar boundaries.</span></span>  
  
 <span data-ttu-id="93ecf-415">파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-415">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-416">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-416">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-417">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-417">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-418">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-418">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-419">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-419">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-420">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-420">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-421">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-421">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="93ecf-422">종속성 속성의 하위 속성이 포함하는 개체의 렌더링에 영향을 주지 않는지 여부를 나타내는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-422">Gets or sets a value that indicates whether sub-properties of the dependency property do not affect the rendering of the containing object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="93ecf-423">하위 속성 값이 변경되어도 렌더링에 영향이 없으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-423">
              <see langword="true" /> if changes to sub-property values do not affect rendering if changed; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="93ecf-424">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-424">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93ecf-425">이 메타 데이터 옵션은 해당 형식 자체의 속성 값에 있는 참조 형식에는 종속성 속성에 대 한 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-425">This metadata option is pertinent for dependency properties that are reference types, where that type has property values of its own.</span></span> <span data-ttu-id="93ecf-426">일반적으로 레이아웃 시스템 논리 하위 속성을 사용 하 여 모든 종속성 속성은 영향을 줄 레이아웃에 변경 내용에 대 한 모든 하위 속성을 확인 하는 것은 실제로 실행 중인 것 보다 더 많은 시간이 소요 되므로 다른 렌더링 패스를 가정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-426">Typically, the layout system logic is to assume that any dependency property with sub-properties potentially will affect layout, because checking all sub-properties for changes is more time consuming than actually running another render pass.</span></span> <span data-ttu-id="93ecf-427">이 옵션을 설정 `true` WPF 프레임 워크 수준 레이아웃 시스템 구현은의 성능을 최적화 하는 데 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-427">Setting this option to `true` is useful for optimizing performance of the WPF framework level layout system implementation.</span></span>  
  
 <span data-ttu-id="93ecf-428">파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-428">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="93ecf-429">이므로 인스턴스를 초기화 한 후 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-429">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="93ecf-430">그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-430">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="93ecf-431">후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-431">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="93ecf-432">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="93ecf-432">XAML Text Usage</span></span>  
 <span data-ttu-id="93ecf-433">이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="93ecf-433">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="93ecf-434">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="93ecf-434">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>