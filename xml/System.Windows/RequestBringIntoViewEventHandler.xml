<Type Name="RequestBringIntoViewEventHandler" FullName="System.Windows.RequestBringIntoViewEventHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1fabd3e8ca79d0ed50a5a9c8a6f00299e7b8f9dd" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="08/24/2018" /><Meta Name="ms.locfileid" Value="37491197" /></Metadata><TypeSignature Language="C#" Value="public delegate void RequestBringIntoViewEventHandler(object sender, RequestBringIntoViewEventArgs e);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed RequestBringIntoViewEventHandler extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RequestBringIntoViewEventHandler" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Sub RequestBringIntoViewEventHandler(sender As Object, e As RequestBringIntoViewEventArgs)" />
  <TypeSignature Language="C++ CLI" Value="public delegate void RequestBringIntoViewEventHandler(System::Object ^ sender, RequestBringIntoViewEventArgs ^ e);" />
  <TypeSignature Language="F#" Value="type RequestBringIntoViewEventHandler = delegate of obj * RequestBringIntoViewEventArgs -&gt; unit" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="sender" Type="System.Object" />
    <Parameter Name="e" Type="System.Windows.RequestBringIntoViewEventArgs" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Void</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="sender"><span data-ttu-id="273a8-101">이벤트 처리기가 연결된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="273a8-101">The object where the event handler is attached.</span></span></param>
    <param name="e"><span data-ttu-id="273a8-102">이벤트 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="273a8-102">The event data.</span></span></param>
    <summary><span data-ttu-id="273a8-103"><see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> 라우트된 이벤트를 처리할 메서드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="273a8-103">Represents the method that will handle the <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /> routed event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="273a8-104">이 이벤트를 처리는 일반적으로 필요한 스크롤 가능한 영역을 지원 하거나 그렇지 않으면 의도적으로 렌더링 크기 보다 작은 설정 결합할 하는 요소 내에서 수행 해당 자식 요소 콘텐츠의 크기만 아니며만 의도적으로 처리 하 여는 이벤트 요소 트리에서 위쪽으로 라우팅되는 고 스크롤 영역 지원 제공 하는 첫 번째 부모에 도달 했습니다.</span><span class="sxs-lookup"><span data-stu-id="273a8-104">Handling this event is typically only done within elements that support a scrollable region, or otherwise deliberately set their rendering size smaller than the combined desired size of their child element content, and is only done by deliberately handling the event once it has routed upwards in the element tree and has reached the first parent that offers scrolling region support.</span></span> <span data-ttu-id="273a8-105">일반적으로 필요한 사용자 컨트롤에 대 한 방식으로 스크롤 영역을 처리 하는 기존 구현을 <xref:System.Windows.Controls.ScrollViewer>합니다.</span><span class="sxs-lookup"><span data-stu-id="273a8-105">An existing implementation that handles scrolling regions in a manner that is typically desirable for user controls is <xref:System.Windows.Controls.ScrollViewer>.</span></span> <span data-ttu-id="273a8-106">파생 하는 경우 <xref:System.Windows.Controls.ScrollViewer>에 대 한 클래스 처리기를 등록할 수 있습니다 <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> 이벤트의 기본 클래스 처리를 보완 합니다.</span><span class="sxs-lookup"><span data-stu-id="273a8-106">If you derive from <xref:System.Windows.Controls.ScrollViewer>, you can register a class handler for <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> and supplement the base class handling of the event.</span></span> <span data-ttu-id="273a8-107">또는 클래스 처리는 클래스 정의 사용 하 여 고려해 야 <xref:System.Windows.Controls.ScrollViewer.ScrollChanged> 이벤트 대신 <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="273a8-107">You should also consider using or class-handling the class-defined <xref:System.Windows.Controls.ScrollViewer.ScrollChanged> event instead of <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType>.</span></span> <span data-ttu-id="273a8-108">또는 완전 한 사용자 지정 클래스에서 파생 되지 않은 경우 만들어야 <xref:System.Windows.Controls.ScrollViewer>를 호출 하 여 처리 하는 클래스를 추가할 수 있습니다 <xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType> 에 클래스 인스턴스화의 합니다.</span><span class="sxs-lookup"><span data-stu-id="273a8-108">Alternatively, if you create an entirely custom class that does not derive from <xref:System.Windows.Controls.ScrollViewer>, you can still add class handling by calling <xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType> in your class instantiation.</span></span>  <span data-ttu-id="273a8-109">클래스 처리에 대 한 자세한 내용은 참조 하세요. [라우트된 이벤트 것으로 표시를 처리 및 클래스 처리](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="273a8-109">For details on class handling, see [Marking Routed Events as Handled, and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="273a8-110">콘텐츠 요소는 이벤트를 콘텐츠 호스트에 의해 발생 될 수 있습니다 (호출 <xref:System.Windows.FrameworkContentElement.BringIntoView%2A> 하 고 발생 시키는 <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> 콘텐츠 호스트에서).</span><span class="sxs-lookup"><span data-stu-id="273a8-110">Content elements can cause the event to be raised by their content hosts (through calling <xref:System.Windows.FrameworkContentElement.BringIntoView%2A> and raising <xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType> from the content host).</span></span> <span data-ttu-id="273a8-111">마찬가지로, 논리적 트리 도우미 메서드를 사용 하 여 뷰에 함께 표시할 요소를 요청할 수 있습니다 <xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="273a8-111">Similarly, you can request logical tree elements to be brought into view with the helper method <xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="273a8-112">A <xref:System.Windows.Controls.ListBox> 관련 되지만 다른 메서드를 구현 <xref:System.Windows.Controls.ListBox.ScrollIntoView%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="273a8-112">A <xref:System.Windows.Controls.ListBox> implements a related but different method <xref:System.Windows.Controls.ListBox.ScrollIntoView%2A>.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.RequestBringIntoViewEventArgs" />
    <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
    <altmember cref="T:System.Windows.Controls.Primitives.ScrollBar" />
    <altmember cref="T:System.Windows.Controls.ScrollViewer" />
    <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
    <altmember cref="M:System.Windows.LogicalTreeHelper.BringIntoView(System.Windows.DependencyObject)" />
  </Docs>
</Type>