<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="RequestBringIntoViewEventHandler.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cda95cbf8cf82761ed796773cf82db1b1779f599.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cda95cbf8cf82761ed796773cf82db1b1779f599</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>The object where the event handler is attached.</source>
          <target state="translated">이벤트 처리기가 연결된 개체입니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>The event data.</source>
          <target state="translated">이벤트 데이터입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Represents the method that will handle the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph> routed event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph> 라우트된 이벤트를 처리할 메서드를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Handling this event is typically only done within elements that support a scrollable region, or otherwise deliberately set their rendering size smaller than the combined desired size of their child element content, and is only done by deliberately handling the event once it has routed upwards in the element tree and has reached the first parent that offers scrolling region support.</source>
          <target state="translated">일반적으로 사용할 수 있는 원하는 스크롤 가능한 영역을 지원 하거나 그렇지 않으면 의도 한 대로 렌더링 크기 보다 작게 설정 조합 하는 요소 내에서 작업 수행은 자식 요소 콘텐츠의 크기 및 의도적으로 처리 하 여만 수행 됩니다이 이벤트를 처리 하는 이벤트 요소 트리에 있는 위쪽으로 라우팅 했습니다 하 고 스크롤 영역 지원에서 제공 하는 첫 번째 부모에 도달 했습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>An existing implementation that handles scrolling regions in a manner that is typically desirable for user controls is <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>.</source>
          <target state="translated">일반적으로 필요한 사용자 컨트롤에 대 한 방법으로 스크롤 영역을 처리 하는 기존 구현을 <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>If you derive from <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, you can register a class handler for <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> and supplement the base class handling of the event.</source>
          <target state="translated">파생 하는 경우 <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>에 대 한 클래스 처리기를 등록할 수 있습니다 <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> 이벤트의 기본 클래스 처리를 보완 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>You should also consider using or class-handling the class-defined <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;</ph> event instead of <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">또는 클래스 정의 한 클래스 처리를 사용 하 여 고려해 야 <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;</ph> 이벤트가 아니라 <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Alternatively, if you create an entirely custom class that does not derive from <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, you can still add class handling by calling <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType&gt;</ph> in your class instantiation.</source>
          <target state="translated">또는 완전 한 사용자 지정 클래스에서 파생 되지 않은 경우 만들 <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, 클래스를 호출 하 여 처리를 추가할 수 있습니다 <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType&gt;</ph> 클래스 인스턴스화에 있습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>For details on class handling, see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</source>
          <target state="translated">클래스 처리에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>표시 라우트된 이벤트로 클래스를 처리 하 고,<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Content elements can cause the event to be raised by their content hosts (through calling <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;</ph> and raising <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> from the content host).</source>
          <target state="translated">콘텐츠 요소는 이벤트를 콘텐츠 호스트에 의해 발생 될 수 있습니다 (호출을 통해 <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;</ph> 및 발생 <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> 는 콘텐츠 호스트에서).</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Similarly, you can request logical tree elements to be brought into view with the helper method <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">마찬가지로, 논리적 트리 도우미 메서드로 보기에 맞게 수정할 수 요소를 요청할 수 있습니다 <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> implements a related but different method <ph id="ph2">&lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;</ph>.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> 관련 하지만 서로 다른 메서드를 구현 <ph id="ph2">&lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;</ph>합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>