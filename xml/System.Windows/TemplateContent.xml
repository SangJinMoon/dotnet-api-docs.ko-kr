<Type Name="TemplateContent" FullName="System.Windows.TemplateContent">
  <TypeSignature Language="C#" Value="public class TemplateContent" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TemplateContent extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.TemplateContent" />
  <TypeSignature Language="VB.NET" Value="Public Class TemplateContent" />
  <TypeSignature Language="C++ CLI" Value="public ref class TemplateContent" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.XamlDeferLoad(typeof(System.Windows.TemplateContentLoader), typeof(System.Windows.FrameworkElement))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ca600-101">템플릿에서 XAML 판독기 및 작성기와 상호 작용할 때 콘텐츠를 지연하는 데 사용하는 기록 및 재생 논리를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="ca600-101">Implements the record and playback logic that templates use for deferring content when they interact with XAML readers and writers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca600-102">이 클래스는 공용 API가 없습니다..NET Framework 4.5 베타에서에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca600-102">This class has no public API in .NET Framework 4.5 Beta.</span></span> <span data-ttu-id="ca600-103">에 대 한 속성 값을 제공 <xref:System.Windows.FrameworkTemplate.Template%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ca600-103">It provides a property value for <xref:System.Windows.FrameworkTemplate.Template%2A>.</span></span> <span data-ttu-id="ca600-104">해당 생성자 내부입니다.</span><span class="sxs-lookup"><span data-stu-id="ca600-104">Its constructor is internal.</span></span> <span data-ttu-id="ca600-105">인스턴스화 경로가 있지만 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca600-105">There is an instantiation pathway, but it is complex.</span></span> <span data-ttu-id="ca600-106">의존 템플릿을 인스턴스화할 <xref:System.Windows.TemplateContentLoader>를 요구 하는 <xref:System.Xaml.XamlReader> 지연 된 판독기 인스턴스를 나타내는 및 <xref:System.Xaml.IXamlObjectWriterFactory> 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="ca600-106">Instantiating a template relies on <xref:System.Windows.TemplateContentLoader>, which requires a <xref:System.Xaml.XamlReader> representing a deferred reader instance, and a <xref:System.Xaml.IXamlObjectWriterFactory> service.</span></span> <span data-ttu-id="ca600-107">이러한 고려 사항은 관련이 있는 것은 일반적으로 일반적인 WPF 응용 프로그램은 필요 하지 않습니다와 인프라의 일부로 템플릿 지연 된 콘텐츠 처리를 포함 하는 WPF 처리 동작에 대 한 기본 XAML을 사용 하지 않는 하는 앞에서 언급 한 Api에 액세스 하려면 작성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ca600-107">Both these considerations are typically only relevant to those that are not using the default XAML for WPF processing behavior, which includes deferred content processing of templates as part of its infrastructure, and does not require the typical WPF application author to access the aforementioned APIs.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members />
</Type>