<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="97fc92af0ea25eec6f71bb4a67579fbfd994f7b4" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52214107" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="8c74d-101">수정 가능한 상태와 읽기 전용(고정) 상태를 가진 개체를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-101">Defines an object that has a modifiable state and a read-only (frozen) state.</span></span> <span data-ttu-id="8c74d-102"><see cref="T:System.Windows.Freezable" />에서 파생된 클래스는 자세한 변경 알림을 제공하며, 변경할 수 없도록 설정될 수 있고, 자신을 복제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-102">Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-103"><xref:System.Windows.Freezable> 클래스는 도움이 되는 특별 한 기능 수정 하거나 복사 하는 데 비용이 많이 드는 개체를 사용 하는 경우 응용 프로그램 성능 향상을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-103">The <xref:System.Windows.Freezable> class provides special features that can help improve application performance when using objects that are expensive to modify or copy.</span></span> <span data-ttu-id="8c74d-104">예가 <xref:System.Windows.Freezable> 개체는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-104">Examples of <xref:System.Windows.Freezable> objects include the following:</span></span>  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a><span data-ttu-id="8c74d-105">Freezable에서 파생</span><span class="sxs-lookup"><span data-stu-id="8c74d-105">Deriving From Freezable</span></span>  
 <span data-ttu-id="8c74d-106">파생 된 클래스 <xref:System.Windows.Freezable> 다음과 같은 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-106">A class that derives from <xref:System.Windows.Freezable> gains the following features:</span></span>  
  
-   <span data-ttu-id="8c74d-107">특수 상태: 읽기 전용 (고정된) 상태와 쓰기 가능한 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-107">Special states: a read-only (frozen) state and a writable state.</span></span>  
  
-   <span data-ttu-id="8c74d-108">스레드 보안: 고정 된 <xref:System.Windows.Freezable> 개체는 스레드 간에 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-108">Thread safety: a frozen <xref:System.Windows.Freezable> object can be shared across threads.</span></span>  
  
-   <span data-ttu-id="8c74d-109">자세한 변경 알림: 달리 <xref:System.Windows.DependencyObject> 개체는 <xref:System.Windows.Freezable> 하위 속성 값을 변경 하는 경우 변경 알림을 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-109">Detailed change notification: Unlike other <xref:System.Windows.DependencyObject> objects, a <xref:System.Windows.Freezable> object provides change notifications when sub-property values change.</span></span>  
  
-   <span data-ttu-id="8c74d-110">쉬운 복제: Freezable 클래스가 이미 전체 복제를 만드는 여러 메서드를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-110">Easy cloning: the Freezable class has already implemented several methods that produce deep clones.</span></span>  
  
 <span data-ttu-id="8c74d-111">사용 및 사용자 고유의 만들기에 대 한 내용은 <xref:System.Windows.Freezable> 개체를 참조 하세요 [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-111">For information on using and creating your own <xref:System.Windows.Freezable> objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="8c74d-112">모든 공용 <see langword="static" /> 이 형식의 멤버는 스레드로부터 안전 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-112">Any public <see langword="static" /> members of this type are thread safe.</span></span> <span data-ttu-id="8c74d-113">인터페이스 멤버는 스레드로부터 안전하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-113">Any instance members are not guaranteed to be thread safe.</span></span>  
  
<span data-ttu-id="8c74d-114">경우는 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="false" />, <see cref="T:System.Windows.Freezable" /> 개체는 생성 된 스레드에서만에서 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-114">When the <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" />, a <see cref="T:System.Windows.Freezable" /> object can be accessed only from the thread on which it was created.</span></span> <span data-ttu-id="8c74d-115">다른 스레드에서 throw에서 액세스를 시도 <see cref="T:System.InvalidOperationException" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-115">Attempting to access it from another thread throws an <see cref="T:System.InvalidOperationException" />.</span></span> <span data-ttu-id="8c74d-116">합니다 <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> 고 <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> 메서드에 대 한 올바른 스레드로 마샬링 지원을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-116">The <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> and <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> methods provide support for marshalling to the correct thread.</span></span>  
  
<span data-ttu-id="8c74d-117">경우 해당 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="true" />, <see cref="T:System.Windows.Freezable" /> 자유 스레드 개체는 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-117">When their <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objects are free-threaded.</span></span>  <span data-ttu-id="8c74d-118">자세한 내용은 [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8c74d-118">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-119"><see cref="T:System.Windows.Freezable" /> 파생 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-119">Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-120">추상 클래스의 보호 된 접근성 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-120">This is the protected-accessibility constructor of an abstract class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8c74d-121">개체를 수정 불가능으로 설정할 수 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-121">Gets a value that indicates whether the object can be made unmodifiable.</span></span></summary>
        <value><span data-ttu-id="8c74d-122">개체를 수정 불가능으로 설정할 수 있거나 이미 수정 불가능이면 <see langword="true" />이고, 설정할 수 없으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-122"><see langword="true" /> if the current object can be made unmodifiable or is already unmodifiable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-123">이 메서드 구현에서 사용 합니다 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드를 <paramref name="isChecking" /> 로 설정 <see langword="true" /> 결정할 여부를 <see cref="T:System.Windows.Freezable" /> 수정할 수.</span><span class="sxs-lookup"><span data-stu-id="8c74d-123">This method implementation uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method with <paramref name="isChecking" /> set to <see langword="true" /> to determine whether a <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span></span> <span data-ttu-id="8c74d-124">파생된 클래스에서이 속성의 동작을 수정 하려면 재정의 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-124">To modify the way this property behaves in a derived class, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8c74d-125"><see cref="T:System.Windows.Freezable" /> 또는 여기에 들어 있는 개체가 수정될 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-125">Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-126">추가 하거나 현재 개체를 수정할 수 없을 때 이벤트 처리기를 제거 하려는 경우 (때 합니다 <xref:System.Windows.Freezable.IsFrozen%2A> 속성은 `true`), 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-126">If you attempt to add or remove event handlers when the current object is not modifiable (when the <xref:System.Windows.Freezable.IsFrozen%2A> property is `true`), an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-127">개체 값의 전체 복사본을 만들어 <see cref="T:System.Windows.Freezable" />의 수정 가능한 복제본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-127">Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values.</span></span> <span data-ttu-id="8c74d-128">개체의 종속성 속성을 복사하는 경우 이 메서드는 더 이상 확인되지 않을 수도 있는 식을 복사하지만 애니메이션 또는 해당 현재 값은 복사하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-128">When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</span></span></summary>
        <returns><span data-ttu-id="8c74d-129">현재 개체의 수정 가능한 복제본입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-129">A modifiable clone of the current object.</span></span> <span data-ttu-id="8c74d-130">소스의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성이 <see langword="true." />인 경우에도 복제된 개체의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-130">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-131"><xref:System.Windows.Freezable.Clone%2A> 하 고 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드 생성의 수정 가능한 복제본 고정 <xref:System.Windows.Freezable> 개체 (도 복제 <xref:System.Windows.Freezable> 고정 되지 않은 개체).</span><span class="sxs-lookup"><span data-stu-id="8c74d-131">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="8c74d-132">복제는 현재 개체의 전체 복사본을 효과적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-132">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="8c74d-133">다음 표에서 간의 차이점을 요약 합니다 <xref:System.Windows.Freezable.Clone%2A> 및 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-133">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="8c74d-134">작업</span><span class="sxs-lookup"><span data-stu-id="8c74d-134">Action</span></span>|<span data-ttu-id="8c74d-135">Clone 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="8c74d-135">Clone method behavior</span></span>|<span data-ttu-id="8c74d-136">CloneCurrentValue 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="8c74d-136">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="8c74d-137">식이 포함 된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="8c74d-137">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="8c74d-138">식 복사 되지만, 더 이상 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-138">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="8c74d-139">자세한 내용은 [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8c74d-139">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="8c74d-140">식 자체 아닌 식의 현재 값을 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-140">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="8c74d-141">애니메이션된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="8c74d-141">Copying an animated dependency property</span></span>|<span data-ttu-id="8c74d-142">속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-142">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="8c74d-143">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-143">Animations are not copied.</span></span>|<span data-ttu-id="8c74d-144">속성의 현재 애니메이션된 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-144">The property's current animated value is copied.</span></span> <span data-ttu-id="8c74d-145">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-145">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="8c74d-146">참고가 설정 되지 않은 속성은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-146">Note that unset properties are not copied.</span></span> <span data-ttu-id="8c74d-147">설정 되지 않은 속성에는 고정 된 기본값이 경우 <xref:System.Windows.Freezable>, 속성 값의 수정 가능한 복제본에서 고정 된 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-147">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="8c74d-148">스레드 간 Freezable 이동</span><span class="sxs-lookup"><span data-stu-id="8c74d-148">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="8c74d-149">이 메서드는 이동 하는 데 유용할 수 있습니다는 <xref:System.Windows.Freezable> 스레드 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-149">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="8c74d-150">먼저 확인 합니다 <xref:System.Windows.Freezable> 를 호출 하 여 수정할 수 없도록 해당 <xref:System.Windows.Freezable.Freeze%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-150">First, make the <xref:System.Windows.Freezable> unmodifiable by calling its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="8c74d-151">이제 다른 스레드가 액세스할 수 합니다 <xref:System.Windows.Freezable> 하 고 로컬 <xref:System.Windows.Freezable.Clone%2A> 액세스할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-151">Now another thread can access the <xref:System.Windows.Freezable> and make a local <xref:System.Windows.Freezable.Clone%2A> that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-152">이 메서드는 <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> 복제본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-152">This method uses <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> to produce the clone.</span></span> <span data-ttu-id="8c74d-153">파생된 클래스에서이 메서드의 동작을 수정 하려면 재정의 <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-153">To modify the behavior of this method in a derived class, override the <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> method.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="8c74d-154">복제할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-154">The object to clone.</span></span></param>
        <summary><span data-ttu-id="8c74d-155">기본(애니메이션이 적용되지 않은) 속성 값을 사용하여 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 복제본(전체 복사본)으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-155">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-156">이 메서드는 <xref:System.Windows.Freezable.Clone%2A> 메서드는 호출 하지 않은 수 사용자 코드에서 직접 제외 하 고이 메서드를 재정의 하는 동안 기본 구현을 호출 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="8c74d-156">This method is called by the <xref:System.Windows.Freezable.Clone%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="8c74d-157">현재 개체의 수정 가능한 복사본을 만들려면 호출 <xref:System.Windows.Freezable.Clone%2A> 이 메서드를 직접 호출 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-157">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.Clone%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-158">파생 하는 경우 <see cref="T:System.Windows.Freezable" />,이 메서드를 재정의 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-158">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span></span> <span data-ttu-id="8c74d-159">재정의 하는 이유는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-159">Reasons to override include the following:</span></span> 
<span data-ttu-id="8c74d-160">-파생된 클래스는 종속성 속성을 통해 노출 되지 않는 데이터를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-160">-   Your derived class has data that is not exposed via dependency properties.</span></span>  
  
<span data-ttu-id="8c74d-161">-파생 된 클래스 재정의 하 여 구현할 수 없는 추가 초기화 작업을 수행 해야 <see cref="M:System.Windows.Freezable.CreateInstanceCore" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-161">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span></span> <span data-ttu-id="8c74d-162">파생된 클래스에서 구현 하는 경우 예를 들어이 적용 됩니다 <see cref="T:System.ComponentModel.ISupportInitialize" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-162">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span></span>  
  
<span data-ttu-id="8c74d-163">종속성 속성의 모든 데이터를 저장 하는 추가 초기화 작업을 수행할 필요가 없습니다 클래스 재정의 하지 않아도 <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-163">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.</span></span>  
  
<span data-ttu-id="8c74d-164">모든 구현이이 메서드의 기본 구현을 반드시 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-164">It is essential that all implementations call the base implementation of this method.</span></span> <span data-ttu-id="8c74d-165">구현만 기본 구현에 의해 수행 되지 않는 작업을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-165">Implementations should only perform work that is not performed by the default implementation.</span></span> <span data-ttu-id="8c74d-166">기본 구현에는 내부 식을 비롯 한 모든 쓰기 가능한 로컬에서 설정 속성을의 전체 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-166">The default implementation makes deep copies of all writable, locally set properties, including internal expressions.</span></span>  
  
<span data-ttu-id="8c74d-167">개체에 데이터 바인딩된 종속성 속성이 있으면 식 복사 되지만 더 이상 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-167">If the object has data-bound dependency properties, the expressions are copied but might no longer resolve.</span></span> <span data-ttu-id="8c74d-168">데이터 바인딩된 개체를 복제 하는 방법에 대 한 자세한 내용은 참조 하세요. [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-168">For more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span> <span data-ttu-id="8c74d-169">개체에 애니메이션이 적용 된 종속성 속성이 해당 속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-169">If the object has animated dependency properties, the base (non-animated) value of those properties is copied.</span></span> <span data-ttu-id="8c74d-170">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-170">Animations are not copied.</span></span>  
  
<span data-ttu-id="8c74d-171">메모는 설정 되지 않은 속성은 복사 되지 않으며 읽기 전용 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-171">Note that unset properties are not copied, nor are read-only properties.</span></span> <span data-ttu-id="8c74d-172">이러한 속성에는 고정 된 기본값이 있으면 <see cref="T:System.Windows.Freezable" />, 속성 값의 수정 가능한 복제본에서 고정 된 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-172">If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
<span data-ttu-id="8c74d-173">다음은이 메서드에 대 한 예상 되는 동작을 요약:</span><span class="sxs-lookup"><span data-stu-id="8c74d-173">The following list summarizes the expected behavior for this method:</span></span> 
<span data-ttu-id="8c74d-174">모든 복사본을 포함 하는 생성 된 복사- <see cref="T:System.Windows.Freezable" /> 하위 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-174">-   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.</span></span>  
  
<span data-ttu-id="8c74d-175">-설정 및 읽기 전용 속성 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-175">-   Unset and read-only properties are not copied.</span></span>  
  
<span data-ttu-id="8c74d-176">식 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-176">-   Expressions are copied.</span></span>  
  
<span data-ttu-id="8c74d-177">-None 이러한 하위 개체는 생성 시 고정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-177">-   None of these sub-objects are frozen on creation.</span></span>  
  
<span data-ttu-id="8c74d-178">자체-복사가 고정 되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-178">-   The copy itself is not frozen.</span></span>  
  
<span data-ttu-id="8c74d-179">-애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-179">-   Animations are not copied.</span></span>  
  
<span data-ttu-id="8c74d-180">속성-기본 값은 복사, 유효 하지 않음 애니메이션된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-180">-   Only property base values are copied, not current animated values.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-181">현재 값을 사용하여 <see cref="T:System.Windows.Freezable" />의 수정 가능한 복제본(전체 복사본)을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-181">Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</span></span></summary>
        <returns><span data-ttu-id="8c74d-182">현재 개체의 수정 가능한 복제본입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-182">A modifiable clone of the current object.</span></span> <span data-ttu-id="8c74d-183">소스의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성이 <see langword="true." />인 경우에도 복제된 개체의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-183">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-184"><xref:System.Windows.Freezable.Clone%2A> 하 고 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드 생성의 수정 가능한 복제본 고정 <xref:System.Windows.Freezable> 개체 (도 복제 <xref:System.Windows.Freezable> 고정 되지 않은 개체).</span><span class="sxs-lookup"><span data-stu-id="8c74d-184">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="8c74d-185">복제는 현재 개체의 전체 복사본을 효과적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-185">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="8c74d-186">다음 표에서 간의 차이점을 요약 합니다 <xref:System.Windows.Freezable.Clone%2A> 및 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-186">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="8c74d-187">작업</span><span class="sxs-lookup"><span data-stu-id="8c74d-187">Action</span></span>|<span data-ttu-id="8c74d-188">Clone 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="8c74d-188">Clone method behavior</span></span>|<span data-ttu-id="8c74d-189">CloneCurrentValue 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="8c74d-189">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="8c74d-190">식이 포함 된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="8c74d-190">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="8c74d-191">식 복사 되지만, 더 이상 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-191">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="8c74d-192">자세한 내용은 [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8c74d-192">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="8c74d-193">식 자체 아닌 식의 현재 값을 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-193">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="8c74d-194">애니메이션된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="8c74d-194">Copying an animated dependency property</span></span>|<span data-ttu-id="8c74d-195">속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-195">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="8c74d-196">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-196">Animations are not copied.</span></span>|<span data-ttu-id="8c74d-197">속성의 현재 애니메이션된 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-197">The property's current animated value is copied.</span></span> <span data-ttu-id="8c74d-198">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-198">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="8c74d-199">참고가 설정 되지 않은 속성은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-199">Note that unset properties are not copied.</span></span> <span data-ttu-id="8c74d-200">설정 되지 않은 속성에는 고정 된 기본값이 경우 <xref:System.Windows.Freezable>, 속성 값의 수정 가능한 복제본에서 고정 된 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-200">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="8c74d-201">스레드 간 Freezable 이동</span><span class="sxs-lookup"><span data-stu-id="8c74d-201">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="8c74d-202">이 메서드는 이동 하는 데 유용할 수 있습니다는 <xref:System.Windows.Freezable> 스레드 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-202">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="8c74d-203">먼저 확인 합니다 <xref:System.Windows.Freezable> 를 사용 하 여 수정할 수 없도록 해당 <xref:System.Windows.Freezable.Freeze%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-203">First, make the <xref:System.Windows.Freezable> unmodifiable by using its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="8c74d-204">이제 다른 스레드가 액세스할 수는 <xref:System.Windows.Freezable> 액세스할 수 있는 로컬 복제본을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-204">Now another thread can access the <xref:System.Windows.Freezable> and make a local clone that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-205">이 메서드는 사용 된 <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> 복제본; 생성 방법 <see cref="T:System.Windows.Freezable" /> 재정의 구현자 <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> 복사 생성 시 고정 되어 있지 않고 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-205">This method uses the <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> method to produce the clone; <see cref="T:System.Windows.Freezable" /> implementers who override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> must ensure that the copy is not frozen on creation.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="8c74d-206">복제할 <see cref="T:System.Windows.Freezable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-206">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span></span></param>
        <summary><span data-ttu-id="8c74d-207">현재 속성 값을 사용하여 이 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 수정 가능한 클론(전체 복사본)으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-207">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-208">이 메서드는 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드는 호출 하지 않은 수 사용자 코드에서 직접 제외 하 고이 메서드를 재정의 하는 동안 기본 구현을 호출 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="8c74d-208">This method is called by the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="8c74d-209">현재 개체의 수정 가능한 복사본을 만들려면 호출 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 이 메서드를 직접 호출 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-209">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.CloneCurrentValue%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-210">파생 하는 경우 <see cref="T:System.Windows.Freezable" />,이 메서드를 재정의 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-210">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span></span> <span data-ttu-id="8c74d-211">재정의 하는 이유는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-211">Reasons to override include the following:</span></span> 
<span data-ttu-id="8c74d-212">-파생된 클래스는 종속성 속성을 통해 노출 되지 않는 데이터를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-212">-   Your derived class has data that is not exposed via dependency properties.</span></span>  
  
<span data-ttu-id="8c74d-213">-파생 된 클래스 재정의 하 여 구현할 수 없는 추가 초기화 작업을 수행 해야 <see cref="M:System.Windows.Freezable.CreateInstanceCore" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-213">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span></span> <span data-ttu-id="8c74d-214">파생된 클래스에서 구현 하는 경우 예를 들어이 적용 됩니다 <see cref="T:System.ComponentModel.ISupportInitialize" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-214">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span></span>  
  
<span data-ttu-id="8c74d-215">종속성 속성의 모든 데이터를 저장 하는 추가 초기화 작업을 수행할 필요가 없습니다 클래스 재정의 하지 않아도 <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-215">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.</span></span>  
  
<span data-ttu-id="8c74d-216">모든 구현이이 메서드의 기본 구현을 반드시 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-216">It is essential that all implementations call the base implementation of this method.</span></span> <span data-ttu-id="8c74d-217">구현만 기본 구현에 의해 수행 되지 않는 작업을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-217">Implementations should only perform work that is not performed by the default implementation.</span></span> <span data-ttu-id="8c74d-218">기본 구현에는 쓰기 가능한에서 로컬로 설정 된 모든 속성의 전체 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-218">The default implementation makes deep copies of all writable, locally set properties.</span></span> <span data-ttu-id="8c74d-219">식 (예: 데이터 바인딩)를 사용 하 여 종속성 속성을 포함 하는 개체, 식 자체 아닌 식의 현재 값을 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-219">If the object contains dependency properties with expressions (such as a data binding), the current value of the expression is copied but not the expression itself.</span></span>  
  
<span data-ttu-id="8c74d-220">개체에서 종속성 속성에 애니메이션 효과가 적용 하는 경우에 해당 속성의 현재 애니메이션된 값을 복사 되 되지만 애니메이션 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-220">If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.</span></span>  
  
<span data-ttu-id="8c74d-221">메모는 설정 되지 않은 속성은 복사 되지 않으며 읽기 전용 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-221">Note that unset properties are not copied, nor are read-only properties.</span></span> <span data-ttu-id="8c74d-222">이러한 속성에는 고정 된 기본값이 있으면 <see cref="T:System.Windows.Freezable" />, 속성 값의 수정 가능한 복제본에서 고정 된 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-222">If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
<span data-ttu-id="8c74d-223">다음은이 메서드에 대 한 예상 되는 동작을 요약합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-223">The following list summarizes the expected behavior for this method.</span></span>  
  
<span data-ttu-id="8c74d-224">모든 복사본을 포함 하는 생성 된 복사- <see cref="T:System.Windows.Freezable" /> 하위 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-224">-   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.</span></span>  
  
<span data-ttu-id="8c74d-225">-설정 및 읽기 전용 속성 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-225">-   Unset and read-only properties are not copied.</span></span>  
  
<span data-ttu-id="8c74d-226">-속성 애니메이션이 적용 되어 있는 경우 해당 현재 값은 복사 이지만 애니메이션 자체에 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-226">-   If a property is animated, its current value is copied, but the animation itself is not.</span></span>  
  
<span data-ttu-id="8c74d-227">-None 이러한 하위 개체는 생성 시 고정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-227">-   None of these sub-objects are frozen on creation.</span></span>  
  
<span data-ttu-id="8c74d-228">자체-복사가 고정 되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-228">-   The copy itself is not frozen.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-229"><see cref="T:System.Windows.Freezable" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-229">Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</span></span></summary>
        <returns><span data-ttu-id="8c74d-230">새 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-230">The new instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-231">이 보호 된 메서드 및 동작에 대 한 실제 개체별 구현을 재정의 구현에 따라 다릅니다.는 <xref:System.Windows.Freezable.CreateInstanceCore%2A> 메서드를 내부적으로이 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-231">This is a protected method, and the actual object-specific implementations for the behavior are dependent on the override implementation of the <xref:System.Windows.Freezable.CreateInstanceCore%2A> method, which this method calls internally.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-232">파생 클래스에서 구현되는 경우 <see cref="T:System.Windows.Freezable" /> 파생 클래스의 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-232">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</span></span></summary>
        <returns><span data-ttu-id="8c74d-233">새 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-233">The new instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-234">직접 (제외 하면 기본 구현에서 호출)이이 메서드를 호출 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="8c74d-234">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="8c74d-235">이 메서드는 내부적으로 <xref:System.Windows.Freezable.CreateInstance%2A> 메서드를 때마다의 새 인스턴스를 <xref:System.Windows.Freezable> 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-235">This method is called internally by the <xref:System.Windows.Freezable.CreateInstance%2A> method whenever a new instance of the <xref:System.Windows.Freezable> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8c74d-236">다음 예제에서는 일반적인 구현은 <xref:System.Windows.Freezable.CreateInstanceCore%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-236">The following example shows a typical implementation of <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span></span>  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-237">모든 <see cref="T:System.Windows.Freezable" /> 파생된 클래스에서이 메서드를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-237">Every <see cref="T:System.Windows.Freezable" /> derived class must implement this method.</span></span> <span data-ttu-id="8c74d-238">일반적인 구현은 단순히 기본 생성자를 호출 하 고 결과 반환 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-238">A typical implementation is to simply call the default constructor and return the result.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8c74d-239"><see cref="T:System.Windows.Freezable" /> 개체를 수정할 수 없게 만들고 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성을 <see langword="true" />로 설정하거나, <see cref="T:System.Windows.Freezable" /> 개체를 수정할 수 없게 만들 수 있는지 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-239">Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-240">현재 개체를 수정할 수 없게 설정하고 해당 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성을 <see langword="true" />로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-240">Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-241">문제를 방지 하려면는 <xref:System.InvalidOperationException> 이 메서드를 호출 하는 경우 확인 합니다 <xref:System.Windows.Freezable.CanFreeze%2A> 속성을 여부를 <xref:System.Windows.Freezable> 수 없게이 메서드를 호출 하기 전에.</span><span class="sxs-lookup"><span data-stu-id="8c74d-241">To avoid the possibility of an <xref:System.InvalidOperationException> when calling this method, check the <xref:System.Windows.Freezable.CanFreeze%2A> property to determine whether the <xref:System.Windows.Freezable> can be made unmodifiable before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8c74d-242"><see cref="T:System.Windows.Freezable" />은 수정할 수 없도록 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-242">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-243">이 메서드는 사용 합니다 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드를는 <see cref="T:System.Windows.Freezable" /> 수정할 수 없게 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-243">This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable.</span></span> <span data-ttu-id="8c74d-244">중단 동작을 수정 하려면 재정의 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-244">To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable"><span data-ttu-id="8c74d-245">확인할 개체 또는 수정할 수 없게 만들 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-245">The object to check or make unmodifiable.</span></span> <span data-ttu-id="8c74d-246"><paramref name="isChecking" />이 <see langword="true" />이면 이 개체를 수정할 수 없게 만들 수 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-246">If <paramref name="isChecking" /> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable.</span></span> <span data-ttu-id="8c74d-247"><paramref name="isChecking" />이 <see langword="false" />이면 가능한 경우 개체를 수정할 수 없게 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-247">If <paramref name="isChecking" /> is <see langword="false" />, the object is made unmodifiable, if possible.</span></span></param>
        <param name="isChecking"><span data-ttu-id="8c74d-248">개체를 실제로 고정하지 않고 고정할 수 있는지 여부를 반환하려면 <see langword="true" />이고, 개체를 실제로 고정하려면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-248"><see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span></span></param>
        <summary><span data-ttu-id="8c74d-249"><paramref name="isChecking" /> 매개 변수가 <see langword="true" />이면 이 메서드는 지정된 <see cref="T:System.Windows.Freezable" />을 수정할 수 없게 만들 수 있는지 여부를 알려 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-249">If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span></span> <span data-ttu-id="8c74d-250"><paramref name="isChecking" /> 매개 변수가 <see langword="false" />이면 이 메서드는 지정된 <see cref="T:System.Windows.Freezable" />을 수정할 수 없게 만들고 이 작업에 성공했는지 여부를 알려 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-250">If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="8c74d-251"><paramref name="isChecking" />이 <see langword="true" />인 경우 이 메서드는 지정된 <see cref="T:System.Windows.Freezable" />을 수정할 수 없게 만들 수 있으면 <see langword="true" />를, 그렇지 않으면 <see langword="false" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-251">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span></span> <span data-ttu-id="8c74d-252"><paramref name="isChecking" />이 <see langword="false" />인 경우 이 메서드는 지정된 <see cref="T:System.Windows.Freezable" />을 이제 수정할 수 없으면 <see langword="true" />를, 수정할 수 없게 만들 수 없으면 <see langword="false" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-252">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-253">파생 하는 경우가 아니면이 메서드를 호출 하지 마세요 <xref:System.Windows.Freezable> 재정의 <xref:System.Windows.Freezable.FreezeCore%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-253">Do not call this method unless you are deriving from <xref:System.Windows.Freezable> and overriding the <xref:System.Windows.Freezable.FreezeCore%2A> method.</span></span>  <span data-ttu-id="8c74d-254">이 메서드를 사용할 수는 <xref:System.Windows.Freezable.FreezeCore%2A> 자체는 클래스 데이터 멤버를 고정 하는 방법 <xref:System.Windows.Freezable> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-254">This method may be used in the <xref:System.Windows.Freezable.FreezeCore%2A> method to freeze class data members that are themselves <xref:System.Windows.Freezable> objects.</span></span>  
  
 <span data-ttu-id="8c74d-255">잘 지 내에서이 메서드를 다시 호출 하는 것을 <xref:System.Windows.Freezable> 개체 (수정할 수 없게) 이미 고정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-255">It is alright to call this method again on a <xref:System.Windows.Freezable> object that is already frozen (unmodifiable).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8c74d-256"><paramref name="isChecking" />이 <see langword="false" />인 경우 <paramref name="freezable" />을 수정할 수 없게 만드는 작업이 실패하면 개체의 상태를 알 수 없게 되며, 부분적으로 고정될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-256">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-257">이 메서드는 사용 합니다 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드를는 <see cref="T:System.Windows.Freezable" /> 수정할 수 없게 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-257">This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable.</span></span> <span data-ttu-id="8c74d-258">중단 동작을 수정 하려면 재정의 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-258">To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><span data-ttu-id="8c74d-259">개체를 실제로 고정하지 않고 고정할 수 있는지 여부를 반환하려면 <see langword="true" />이고, 개체를 실제로 고정하려면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-259"><see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span></span></param>
        <summary><span data-ttu-id="8c74d-260"><see cref="T:System.Windows.Freezable" />을 수정할 수 없게 만들거나, 수정할 수 없게 만들 수 있는지 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-260">Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</span></span></summary>
        <returns><span data-ttu-id="8c74d-261"><paramref name="isChecking" />이 <see langword="true" />인 경우 이 메서드는 <see cref="T:System.Windows.Freezable" />을 수정할 수 없게 만들 수 있으면 <see langword="true" />를, 그렇지 않으면 <see langword="false" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-261">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span></span> <span data-ttu-id="8c74d-262"><paramref name="isChecking" />이 <see langword="false" />인 경우 이 메서드는 지정된 <see cref="T:System.Windows.Freezable" />을 이제 수정할 수 없으면 <see langword="true" />를, 수정할 수 없게 만들 수 없으면 <see langword="false" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-262">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-263">직접 (제외 하면 기본 구현에서 호출)이이 메서드를 호출 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="8c74d-263">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="8c74d-264">이 메서드는 내부적으로 호출 합니다 <xref:System.Windows.Freezable.CanFreeze%2A> 속성 (사용 하 여 `isChecking` 같음 `true`) 및 <xref:System.Windows.Freezable.Freeze%2A> 메서드 (사용 하 여 `isChecking` 같음 `false`).</span><span class="sxs-lookup"><span data-stu-id="8c74d-264">This method is called internally by the <xref:System.Windows.Freezable.CanFreeze%2A> property (with `isChecking` equal to `true`) and the <xref:System.Windows.Freezable.Freeze%2A> method (with `isChecking` equal to `false`).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-265">
            <see cref="T:System.Windows.Freezable" /> 구현자는 클래스는 종속성 속성을 사용 하 여 저장 되지 않은 데이터를 포함 하는 경우이 메서드를 재정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-265">
            <see cref="T:System.Windows.Freezable" /> implementers must override this method when the class contains data that is not stored using dependency properties.</span></span>  
  
<span data-ttu-id="8c74d-266">일반적인 구현은 기본를 호출한 다음 정적 호출 <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> 메서드를 모두 <see cref="T:System.Windows.Freezable" /> 형식의 반환을 클래스에 들어 있는 속성을 <see langword="true" /> 또는 경우에 모든 속성이 고정 된 (수 있는 고정 된을 지정 하는 경우 <see langword="true" /> 에 대 한 <paramref name="isChecking" />).</span><span class="sxs-lookup"><span data-stu-id="8c74d-266">A typical implementation would call base, then call the static <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> method on all <see cref="T:System.Windows.Freezable" /> typed properties that the class contains, returning <see langword="true" /> only if all properties were frozen (or could have been frozen, in the case of specifying <see langword="true" /> for <paramref name="isChecking" />).</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-267">애니메이션이 적용되지 않은 기준 속성 값을 사용하여 <see cref="T:System.Windows.Freezable" />의 고정된 복사본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-267">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values.</span></span> <span data-ttu-id="8c74d-268">복사본이 고정되므로 고정된 하위 개체는 모두 참조를 통해 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-268">Because the copy is frozen, any frozen sub-objects are copied by reference.</span></span></summary>
        <returns><span data-ttu-id="8c74d-269"><see cref="T:System.Windows.Freezable" />의 고정된 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-269">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span></span> <span data-ttu-id="8c74d-270">복사본의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="true" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-270">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-271">확인 해야 합니다 <xref:System.Windows.Freezable.CanFreeze%2A> 되어 있는지 확인 하려면이 메서드를 호출 하기 전에 속성은 <xref:System.Windows.Freezable> 고정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-271">You should check the <xref:System.Windows.Freezable.CanFreeze%2A> property before calling this method to verify that the <xref:System.Windows.Freezable> can be frozen.</span></span> <span data-ttu-id="8c74d-272">이 메서드를 사용 하는 것은 사용 하 여 복사본을 만드는 것과 유사 합니다 <xref:System.Windows.Freezable.Clone%2A> 한 다음 사용 하 여 고정 및를 <xref:System.Windows.Freezable.Freeze%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-272">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.Clone%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="8c74d-273"><xref:System.Windows.Freezable.GetAsFrozen%2A> 하 고 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 복제 하지 마세요 있으므로 메서드 복사 성능이 향상 <xref:System.Windows.Freezable> 하위 개체는는 이미 고정 된;만 복사 되 고 참조로 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-273">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="8c74d-274">다음 표에서 간의 차이점을 요약 합니다 <xref:System.Windows.Freezable.GetAsFrozen%2A> 및 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-274">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="8c74d-275">작업</span><span class="sxs-lookup"><span data-stu-id="8c74d-275">Action</span></span>|<span data-ttu-id="8c74d-276">GetAsFrozen 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="8c74d-276">GetAsFrozen method behavior</span></span>|<span data-ttu-id="8c74d-277">GetCurrentValueAsFrozen 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="8c74d-277">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="8c74d-278">식이 포함 된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="8c74d-278">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="8c74d-279">메서드에서 throw 한 <xref:System.InvalidOperationException> 수 없어서 <xref:System.Windows.Freezable.Freeze%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-279">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="8c74d-280">식 자체 아닌 식의 현재 값을 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-280">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="8c74d-281">애니메이션된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="8c74d-281">Copying an animated dependency property</span></span>|<span data-ttu-id="8c74d-282">속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-282">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="8c74d-283">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-283">Animations are not copied.</span></span>|<span data-ttu-id="8c74d-284">속성의 현재 애니메이션된 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-284">The property's current animated value is copied.</span></span> <span data-ttu-id="8c74d-285">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-285">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="8c74d-286">메모는 설정 되지 않은 속성은 복사 되지 않으며 읽기 전용 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-286">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="8c74d-287">복사본을 만드는 합니다 <xref:System.Windows.Freezable> 즉 고정된 되지를 사용 하 여는 <xref:System.Windows.Freezable.Clone%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-287">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.Clone%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8c74d-288">식 또는 애니메이션이 적용된 속성이 들어 있어서 <see cref="T:System.Windows.Freezable" />을 고정할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="8c74d-288">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-289">이 메서드를 사용 하 여 가상 <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> 메서드 복제본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-289">This method uses the virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="8c74d-290">복사할 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-290">The instance to copy.</span></span></param>
        <summary><span data-ttu-id="8c74d-291">기본(애니메이션이 적용되지 않은) 속성 값을 사용하여 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 고정된 복제본으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-291">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-292">이 메서드는 <xref:System.Windows.Freezable.GetAsFrozen%2A> 메서드는 호출 하지 않은 수 사용자 코드에서 직접 제외 하 고이 메서드를 재정의 하는 동안 기본 구현을 호출 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="8c74d-292">This method is called by the <xref:System.Windows.Freezable.GetAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="8c74d-293">현재 개체의 고정 된 복사본을 만들려면 호출 <xref:System.Windows.Freezable.GetAsFrozen%2A> 이 메서드를 직접 호출 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-293">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-294">파생 하는 경우 <see cref="T:System.Windows.Freezable" /> 이 메서드를 재정의 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-294">If you derive from <see cref="T:System.Windows.Freezable" /> you may need to override this method.</span></span> <span data-ttu-id="8c74d-295">재정의 하는 이유는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-295">Reasons to override include the following:</span></span> 
<span data-ttu-id="8c74d-296">-파생된 클래스는 종속성 속성을 통해 노출 되지 않는 데이터를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-296">-   Your derived class has data that is not exposed via dependency properties.</span></span>  
  
<span data-ttu-id="8c74d-297">-파생 된 클래스 재정의 하 여 구현할 수 없는 추가 초기화 작업을 수행 해야 <see cref="M:System.Windows.Freezable.CreateInstanceCore" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-297">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span></span> <span data-ttu-id="8c74d-298">파생된 클래스에서 구현 하는 경우 예를 들어이 적용 됩니다 <see cref="T:System.ComponentModel.ISupportInitialize" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-298">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span></span>  
  
<span data-ttu-id="8c74d-299">종속성 속성의 모든 데이터를 저장 하는 추가 초기화 작업을 수행할 필요가 없습니다 클래스 재정의 하지 않아도 <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-299">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.</span></span>  
  
<span data-ttu-id="8c74d-300">모든 구현이이 메서드의 기본 구현을 반드시 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-300">It is essential that all implementations call the base implementation of this method.</span></span> <span data-ttu-id="8c74d-301">구현만 기본 구현에 의해 수행 되지 않는 작업을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-301">Implementations should only perform work that is not performed by the default implementation.</span></span> <span data-ttu-id="8c74d-302">기본 구현에는 모든 고정 되지 않은 freezable 다른 모든 쓰기 가능한의 단순 복사본을 로컬로 포함 된 설정 속성의 전체 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-302">The default implementation makes deep copies of any unfrozen freezables and shallow copies of all other writable, locally set properties it contains.</span></span> <span data-ttu-id="8c74d-303">개체 데이터 바인딩 종속성 속성에 식 복사 됩니다 되지만 더 이상 해결할 수 없습니다. 데이터 바인딩된 개체를 복제 하는 방법에 대 한 자세한 내용은 참조 하세요. [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-303">If the object has data-bound dependency properties, the expressions are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span> <span data-ttu-id="8c74d-304">개체에 애니메이션이 적용 된 종속성 속성이 해당 속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-304">If the object has animated dependency properties, the base (non-animated) values of those properties are copied.</span></span> <span data-ttu-id="8c74d-305">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-305">Animations are not copied.</span></span>  
  
<span data-ttu-id="8c74d-306">메모는 설정 되지 않은 속성은 복사 되지 않으며 읽기 전용 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-306">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
<span data-ttu-id="8c74d-307">이 메서드를 재정의 하는 경우에 기본 구현을 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-307">If you do override this method, you must call the base implementation.</span></span>  
  
<span data-ttu-id="8c74d-308">필요가 없습니다 <see cref="M:System.Windows.Freezable.Freeze" /> 값 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-308">You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.</span></span>  <span data-ttu-id="8c74d-309">결과 고정 한 <see cref="M:System.Windows.Freezable.GetAsFrozen" /> 반환 되기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-309">The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-310">현재 속성 값을 사용하여 <see cref="T:System.Windows.Freezable" />의 고정된 복사본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-310">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values.</span></span> <span data-ttu-id="8c74d-311">복사본이 고정되므로 고정된 하위 개체는 모두 참조를 통해 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-311">Because the copy is frozen, any frozen sub-objects are copied by reference.</span></span></summary>
        <returns><span data-ttu-id="8c74d-312"><see cref="T:System.Windows.Freezable" />의 고정된 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-312">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span></span> <span data-ttu-id="8c74d-313">복사본의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="true" />로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-313">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-314">이 메서드를 사용 하는 것은 사용 하 여 복사본을 만드는 것과 유사 합니다 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 한 다음 사용 하 여 고정 및를 <xref:System.Windows.Freezable.Freeze%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-314">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.CloneCurrentValue%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="8c74d-315"><xref:System.Windows.Freezable.GetAsFrozen%2A> 하 고 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 복제 하지 마세요 있으므로 메서드 복사 성능이 향상 <xref:System.Windows.Freezable> 하위 개체는는 이미 고정 된;만 복사 되 고 참조로 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-315">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="8c74d-316">다음 표에서 간의 차이점을 요약 합니다 <xref:System.Windows.Freezable.GetAsFrozen%2A> 및 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-316">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="8c74d-317">작업</span><span class="sxs-lookup"><span data-stu-id="8c74d-317">Action</span></span>|<span data-ttu-id="8c74d-318">GetAsFrozen 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="8c74d-318">GetAsFrozen method behavior</span></span>|<span data-ttu-id="8c74d-319">GetCurrentValueAsFrozen 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="8c74d-319">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="8c74d-320">식이 포함 된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="8c74d-320">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="8c74d-321">메서드에서 throw 한 <xref:System.InvalidOperationException> 수 없어서 <xref:System.Windows.Freezable.Freeze%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-321">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="8c74d-322">식 자체 아닌 식의 현재 값을 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-322">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="8c74d-323">애니메이션된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="8c74d-323">Copying an animated dependency property</span></span>|<span data-ttu-id="8c74d-324">속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-324">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="8c74d-325">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-325">Animations are not copied.</span></span>|<span data-ttu-id="8c74d-326">속성의 현재 애니메이션된 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-326">The property's current animated value is copied.</span></span> <span data-ttu-id="8c74d-327">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-327">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="8c74d-328">메모는 설정 되지 않은 속성은 복사 되지 않으며 읽기 전용 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-328">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="8c74d-329">복사본을 만드는 합니다 <xref:System.Windows.Freezable> 즉 고정된 되지를 사용 하 여는 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8c74d-329">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-330">이 메서드를 사용 하 여 가상 <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> 메서드 복제본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-330">This method uses the virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="8c74d-331">복사 및 고정할 <see cref="T:System.Windows.Freezable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-331">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span></span></param>
        <summary><span data-ttu-id="8c74d-332">현재 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 고정 클론으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-332">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span></span> <span data-ttu-id="8c74d-333">개체에 애니메이션 효과를 준 종속성 속성이 있는 경우 애니메이션 효과를 준 현재 값이 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-333">If the object has animated dependency properties, their current animated values are copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-334">이 메서드는 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 메서드는 호출 하지 않은 수 사용자 코드에서 직접 제외 하 고이 메서드를 재정의 하는 동안 기본 구현을 호출 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="8c74d-334">This method is called by the <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="8c74d-335">현재 개체의 고정 된 복사본을 만들려면 호출 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 이 메서드를 직접 호출 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-335">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-336">파생 하는 경우 <see cref="T:System.Windows.Freezable" />,이 메서드를 재정의 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-336">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span></span> <span data-ttu-id="8c74d-337">재정의 하는 이유는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-337">Reasons to override include the following:</span></span> 
<span data-ttu-id="8c74d-338">-파생된 클래스는 종속성 속성을 통해 노출 되지 않는 데이터를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-338">-   Your derived class has data that is not exposed via dependency properties.</span></span>  
  
<span data-ttu-id="8c74d-339">-파생 된 클래스 재정의 하 여 구현할 수 없는 추가 초기화 작업을 수행 해야 <see cref="M:System.Windows.Freezable.CreateInstanceCore" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-339">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span></span> <span data-ttu-id="8c74d-340">파생된 클래스에서 구현 하는 경우 예를 들어이 적용 됩니다 <see cref="T:System.ComponentModel.ISupportInitialize" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-340">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span></span>  
  
<span data-ttu-id="8c74d-341">종속성 속성의 모든 데이터를 저장 하는 추가 초기화 작업을 수행할 필요가 없습니다 클래스 재정의 하지 않아도 <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-341">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.</span></span>  
  
<span data-ttu-id="8c74d-342">모든 구현이이 메서드의 기본 구현을 반드시 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-342">It is essential that all implementations call the base implementation of this method.</span></span> <span data-ttu-id="8c74d-343">구현만 기본 구현에 의해 수행 되지 않는 작업을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-343">Implementations should only perform work that is not performed by the default implementation.</span></span> <span data-ttu-id="8c74d-344">기본 구현에서는 새 <see cref="T:System.Windows.Freezable" /> 를 사용 하는 <see cref="M:System.Windows.Freezable.CreateInstance" /> 고정 되지 않은 freezable의 전체 복사본을 메서드 및 다른 모든 쓰기 가능한의 단순 복사본은 로컬로 포함 된 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-344">The default implementation creates a new <see cref="T:System.Windows.Freezable" /> using the <see cref="M:System.Windows.Freezable.CreateInstance" /> method and makes deep copies of unfrozen freezables and shallow copies of all other writable, locally set properties it contains.</span></span> <span data-ttu-id="8c74d-345">개체에 데이터 바인딩된 종속성 속성이 데이터 바인딩을 복사 됩니다 되지만 더 이상 해결할 수 없습니다. 데이터 바인딩된 개체를 복제 하는 방법에 대 한 자세한 내용은 참조 하세요. [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-345">If the object has data-bound dependency properties, the data bindings are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span> <span data-ttu-id="8c74d-346">개체에서 종속성 속성에 애니메이션 효과가 적용 하는 경우에 해당 속성의 현재 애니메이션된 값을 복사 되 되지만 애니메이션 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-346">If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.</span></span>  
  
<span data-ttu-id="8c74d-347">내에서 읽기 전용 종속성 속성을 <see cref="T:System.Windows.Freezable" /> 이 기본 구현에서 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-347">Read-only dependency properties within a <see cref="T:System.Windows.Freezable" /> are not copied by this default implementation.</span></span>  
  
<span data-ttu-id="8c74d-348">이 메서드를 재정의 하는 경우에 기본 구현을 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-348">If you do override this method, you must call the base implementation.</span></span>  
  
<span data-ttu-id="8c74d-349">필요가 없습니다 <see cref="M:System.Windows.Freezable.Freeze" /> 값 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-349">You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.</span></span>  <span data-ttu-id="8c74d-350">결과 고정 한 <see cref="M:System.Windows.Freezable.GetAsFrozen" /> 반환 되기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-350">The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8c74d-351">개체가 현재 수정 가능한지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-351">Gets a value that indicates whether the object is currently modifiable.</span></span></summary>
        <value><span data-ttu-id="8c74d-352">개체가 고정되어 있어 수정할 수 없으면 <see langword="true" />이고, 개체를 수정할 수 있으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-352"><see langword="true" /> if the object is frozen and cannot be modified; <see langword="false" /> if the object can be modified.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-353">개체를 수정 하는 경우 해당 <xref:System.Windows.Freezable.IsFrozen%2A> 속성은 `true` throw는 <xref:System.InvalidOperationException>합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-353">Attempting to modify an object when its <xref:System.Windows.Freezable.IsFrozen%2A> property is `true` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="8c74d-354">이 속성은 개체 모델 관점에서 읽기 전용.</span><span class="sxs-lookup"><span data-stu-id="8c74d-354">This property is read-only from the object model perspective.</span></span> <span data-ttu-id="8c74d-355">에 대 한 설명서의 일부 <xref:System.Windows.Freezable> 동작을 언급할 수 있습니다 "설정 <xref:System.Windows.Freezable.IsFrozen%2A> 하 `true`" 또는 다른 방법의 동작을 설명할 때 <xref:System.Windows.Freezable>, 있지만이 동작에서에서 발생 하는 내부적으로 클래스 인스턴스 때 인스턴스 메서드는 추상 클래스 내에 있는 개인 변수를 조작 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-355">Some of the documentation about <xref:System.Windows.Freezable> behaviors may mention "sets <xref:System.Windows.Freezable.IsFrozen%2A> to `true`" or similar language when discussing the behavior of other methods of <xref:System.Windows.Freezable>, but this behavior is happening internally in the class instances, when methods of the instance manipulate the private variables that exist within the abstract class.</span></span> <span data-ttu-id="8c74d-356">이 속성의 값을 설정 하려면 호출 해야 <xref:System.Windows.Freezable.Freeze%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-356">To set the value of this property, you should call <xref:System.Windows.Freezable.Freeze%2A>.</span></span> <span data-ttu-id="8c74d-357">변경 하는 일회성 작업을 효과적으로 이것이 <xref:System.Windows.Freezable.IsFrozen%2A> 초기 기본값과에서 속성 `false` 상태는 `true` 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-357">This effectively is a one-time operation to change the <xref:System.Windows.Freezable.IsFrozen%2A> property from the initial default `false` state to the `true` state.</span></span> <span data-ttu-id="8c74d-358">값을 설정할 수는 없습니다 다시 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-358">There is no available means to set the value back to `false`.</span></span> <span data-ttu-id="8c74d-359">대신 원래에서 만든 전체 복사본을 변경할 수 있습니다 (참조는 <xref:System.Windows.Freezable.Clone%2A> 메서드).</span><span class="sxs-lookup"><span data-stu-id="8c74d-359">Instead, you could change any deep copy made from the original (see the <xref:System.Windows.Freezable.Clone%2A> method).</span></span> <span data-ttu-id="8c74d-360">이 동작은 의도적인 것 이며 사례에 적용 하는 경우 파생된 클래스 동작 방식 여기서는 <xref:System.Windows.Freezable> 패턴은 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-360">This is by design and is how any derived class should behave when applied to the cases where the <xref:System.Windows.Freezable> pattern is useful.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-361">현재 <see cref="T:System.Windows.Freezable" /> 개체가 수정될 때 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-361">Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-362">이 메서드는 때마다는 <xref:System.Windows.Freezable.Changed> 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-362">This method is called whenever the <xref:System.Windows.Freezable.Changed> event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-363">파생 된 클래스를 구현 하는 경우 <see cref="T:System.Windows.Freezable" />, 작업을 수행 하려면이 메서드를 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-363">When you implement a class that derives from <see cref="T:System.Windows.Freezable" />, you may override this method to perform tasks.</span></span></para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8c74d-364">방금 수정된 <see cref="T:System.Windows.DependencyObject" /> 형식 데이터 멤버에 대한 적절한 컨텍스트 포인터를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-364">Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="8c74d-365">데이터 멤버의 이전 값입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-365">The previous value of the data member.</span></span></param>
        <param name="newValue"><span data-ttu-id="8c74d-366">데이터 멤버의 현재 값입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-366">The current value of the data member.</span></span></param>
        <summary><span data-ttu-id="8c74d-367">방금 설정된 <see cref="T:System.Windows.DependencyObjectType" /> 데이터 멤버에 대한 적절한 컨텍스트 포인터를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-367">Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-368">이 메서드를 호출 해야 <xref:System.Windows.Freezable> 상속자 때마다를 <xref:System.Windows.DependencyObject> 으로 저장 되지 않은 데이터 멤버는 <xref:System.Windows.DependencyProperty> 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-368">This method should be called by <xref:System.Windows.Freezable> inheritors each time a <xref:System.Windows.DependencyObject> data member that is not stored as a <xref:System.Windows.DependencyProperty> is set.</span></span>  
  
 <span data-ttu-id="8c74d-369">이 메서드를 호출할 필요가 없습니다 <xref:System.Windows.DependencyObject> 를 사용 하 여 저장 된 데이터 멤버는 <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-369">This method does not need to be called for <xref:System.Windows.DependencyObject> data members that are stored using a <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="8c74d-370">데이터 멤버의 이전 값입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-370">The previous value of the data member.</span></span></param>
        <param name="newValue"><span data-ttu-id="8c74d-371">데이터 멤버의 현재 값입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-371">The current value of the data member.</span></span></param>
        <param name="property"><span data-ttu-id="8c74d-372">변경된 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-372">The property that changed.</span></span></param>
        <summary><span data-ttu-id="8c74d-373">이 멤버는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 인프라를 지원하며 코드에서 직접 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-373">This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="8c74d-374">변경된 속성, 해당하는 이전 값 및 새 값에 관한 정보가 포함된 이벤트 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-374">Event data that contains information about which property changed, and its old and new values.</span></span></param>
        <summary><span data-ttu-id="8c74d-375"><see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />의 <see cref="T:System.Windows.DependencyObject" /> 구현을 재정의하여 <see cref="T:System.Windows.Freezable" /> 형식의 변화하는 종속성 속성에 대한 응답으로 <see cref="E:System.Windows.Freezable.Changed" /> 처리기도 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-375">Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-376">이벤트 데이터에 대 한 정보가는 <xref:System.Windows.Freezable> 자체입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-376">The event data contains information about only the <xref:System.Windows.Freezable> itself.</span></span> <span data-ttu-id="8c74d-377">하위 속성 정보를 통해 얻어야 합니다 <xref:System.Windows.Freezable.Changed> 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-377">Any sub-property information must be obtained through the <xref:System.Windows.Freezable.Changed> handlers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-378">유효한 스레드에서 <see cref="T:System.Windows.Freezable" />에 액세스하고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-378">Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread.</span></span> <span data-ttu-id="8c74d-379"><see cref="T:System.Windows.Freezable" /> 상속자는 종속성 속성이 아닌 데이터 멤버를 읽는 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]의 시작 부분에서 이 메서드를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-379">Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-380">파생 된 클래스 <see cref="T:System.Windows.Freezable" /> 를 호출 해야 합니다 <see cref="M:System.Windows.Freezable.ReadPreamble" /> 메서드는 종속성 속성이 아닌는 모든 멤버에 액세스 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-380">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call the <see cref="M:System.Windows.Freezable.ReadPreamble" /> method before they attempt to access any members that are not dependency properties.</span></span> <span data-ttu-id="8c74d-381"><see cref="M:System.Windows.Freezable.WritePreamble" /> 이러한 멤버에 쓰기 전에 메서드를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-381">The <see cref="M:System.Windows.Freezable.WritePreamble" /> method should be called before any such members are written to.</span></span>  
  
<span data-ttu-id="8c74d-382">이 메서드가 효과적으로 아무 작업도 수행 하지 보다 호출 <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-382">This method effectively does nothing more than call <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-383"><see cref="T:System.Windows.Freezable" />에 대한 <see cref="E:System.Windows.Freezable.Changed" /> 이벤트를 발생시키고 해당 <see cref="M:System.Windows.Freezable.OnChanged" /> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-383">Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method.</span></span> <span data-ttu-id="8c74d-384"><see cref="T:System.Windows.Freezable" />에서 파생된 클래스는 종속성 속성으로 저장되지 않은 클래스 멤버를 수정하는 모든 API의 끝에서 이 메서드를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-384">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-385">파생 된 클래스 <see cref="T:System.Windows.Freezable" /> 으로 저장 하지 않는 클래스 멤버를 수정 하는 API 끝에이 메서드를 호출 해야는 <see cref="T:System.Windows.DependencyProperty" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-385">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies a class member that is not stored as a <see cref="T:System.Windows.DependencyProperty" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8c74d-386"><see cref="T:System.Windows.Freezable" />이 고정되어 있지 않고 유효한 스레드 컨텍스트에서 액세스되고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-386">Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context.</span></span> <span data-ttu-id="8c74d-387"><see cref="T:System.Windows.Freezable" /> 상속자는 종속성 속성이 아닌 데이터 멤버에 쓰는 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]의 시작 부분에서 이 메서드를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-387"><see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8c74d-388">이 메서드를 호출 <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 스레딩 컨텍스트에 액세스할 수 있으며, 경우에 예외를 throw 할는 <xref:System.Windows.Freezable> 인스턴스가 이미 고정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-388">This method calls <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> to verify the threading context is accessible, and it throws an exception if the <xref:System.Windows.Freezable> instance is already frozen.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8c74d-389"><see cref="T:System.Windows.Freezable" /> 인스턴스가 고정되어 있어 해당 멤버에 쓸 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="8c74d-389">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="8c74d-390">파생 된 클래스 <see cref="T:System.Windows.Freezable" /> 를 호출 해야 <see cref="M:System.Windows.Freezable.WritePreamble" /> 는 종속성 속성이 아닌 멤버에 쓰기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-390">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call <see cref="M:System.Windows.Freezable.WritePreamble" /> before attempting to write to any members that are not dependency properties.</span></span> <span data-ttu-id="8c74d-391">호출 하는 경우 <see cref="M:System.Windows.Freezable.WritePreamble" /> 에 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]에 대 한 호출을 생략할 수 있습니다 <see cref="M:System.Windows.Freezable.ReadPreamble" />합니다.</span><span class="sxs-lookup"><span data-stu-id="8c74d-391">If you call <see cref="M:System.Windows.Freezable.WritePreamble" /> in an [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], you can omit a call to <see cref="M:System.Windows.Freezable.ReadPreamble" />.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>