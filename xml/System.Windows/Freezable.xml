<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="973c346f1874ce6fbdd0454e4370d678d8bcf9de" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39786886" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="07c8d-101">수정 가능한 상태와 읽기 전용(고정) 상태를 가진 개체를 정의합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="07c8d-101">Defines an object that has a modifiable state and a read-only (frozen) state.</span>
      </span>
      <span data-ttu-id="07c8d-102">
        <see cref="T:System.Windows.Freezable" />에서 파생되는 클래스는 자세한 변경 알림을 제공하고, 변경할 수 없게 만들 수 있으며, 자신을 복제할 수 있습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="07c8d-102">Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-103"><xref:System.Windows.Freezable> 클래스는 도움이 되는 특별 한 기능 수정 하거나 복사 하는 데 비용이 많이 드는 개체를 사용 하는 경우 응용 프로그램 성능 향상을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-103">The <xref:System.Windows.Freezable> class provides special features that can help improve application performance when using objects that are expensive to modify or copy.</span></span> <span data-ttu-id="07c8d-104">예가 <xref:System.Windows.Freezable> 개체는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-104">Examples of <xref:System.Windows.Freezable> objects include the following:</span></span>  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a><span data-ttu-id="07c8d-105">Freezable에서 파생</span><span class="sxs-lookup"><span data-stu-id="07c8d-105">Deriving From Freezable</span></span>  
 <span data-ttu-id="07c8d-106">파생 된 클래스 <xref:System.Windows.Freezable> 다음과 같은 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-106">A class that derives from <xref:System.Windows.Freezable> gains the following features:</span></span>  
  
-   <span data-ttu-id="07c8d-107">특수 상태: 읽기 전용 (고정된) 상태와 쓰기 가능한 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-107">Special states: a read-only (frozen) state and a writable state.</span></span>  
  
-   <span data-ttu-id="07c8d-108">스레드 보안: 고정 된 <xref:System.Windows.Freezable> 개체는 스레드 간에 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-108">Thread safety: a frozen <xref:System.Windows.Freezable> object can be shared across threads.</span></span>  
  
-   <span data-ttu-id="07c8d-109">자세한 변경 알림: 달리 <xref:System.Windows.DependencyObject> 개체는 <xref:System.Windows.Freezable> 하위 속성 값을 변경 하는 경우 변경 알림을 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-109">Detailed change notification: Unlike other <xref:System.Windows.DependencyObject> objects, a <xref:System.Windows.Freezable> object provides change notifications when sub-property values change.</span></span>  
  
-   <span data-ttu-id="07c8d-110">쉬운 복제: Freezable 클래스가 이미 전체 복제를 만드는 여러 메서드를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-110">Easy cloning: the Freezable class has already implemented several methods that produce deep clones.</span></span>  
  
 <span data-ttu-id="07c8d-111">사용 및 사용자 고유의 만들기에 대 한 내용은 <xref:System.Windows.Freezable> 개체를 참조 하세요 [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-111">For information on using and creating your own <xref:System.Windows.Freezable> objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="07c8d-112">모든 공용 <see langword="static" /> 이 형식의 멤버는 스레드로부터 안전 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="07c8d-112">Any public <see langword="static" /> members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="07c8d-113">인터페이스 멤버는 스레드로부터 안전하지 않습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="07c8d-113">Any instance members are not guaranteed to be thread safe.</span>
      </span>
      <span data-ttu-id="07c8d-114">경우는 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="false" />, <see cref="T:System.Windows.Freezable" /> 개체는 생성 된 스레드에서만에서 액세스할 수 있습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="07c8d-114">When the <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" />, a <see cref="T:System.Windows.Freezable" /> object can be accessed only from the thread on which it was created.</span>
      </span>
      <span data-ttu-id="07c8d-115">다른 스레드에서 throw에서 액세스를 시도 <see cref="T:System.InvalidOperationException" />합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="07c8d-115">Attempting to access it from another thread throws an <see cref="T:System.InvalidOperationException" />.</span>
      </span>
      <span data-ttu-id="07c8d-116">합니다 <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> 고 <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> 메서드에 대 한 올바른 스레드로 마샬링 지원을 제공 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="07c8d-116">The <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> and <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> methods provide support for marshalling to the correct thread.</span>
      </span>
      <span data-ttu-id="07c8d-117">경우 해당 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="true" />, <see cref="T:System.Windows.Freezable" /> 자유 스레드 개체는 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="07c8d-117">When their <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objects are free-threaded.</span>
      </span>
      <span data-ttu-id="07c8d-118">자세한 내용은 [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)를 참조하세요.</span>
      <span class="sxs-lookup">
        <span data-stu-id="07c8d-118">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-119">
            <see cref="T:System.Windows.Freezable" /> 파생 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-119">Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-120">추상 클래스의 보호 된 접근성 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-120">This is the protected-accessibility constructor of an abstract class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-121">개체를 수정 불가능으로 설정할 수 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-121">Gets a value that indicates whether the object can be made unmodifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="07c8d-122">개체를 수정 불가능으로 설정할 수 있거나 이미 수정 불가능이면 <see langword="true" />이고, 설정할 수 없으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-122">
              <see langword="true" /> if the current object can be made unmodifiable or is already unmodifiable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-123">
            <para>이 메서드 구현에서 사용 합니다 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드를 <paramref name="isChecking" /> 로 설정 <see langword="true" /> 결정할 여부를 <see cref="T:System.Windows.Freezable" /> 수정할 수. 파생된 클래스에서이 속성의 동작을 수정 하려면 재정의 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-123">
              <para>This method implementation uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method with <paramref name="isChecking" /> set to <see langword="true" /> to determine whether a <see cref="T:System.Windows.Freezable" /> can be made unmodifiable. To modify the way this property behaves in a derived class, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-124">
            <see cref="T:System.Windows.Freezable" /> 또는 여기에 들어 있는 개체가 수정될 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-124">Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-125">추가 하거나 현재 개체를 수정할 수 없을 때 이벤트 처리기를 제거 하려는 경우 (때 합니다 <xref:System.Windows.Freezable.IsFrozen%2A> 속성은 `true`), 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-125">If you attempt to add or remove event handlers when the current object is not modifiable (when the <xref:System.Windows.Freezable.IsFrozen%2A> property is `true`), an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-126">개체 값의 전체 복사본을 만들어 <see cref="T:System.Windows.Freezable" />의 수정 가능한 복제본을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-126">Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values.</span>
          </span>
          <span data-ttu-id="07c8d-127">개체의 종속성 속성을 복사하는 경우 이 메서드는 더 이상 확인되지 않을 수도 있는 식을 복사하지만 애니메이션 또는 해당 현재 값은 복사하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-127">When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="07c8d-128">현재 개체의 수정 가능한 복제본입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-128">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="07c8d-129">소스의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성이 <see langword="true." />인 경우에도 복제된 개체의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-129">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-130"><xref:System.Windows.Freezable.Clone%2A> 하 고 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드 생성의 수정 가능한 복제본 고정 <xref:System.Windows.Freezable> 개체 (도 복제 <xref:System.Windows.Freezable> 고정 되지 않은 개체).</span><span class="sxs-lookup"><span data-stu-id="07c8d-130">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="07c8d-131">복제는 현재 개체의 전체 복사본을 효과적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-131">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="07c8d-132">다음 표에서 간의 차이점을 요약 합니다 <xref:System.Windows.Freezable.Clone%2A> 및 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="07c8d-132">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="07c8d-133">작업</span><span class="sxs-lookup"><span data-stu-id="07c8d-133">Action</span></span>|<span data-ttu-id="07c8d-134">Clone 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="07c8d-134">Clone method behavior</span></span>|<span data-ttu-id="07c8d-135">CloneCurrentValue 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="07c8d-135">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="07c8d-136">식이 포함 된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="07c8d-136">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="07c8d-137">식 복사 되지만, 더 이상 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-137">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="07c8d-138">자세한 내용은 [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="07c8d-138">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="07c8d-139">식 자체 아닌 식의 현재 값을 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-139">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="07c8d-140">애니메이션된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="07c8d-140">Copying an animated dependency property</span></span>|<span data-ttu-id="07c8d-141">속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-141">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="07c8d-142">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-142">Animations are not copied.</span></span>|<span data-ttu-id="07c8d-143">속성의 현재 애니메이션된 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-143">The property's current animated value is copied.</span></span> <span data-ttu-id="07c8d-144">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-144">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="07c8d-145">참고가 설정 되지 않은 속성은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-145">Note that unset properties are not copied.</span></span> <span data-ttu-id="07c8d-146">설정 되지 않은 속성에는 고정 된 기본값이 경우 <xref:System.Windows.Freezable>, 속성 값의 수정 가능한 복제본에서 고정 된 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-146">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="07c8d-147">스레드 간 Freezable 이동</span><span class="sxs-lookup"><span data-stu-id="07c8d-147">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="07c8d-148">이 메서드는 이동 하는 데 유용할 수 있습니다는 <xref:System.Windows.Freezable> 스레드 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-148">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="07c8d-149">먼저 확인 합니다 <xref:System.Windows.Freezable> 를 호출 하 여 수정할 수 없도록 해당 <xref:System.Windows.Freezable.Freeze%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="07c8d-149">First, make the <xref:System.Windows.Freezable> unmodifiable by calling its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="07c8d-150">이제 다른 스레드가 액세스할 수 합니다 <xref:System.Windows.Freezable> 하 고 로컬 <xref:System.Windows.Freezable.Clone%2A> 액세스할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-150">Now another thread can access the <xref:System.Windows.Freezable> and make a local <xref:System.Windows.Freezable.Clone%2A> that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-151">
            <para>이 메서드는 <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> 복제본을 만듭니다. 파생된 클래스에서이 메서드의 동작을 수정 하려면 재정의 <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-151">
              <para>This method uses <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> to produce the clone. To modify the behavior of this method in a derived class, override the <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="07c8d-152">복제할 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-152">The object to clone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="07c8d-153">기본(애니메이션이 적용되지 않은) 속성 값을 사용하여 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 복제본(전체 복사본)으로 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-153">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-154">이 메서드는 <xref:System.Windows.Freezable.Clone%2A> 메서드는 호출 하지 않은 수 사용자 코드에서 직접 제외 하 고이 메서드를 재정의 하는 동안 기본 구현을 호출 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="07c8d-154">This method is called by the <xref:System.Windows.Freezable.Clone%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="07c8d-155">현재 개체의 수정 가능한 복사본을 만들려면 호출 <xref:System.Windows.Freezable.Clone%2A> 이 메서드를 직접 호출 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-155">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.Clone%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-156">
            <para>파생 하는 경우 <see cref="T:System.Windows.Freezable" />,이 메서드를 재정의 해야 할 수 있습니다. 재정의 하는 이유는 다음과 같습니다.-파생된 클래스는 종속성 속성을 통해 노출 되지 않는 데이터입니다.  -파생 된 클래스 재정의 하 여 구현할 수 없는 추가 초기화 작업을 수행 해야 <see cref="M:System.Windows.Freezable.CreateInstanceCore" />합니다. 파생된 클래스에서 구현 하는 경우 예를 들어이 적용 됩니다 <see cref="T:System.ComponentModel.ISupportInitialize" />합니다.  종속성 속성의 모든 데이터를 저장 하는 추가 초기화 작업을 수행할 필요가 없습니다 클래스 재정의 하지 않아도 <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />합니다.  모든 구현이이 메서드의 기본 구현을 반드시 합니다. 구현만 기본 구현에 의해 수행 되지 않는 작업을 수행 해야 합니다. 기본 구현에는 내부 식을 비롯 한 모든 쓰기 가능한 로컬에서 설정 속성을의 전체 복사본입니다.  개체에 데이터 바인딩된 종속성 속성이 있으면 식 복사 되지만 더 이상 확인할 수 없습니다. 데이터 바인딩된 개체를 복제 하는 방법에 대 한 자세한 내용은 참조 하세요. [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)합니다. 개체에 애니메이션이 적용 된 종속성 속성이 해당 속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다. 애니메이션은 복사 되지 않습니다.  메모는 설정 되지 않은 속성은 복사 되지 않으며 읽기 전용 속성입니다. 이러한 속성에는 고정 된 기본값이 있으면 <see cref="T:System.Windows.Freezable" />, 속성 값의 수정 가능한 복제본에서 고정 된 상태로 유지 됩니다.  다음 목록은이 메서드에 대 한 예상 되는 동작을 요약:-모든 복사본을 포함 하는 생성 된 복사본 <see cref="T:System.Windows.Freezable" /> 하위 개체입니다.  -설정 및 읽기 전용 속성 복사 되지 않습니다.  식 복사 됩니다.  -None 이러한 하위 개체는 생성 시 고정 됩니다.  자체-복사가 고정 되는 것은 아닙니다.  -애니메이션은 복사 되지 않습니다.  속성-기본 값은 복사, 유효 하지 않음 애니메이션된 값입니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-156">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties, including internal expressions.  If the object has data-bound dependency properties, the expressions are copied but might no longer resolve. For more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) value of those properties is copied. Animations are not copied.  Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  The following list summarizes the expected behavior for this method:  -   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  -   Unset and read-only properties are not copied.  -   Expressions are copied.  -   None of these sub-objects are frozen on creation.  -   The copy itself is not frozen.  -   Animations are not copied.  -   Only property base values are copied, not current animated values.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-157">현재 값을 사용하여 <see cref="T:System.Windows.Freezable" />의 수정 가능한 복제본(전체 복사본)을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-157">Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="07c8d-158">현재 개체의 수정 가능한 복제본입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-158">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="07c8d-159">소스의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성이 <see langword="true." />인 경우에도 복제된 개체의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-159">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-160"><xref:System.Windows.Freezable.Clone%2A> 하 고 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드 생성의 수정 가능한 복제본 고정 <xref:System.Windows.Freezable> 개체 (도 복제 <xref:System.Windows.Freezable> 고정 되지 않은 개체).</span><span class="sxs-lookup"><span data-stu-id="07c8d-160">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="07c8d-161">복제는 현재 개체의 전체 복사본을 효과적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-161">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="07c8d-162">다음 표에서 간의 차이점을 요약 합니다 <xref:System.Windows.Freezable.Clone%2A> 및 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="07c8d-162">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="07c8d-163">작업</span><span class="sxs-lookup"><span data-stu-id="07c8d-163">Action</span></span>|<span data-ttu-id="07c8d-164">Clone 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="07c8d-164">Clone method behavior</span></span>|<span data-ttu-id="07c8d-165">CloneCurrentValue 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="07c8d-165">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="07c8d-166">식이 포함 된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="07c8d-166">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="07c8d-167">식 복사 되지만, 더 이상 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-167">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="07c8d-168">자세한 내용은 [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="07c8d-168">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="07c8d-169">식 자체 아닌 식의 현재 값을 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-169">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="07c8d-170">애니메이션된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="07c8d-170">Copying an animated dependency property</span></span>|<span data-ttu-id="07c8d-171">속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-171">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="07c8d-172">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-172">Animations are not copied.</span></span>|<span data-ttu-id="07c8d-173">속성의 현재 애니메이션된 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-173">The property's current animated value is copied.</span></span> <span data-ttu-id="07c8d-174">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-174">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="07c8d-175">참고가 설정 되지 않은 속성은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-175">Note that unset properties are not copied.</span></span> <span data-ttu-id="07c8d-176">설정 되지 않은 속성에는 고정 된 기본값이 경우 <xref:System.Windows.Freezable>, 속성 값의 수정 가능한 복제본에서 고정 된 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-176">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="07c8d-177">스레드 간 Freezable 이동</span><span class="sxs-lookup"><span data-stu-id="07c8d-177">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="07c8d-178">이 메서드는 이동 하는 데 유용할 수 있습니다는 <xref:System.Windows.Freezable> 스레드 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-178">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="07c8d-179">먼저 확인 합니다 <xref:System.Windows.Freezable> 를 사용 하 여 수정할 수 없도록 해당 <xref:System.Windows.Freezable.Freeze%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="07c8d-179">First, make the <xref:System.Windows.Freezable> unmodifiable by using its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="07c8d-180">이제 다른 스레드가 액세스할 수는 <xref:System.Windows.Freezable> 액세스할 수 있는 로컬 복제본을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-180">Now another thread can access the <xref:System.Windows.Freezable> and make a local clone that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-181">
            <para>이 메서드는 사용 된 <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> 복제본; 생성 방법 <see cref="T:System.Windows.Freezable" /> 재정의 구현자 <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> 복사 생성 시 고정 되어 있지 않고 확인 해야 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-181">
              <para>This method uses the <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> method to produce the clone; <see cref="T:System.Windows.Freezable" /> implementers who override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> must ensure that the copy is not frozen on creation.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="07c8d-182">복제할 <see cref="T:System.Windows.Freezable" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-182">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="07c8d-183">현재 속성 값을 사용하여 이 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 수정 가능한 클론(전체 복사본)으로 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-183">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-184">이 메서드는 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드는 호출 하지 않은 수 사용자 코드에서 직접 제외 하 고이 메서드를 재정의 하는 동안 기본 구현을 호출 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="07c8d-184">This method is called by the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="07c8d-185">현재 개체의 수정 가능한 복사본을 만들려면 호출 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 이 메서드를 직접 호출 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-185">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.CloneCurrentValue%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-186">
            <para>파생 하는 경우 <see cref="T:System.Windows.Freezable" />,이 메서드를 재정의 해야 할 수 있습니다. 재정의 하는 이유는 다음과 같습니다.-파생된 클래스는 종속성 속성을 통해 노출 되지 않는 데이터입니다.  -파생 된 클래스 재정의 하 여 구현할 수 없는 추가 초기화 작업을 수행 해야 <see cref="M:System.Windows.Freezable.CreateInstanceCore" />합니다. 파생된 클래스에서 구현 하는 경우 예를 들어이 적용 됩니다 <see cref="T:System.ComponentModel.ISupportInitialize" />합니다.  종속성 속성의 모든 데이터를 저장 하는 추가 초기화 작업을 수행할 필요가 없습니다 클래스 재정의 하지 않아도 <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />합니다.  모든 구현이이 메서드의 기본 구현을 반드시 합니다. 구현만 기본 구현에 의해 수행 되지 않는 작업을 수행 해야 합니다. 기본 구현에는 쓰기 가능한에서 로컬로 설정 된 모든 속성의 전체 복사본입니다. 식 (예: 데이터 바인딩)를 사용 하 여 종속성 속성을 포함 하는 개체, 식 자체 아닌 식의 현재 값을 복사 됩니다.  개체에서 종속성 속성에 애니메이션 효과가 적용 하는 경우에 해당 속성의 현재 애니메이션된 값을 복사 되 되지만 애니메이션 되지 않습니다.  메모는 설정 되지 않은 속성은 복사 되지 않으며 읽기 전용 속성입니다. 이러한 속성에는 고정 된 기본값이 있으면 <see cref="T:System.Windows.Freezable" />, 속성 값의 수정 가능한 복제본에서 고정 된 상태로 유지 됩니다.  다음은이 메서드에 대 한 예상 되는 동작을 요약합니다.  모든 복사본을 포함 하는 생성 된 복사- <see cref="T:System.Windows.Freezable" /> 하위 개체입니다.  -설정 및 읽기 전용 속성 복사 되지 않습니다.  -속성 애니메이션이 적용 되어 있는 경우 해당 현재 값은 복사 이지만 애니메이션 자체에 아닙니다.  -None 이러한 하위 개체는 생성 시 고정 됩니다.  자체-복사가 고정 되는 것은 아닙니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-186">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties. If the object contains dependency properties with expressions (such as a data binding), the current value of the expression is copied but not the expression itself.  If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  The following list summarizes the expected behavior for this method.  -   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  -   Unset and read-only properties are not copied.  -   If a property is animated, its current value is copied, but the animation itself is not.  -   None of these sub-objects are frozen on creation.  -   The copy itself is not frozen.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-187">
            <see cref="T:System.Windows.Freezable" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-187">Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="07c8d-188">새 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-188">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-189">이 보호 된 메서드 및 동작에 대 한 실제 개체별 구현을 재정의 구현에 따라 다릅니다.는 <xref:System.Windows.Freezable.CreateInstanceCore%2A> 메서드를 내부적으로이 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-189">This is a protected method, and the actual object-specific implementations for the behavior are dependent on the override implementation of the <xref:System.Windows.Freezable.CreateInstanceCore%2A> method, which this method calls internally.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-190">파생 클래스에서 구현되는 경우 <see cref="T:System.Windows.Freezable" /> 파생 클래스의 새 인스턴스를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-190">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="07c8d-191">새 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-191">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-192">직접 (제외 하면 기본 구현에서 호출)이이 메서드를 호출 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="07c8d-192">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="07c8d-193">이 메서드는 내부적으로 <xref:System.Windows.Freezable.CreateInstance%2A> 메서드를 때마다의 새 인스턴스를 <xref:System.Windows.Freezable> 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-193">This method is called internally by the <xref:System.Windows.Freezable.CreateInstance%2A> method whenever a new instance of the <xref:System.Windows.Freezable> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="07c8d-194">다음 예제에서는 일반적인 구현은 <xref:System.Windows.Freezable.CreateInstanceCore%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-194">The following example shows a typical implementation of <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span></span>  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-195">
            <para>모든 <see cref="T:System.Windows.Freezable" /> 파생된 클래스에서이 메서드를 구현 해야 합니다. 일반적인 구현은 단순히 기본 생성자를 호출 하 고 결과 반환 하는 것입니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-195">
              <para>Every <see cref="T:System.Windows.Freezable" /> derived class must implement this method. A typical implementation is to simply call the default constructor and return the result.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-196">
            <see cref="T:System.Windows.Freezable" /> 개체를 수정할 수 없게 만들고 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성을 <see langword="true" />로 설정하거나, <see cref="T:System.Windows.Freezable" /> 개체를 수정할 수 없게 만들 수 있는지 테스트합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-196">Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-197">현재 개체를 수정할 수 없게 만들고 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성을 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-197">Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-198">문제를 방지 하려면는 <xref:System.InvalidOperationException> 이 메서드를 호출 하는 경우 확인 합니다 <xref:System.Windows.Freezable.CanFreeze%2A> 속성을 여부를 <xref:System.Windows.Freezable> 수 없게이 메서드를 호출 하기 전에.</span><span class="sxs-lookup"><span data-stu-id="07c8d-198">To avoid the possibility of an <xref:System.InvalidOperationException> when calling this method, check the <xref:System.Windows.Freezable.CanFreeze%2A> property to determine whether the <xref:System.Windows.Freezable> can be made unmodifiable before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="07c8d-199">
            <see cref="T:System.Windows.Freezable" />을 수정할 수 없게 만들 수 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-199">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-200">
            <para>이 메서드는 사용 합니다 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드를는 <see cref="T:System.Windows.Freezable" /> 수정할 수 없게 합니다. 중단 동작을 수정 하려면 재정의 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-200">
              <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">
          <span data-ttu-id="07c8d-201">확인할 개체 또는 수정할 수 없게 만들 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-201">The object to check or make unmodifiable.</span>
          </span>
          <span data-ttu-id="07c8d-202">
            <c>isChecking</c>이 <see langword="true" />이면 이 개체를 수정할 수 없게 만들 수 있는지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-202">If <c>isChecking</c> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="07c8d-203">
            <c>isChecking</c>이 <see langword="false" />이면 가능한 경우 개체를 수정할 수 없게 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-203">If <c>isChecking</c> is <see langword="false" />, the object is made unmodifiable, if possible.</span>
          </span>
        </param>
        <param name="isChecking">
          <span data-ttu-id="07c8d-204">개체를 실제로 고정하지 않고 고정할 수 있는지 여부를 반환하려면 <see langword="true" />이고, 개체를 실제로 고정하려면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-204">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="07c8d-205">
            <paramref name="isChecking" /> 매개 변수가 <see langword="true" />이면 이 메서드는 지정된 <see cref="T:System.Windows.Freezable" />을 수정할 수 없게 만들 수 있는지 여부를 알려 줍니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-205">If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="07c8d-206">
            <paramref name="isChecking" /> 매개 변수가 <see langword="false" />이면 이 메서드는 지정된 <see cref="T:System.Windows.Freezable" />을 수정할 수 없게 만들고 이 작업에 성공했는지 여부를 알려 줍니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-206">If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="07c8d-207">
            <paramref name="isChecking" />이 <see langword="true" />인 경우 이 메서드는 지정된 <see cref="T:System.Windows.Freezable" />을 수정할 수 없게 만들 수 있으면 <see langword="true" />를, 그렇지 않으면 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-207">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="07c8d-208">
            <paramref name="isChecking" />이 <see langword="false" />인 경우 이 메서드는 지정된 <see cref="T:System.Windows.Freezable" />을 이제 수정할 수 없으면 <see langword="true" />를, 수정할 수 없게 만들 수 없으면 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-208">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-209">파생 하는 경우가 아니면이 메서드를 호출 하지 마세요 <xref:System.Windows.Freezable> 재정의 <xref:System.Windows.Freezable.FreezeCore%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="07c8d-209">Do not call this method unless you are deriving from <xref:System.Windows.Freezable> and overriding the <xref:System.Windows.Freezable.FreezeCore%2A> method.</span></span>  <span data-ttu-id="07c8d-210">이 메서드를 사용할 수는 <xref:System.Windows.Freezable.FreezeCore%2A> 자체는 클래스 데이터 멤버를 고정 하는 방법 <xref:System.Windows.Freezable> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-210">This method may be used in the <xref:System.Windows.Freezable.FreezeCore%2A> method to freeze class data members that are themselves <xref:System.Windows.Freezable> objects.</span></span>  
  
 <span data-ttu-id="07c8d-211">잘 지 내에서이 메서드를 다시 호출 하는 것을 <xref:System.Windows.Freezable> 개체 (수정할 수 없게) 이미 고정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-211">It is alright to call this method again on a <xref:System.Windows.Freezable> object that is already frozen (unmodifiable).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="07c8d-212">
            <paramref name="isChecking" />이 <see langword="false" />인 경우 <paramref name="freezable" />을 수정할 수 없게 만드는 작업이 실패하면 개체의 상태를 알 수 없게 되며, 부분적으로 고정될 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-212">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-213">
            <para>이 메서드는 사용 합니다 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드를는 <see cref="T:System.Windows.Freezable" /> 수정할 수 없게 합니다. 중단 동작을 수정 하려면 재정의 <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> 메서드.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-213">
              <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <span data-ttu-id="07c8d-214">개체를 실제로 고정하지 않고 고정할 수 있는지 여부를 반환하려면 <see langword="true" />이고, 개체를 실제로 고정하려면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-214">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="07c8d-215">
            <see cref="T:System.Windows.Freezable" />을 수정할 수 없게 만들거나, 수정할 수 없게 만들 수 있는지 테스트합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-215">Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="07c8d-216">
            <paramref name="isChecking" />이 <see langword="true" />인 경우 이 메서드는 <see cref="T:System.Windows.Freezable" />을 수정할 수 없게 만들 수 있으면 <see langword="true" />를, 그렇지 않으면 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-216">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="07c8d-217">
            <paramref name="isChecking" />이 <see langword="false" />인 경우 이 메서드는 지정된 <see cref="T:System.Windows.Freezable" />을 이제 수정할 수 없으면 <see langword="true" />를, 수정할 수 없게 만들 수 없으면 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-217">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-218">직접 (제외 하면 기본 구현에서 호출)이이 메서드를 호출 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="07c8d-218">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="07c8d-219">이 메서드는 내부적으로 호출 합니다 <xref:System.Windows.Freezable.CanFreeze%2A> 속성 (사용 하 여 `isChecking` 같음 `true`) 및 <xref:System.Windows.Freezable.Freeze%2A> 메서드 (사용 하 여 `isChecking` 같음 `false`).</span><span class="sxs-lookup"><span data-stu-id="07c8d-219">This method is called internally by the <xref:System.Windows.Freezable.CanFreeze%2A> property (with `isChecking` equal to `true`) and the <xref:System.Windows.Freezable.Freeze%2A> method (with `isChecking` equal to `false`).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-220">
            <para>
              <see cref="T:System.Windows.Freezable" /> 구현자는 클래스는 종속성 속성을 사용 하 여 저장 되지 않은 데이터를 포함 하는 경우이 메서드를 재정의 해야 합니다.  일반적인 구현은 기본를 호출한 다음 정적 호출 <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> 메서드를 모두 <see cref="T:System.Windows.Freezable" /> 형식의 반환을 클래스에 들어 있는 속성을 <see langword="true" /> 또는 경우에 모든 속성이 고정 된 (수 있는 고정 된을 지정 하는 경우 <see langword="true" /> 에 대 한 <paramref name="isChecking" />).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-220">
              <para>
                <see cref="T:System.Windows.Freezable" /> implementers must override this method when the class contains data that is not stored using dependency properties.  A typical implementation would call base, then call the static <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> method on all <see cref="T:System.Windows.Freezable" /> typed properties that the class contains, returning <see langword="true" /> only if all properties were frozen (or could have been frozen, in the case of specifying <see langword="true" /> for <paramref name="isChecking" />).</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-221">애니메이션이 적용되지 않은 기준 속성 값을 사용하여 <see cref="T:System.Windows.Freezable" />의 고정된 복사본을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-221">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values.</span>
          </span>
          <span data-ttu-id="07c8d-222">복사본이 고정되므로 고정된 하위 개체는 모두 참조를 통해 복사됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-222">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="07c8d-223">
            <see cref="T:System.Windows.Freezable" />의 고정된 복사본입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-223">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="07c8d-224">복사본의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="true" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-224">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-225">확인 해야 합니다 <xref:System.Windows.Freezable.CanFreeze%2A> 되어 있는지 확인 하려면이 메서드를 호출 하기 전에 속성은 <xref:System.Windows.Freezable> 고정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-225">You should check the <xref:System.Windows.Freezable.CanFreeze%2A> property before calling this method to verify that the <xref:System.Windows.Freezable> can be frozen.</span></span> <span data-ttu-id="07c8d-226">이 메서드를 사용 하는 것은 사용 하 여 복사본을 만드는 것과 유사 합니다 <xref:System.Windows.Freezable.Clone%2A> 한 다음 사용 하 여 고정 및를 <xref:System.Windows.Freezable.Freeze%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="07c8d-226">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.Clone%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="07c8d-227"><xref:System.Windows.Freezable.GetAsFrozen%2A> 하 고 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 복제 하지 마세요 있으므로 메서드 복사 성능이 향상 <xref:System.Windows.Freezable> 하위 개체는는 이미 고정 된;만 복사 되 고 참조로 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-227">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="07c8d-228">다음 표에서 간의 차이점을 요약 합니다 <xref:System.Windows.Freezable.GetAsFrozen%2A> 및 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="07c8d-228">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="07c8d-229">작업</span><span class="sxs-lookup"><span data-stu-id="07c8d-229">Action</span></span>|<span data-ttu-id="07c8d-230">GetAsFrozen 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="07c8d-230">GetAsFrozen method behavior</span></span>|<span data-ttu-id="07c8d-231">GetCurrentValueAsFrozen 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="07c8d-231">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="07c8d-232">식이 포함 된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="07c8d-232">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="07c8d-233">메서드에서 throw 한 <xref:System.InvalidOperationException> 수 없어서 <xref:System.Windows.Freezable.Freeze%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-233">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="07c8d-234">식 자체 아닌 식의 현재 값을 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-234">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="07c8d-235">애니메이션된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="07c8d-235">Copying an animated dependency property</span></span>|<span data-ttu-id="07c8d-236">속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-236">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="07c8d-237">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-237">Animations are not copied.</span></span>|<span data-ttu-id="07c8d-238">속성의 현재 애니메이션된 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-238">The property's current animated value is copied.</span></span> <span data-ttu-id="07c8d-239">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-239">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="07c8d-240">메모는 설정 되지 않은 속성은 복사 되지 않으며 읽기 전용 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-240">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="07c8d-241">복사본을 만드는 합니다 <xref:System.Windows.Freezable> 즉 고정된 되지를 사용 하 여는 <xref:System.Windows.Freezable.Clone%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="07c8d-241">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.Clone%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="07c8d-242">식 또는 애니메이션이 적용된 속성이 들어 있어서 <see cref="T:System.Windows.Freezable" />을 고정할 수 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-242">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-243">
            <para>이 메서드를 사용 하 여 가상 <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> 메서드 복제본을 만듭니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-243">
              <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="07c8d-244">복사할 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-244">The instance to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="07c8d-245">애니메이션이 적용되지 않은 기준 속성 값을 사용하여 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 고정된 복제본으로 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-245">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-246">이 메서드는 <xref:System.Windows.Freezable.GetAsFrozen%2A> 메서드는 호출 하지 않은 수 사용자 코드에서 직접 제외 하 고이 메서드를 재정의 하는 동안 기본 구현을 호출 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="07c8d-246">This method is called by the <xref:System.Windows.Freezable.GetAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="07c8d-247">현재 개체의 고정 된 복사본을 만들려면 호출 <xref:System.Windows.Freezable.GetAsFrozen%2A> 이 메서드를 직접 호출 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-247">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-248">
            <para>파생 하는 경우 <see cref="T:System.Windows.Freezable" /> 이 메서드를 재정의 해야 할 수 있습니다. 재정의 하는 이유는 다음과 같습니다.-파생된 클래스는 종속성 속성을 통해 노출 되지 않는 데이터입니다.  -파생 된 클래스 재정의 하 여 구현할 수 없는 추가 초기화 작업을 수행 해야 <see cref="M:System.Windows.Freezable.CreateInstanceCore" />합니다. 파생된 클래스에서 구현 하는 경우 예를 들어이 적용 됩니다 <see cref="T:System.ComponentModel.ISupportInitialize" />합니다.  종속성 속성의 모든 데이터를 저장 하는 추가 초기화 작업을 수행할 필요가 없습니다 클래스 재정의 하지 않아도 <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />합니다.  모든 구현이이 메서드의 기본 구현을 반드시 합니다. 구현만 기본 구현에 의해 수행 되지 않는 작업을 수행 해야 합니다. 기본 구현에는 모든 고정 되지 않은 freezable 다른 모든 쓰기 가능한의 단순 복사본을 로컬로 포함 된 설정 속성의 전체 복사본입니다. 개체 데이터 바인딩 종속성 속성에 식 복사 됩니다 되지만 더 이상 해결할 수 없습니다. 데이터 바인딩된 개체를 복제 하는 방법에 대 한 자세한 내용은 참조 하세요. [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)합니다. 개체에 애니메이션이 적용 된 종속성 속성이 해당 속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다. 애니메이션은 복사 되지 않습니다.  메모는 설정 되지 않은 속성은 복사 되지 않으며 읽기 전용 속성입니다.  이 메서드를 재정의 하는 경우에 기본 구현을 호출 해야 합니다.  필요가 없습니다 <see cref="M:System.Windows.Freezable.Freeze" /> 값 복사 됩니다.  결과 고정 한 <see cref="M:System.Windows.Freezable.GetAsFrozen" /> 반환 되기 전에 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-248">
              <para>If you derive from <see cref="T:System.Windows.Freezable" /> you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of any unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the expressions are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) values of those properties are copied. Animations are not copied.  Note that unset properties are not copied, nor are read-only properties.  If you do override this method, you must call the base implementation.  You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-249">현재 속성 값을 사용하여 <see cref="T:System.Windows.Freezable" />의 고정된 복사본을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-249">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
          <span data-ttu-id="07c8d-250">복사본이 고정되므로 고정된 하위 개체는 모두 참조를 통해 복사됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-250">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="07c8d-251">
            <see cref="T:System.Windows.Freezable" />의 고정된 복사본입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-251">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="07c8d-252">복사본의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="true" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-252">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-253">이 메서드를 사용 하는 것은 사용 하 여 복사본을 만드는 것과 유사 합니다 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 한 다음 사용 하 여 고정 및를 <xref:System.Windows.Freezable.Freeze%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="07c8d-253">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.CloneCurrentValue%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="07c8d-254"><xref:System.Windows.Freezable.GetAsFrozen%2A> 하 고 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 복제 하지 마세요 있으므로 메서드 복사 성능이 향상 <xref:System.Windows.Freezable> 하위 개체는는 이미 고정 된;만 복사 되 고 참조로 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-254">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="07c8d-255">다음 표에서 간의 차이점을 요약 합니다 <xref:System.Windows.Freezable.GetAsFrozen%2A> 및 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="07c8d-255">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="07c8d-256">작업</span><span class="sxs-lookup"><span data-stu-id="07c8d-256">Action</span></span>|<span data-ttu-id="07c8d-257">GetAsFrozen 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="07c8d-257">GetAsFrozen method behavior</span></span>|<span data-ttu-id="07c8d-258">GetCurrentValueAsFrozen 메서드 동작</span><span class="sxs-lookup"><span data-stu-id="07c8d-258">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="07c8d-259">식이 포함 된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="07c8d-259">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="07c8d-260">메서드에서 throw 한 <xref:System.InvalidOperationException> 수 없어서 <xref:System.Windows.Freezable.Freeze%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-260">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="07c8d-261">식 자체 아닌 식의 현재 값을 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-261">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="07c8d-262">애니메이션된 종속성 속성 복사</span><span class="sxs-lookup"><span data-stu-id="07c8d-262">Copying an animated dependency property</span></span>|<span data-ttu-id="07c8d-263">속성의 기본 (애니메이션이 적용 되지 않은) 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-263">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="07c8d-264">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-264">Animations are not copied.</span></span>|<span data-ttu-id="07c8d-265">속성의 현재 애니메이션된 값이 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-265">The property's current animated value is copied.</span></span> <span data-ttu-id="07c8d-266">애니메이션은 복사 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-266">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="07c8d-267">메모는 설정 되지 않은 속성은 복사 되지 않으며 읽기 전용 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-267">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="07c8d-268">복사본을 만드는 합니다 <xref:System.Windows.Freezable> 즉 고정된 되지를 사용 하 여는 <xref:System.Windows.Freezable.CloneCurrentValue%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="07c8d-268">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-269">
            <para>이 메서드를 사용 하 여 가상 <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> 메서드 복제본을 만듭니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-269">
              <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="07c8d-270">복사 및 고정할 <see cref="T:System.Windows.Freezable" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-270">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="07c8d-271">현재 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 고정된 복제본으로 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-271">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="07c8d-272">개체에 애니메이션 효과를 준 종속성 속성이 있는 경우 애니메이션 효과를 준 현재 값이 복사됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-272">If the object has animated dependency properties, their current animated values are copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-273">이 메서드는 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 메서드는 호출 하지 않은 수 사용자 코드에서 직접 제외 하 고이 메서드를 재정의 하는 동안 기본 구현을 호출 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="07c8d-273">This method is called by the <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="07c8d-274">현재 개체의 고정 된 복사본을 만들려면 호출 <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> 이 메서드를 직접 호출 하는 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-274">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-275">
            <para>파생 하는 경우 <see cref="T:System.Windows.Freezable" />,이 메서드를 재정의 해야 할 수 있습니다. 재정의 하는 이유는 다음과 같습니다.-파생된 클래스는 종속성 속성을 통해 노출 되지 않는 데이터입니다.  -파생 된 클래스 재정의 하 여 구현할 수 없는 추가 초기화 작업을 수행 해야 <see cref="M:System.Windows.Freezable.CreateInstanceCore" />합니다. 파생된 클래스에서 구현 하는 경우 예를 들어이 적용 됩니다 <see cref="T:System.ComponentModel.ISupportInitialize" />합니다.  종속성 속성의 모든 데이터를 저장 하는 추가 초기화 작업을 수행할 필요가 없습니다 클래스 재정의 하지 않아도 <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />합니다.  모든 구현이이 메서드의 기본 구현을 반드시 합니다. 구현만 기본 구현에 의해 수행 되지 않는 작업을 수행 해야 합니다. 기본 구현에서는 새 <see cref="T:System.Windows.Freezable" /> 를 사용 하는 <see cref="M:System.Windows.Freezable.CreateInstance" /> 고정 되지 않은 freezable의 전체 복사본을 메서드 및 다른 모든 쓰기 가능한의 단순 복사본은 로컬로 포함 된 속성을 설정 합니다. 개체에 데이터 바인딩된 종속성 속성이 데이터 바인딩을 복사 됩니다 되지만 더 이상 해결할 수 없습니다. 데이터 바인딩된 개체를 복제 하는 방법에 대 한 자세한 내용은 참조 하세요. [Freezable 개체 개요](~/docs/framework/wpf/advanced/freezable-objects-overview.md)합니다. 개체에서 종속성 속성에 애니메이션 효과가 적용 하는 경우에 해당 속성의 현재 애니메이션된 값을 복사 되 되지만 애니메이션 되지 않습니다.  내에서 읽기 전용 종속성 속성을 <see cref="T:System.Windows.Freezable" /> 이 기본 구현에서 복사 되지 않습니다.  이 메서드를 재정의 하는 경우에 기본 구현을 호출 해야 합니다.  필요가 없습니다 <see cref="M:System.Windows.Freezable.Freeze" /> 값 복사 됩니다.  결과 고정 한 <see cref="M:System.Windows.Freezable.GetAsFrozen" /> 반환 되기 전에 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-275">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation creates a new <see cref="T:System.Windows.Freezable" /> using the <see cref="M:System.Windows.Freezable.CreateInstance" /> method and makes deep copies of unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the data bindings are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  Read-only dependency properties within a <see cref="T:System.Windows.Freezable" /> are not copied by this default implementation.  If you do override this method, you must call the base implementation.  You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-276">개체가 현재 수정 가능한지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-276">Gets a value that indicates whether the object is currently modifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="07c8d-277">개체가 고정되어 수정할 수 없으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-277">
              <see langword="true" /> if the object is frozen and cannot be modified; <see langword="false" /> if the object can be modified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-278">개체를 수정 하는 경우 해당 <xref:System.Windows.Freezable.IsFrozen%2A> 속성은 `true` throw는 <xref:System.InvalidOperationException>합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-278">Attempting to modify an object when its <xref:System.Windows.Freezable.IsFrozen%2A> property is `true` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="07c8d-279">이 속성은 개체 모델 관점에서 읽기 전용.</span><span class="sxs-lookup"><span data-stu-id="07c8d-279">This property is read-only from the object model perspective.</span></span> <span data-ttu-id="07c8d-280">에 대 한 설명서의 일부 <xref:System.Windows.Freezable> 동작을 언급할 수 있습니다 "설정 <xref:System.Windows.Freezable.IsFrozen%2A> 하 `true`" 또는 다른 방법의 동작을 설명할 때 <xref:System.Windows.Freezable>, 있지만이 동작에서에서 발생 하는 내부적으로 클래스 인스턴스 때 인스턴스 메서드는 추상 클래스 내에 있는 개인 변수를 조작 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-280">Some of the documentation about <xref:System.Windows.Freezable> behaviors may mention "sets <xref:System.Windows.Freezable.IsFrozen%2A> to `true`" or similar language when discussing the behavior of other methods of <xref:System.Windows.Freezable>, but this behavior is happening internally in the class instances, when methods of the instance manipulate the private variables that exist within the abstract class.</span></span> <span data-ttu-id="07c8d-281">이 속성의 값을 설정 하려면 호출 해야 <xref:System.Windows.Freezable.Freeze%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-281">To set the value of this property, you should call <xref:System.Windows.Freezable.Freeze%2A>.</span></span> <span data-ttu-id="07c8d-282">변경 하는 일회성 작업을 효과적으로 이것이 <xref:System.Windows.Freezable.IsFrozen%2A> 초기 기본값과에서 속성 `false` 상태는 `true` 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-282">This effectively is a one-time operation to change the <xref:System.Windows.Freezable.IsFrozen%2A> property from the initial default `false` state to the `true` state.</span></span> <span data-ttu-id="07c8d-283">값을 설정할 수는 없습니다 다시 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-283">There is no available means to set the value back to `false`.</span></span> <span data-ttu-id="07c8d-284">대신 원래에서 만든 전체 복사본을 변경할 수 있습니다 (참조는 <xref:System.Windows.Freezable.Clone%2A> 메서드).</span><span class="sxs-lookup"><span data-stu-id="07c8d-284">Instead, you could change any deep copy made from the original (see the <xref:System.Windows.Freezable.Clone%2A> method).</span></span> <span data-ttu-id="07c8d-285">이 동작은 의도적인 것 이며 사례에 적용 하는 경우 파생된 클래스 동작 방식 여기서는 <xref:System.Windows.Freezable> 패턴은 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-285">This is by design and is how any derived class should behave when applied to the cases where the <xref:System.Windows.Freezable> pattern is useful.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-286">현재 <see cref="T:System.Windows.Freezable" /> 개체가 수정될 때 호출됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-286">Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-287">이 메서드는 때마다는 <xref:System.Windows.Freezable.Changed> 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-287">This method is called whenever the <xref:System.Windows.Freezable.Changed> event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-288">
            <para>파생 된 클래스를 구현 하는 경우 <see cref="T:System.Windows.Freezable" />, 작업을 수행 하려면이 메서드를 재정의할 수 있습니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-288">
              <para>When you implement a class that derives from <see cref="T:System.Windows.Freezable" />, you may override this method to perform tasks.</para>
            </span>
          </span>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-289">방금 수정된 <see cref="T:System.Windows.DependencyObject" /> 형식 데이터 멤버에 대한 적절한 컨텍스트 포인터를 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-289">Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="07c8d-290">데이터 멤버의 이전 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-290">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="07c8d-291">데이터 멤버의 현재 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-291">The current value of the data member.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="07c8d-292">방금 설정된 <see cref="T:System.Windows.DependencyObjectType" /> 데이터 멤버에 대한 적절한 컨텍스트 포인터를 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-292">Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-293">이 메서드를 호출 해야 <xref:System.Windows.Freezable> 상속자 때마다를 <xref:System.Windows.DependencyObject> 으로 저장 되지 않은 데이터 멤버는 <xref:System.Windows.DependencyProperty> 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-293">This method should be called by <xref:System.Windows.Freezable> inheritors each time a <xref:System.Windows.DependencyObject> data member that is not stored as a <xref:System.Windows.DependencyProperty> is set.</span></span>  
  
 <span data-ttu-id="07c8d-294">이 메서드를 호출할 필요가 없습니다 <xref:System.Windows.DependencyObject> 를 사용 하 여 저장 된 데이터 멤버는 <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-294">This method does not need to be called for <xref:System.Windows.DependencyObject> data members that are stored using a <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="07c8d-295">데이터 멤버의 이전 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-295">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="07c8d-296">데이터 멤버의 현재 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-296">The current value of the data member.</span>
          </span>
        </param>
        <param name="property">
          <span data-ttu-id="07c8d-297">변경된 속성입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-297">The property that changed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="07c8d-298">이 멤버는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 인프라를 지원하며 코드에서 직접 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-298">This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="07c8d-299">변경된 속성, 해당하는 이전 값 및 새 값에 관한 정보가 포함된 이벤트 데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-299">Event data that contains information about which property changed, and its old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="07c8d-300">
            <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />의 <see cref="T:System.Windows.DependencyObject" /> 구현을 재정의하여 <see cref="T:System.Windows.Freezable" /> 형식의 변화하는 종속성 속성에 대한 응답으로 <see cref="E:System.Windows.Freezable.Changed" /> 처리기도 호출합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-300">Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-301">이벤트 데이터에 대 한 정보가는 <xref:System.Windows.Freezable> 자체입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-301">The event data contains information about only the <xref:System.Windows.Freezable> itself.</span></span> <span data-ttu-id="07c8d-302">하위 속성 정보를 통해 얻어야 합니다 <xref:System.Windows.Freezable.Changed> 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-302">Any sub-property information must be obtained through the <xref:System.Windows.Freezable.Changed> handlers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-303">유효한 스레드에서 <see cref="T:System.Windows.Freezable" />에 액세스하고 있는지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-303">Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread.</span>
          </span>
          <span data-ttu-id="07c8d-304">
            <see cref="T:System.Windows.Freezable" /> 상속자는 종속성 속성이 아닌 데이터 멤버를 읽는 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]의 시작 부분에서 이 메서드를 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-304">Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-305">
            <para>파생 된 클래스 <see cref="T:System.Windows.Freezable" /> 를 호출 해야 합니다 <see cref="M:System.Windows.Freezable.ReadPreamble" /> 메서드는 종속성 속성이 아닌는 모든 멤버에 액세스 하기 전에 합니다. <see cref="M:System.Windows.Freezable.WritePreamble" /> 이러한 멤버에 쓰기 전에 메서드를 호출 해야 합니다.  이 메서드가 효과적으로 아무 작업도 수행 하지 보다 호출 <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-305">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call the <see cref="M:System.Windows.Freezable.ReadPreamble" /> method before they attempt to access any members that are not dependency properties. The <see cref="M:System.Windows.Freezable.WritePreamble" /> method should be called before any such members are written to.  This method effectively does nothing more than call <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-306">
            <see cref="E:System.Windows.Freezable.Changed" />에 대한 <see cref="T:System.Windows.Freezable" /> 이벤트를 발생시키고 <see cref="M:System.Windows.Freezable.OnChanged" /> 메서드를 호출합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-306">Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method.</span>
          </span>
          <span data-ttu-id="07c8d-307">
            <see cref="T:System.Windows.Freezable" />에서 파생된 클래스는 종속성 속성으로 저장되지 않은 클래스 멤버를 수정하는 모든 API의 끝에서 이 메서드를 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-307">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-308">
            <para>파생 된 클래스 <see cref="T:System.Windows.Freezable" /> 으로 저장 하지 않는 클래스 멤버를 수정 하는 API 끝에이 메서드를 호출 해야는 <see cref="T:System.Windows.DependencyProperty" />합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-308">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies a class member that is not stored as a <see cref="T:System.Windows.DependencyProperty" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="07c8d-309">
            <see cref="T:System.Windows.Freezable" />이 고정되어 있지 않고 유효한 스레드 컨텍스트에서 액세스되고 있는지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-309">Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context.</span>
          </span>
          <span data-ttu-id="07c8d-310">
            <see cref="T:System.Windows.Freezable" /> 상속자는 종속성 속성이 아닌 데이터 멤버에 쓰는 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]의 시작 부분에서 이 메서드를 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-310">
              <see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="07c8d-311">이 메서드를 호출 <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 스레딩 컨텍스트에 액세스할 수 있으며, 경우에 예외를 throw 할는 <xref:System.Windows.Freezable> 인스턴스가 이미 고정 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="07c8d-311">This method calls <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> to verify the threading context is accessible, and it throws an exception if the <xref:System.Windows.Freezable> instance is already frozen.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="07c8d-312">
            <see cref="T:System.Windows.Freezable" /> 인스턴스가 고정되어 있어 해당 멤버에 쓸 수 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-312">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="07c8d-313">
            <para>파생 된 클래스 <see cref="T:System.Windows.Freezable" /> 를 호출 해야 <see cref="M:System.Windows.Freezable.WritePreamble" /> 는 종속성 속성이 아닌 멤버에 쓰기 전에 합니다. 호출 하는 경우 <see cref="M:System.Windows.Freezable.WritePreamble" /> 에 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]에 대 한 호출을 생략할 수 있습니다 <see cref="M:System.Windows.Freezable.ReadPreamble" />합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="07c8d-313">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call <see cref="M:System.Windows.Freezable.WritePreamble" /> before attempting to write to any members that are not dependency properties. If you call <see cref="M:System.Windows.Freezable.WritePreamble" /> in an [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], you can omit a call to <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>