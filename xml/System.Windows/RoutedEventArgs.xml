<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="RoutedEventArgs.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac58f6112c09b1f961b689a530d29b65eeca46e3156.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8f6112c09b1f961b689a530d29b65eeca46e3156</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.RoutedEventArgs">
          <source>Contains state information and event data associated with a routed event.</source>
          <target state="translated">라우트된 이벤트와 연결된 상태 정보 및 이벤트 데이터를 포함합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RoutedEventArgs">
          <source>Different <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> can be used with a single <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">다른 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> 사용 하 여 단일 <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RoutedEventArgs">
          <source>This class is responsible for packaging the event data for a <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph>, providing extra event state information, and is used by the event system for invoking the handler associated with the routed event.</source>
          <target state="translated">이 클래스는 이벤트 데이터를 패키지 하는 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph>, 추가 이벤트 상태 정보를 제공 하 고 이벤트 시스템에 의해 라우트된 이벤트와 연결 된 처리기를 호출 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="T:System.Windows.RoutedEventArgs">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor">
          <source>When using this parameterless constructor, all public properties of the new <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> instance assume the following default values:</source>
          <target state="translated">이 매개 변수가 없는 생성자, 새 모든 공용 속성을 사용 하는 경우 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> 인스턴스는 다음과 같은 기본값을 가정 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph> defaults to <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph> 기본적으로 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> defaults to <ph id="ph2">`false`</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> 기본적으로 <ph id="ph2">`false`</ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> defaults to <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> 기본적으로 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> defaults to <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> 기본적으로 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor">
          <source>Null values for <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> only mean that the <ph id="ph3">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> data makes no attempt to specify the source.</source>
          <target state="translated">값이 null <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> 만 된다는 의미는 <ph id="ph3">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> 데이터에서는 소스를 지정 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor">
          <source>When this instance is used in a call to <ph id="ph1">&lt;xref:System.Windows.UIElement.RaiseEvent%2A&gt;</ph>, the  <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> values are populated based on the element that raised the event and are passed on to listeners through the routing.</source>
          <target state="translated">에 대 한 호출에서이 인스턴스를 사용 하는 경우 <ph id="ph1">&lt;xref:System.Windows.UIElement.RaiseEvent%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> 하 이벤트를 발생 하 고 라우팅을 통해 수신기로 전달 되는 요소에 따라 값은 채워집니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)">
          <source>The routed event identifier for this instance of the <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> 클래스의 이 인스턴스에 대한 라우트된 이벤트 식별자입니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> class, using the supplied routed event identifier.</source>
          <target state="translated">제공된 라우트된 이벤트 식별자를 사용하여 <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)">
          <source>When using this overloaded constructor, unspecified properties of the new <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> instance assume the following default values:</source>
          <target state="translated">이 오버 로드 된 생성자를 사용할 때는 새 속성을 지정 하지 않으면 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> 인스턴스는 다음과 같은 기본값을 가정 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> defaults to <ph id="ph2">`false`</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> 기본적으로 <ph id="ph2">`false`</ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> defaults to <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> 기본적으로 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> defaults to <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> 기본적으로 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)">
          <source>Null values for <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> only mean that this <ph id="ph3">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> makes no attempt to specify the source.</source>
          <target state="translated">값이 null <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> 만이 구성이 <ph id="ph3">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> 원본을 지정 하려고 하지 않으므로 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)">
          <source>When this instance is used in a call to <ph id="ph1">&lt;xref:System.Windows.UIElement.RaiseEvent%2A&gt;</ph>, the  <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> values are populated based on the element that raised the event and are passed on to listeners through the routing.</source>
          <target state="translated">에 대 한 호출에서이 인스턴스를 사용 하는 경우 <ph id="ph1">&lt;xref:System.Windows.UIElement.RaiseEvent%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> 하 이벤트를 발생 하 고 라우팅을 통해 수신기로 전달 되는 요소에 따라 값은 채워집니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)">
          <source>The following example constructs a new <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> for use in a call to <ph id="ph2">&lt;xref:System.Windows.UIElement.RaiseEvent%2A&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 새 생성 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> 에 대 한 호출에서 사용 하기 위해 <ph id="ph2">&lt;xref:System.Windows.UIElement.RaiseEvent%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)">
          <source>The routed event identifier for this instance of the <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> 클래스의 이 인스턴스에 대한 라우트된 이벤트 식별자입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)">
          <source>An alternate source that will be reported when the event is handled.</source>
          <target state="translated">이벤트가 처리되면 보고될 대체 소스입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)">
          <source>This pre-populates the <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.Source" /&gt;</ph> property.</source>
          <target state="translated">이 소스는 <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.Source" /&gt;</ph> 속성을 미리 채웁니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> class, using the supplied routed event identifier, and providing the opportunity to declare a different source for the event.</source>
          <target state="translated">제공된 라우트된 이벤트 식별자를 사용하여 <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> 클래스의 새 인스턴스를 초기화하고 이벤트에 대해 다른 소스를 선언할 수 있는 기회를 제공합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)">
          <source>When using this overloaded constructor, unspecified properties of the new <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> instance assume the following default values:</source>
          <target state="translated">이 오버 로드 된 생성자를 사용할 때는 새 속성을 지정 하지 않으면 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> 인스턴스는 다음과 같은 기본값을 가정 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> defaults to <ph id="ph2">`false`</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> 기본적으로 <ph id="ph2">`false`</ph></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> defaults to <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> 기본적으로 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)">
          <source>Null values for <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> are populated based on the element that raised the event and passed on through the routing, but will read <ph id="ph2">`null`</ph> prior to invocation.</source>
          <target state="translated">값이 null <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> 이벤트를 발생 하는 라우팅 전달 하는 요소에 따라 채워진 있지만 읽을 <ph id="ph2">`null`</ph> 호출 이전 합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)">
          <source>Use this signature when passing <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> to virtuals such as <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A&gt;</ph>, where the arguments are used to call <ph id="ph3">&lt;xref:System.Windows.UIElement.RaiseEvent%2A&gt;</ph> internally.</source>
          <target state="translated">전달 하는 경우이 서명을 사용 하 여 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> 와 같은 가상 메서드를 <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A&gt;</ph>호출에 인수가 사용 되는 위치, <ph id="ph3">&lt;xref:System.Windows.UIElement.RaiseEvent%2A&gt;</ph> 내부적으로 합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>Gets or sets a value that indicates the present state of the event handling for a routed event as it travels the route.</source>
          <target state="translated">경로를 따라 이동할 때 라우트된 이벤트의 현재 이벤트 처리 상태를 나타내는 값을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>If setting, set to <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the event is to be marked handled; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">로 설정 하 고, <ph id="ph1">&lt;see langword="true" /&gt;</ph> 이벤트가 처리 되지 않으면 표시할 경우 <ph id="ph2">&lt;see langword="false" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>If reading this value, <ph id="ph1">&lt;see langword="true" /&gt;</ph> indicates that either a class handler, or some instance handler along the route, has already marked this event handled.</source>
          <target state="translated">이 값을 읽는 경우 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 클래스 처리기 또는 경로의 일부 인스턴스 처리기가 이미 표시 나타냅니다이 이벤트를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph>.indicates that no such handler has marked the event handled.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>는 그러한 처리기가 이벤트를 처리된 것으로 표시하지 않았음을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>The default value is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">기본값은 <ph id="ph1">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>Marking the event handled will limit the visibility of the routed event to listeners along the event route.</source>
          <target state="translated">이벤트를 처리 하는 이벤트 경로 따라 수신기 라우트된 이벤트의 표시 유형을 제한 됩니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>The event does still travel the remainder of the route, but only handlers specifically added with <ph id="ph1">`HandledEventsToo`</ph> <ph id="ph2">`true`</ph> in the <ph id="ph3">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> method call will be invoked in response.</source>
          <target state="translated">이벤트는 경로의 나머지 부분을 계속 이동지 않습니다와 특히만 처리기를 추가 하지만 <ph id="ph1">`HandledEventsToo`</ph> <ph id="ph2">`true`</ph> 에 <ph id="ph3">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> 응답에서 호출 될 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>Default handlers on instance listeners (such as those expressed in <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>) will not be invoked.</source>
          <target state="translated">기본 인스턴스 수신기에 대 한 처리기 (로 표현 되는 같은 <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>) 호출 되지 것입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>Handling events that are marked handled is not a common scenario.</source>
          <target state="translated">일반적인 시나리오는 아닙니다 처리 표시 된 이벤트를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>If you are a control author defining your own events, the decisions you make regarding event handling at the class level will impact users of your control as well as any users of derived controls, and potentially other elements that are either contained by your control or that contain your control.</source>
          <target state="translated">제어 작성자는 클래스 수준에서 처리 컨트롤의 사용자와 파생 된 컨트롤의 모든 사용자 이벤트와 관련 영향을 주며 컨트롤에 다른 요소 중 하나를 포함 하는 잠재적으로 결정 하 여 고유한 이벤트를 정의 합니다. 또는 컨트롤을 포함 하는 합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>For more information, see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</source>
          <target state="translated">자세한 내용은 <bpt id="p1">[</bpt>라우트된 이벤트를 처리된 것으로 표시 및 클래스 처리<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>In very rare circumstances it is appropriate to handle events where  <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> is marked <ph id="ph2">`true`</ph>, and modify the event arguments by changing <ph id="ph3">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> to <ph id="ph4">`false`</ph>.</source>
          <target state="translated">매우 드문에서 이벤트를 처리 하기에 적합 한지를 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> 표시 되어 <ph id="ph2">`true`</ph>, 변경 하 여 이벤트의 인수를 수정 하 고 <ph id="ph3">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> 를 <ph id="ph4">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>This can be necessary in certain areas of input events of controls, such as key handling of <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> versus <ph id="ph2">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> where low level and high level input events compete for the handling, and each is attempting to work with a different routing strategy.</source>
          <target state="translated">이의 키 처리 같은 컨트롤의 입력된 이벤트의 특정 영역에 필요할 수 있습니다 <ph id="ph1">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> 비교 <ph id="ph2">&lt;xref:System.Windows.UIElement.TextInput&gt;</ph> 는 낮은 수준과 및 높은 수준의 입력된 이벤트 처리를 위해 경쟁 하 고, 각각 서로 다른 라우팅 전략을 사용 하려고 합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Handled">
          <source>The following example implements an event handler that marks the event handled.</source>
          <target state="translated">다음 예제에서는 이벤트를 처리를 표시 하는 이벤트 처리기를 구현 합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>The generic handler / delegate implementation to be invoked.</source>
          <target state="translated">호출할 제네릭 처리기/대리자 구현입니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>The target on which the provided handler should be invoked.</source>
          <target state="translated">지정된 처리기가 호출되어야 하는 대상입니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>When overridden in a derived class, provides a way to invoke event handlers in a type-specific way, which can increase efficiency over the base implementation.</source>
          <target state="translated">파생 클래스에서 재정의된 경우 기본 구현 이상으로 효율성을 높일 수 있는 형식별 방법으로 이벤트 처리기를 호출하는 방법을 제공합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>The base implementation incorporates reflection to determine the right handler for any case where the handler is not literally <ph id="ph1">&lt;xref:System.Windows.RoutedEventHandler&gt;</ph>, and this reflection step does have some performance consequences.</source>
          <target state="translated">리플렉션을 처리기 하지 않은 문자 그대로 모든 경우에 적절 한 처리기를 통합 하는 기본 구현을 <ph id="ph1">&lt;xref:System.Windows.RoutedEventHandler&gt;</ph>, 성능은 저하 없고이 리플렉션 단계입니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>Invocations can be made more efficient by not relying on reflection.</source>
          <target state="translated">호출 가능 더 효율적으로 리플렉션을 사용 하지 않고도 합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>This is the scenario that motivates this method being available for any routed event arguments class that choose to override it.</source>
          <target state="translated">이 메서드를 재정의 하는 모든 라우트된 이벤트 인수 클래스에 대해 사용 가능 하면 시나리오입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>Implementations should not call the base for this method, because your implementation should already be responsible for invoking the type safe handlers.</source>
          <target state="translated">구현은 구현 이미를 형식이 안전한 처리기를 호출 해야 하기 때문에이 메서드에 대 한 기본을 호출 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>The following is pseudocode that illustrates a basic pattern that can be used for implementation.</source>
          <target state="translated">다음은 의사 코드 구현에 사용할 수 있는 기본 패턴을 나타내는입니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>Here, <ph id="ph1">`MyRoutedEventHandler`</ph> is a subclass of <ph id="ph2">&lt;xref:System.Windows.RoutedEventHandler&gt;</ph>.</source>
          <target state="translated">여기에서 <ph id="ph1">`MyRoutedEventHandler`</ph> 의 서브 클래스가 <ph id="ph2">&lt;xref:System.Windows.RoutedEventHandler&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>This method is intended to be overridden by derived event data classes to provide more efficient invocation of their delegates.</source>
          <target state="translated">이 메서드를 사용 하 여 보다 효율적으로 해당 대리자 호출을 제공 하는 파생 된 이벤트 데이터 클래스에서 재정의 됩니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>The implementation should cast the provided <ph id="ph1">&lt;paramref name="genericHandler" /&gt;</ph> to the type-specific delegate, and then invoke that handler.</source>
          <target state="translated">구현에서는 제공 된 캐스팅 해야 <ph id="ph1">&lt;paramref name="genericHandler" /&gt;</ph> 형식 특정 대리자와 다음 해당 처리기를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>The default implementation will attempt to invoke the provided handler, attempting to cast it as <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventHandler" /&gt;</ph>.</source>
          <target state="translated">기본 구현은로 캐스팅 하는 제공 된 처리기를 호출 하려고 <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventHandler" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)">
          <source>If either <ph id="ph1">&lt;paramref name="genericHandler" /&gt;</ph> or <ph id="ph2">&lt;paramref name="genericTarget" /&gt;</ph> is provided as <ph id="ph3">&lt;see langword="null" /&gt;</ph>, exceptions will be raised.</source>
          <target state="translated">어느 경우 <ph id="ph1">&lt;paramref name="genericHandler" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="genericTarget" /&gt;</ph> 으로 제공 <ph id="ph3">&lt;see langword="null" /&gt;</ph>, 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)">
          <source>The new value that <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.Source" /&gt;</ph> is being set to.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.Source" /&gt;</ph>가 설정되는 새 값입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)">
          <source>When overridden in a derived class, provides a notification callback entry point whenever the value of the <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.Source" /&gt;</ph> property of an instance changes.</source>
          <target state="translated">파생된 클래스에서 재정의되는 경우 인스턴스의 <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.Source" /&gt;</ph> 속성 값이 변경될 때마다 알림 콜백 진입점을 제공합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)">
          <source>Changing the reported source of an event programmatically can potentially require updating the type-specific data within the event.</source>
          <target state="translated">보고 된 이벤트의 소스를 프로그래밍 방식으로 변경 이벤트 내에서 특정 형식의 데이터를 업데이트 해야 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)">
          <source>For this reason, the <ph id="ph1">&lt;see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /&gt;</ph> method is protected virtual and is intended to be overridden by subclasses of <ph id="ph2">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph>.</source>
          <target state="translated">이러한 이유로 <ph id="ph1">&lt;see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /&gt;</ph> 메서드 가상 보호 되 고의 서브 클래스에서 재정의 <ph id="ph2">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)">
          <source>This method has no default implementation.</source>
          <target state="translated">이 메서드는 기본 구현이 없습니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="P:System.Windows.RoutedEventArgs.OriginalSource">
          <source>Gets the original reporting source as determined by pure hit testing, before any possible <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.Source" /&gt;</ph> adjustment by a parent class.</source>
          <target state="translated">부모 클래스에 의한 <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.Source" /&gt;</ph> 조정 앞에 순수 적중 횟수 테스트에서 결정한 원본 보고 원본을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.OriginalSource">
          <source>The original reporting source, before any possible <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.Source" /&gt;</ph> adjustment made by class handling, which may have been done to flatten composited element trees.</source>
          <target state="translated">복합 요소 트리를 직선으로 만들기 위해 수행되었을 수 있는 클래스 처리에 의해 <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.Source" /&gt;</ph>가 조정되기 전의 원본 보고 소스입니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.OriginalSource">
          <source>This property acquires its value once, before the class event handlers or any instance handlers are invoked, and is never adjusted past this point.</source>
          <target state="translated">이 속성을 한 번만 클래스 하기 전에 이벤트 처리기 또는 모든 인스턴스 호출 되 고이 지점 이후의 조정 되지 않습니다 해당 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.OriginalSource">
          <source>The original source information is read-only to class handlers or class implementations, just as it is reported in the event data.</source>
          <target state="translated">원본 소스 정보는 이벤트 데이터에서 보고 하는 것 처럼 클래스 처리기 또는 클래스 구현에 읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.OriginalSource">
          <source>Common cases where the source may be adjusted include content elements inside a content model for a control (the contents of a list item, for instance, will report the list item element as the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> and the actual element within the list item will be the <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph>.</source>
          <target state="translated">컨트롤에 대 한 콘텐츠 모델 내 콘텐츠 요소를 포함 하는 일반적인 경우는 소스를 조정할 수 있습니다 (예를 들어, 목록 항목의 내용으로 목록 항목 요소에서 보고는 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> 목록 항목 내에서 실제 요소는 됩니다<ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.OriginalSource">
          <source>Source adjustment by various elements and content models varies from class to class.</source>
          <target state="translated">다양 한 요소 및 정적 콘텐츠 모델에서 원본 조정 클래스에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.OriginalSource">
          <source>Each class that adjusts event sources attempts to anticipate which source is the most useful to report for most input scenarios and the scenarios for which the class is intended, and then sets that source as the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph>.</source>
          <target state="translated">이벤트 소스를 조정 하는 각 클래스 소스를 대부분의 입력된 시나리오 및 의도 클래스 한 시나리오에 대 한 보고 하는 가장 유용한 예측 하 하 고 다음 집합 있는 원본으로 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.OriginalSource">
          <source>If this source is not the one that has relevance to your handling of the event, try checking <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> instead to see if it reports a different source that is more suitable.</source>
          <target state="translated">이 원본이이 이벤트의 처리와 관련 내용이 없는 경우 확인해 보십시오 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> 대신 더욱 적합 한 다른 원본을 보고 하 고 볼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.OriginalSource">
          <source>For more details on input events, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">입력된 이벤트에 대 한 자세한 내용은 참조 하십시오. <bpt id="p1">[</bpt>입력 개요<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="P:System.Windows.RoutedEventArgs.RoutedEvent">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /&gt;</ph> associated with this <ph id="ph2">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> instance.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /&gt;</ph> 인스턴스와 연결된 <ph id="ph2">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph>를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.RoutedEvent">
          <source>The identifier for the event that has been invoked.</source>
          <target state="translated">호출된 이벤트의 식별자입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.RoutedEvent">
          <source>You cannot set this value on a <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> that has already been routed (for instance, if you obtained the arguments through a handler).</source>
          <target state="translated">이 값을 설정할 수 없습니다는 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> 있는 이미 라우팅된 (예를 들어, 구입한 경우 처리기를 통해 인수).</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.RoutedEvent">
          <source>Attempting to do so will generate an exception.</source>
          <target state="translated">이렇게 하면 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.RoutedEvent">
          <source>You can only set it on an instance that has not yet been used to generate an invocation of the event.</source>
          <target state="translated">이벤트의 호출을 생성 하는 아직 사용 하지 않은 인스턴스만 설정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.RoutedEvent">
          <source>The value of <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph> cannot be <ph id="ph2">`null`</ph> at any time.</source>
          <target state="translated">값 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph> 안 <ph id="ph2">`null`</ph> 언제 든 지 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.RoutedEvent">
          <source>The following example creates new routed event data with an initial constructor and then sets the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph> property as a subsequent operation.</source>
          <target state="translated">다음 예에서는 초기 생성자와 함께 새 라우트된 이벤트 데이터를 만들고 다음 설정의 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph> 후속 작업으로 속성입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.RoutedEvent">
          <source>You must have <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph> set prior to raising the routed event.</source>
          <target state="translated">있어야 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.RoutedEvent%2A&gt;</ph> 라우트된 이벤트를 발생 시키기 전에 설정 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="P:System.Windows.RoutedEventArgs.RoutedEvent">
          <source>Attempted to change the <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /&gt;</ph> value while the event is being routed.</source>
          <target state="translated">이벤트가 라우트되는 동안 <ph id="ph1">&lt;see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /&gt;</ph> 값을 변경하려고 시도했습니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="P:System.Windows.RoutedEventArgs.Source">
          <source>Gets or sets a reference to the object that raised the event.</source>
          <target state="translated">이벤트를 발생시킨 개체에 대한 참조를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Source">
          <source>The object that raised the event.</source>
          <target state="translated">이벤트를 발생시킨 개체입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Source">
          <source>For any bubbling routed event that has actually traveled the route beyond the element that raised it, and for any tunneling routed event that has not yet tunneled down to the element that raised it, the value of <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> will be different than the value of the <ph id="ph2">`sender`</ph> parameter of the event arguments class.</source>
          <target state="translated">라우트된 이벤트 하지 않는지 아직 값을 발생 시킨 요소 터널링 된 모든 터널링에 대 한 모든 버블링 라우트된 이벤트를 발생 시킨 요소 경로 이동한 실제로 대 한 및 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> 는 값다르다는것 <ph id="ph2">`sender`</ph> 이벤트 인수 클래스의 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Source">
          <source>Which of the two elements involved in the event is of the most importance in any given handler (<ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph>, the element that raised it, or <ph id="ph2">`sender`</ph>, the element that is currently handling it) is dependent on the application logic that your handler is addressing.</source>
          <target state="translated">이 두 요소 중 이벤트와 관련 된 지정 된 임의의 처리기에서 가장 중요 (<ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph>, 발생 하는 요소 또는 <ph id="ph2">`sender`</ph>, 현재이 처리 하는 요소) 처리기가 응용 프로그램 논리에 따라 달라 집니다 주소를 지정 합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Source">
          <source>Setting this property is typically only done when overriding or implementing other <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> that adjust event sources, such as when class handling an event.</source>
          <target state="translated">이 속성은 일반적으로 경우에 수행 재정의 하거나 구현 다른 <ph id="ph1">[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]</ph> 때 처럼 이벤트 소스를 조정 하는 클래스는 이벤트를 처리 합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Source">
          <source>Resetting apparent event sources from instance handlers is not recommended, particularly when the handler does not mark the event as handled.</source>
          <target state="translated">인스턴스 처리기에서 명백한 이벤트 소스를 다시 설정 하면 권장 되지 않습니다, 특히 처리 처리기 이벤트를 표시 하지 않는 경우.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.RoutedEventArgs.Source">
          <source>If you do reset <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> to report a different event source, <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> will continue to report the source as first raised by the originating <ph id="ph3">&lt;xref:System.Windows.UIElement.RaiseEvent%2A&gt;</ph> call.</source>
          <target state="translated">다시 설정 해도 <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> 다른 이벤트 소스를 보고 하기 위해 <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.OriginalSource%2A&gt;</ph> 첫 번째 소스로 시작에 의해 발생 하는 보고서는 계속 <ph id="ph3">&lt;xref:System.Windows.UIElement.RaiseEvent%2A&gt;</ph> 호출 합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>