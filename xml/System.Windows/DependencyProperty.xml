<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="48e189814c9d38e818a9d416a18db9a92e096f66" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48623039" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="b3c0a-101">스타일 지정, 데이터 바인딩, 애니메이션 및 상속과 같은 메서드를 통해 설정할 수 있는 속성을 나타냅니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b3c0a-101">Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-102">A <xref:System.Windows.DependencyProperty> 의 다음 기능을 지 원하는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:</span><span class="sxs-lookup"><span data-stu-id="b3c0a-102">A <xref:System.Windows.DependencyProperty> supports the following capabilities in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:</span></span>  
  
-   <span data-ttu-id="b3c0a-103">스타일에서 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-103">The property can be set in a style.</span></span> <span data-ttu-id="b3c0a-104">자세한 내용은 [스타일 지정 및 템플릿](~/docs/framework/wpf/controls/styling-and-templating.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-104">For more information, see [Styling and Templating](~/docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
-   <span data-ttu-id="b3c0a-105">데이터 바인딩을 통해 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-105">The property can be set through data binding.</span></span> <span data-ttu-id="b3c0a-106">데이터 바인딩 종속성 속성에 대 한 자세한 내용은 참조 하세요. [방법: 두 컨트롤 속성 바인딩](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-106">For more information about data binding dependency properties, see [How to: Bind the Properties of Two Controls](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).</span></span>  
  
-   <span data-ttu-id="b3c0a-107">동적 리소스 참조를 사용 하 여 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-107">The property can be set with a dynamic resource reference.</span></span> <span data-ttu-id="b3c0a-108">자세한 내용은 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-108">For more information, see [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
-   <span data-ttu-id="b3c0a-109">속성은 요소 트리의 부모 요소에서 해당 값 작업을 자동으로 상속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-109">The property can inherit its value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="b3c0a-110">자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-110">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
-   <span data-ttu-id="b3c0a-111">속성 애니메이션을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-111">The property can be animated.</span></span> <span data-ttu-id="b3c0a-112">자세한 내용은 [애니메이션 개요](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-112">For more information, see [Animation Overview](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).</span></span>  
  
-   <span data-ttu-id="b3c0a-113">속성을 변경한 속성의 이전 값 및 속성 값을 강제 변환 될 수 있는 경우에 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-113">The property can report when the previous value of the property has been changed and the property value can be coerced.</span></span> <span data-ttu-id="b3c0a-114">자세한 내용은 [종속성 속성 콜백 및 유효성 검사](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-114">For more information, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
-   <span data-ttu-id="b3c0a-115">속성에 대 한 정보를 보고 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]여부 속성을 변경 해야 요소에 대 한 시각적 개체를 다시 구성 하기 위해 레이아웃 시스템 같은, 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-115">The property reports information to [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], such as whether changing a property value should require the layout system to recompose the visuals for an element.</span></span>  
  
-   <span data-ttu-id="b3c0a-116">속성에서 지원을 받습니다는 [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-116">The property receives support in the [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].</span></span>  <span data-ttu-id="b3c0a-117">예를 들어, 속성을 편집할 수 있습니다 합니다 **속성** 창입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-117">For example, the property can be edited in the **Properties** window.</span></span>  
  
 <span data-ttu-id="b3c0a-118">종속성 속성에 대 한 자세한 내용은 참조 하세요 [종속성 속성 개요](~/docs/framework/wpf/advanced/dependency-properties-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-118">To learn more about dependency properties, see [Dependency Properties Overview](~/docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span> <span data-ttu-id="b3c0a-119">앞의 목록에 기능을 지원 하도록 사용자 지정 형식에서 속성을 원하는 경우에 종속성 속성을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-119">If you want properties on your custom types to support the capabilities in the preceding list, you should create a dependency property.</span></span>  <span data-ttu-id="b3c0a-120">사용자 지정 종속성 속성을 만드는 방법에 알아보려면 참조 [사용자 지정 종속성 속성](~/docs/framework/wpf/advanced/custom-dependency-properties.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-120">To learn how to create custom dependency properties, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="b3c0a-121">연결된 된 속성은 모든 개체에 연결된 된 속성을 정의 하는 형식 정보를 보고할 수 있도록 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-121">An attached property is a property that enables any object to report information to the type that defines the attached property.</span></span> <span data-ttu-id="b3c0a-122">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]에서 상속 되는 모든 형식을 <xref:System.Windows.DependencyObject> 속성을 정의 하는 형식에서 상속 되었는지에 관계 없이 연결된 된 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-122">In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], any type that inherits from <xref:System.Windows.DependencyObject> can use an attached property regardless of whether the type inherits from the type that defines the property.</span></span> <span data-ttu-id="b3c0a-123">연결된 된 속성의 기능은 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-123">An attached property is a feature of the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] language.</span></span>  <span data-ttu-id="b3c0a-124">연결된 된 속성을 설정 하려면 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]를 사용 합니다 *ownerType*.\* propertyName\* 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-124">To set an attached property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], use the *ownerType*.*propertyName* syntax.</span></span> <span data-ttu-id="b3c0a-125">연결된 된 속성의 예로 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-125">An example of an attached property is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b3c0a-126">모든 사용할 수 있는 속성을 만들려는 경우 <xref:System.Windows.DependencyObject> 형식, 연결된 된 속성을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-126">If you want to create a property that can be used on all <xref:System.Windows.DependencyObject> types, then you should create an attached property.</span></span> <span data-ttu-id="b3c0a-127">참조를 만드는 방법을 비롯 하 여 연결 된 속성에 자세히 알아보려면 [연결 된 속성 개요](~/docs/framework/wpf/advanced/attached-properties-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-127">To learn more about attached properties, including how to create them, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="b3c0a-128">XAML 특성 사용</span><span class="sxs-lookup"><span data-stu-id="b3c0a-128">XAML Attribute Usage</span></span>  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a><span data-ttu-id="b3c0a-129">XAML 값</span><span class="sxs-lookup"><span data-stu-id="b3c0a-129">XAML Values</span></span>  
 `dependencyPropertyName`  
 <span data-ttu-id="b3c0a-130">지정 하는 문자열을 <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> 원하는 종속성 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-130">A string that specifies the <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> of the desired dependency property.</span></span> <span data-ttu-id="b3c0a-131">이 올 수 있습니다 XML 네임 스페이스 접두사 속성은 기본 XML 네임 스페이스에 없는 경우 (자세한 내용은 참조 하세요 [XAML 네임 스페이스 및 WPF XAML에 대 한 매핑 Namespace](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)</span><span class="sxs-lookup"><span data-stu-id="b3c0a-131">This can be preceded by an XML namespace prefix if the property is not in the default XML namespace (for details, see [XAML Namespaces and Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)</span></span>  
  
 <span data-ttu-id="b3c0a-132">`ownerType`.`dependencyPropertyName`</span><span class="sxs-lookup"><span data-stu-id="b3c0a-132">`ownerType`.`dependencyPropertyName`</span></span>  
 <span data-ttu-id="b3c0a-133">점 (.), 종속성 속성의 소유자 형식 지정 하는 문자열 해당 <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-133">A string that specifies an owner type of a dependency property, a dot (.), then the <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b3c0a-134">`ownerType` XML 네임 스페이스 접두사 뒤에 올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-134">`ownerType` can also be preceded by an XML namespace prefix.</span></span> <span data-ttu-id="b3c0a-135">이 사용량이 바인딩된 스타일 및 템플릿 때문에 컨텍스트를 구문 분석에 대 한 종속성 속성의 소유자를 지정 해야 합니다는 `TargetType` 아직 알려지지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-135">This usage is particular to late-bound styles and templates, where the owner of the dependency property must be specified for parsing context because the `TargetType` is not yet known.</span></span> <span data-ttu-id="b3c0a-136">자세한 내용은 [스타일 지정 및 템플릿](~/docs/framework/wpf/controls/styling-and-templating.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-136">For more information, see [Styling and Templating](~/docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="b3c0a-137">`attachedPropertyOwnerType` *.*</span><span class="sxs-lookup"><span data-stu-id="b3c0a-137">`attachedPropertyOwnerType` *.*</span></span> `attachedPropertyName`  
 <span data-ttu-id="b3c0a-138">연결된 된 속성 이름, 점 (.), 연결된 된 속성의 소유자를 지정 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-138">A string that specifies  the owner of an attached property, a dot (.), then the attached property name.</span></span> <span data-ttu-id="b3c0a-139">`attachedPropertyOwnerType` XML 네임 스페이스 접두사 뒤에 올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-139">`attachedPropertyOwnerType` can also be preceded by an XML namespace prefix.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-140">형식에 이미 등록된 종속성 속성의 소유자로 다른 형식을 추가합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-140">Adds another type as an owner of a dependency property that has already been registered to a type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-141">이 종속성 속성의 소유자로 추가할 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-141">The type to add as an owner of this dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-142">이미 등록된 종속성 속성의 소유자로 다른 형식을 추가합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-142">Adds another type as an owner of a dependency property that has already been registered.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-143">종속성 속성을 식별하는 원본 <see cref="T:System.Windows.DependencyProperty" /> 식별자에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-143">A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property.</span>
          </span>
          <span data-ttu-id="b3c0a-144">추가하는 클래스에서는 이 식별자를 <see langword="public static readonly" /> 필드로 노출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-144">This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-145">이 메서드를 사용 하면 해당 특정 종속성 속성을 처음에 등록 하지 않은 형식에 종속성 속성을 인식 하는 속성 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-145">This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</span></span>  
  
 <span data-ttu-id="b3c0a-146">일반적으로 <xref:System.Windows.DependencyProperty.AddOwner%2A> 이미 관리 되는 클래스 상속을 통해 종속성 속성을 노출 하지 않는 클래스에 종속성 속성을 추가 하는 데 사용 됩니다 (클래스 상속으로 인해 파생된 클래스에서 상속 하는 래퍼 속성 이므로 제공 된 종속성 속성에 대 한 일반 멤버 테이블 액세스 이미).</span><span class="sxs-lookup"><span data-stu-id="b3c0a-146">Typically, <xref:System.Windows.DependencyProperty.AddOwner%2A> is used to add dependency properties to classes that do not already expose that dependency property through managed class inheritance (class inheritance would cause the wrapper properties to be inherited by the derived class, and thus would provide general members-table access to the dependency property already).</span></span> <span data-ttu-id="b3c0a-147"><xref:System.Windows.DependencyProperty.AddOwner%2A> 처음에 종속성 속성 등록 하지 않은 형식에 종속성 속성을 인식 하는 속성 시스템을 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-147"><xref:System.Windows.DependencyProperty.AddOwner%2A> enables the property system to recognize a dependency property on a type that did not register that dependency property initially.</span></span>  
  
 <span data-ttu-id="b3c0a-148">메타 데이터를 지정 하는 데이 시그니처를 허용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-148">This signature does not allow for specifying metadata.</span></span>  <span data-ttu-id="b3c0a-149">이 메서드를 사용 하면 새 메타 데이터를 자동으로 생성 됩니다 <xref:System.Windows.DependencyProperty> 와 소유자 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-149">When you use this method, the metadata is automatically generated for the new <xref:System.Windows.DependencyProperty> and its owner type.</span></span> <span data-ttu-id="b3c0a-150">자동으로 생성 된 메타 데이터에는이 속성이 정의 된 기본 형식의 모든 병합된 메타 데이터의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-150">The auto-generated metadata is the result of the merged metadata from all of the base types that have this property defined.</span></span> <span data-ttu-id="b3c0a-151">병합된 메타 데이터를 사용할 수 있는 속성에 대 한 기본 메타 데이터 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-151">If no merged metadata is available, then the default metadata for the property is used.</span></span> <span data-ttu-id="b3c0a-152">속성을 사용 하 여 등록 된 경우는 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 메서드를 기본 메타 데이터는 때 생성 되는 메타 데이터와 동일한 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 호출 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-152">If the property is registered by using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, then the default metadata is the same as the metadata that is created when <xref:System.Windows.DependencyProperty.RegisterAttached%2A> was called.</span></span> <span data-ttu-id="b3c0a-153">이 고, 그렇지는 <xref:System.Windows.PropertyMetadata> 개체를 만든를 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 속성 형식의 기본값과 다른 모든 속성을 설정 하는 속성을 <xref:System.Windows.PropertyMetadata> 로 설정 된 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-153">Otherwise, the <xref:System.Windows.PropertyMetadata> object is created with the <xref:System.Windows.PropertyMetadata.DefaultValue%2A> property set to the property type's default and all other properties of the <xref:System.Windows.PropertyMetadata> is set to `null`.</span></span> <span data-ttu-id="b3c0a-154">사용 된 <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> 서명이 제공된 된 형식에 추가 된 종속성 속성의 버전에 대 한 메타 데이터를 제공 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-154">Use the <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> signature if you want to provide metadata for the version of the dependency property as added to the provided type.</span></span>  
  
 <span data-ttu-id="b3c0a-155">이 메서드의 반환 값을 선언 하 여 종속성 속성 식별자를 저장 하 여 종속성 속성을 노출 일반적으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-155">The return value of this method is typically used to declare and expose the dependency property by storing a dependency property identifier.</span></span> <span data-ttu-id="b3c0a-156">식별자 속성 시스템을 호출 하려는 경우 종속성 속성에 대 한 액세스를 제공 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 종속성 속성에 대해 특히 존재 하므로 추가 소유자 클래스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-156">The identifier provides access to the dependency property if you want to call property system [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] against the dependency property, particularly as it exists on the adding owner class.</span></span> <span data-ttu-id="b3c0a-157">원래 소유자와 추가 된 소유자에 대 한 속성 이름이 비슷한 기능을 나타내는 데 사용할 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-157">The same property name for both original owner and added owner should be used to indicate the similar functionality.</span></span> <span data-ttu-id="b3c0a-158">사용 해야 합니다 <xref:System.Windows.DependencyProperty> 의 값을 반환 합니다 <xref:System.Windows.DependencyProperty.AddOwner%2A> 종속성 속성 식별자를 정의 하 고 선언도 메서드 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 속성 래퍼를 사용 하 여 형식에 추가 되는 종속성 속성에 대 한 <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-158">You should use the <xref:System.Windows.DependencyProperty> return value of the <xref:System.Windows.DependencyProperty.AddOwner%2A> method to define the dependency property identifier, and also to declare [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span></span>  
  
 <span data-ttu-id="b3c0a-159">합니다 <xref:System.Windows.DependencyProperty.AddOwner%2A> 내에 선언 된 종속성 속성을 만들 때 위에서 권장 하는 방법론을 사용 하는 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-159">The <xref:System.Windows.DependencyProperty.AddOwner%2A> methodology recommended above is used when creating the dependency properties that are declared within [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="b3c0a-160">예를 들어, 둘 다 <xref:System.Windows.Controls.Border> 하 고 <xref:System.Windows.Controls.Control> 정의 `BorderBrush` 비슷한 기능을 가진 종속성 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-160">For instance, both <xref:System.Windows.Controls.Border> and <xref:System.Windows.Controls.Control> define a `BorderBrush` dependency property, which have similar functionality.</span></span> <span data-ttu-id="b3c0a-161"><xref:System.Windows.Controls.Control> 정의 해당 `BorderBrush` 속성을 호출 하 여 속성 시스템 <xref:System.Windows.DependencyProperty.AddOwner%2A> 원래 소유자에 따라 <xref:System.Windows.Controls.Border> 및 등록 된 <xref:System.Windows.Controls.Border.BorderBrushProperty> 종속성 속성 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-161"><xref:System.Windows.Controls.Control> defines its `BorderBrush` property to the property system by calling <xref:System.Windows.DependencyProperty.AddOwner%2A> based on the original owner <xref:System.Windows.Controls.Border> and its registered <xref:System.Windows.Controls.Border.BorderBrushProperty> dependency property identifer.</span></span> <span data-ttu-id="b3c0a-162"><xref:System.Windows.DependencyProperty.AddOwner%2A> 반환 하는 새 정적 설정 값을 사용 합니다 <xref:System.Windows.DependencyProperty> 필드 (<xref:System.Windows.Controls.Control.BorderBrushProperty>)에서 추가 된 소유자, 해당 속성 및 `BorderBrush` 속성 래퍼를 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-162">The <xref:System.Windows.DependencyProperty.AddOwner%2A> return value is then used to establish a new static <xref:System.Windows.DependencyProperty> field (<xref:System.Windows.Controls.Control.BorderBrushProperty>) for that property on the added owner, and a `BorderBrush` property wrapper is also declared.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-163">이 종속성 속성의 소유자로 추가할 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-163">The type to add as owner of this dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="b3c0a-164">제공된 형식에 존재하는 종속성 속성을 정규화하는 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-164">The metadata that qualifies the dependency property as it exists on the provided type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-165">이미 등록된 종속성 속성의 소유자로 다른 형식을 추가하며, 제공된 소유자 형식에 존재하는 종속성 속성에 대한 종속성 속성 메타데이터를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-165">Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-166">종속성 속성을 식별하는 원본 <see cref="T:System.Windows.DependencyProperty" /> 식별자에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-166">A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property.</span>
          </span>
          <span data-ttu-id="b3c0a-167">추가하는 클래스에서는 이 식별자를 <see langword="public static readonly" /> 필드로 노출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-167">This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-168">이 메서드를 사용 하면 해당 특정 종속성 속성을 처음에 등록 하지 않은 형식에 종속성 속성을 인식 하는 속성 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-168">This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</span></span>  
  
 <span data-ttu-id="b3c0a-169">이 메서드의 반환 값을 추가 하는 소유자 클래스에 있으므로 특히를 선언 하 여 종속성 속성을 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-169">The return value of this method is used to declare and expose the dependency property, particularly as it exists on the adding owner class.</span></span> <span data-ttu-id="b3c0a-170">일반적으로 원래 소유자와 추가 된 소유자에 대 한 속성 이름이 비슷한 기능을 나타내는 데 사용할 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-170">Generally, the same property name for both original owner and added owner should be used to indicate the similar functionality.</span></span> <span data-ttu-id="b3c0a-171">도 새 식별자를 노출 하는 것이 좋습니다 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 사용 하 여 형식에 추가 되는 종속성 속성에 대 한 속성 래퍼 <xref:System.Windows.DependencyProperty.AddOwner%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-171">It is good practice to expose the identifiers, as well as new [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>.</span></span>  
  
 <span data-ttu-id="b3c0a-172">합니다 <xref:System.Windows.DependencyProperty.AddOwner%2A> 위에서 권장 하는 방법론은 만들 때 사용 됩니다 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 내에 선언 된 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-172">The <xref:System.Windows.DependencyProperty.AddOwner%2A> methodology recommended above is used when creating [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] declared within [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="b3c0a-173">예를 들어, 둘 다 <xref:System.Windows.Controls.Border> 하 고 <xref:System.Windows.Controls.Control> 정의 `BorderBrush` 비슷한 기능을 가진 종속성 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-173">For instance, both <xref:System.Windows.Controls.Border> and <xref:System.Windows.Controls.Control> define a `BorderBrush` dependency property, which have similar functionality.</span></span> <span data-ttu-id="b3c0a-174"><xref:System.Windows.Controls.Control> 정의 해당 `BorderBrush` 속성을 호출 하 여 속성 시스템 <xref:System.Windows.DependencyProperty.AddOwner%2A> 의 원래 소유자 <xref:System.Windows.Controls.Border> 및 등록 된 <xref:System.Windows.Controls.Border.BorderBrushProperty> 종속성 속성 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-174"><xref:System.Windows.Controls.Control> defines its `BorderBrush` property to the property system by calling <xref:System.Windows.DependencyProperty.AddOwner%2A> on original owner <xref:System.Windows.Controls.Border> and its registered <xref:System.Windows.Controls.Border.BorderBrushProperty> dependency property identifer.</span></span> <span data-ttu-id="b3c0a-175">합니다 <xref:System.Windows.DependencyProperty.AddOwner%2A> 반환 값은 다음 정적 설정 하는 데 사용 됩니다 <xref:System.Windows.DependencyProperty> 필드 (<xref:System.Windows.Controls.Control.BorderBrushProperty>)에 추가 된 소유자, 해당 속성에 대 한 및 `BorderBrush` 속성 래퍼를 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-175">The <xref:System.Windows.DependencyProperty.AddOwner%2A> return value is then used to establish a static <xref:System.Windows.DependencyProperty> field (<xref:System.Windows.Controls.Control.BorderBrushProperty>) for that property on the added owner, and a `BorderBrush` property wrapper is also declared.</span></span>  
  
 <span data-ttu-id="b3c0a-176">추가 된 소유자의 종속성 속성 식별자에 사용할 작업 같은 <xref:System.Windows.DependencyObject.GetValue%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-176">The added owner's dependency property identifier should be used for operations such as <xref:System.Windows.DependencyObject.GetValue%2A>.</span></span> <span data-ttu-id="b3c0a-177">그러나 형식 또는 다른 메타 데이터를 사용 하 여 소유자는 여전히 추가 된 클래스의 인스턴스를 포함 하는 type 별 작업을 반환할 경우에도 예상된 결과 원래 (없습니다 추가 된 소유자의)에 지정 된 종속성 속성 식별자 와 같은 메서드를 호출 <xref:System.Windows.DependencyObject.GetValue%2A> 또는 <xref:System.Windows.DependencyProperty.GetMetadata%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-177">However, type-specific operations involving either types or instances of the class that was added as owner with different metadata will still return the expected results even if the original (not the added owner's) dependency property identifier is specified in calls to methods such as <xref:System.Windows.DependencyObject.GetValue%2A> or <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</span></span> <span data-ttu-id="b3c0a-178">추가 된 소유자에 대 한 메타 데이터에서 지속 되는 <xref:System.Windows.DependencyProperty.AddOwner%2A> 추가 소유자 클래스 식별자 필드에서 단독으로 참조 하지 않아도 자신을 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-178">The metadata for the added owner is perpetuated by the <xref:System.Windows.DependencyProperty.AddOwner%2A> call itself, not necessarily referenced exclusively by the adding owner class identifier field.</span></span> <span data-ttu-id="b3c0a-179">그럼에도 불구 하 고 것에 새 식별자를 노출 하는 것이 좋습니다 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 사용 하 여 형식에 추가 되는 종속성 속성에 대 한 속성 래퍼 <xref:System.Windows.DependencyProperty.AddOwner%2A>간의 차이 만들기 위해 실패 때문에 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 및 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 속성의 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-179">Nevertheless, it is good practice to expose the  identifier, as well as new [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] property wrappers, for dependency properties that are added to types using <xref:System.Windows.DependencyProperty.AddOwner%2A>, because failing to do so creates disparity between the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] representations of your properties.</span></span>  
  
 <span data-ttu-id="b3c0a-180">제공 된 메타 데이터는 기본 소유자에 있는 종속성 속성의 속성 메타 데이터를 사용 하 여 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-180">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="b3c0a-181">원래 기본 메타 데이터에 지정 된 모든 특성이 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-181">Any characteristics that were specified in the original base metadata will persist.</span></span> <span data-ttu-id="b3c0a-182">새 메타 데이터에 특별히 변경 된 특성만 기본 메타 데이터의 특징을 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-182">Only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="b3c0a-183">일부 특성을 같은 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, 새 메타 데이터에 지정 된 경우에 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-183">Some characteristics, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are replaced if they are specified in the new metadata.</span></span> <span data-ttu-id="b3c0a-184">다른 사용자와 같은 <xref:System.Windows.PropertyChangedCallback>에 결합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-184">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="b3c0a-185">병합 동작 하므로 여기에 설명 된 동작은 사용 되는 기존 속성 메타 데이터 클래스에 대 한 재정의 사용 중인 속성 메타 데이터 형식에 따라 다르며 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 종속성 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-185">Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] dependency properties.</span></span> <span data-ttu-id="b3c0a-186">자세한 내용은 참조 하세요 [종속성 속성 메타 데이터](~/docs/framework/wpf/advanced/dependency-property-metadata.md) 하 고 [프레임 워크 속성 메타 데이터](~/docs/framework/wpf/advanced/framework-property-metadata.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-186">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-187">종속성 속성의 기본 메타데이터를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-187">Gets the default metadata of the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3c0a-188">종속성 속성의 기본 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-188">The default metadata of the dependency property.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-189">기본 메타 데이터는 대체 메타 데이터가 명시적으로 제공한 위치는 특정 개체 또는 파생 형식의 개체에 사용할 수 있는 속성 메타 데이터 <xref:System.Windows.DependencyProperty.Register%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-189">The default metadata is the property metadata that is available to that particular object or an object of a derived type where no alternative metadata was supplied by an explicit <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> call.</span></span>  
  
 <span data-ttu-id="b3c0a-190">원래 소유자를 먼저 메타 데이터를 적용 하는 경우 <xref:System.Windows.DependencyProperty.Register%2A> 으로 반환 되 고 해당 메타 데이터 종속성 속성을 설정 하는 호출 <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-190">If the original owner applied metadata to the first <xref:System.Windows.DependencyProperty.Register%2A> call that established the dependency property, then that metadata is returned as <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
 <span data-ttu-id="b3c0a-191">메타 데이터가 원래에서 적용 된 경우 <xref:System.Windows.DependencyProperty.Register%2A> 호출에 기본 메타 데이터 내에서 생성 되는 <xref:System.Windows.DependencyProperty.Register%2A> 호출과이 값으로 반환 됩니다는 <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-191">If no metadata was applied in the original <xref:System.Windows.DependencyProperty.Register%2A> call, then default metadata is generated from within the <xref:System.Windows.DependencyProperty.Register%2A> call and this value is returned as the <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
 <span data-ttu-id="b3c0a-192">연결 된 기본 메타 데이터의 주요 목적은 <xref:System.Windows.DependencyProperty> 에서이 속성에 대 한 기본값을 제공 하는 데 <xref:System.Windows.DependencyObject> 또는 파생된 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-192">The main purpose of having default metadata associated with a <xref:System.Windows.DependencyProperty> is to supply a default value for this property on any <xref:System.Windows.DependencyObject> or a derived type.</span></span>  
  
 <span data-ttu-id="b3c0a-193">연결 되지 않은 속성에 대 한이 속성에 의해 반환 되는 메타 데이터 형식 캐스팅할 수 없는 파생된 유형의 <xref:System.Windows.PropertyMetadata> 속성이 파생 된 메타 데이터 형식을 사용 하 여 원래 등록 된 경우에 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-193">For nonattached properties, the metadata type returned by this property cannot be cast to derived types of <xref:System.Windows.PropertyMetadata> type, even if the property was originally registered with a derived metadata type.</span></span> <span data-ttu-id="b3c0a-194">해당 원래 가능한 경우 파생 된 메타 데이터 유형을 포함 하 여 원래 등록 된 메타 데이터를 원하는 경우 호출 <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> 형식을 매개 변수로 대신 원래 등록을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-194">If you want the originally registered metadata including its original possibly derived metadata type, call <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> instead, passing the original registering type as a parameter.</span></span>  
  
 <span data-ttu-id="b3c0a-195">연결 된 속성에 대 한이 속성에서 반환 하는 메타 데이터 유형을 원래 지정 된 형식과 일치는 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 등록 메서드.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-195">For attached properties, the type of the metadata returned by this property will match the type given in the original <xref:System.Windows.DependencyProperty.RegisterAttached%2A> registration method.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-196">이 <see cref="T:System.Windows.DependencyProperty" />의 해시 코드를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-196">Returns a hash code for this <see cref="T:System.Windows.DependencyProperty" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-197">이 <see cref="T:System.Windows.DependencyProperty" />에 대한 해시 코드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-197">The hash code for this <see cref="T:System.Windows.DependencyProperty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-198">속성 시스템 자체 고유 식별자를 사용 하 여 <xref:System.Windows.DependencyProperty.GlobalIndex%2A>를 반환한 속성의 값 및 <xref:System.Windows.DependencyProperty.GetHashCode%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-198">The property system uses its own unique identifier <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, and the value of that property is returned by <xref:System.Windows.DependencyProperty.GetHashCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-199">특정 형식에 대해 존재하는 이 종속성 속성과 연결된 메타데이터를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-199">Returns the metadata associated with this dependency property as it exists for a particular type.</span>
          </span>
          <span data-ttu-id="b3c0a-200">종속성 속성은 처음 등록된 형식 또는 이후에 추가된 형식이거나, 상속을 통해 종속성 속성을 가져왔지만 메타데이터가 명시적으로 재정의된 형식일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-200">This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">
          <span data-ttu-id="b3c0a-201">종속성 속성 메타데이터를 검색할 특정 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-201">The specific type from which to retrieve the dependency property metadata.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-202">종속성 속성이 지정된 기존 형식일 경우 이 종속성 속성의 메타데이터를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-202">Returns the metadata for this dependency property as it exists on a specified existing type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-203">속성 메타데이터 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-203">A property metadata object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-204">형식 또는 개체 참조를 사용할 형식 필요한 메타 데이터를 원래 등록에서 달라질 수 있으므로 지정 <xref:System.Windows.DependencyProperty.AddOwner%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 형식에 있는 종속성 속성의 메타 데이터를 변경 하는 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-204">Specifying either the type or an object reference to use as type is necessary because the metadata can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that alter the metadata of the dependency property as it exists on a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-205">다음 예제에서는 해당 형식에 따라 종속성 속성 메타 데이터를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-205">The following example gets metadata for a dependency property based on its type.</span></span> <span data-ttu-id="b3c0a-206">형식을 사용 하 여를 `typeof` 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-206">The type is obtained by using a `typeof` operator.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">
          <span data-ttu-id="b3c0a-207">메타데이터를 가져와야 하는 종속성 속성의 형식별 버전을 결정하기 위해 형식이 검사된 종속성 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-207">A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-208">종속성 속성이 지정된 개체 인스턴스에 있을 때 이 종속성 속성의 메타데이터를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-208">Returns the metadata for this dependency property as it exists on the specified object instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-209">속성 메타데이터 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-209">A property metadata object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-210">지정 하는 형식 또는 개체 참조를 필요한 특정된 종속성 속성의 메타 데이터를 원래 등록에서 달라질 수 있으므로 <xref:System.Windows.DependencyProperty.AddOwner%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 에 있는 속성 메타 데이터를 수정 하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-210">Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that can refine the property metadata as it exists on a type.</span></span>  
  
 <span data-ttu-id="b3c0a-211">인스턴스를 기반으로 하는 속성 메타 데이터를 요청 하면 실제로 전달 하는 인스턴스 형식과 내부적으로 계산할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-211">When you request property metadata based on an instance, you are really just passing the instance so that its type can be evaluated internally.</span></span> <span data-ttu-id="b3c0a-212">종속성 속성 메타 데이터 인스턴스 별로 달라 지지 않습니다. 지정 된 type 속성 조합에 대해 일관성은 항상입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-212">Dependency property metadata does not vary per instance; it is always consistent for any given type-property combination.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-213">다음 예제에서는 특정 기반 종속성 속성 메타 데이터를 가져옵니다 <xref:System.Windows.DependencyObject> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-213">The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">
          <span data-ttu-id="b3c0a-214">종속성 속성 메타데이터가 필요한 종속성 개체 형식을 기록하는 특정 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-214">A specific object that records the dependency object type from which the dependency property metadata is desired.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-215">종속성 속성이 지정된 형식일 때 이 종속성 속성의 메타데이터를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-215">Returns the metadata for this dependency property as it exists on a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-216">속성 메타데이터 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-216">A property metadata object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-217">지정 하는 형식 또는 개체 참조를 필요한 특정된 종속성 속성의 메타 데이터를 원래 등록에서 달라질 수 있으므로 <xref:System.Windows.DependencyProperty.AddOwner%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 에 있는 속성 메타 데이터를 수정 하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-217">Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> calls that can refine the property metadata as it exists on a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-218">다음 예제에서는 메타 데이터 기반 종속성 속성에 대 한 해당 <xref:System.Windows.DependencyObjectType>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-218">The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-219">종속성 속성을 고유하게 식별하는 내부 생성 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-219">Gets an internally generated value that uniquely identifies the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3c0a-220">고유 숫자 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-220">A unique numeric identifier.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-221">이 값은 정수를 전역적으로 고유 식별자 (GUID) 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-221">This value is an integer, not a globally unique identifier (GUID).</span></span> <span data-ttu-id="b3c0a-222">일반적으로이 인덱스 값을 사용 하 여 필요 하지 않습니다 및 모든 종속성 속성의 테이블에 액세스할 수 없는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-222">Generally, using this index value is not required, and there is no index access to tables of all dependency properties.</span></span> <span data-ttu-id="b3c0a-223">종속성 속성 식별자 필드 대신 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-223">Dependency properties should instead be referenced by their identifier fields.</span></span>  
  
 <span data-ttu-id="b3c0a-224"><xref:System.Windows.DependencyProperty.GlobalIndex%2A> 내부적으로 사용 하는 데이터 구조에 대 한 빠른 액세스는 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> 0부터 시작 배열 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-224"><xref:System.Windows.DependencyProperty.GlobalIndex%2A> is used internally for faster access to data structures that use the <xref:System.Windows.DependencyProperty.GlobalIndex%2A> as a zero-based array index.</span></span> <span data-ttu-id="b3c0a-225">비슷한 사용량 디자이너 또는 도구에 대 한 응용 프로그램에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-225">A similar usage might have applications for designers or tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b3c0a-226">확인할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-226">The value to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-227">원래 종속성 속성 등록 시 제공된 속성 형식을 기준으로 지정된 값을 이 종속성 속성 형식에 사용할 수 있는지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-227">Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-228">지정된 값이 등록된 속성 형식이거나 사용 가능한 파생 형식이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-228">
              <see langword="true" /> if the specified value is the registered property type or an acceptable derived type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-229">값 `null` 유효한 형식이 또는 참조 형식 종속성 속성에 대 한는 <xref:System.Nullable%601> 종속성 속성인이 반환 `true` 이러한 경우에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-229">A value of `null` is a valid type for reference type dependency properties, or for a <xref:System.Nullable%601> dependency property, and would return `true` for these cases.</span></span> <span data-ttu-id="b3c0a-230">종속성 속성은 모두 참조 하는 경우에서 또는 <xref:System.Nullable%601> 유형을 <xref:System.Windows.DependencyProperty.IsValidType%2A> 돌아갑니다 `false` 예외가 발생 하지 않고 null 값에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-230">In cases where the dependency property is neither a reference nor a <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> will return `false` for a null value rather than raise an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-231">다음 예제에서는 <xref:System.Windows.DependencyProperty.IsValidType%2A> 호출 하기 전에 검사 <xref:System.Windows.DependencyObject.SetValue%2A> 종속성 속성에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-231">The following example uses <xref:System.Windows.DependencyProperty.IsValidType%2A> as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="b3c0a-232">확인할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-232">The value to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-233">제공된 값이 속성 형식에 허용되는지 기본 형식 확인을 통해 확인하고, 해당 형식에 허용되는 값 범위에 속하는지도 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-233">Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-234">값을 사용할 수 있고 올바른 형식이거나 파생 형식이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-234">
              <see langword="true" /> if the value is acceptable and is of the correct type or a derived type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-235">종속성 속성의 경우 해당 형식에 대 한 값의 허용된 범위를 통해 지정할 수 있습니다는 <xref:System.Windows.ValidateValueCallback> 가 제공 하는 종속성 속성 등록에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-235">For a dependency property, an allowed range of values for that type can be specified through a <xref:System.Windows.ValidateValueCallback> that is provided in the dependency property registration.</span></span>  
  
 <span data-ttu-id="b3c0a-236">이 메서드를 호출 <xref:System.Windows.DependencyProperty.IsValidType%2A> 내부적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-236">This method calls <xref:System.Windows.DependencyProperty.IsValidType%2A> internally.</span></span> <span data-ttu-id="b3c0a-237">해당 종속성 속성에 없을 경우 <xref:System.Windows.ValidateValueCallback>,이 메서드를 호출 하는 것은 효과적으로 호출할 때와 동일한 <xref:System.Windows.DependencyProperty.IsValidType%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-237">If the dependency property in question has no <xref:System.Windows.ValidateValueCallback>,then calling this method is effectively equivalent to calling <xref:System.Windows.DependencyProperty.IsValidType%2A>.</span></span> <span data-ttu-id="b3c0a-238">종속성 속성이 없는 경우는 <xref:System.Windows.ValidateValueCallback>, 경우에 <xref:System.Windows.DependencyProperty.IsValidType%2A> 가 반환 되 `true`, 콜백에서 구현 될 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-238">If the dependency property does have a <xref:System.Windows.ValidateValueCallback>, and if <xref:System.Windows.DependencyProperty.IsValidType%2A> would have returned `true`, then the value returned will be as implemented in the callback.</span></span>  
  
 <span data-ttu-id="b3c0a-239">Null 값 또는 참조 형식 종속성 속성에 대 한 유효한 값은는 <xref:System.Nullable%601> 종속성 속성을 반환 하 고 `true` 이러한 경우에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-239">A null value is a valid value for reference type dependency properties, or for a <xref:System.Nullable%601> dependency property, and would return `true` for these cases.</span></span> <span data-ttu-id="b3c0a-240">종속성 속성은 모두 참조 하는 경우에서 또는 <xref:System.Nullable%601> 유형을 <xref:System.Windows.DependencyProperty.IsValidType%2A> 돌아갑니다 `false` 예외가 발생 하지 않고 null 값에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-240">In cases where the dependency property is neither a reference nor a <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> will return `false` for a null value rather than raise an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-241">다음 예제에서는 <xref:System.Windows.DependencyProperty.IsValidValue%2A> 호출 하기 전에 검사 <xref:System.Windows.DependencyObject.SetValue%2A> 종속성 속성에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-241">The following example uses <xref:System.Windows.DependencyProperty.IsValidValue%2A> as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-242">종속성 속성의 이름을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-242">Gets the name of the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3c0a-243">속성의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-243">The name of the property.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-244">이 속성으로 제공 된 이름을 가져옵니다는 `name` 종속성 속성 등록 중에 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-244">This property gets the name provided as the `name` parameter during dependency property registration.</span></span> <span data-ttu-id="b3c0a-245">이 이름은 변경할 수 이며 안 `null` 또는 빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-245">This name is immutable, and cannot be `null` or an empty string.</span></span> <span data-ttu-id="b3c0a-246">동일한 소유자 형식에 중복 이름이 등록은 허용 되지 않으며, 중복 등록 하려고 할 때 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-246">Duplicate name registrations on the same owner type are not permitted, and will throw an exception when you attempt to register the duplicate.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b3c0a-247"><xref:System.Windows.DependencyProperty.Name%2A> 종속성 속성에서 "Property" 접미사를 뺀 해당 종속성 속성 식별자의 이름을 일치 하는 규칙을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-247">The <xref:System.Windows.DependencyProperty.Name%2A> of a dependency property must follow the convention of matching the name of its dependency property identifier minus the suffix "Property".</span></span> <span data-ttu-id="b3c0a-248">자세한 내용은 [사용자 지정 종속성 속성](~/docs/framework/wpf/advanced/custom-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-248">For details, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-249">다음 예제 쿼리는 종속성 속성 식별자의 다양 한 특성 등을 <xref:System.Windows.DependencyProperty.Name%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-249">The following example queries various characteristics of a dependency property identifier, including the <xref:System.Windows.DependencyProperty.Name%2A>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-250">지정된 형식의 인스턴스에 있을 경우 이 종속성 속성에 대해 초기 종속성 속성 등록 시 제공된 메타데이터가 아니라 대체 메타데이터를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-250">Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">
          <span data-ttu-id="b3c0a-251">이 종속성 속성에 상속되는 형식이며, 지정된 대체 메타데이터에 적용될 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-251">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="b3c0a-252">재정의하는 형식에서 종속성 속성에 적용할 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-252">The metadata to apply to the dependency property on the overriding type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-253">지정된 형식의 인스턴스에 있는 경우 이 종속성 속성에 대해 대체 메타데이터를 지정하고, 기본 형식에서 상속된 종속성 속성에 존재하는 메타데이터를 재정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-253">Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-254">속성 시스템 종속성 속성을 사용 하기 전에 종속성 속성 메타 데이터를 재정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-254">Dependency property metadata should be overridden before the property system uses the dependency property.</span></span> <span data-ttu-id="b3c0a-255">이 종속성 속성을 등록 하는 클래스를 사용 하 여 특정 인스턴스가 생성 되는 경우와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-255">This equates to the time that specific instances are created using the class that registers the dependency property.</span></span> <span data-ttu-id="b3c0a-256">에 대 한 호출 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 서 자신을 제공 하는 형식의 정적 생성자 내에 수행 해야 합니다 `forType` 이 메서드 또는 비슷한 인스턴스화를 통해 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-256">Calls to <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or through similar instantiation.</span></span> <span data-ttu-id="b3c0a-257">소유자 형식의 인스턴스가 후 메타 데이터를 변경 하는 예외를 발생 하지 않지만 속성 시스템에서 일관성 없는 동작이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-257">Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</span></span>  
  
 <span data-ttu-id="b3c0a-258">이 메서드를 사용 하 여 특정 파생된 클래스 재정의 대 한 메타 데이터 설정 되 면 이후에 동일한 파생된 클래스에서 메타 데이터 재정의 하려고 시도 하면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-258">After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</span></span>  
  
 <span data-ttu-id="b3c0a-259">제공 된 메타 데이터는 기본 소유자에 있는 종속성 속성의 속성 메타 데이터를 사용 하 여 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-259">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="b3c0a-260">원래 기본 메타 데이터에 지정 된 특성 유지 됩니다. 새 메타 데이터에 특별히 변경 된 특성만 기본 메타 데이터의 특징을 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-260">Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="b3c0a-261">와 같은 몇 가지 특징 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 새 메타 데이터에 지정 된 경우에 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-261">Some characteristics such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A> are replaced if specified in the new metadata.</span></span> <span data-ttu-id="b3c0a-262">다른 사용자와 같은 <xref:System.Windows.PropertyChangedCallback>에 결합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-262">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="b3c0a-263">병합 동작 하므로 여기에 설명 된 동작은 사용 되는 기존 속성 메타 데이터 클래스에 대 한 재정의 사용 중인 속성 메타 데이터 형식에 따라 다르며 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 종속성 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-263">Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] dependency properties.</span></span> <span data-ttu-id="b3c0a-264">자세한 내용은 참조 하세요 [종속성 속성 메타 데이터](~/docs/framework/wpf/advanced/dependency-property-metadata.md) 하 고 [프레임 워크 속성 메타 데이터](~/docs/framework/wpf/advanced/framework-property-metadata.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-264">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b3c0a-265">읽기 전용 종속성 속성에서 메타데이터 재정의를 시도한 경우(이 서명을 사용하여 해당 작업을 완료할 수 없음)</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-265">An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b3c0a-266">지정된 형식에 있는 종속성 속성에 대해 메타데이터가 이미 설정되어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-266">Metadata was already established for the dependency property as it exists on the provided type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">
          <span data-ttu-id="b3c0a-267">이 종속성 속성에 상속되는 형식이며, 지정된 대체 메타데이터에 적용될 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-267">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="b3c0a-268">재정의하는 형식에서 종속성 속성에 적용할 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-268">The metadata to apply to the dependency property on the overriding type.</span>
          </span>
        </param>
        <param name="key">
          <span data-ttu-id="b3c0a-269">읽기 전용 종속성 속성에 대한 액세스 키입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-269">The access key for a read-only dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-270">지정된 형식의 인스턴스에 있을 경우 읽기 전용 종속성 속성에 대해 대체 메타데이터를 제공하여 초기 종속성 속성 등록 시 제공된 메타데이터를 재정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-270">Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration.</span>
          </span>
          <span data-ttu-id="b3c0a-271">예외가 발생하지 않도록 읽기 전용 종속성 속성의 <see cref="T:System.Windows.DependencyPropertyKey" />를 전달해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-271">You must pass the <see cref="T:System.Windows.DependencyPropertyKey" /> for the read-only dependency property to avoid raising an exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-272">이 서명은 읽기 전용 종속성 속성 식별자에 대 한 기본 구현 (<xref:System.Windows.DependencyPropertyKey>) 메서드.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-272">This signature provides underlying implementation for a read-only dependency property identifier (<xref:System.Windows.DependencyPropertyKey>) method.</span></span> <span data-ttu-id="b3c0a-273">읽기-쓰기 종속성 속성에 대 한 메타 데이터를 재정의 하는 경우 사용 하 여 <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-273">If overriding metadata for a read-write dependency property, use <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</span></span>  
  
 <span data-ttu-id="b3c0a-274">속성 시스템 종속성 속성을 사용 하기 전에 종속성 속성 메타 데이터를 재정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-274">Dependency property metadata should be overridden before the property system uses the dependency property.</span></span> <span data-ttu-id="b3c0a-275">이 종속성 속성을 등록 하는 클래스에 대 한 시간을 특정 개체가 만들어지는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-275">This equates to the time that specific objects are created for the class that registers the dependency property.</span></span> <span data-ttu-id="b3c0a-276">에 대 한 호출 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 서 자신을 제공 하는 형식의 정적 생성자 내에 수행 해야 합니다 `forType` 이 메서드 또는 비슷한 인스턴스화를 통해 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-276">Calls to <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or through similar instantiation.</span></span> <span data-ttu-id="b3c0a-277">소유자 형식의 인스턴스가 후 메타 데이터를 변경 하는 예외를 발생 하지 않지만 속성 시스템에서 일관성 없는 동작이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-277">Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</span></span>  
  
 <span data-ttu-id="b3c0a-278">이 메서드를 사용 하 여 특정 파생된 클래스 재정의 대 한 메타 데이터 설정 되 면 이후에 동일한 파생된 클래스에서 메타 데이터 재정의 하려고 시도 하면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-278">After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</span></span>  
  
 <span data-ttu-id="b3c0a-279">제공 된 메타 데이터는 기본 소유자에 있는 종속성 속성의 속성 메타 데이터를 사용 하 여 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-279">The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</span></span> <span data-ttu-id="b3c0a-280">원래 기본 메타 데이터에 지정 된 특성 유지 됩니다. 새 메타 데이터에 특별히 변경 된 특성만 기본 메타 데이터의 특징을 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-280">Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</span></span> <span data-ttu-id="b3c0a-281">와 같은 몇 가지 특징 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 새 메타 데이터에 지정 된 경우에 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-281">Some characteristics such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A> are replaced if specified in the new metadata.</span></span> <span data-ttu-id="b3c0a-282">다른 사용자와 같은 <xref:System.Windows.PropertyChangedCallback>에 결합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-282">Others, such as <xref:System.Windows.PropertyChangedCallback>, are combined.</span></span> <span data-ttu-id="b3c0a-283">병합 동작을 재정의 하는 데 사용 되 고 속성 메타 데이터 형식에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-283">The merge behavior depends on the property metadata type being used for the override.</span></span> <span data-ttu-id="b3c0a-284">자세한 내용은 참조 하세요 [종속성 속성 메타 데이터](~/docs/framework/wpf/advanced/dependency-property-metadata.md) 하 고 [프레임 워크 속성 메타 데이터](~/docs/framework/wpf/advanced/framework-property-metadata.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-284">For details, see [Dependency Property Metadata](~/docs/framework/wpf/advanced/dependency-property-metadata.md) and [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-285">속성 시스템에 종속성 속성을 등록하거나 자체적으로 속성 소유자로 추가한 개체의 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-285">Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3c0a-286">속성을 등록하거나 자체적으로 속성 소유자로 추가한 개체의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-286">The type of the object that registered the property or added itself as owner of the property.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-287">이 값이 속성을 등록할 때 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-287">This value was provided during property registration.</span></span> <span data-ttu-id="b3c0a-288">소유자는 형식일 하거나 원래 등록의 경우는 <xref:System.Windows.DependencyProperty> 에서 생성 된 식별자를 <xref:System.Windows.DependencyProperty.Register%2A> 통화 또는 자체의 경우 소유자로 추가 하는 형식을 <xref:System.Windows.DependencyProperty> 에서 생성 된 식별자는 <xref:System.Windows.DependencyProperty.AddOwner%2A> 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-288">The owner will be either the original registering type in the case of a <xref:System.Windows.DependencyProperty> identifier generated from a <xref:System.Windows.DependencyProperty.Register%2A> call, or the type that added itself as owner in the case of a <xref:System.Windows.DependencyProperty> identifier generated from an <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span>  
  
 <span data-ttu-id="b3c0a-289"><xref:System.Windows.DependencyProperty.OwnerType%2A> 에 지정 된 모든 <xref:System.Windows.DependencyProperty> 변경할 수 없는 및 일 수 없습니다 `null` 에 유효한 <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-289">The <xref:System.Windows.DependencyProperty.OwnerType%2A> on any given <xref:System.Windows.DependencyProperty> is immutable, and cannot be `null` in a valid <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-290">다음 예제에서는 종속성 속성 식별자를 기반으로 소유자 형식을 가져옵니다 `dp`, 한 다음 해당 식별자를 소유자 유형의 메타 데이터를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-290">The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier.</span></span> <span data-ttu-id="b3c0a-291">이 작업은 실제로를 가져오는 <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> 에서 `dp`합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-291">This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-292">종속성 속성에서 값으로 사용하는 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-292">Gets the type that the dependency property uses for its value.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3c0a-293">속성 값의 <see cref="T:System.Type" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-293">The <see cref="T:System.Type" /> of the property value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-294">이 속성을 통해 원래 속성 등록에서 선언 된 속성의 값 형식을 보고 합니다 `propertyType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-294">This property reports the type of the property's value as declared by the original property registration, through the `propertyType` parameter.</span></span> <span data-ttu-id="b3c0a-295">비슷합니다는 <xref:System.Windows.DependencyProperty.Name%2A>, 등록 후 종속성 속성의 속성 형식을 변경할 수 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-295">Similar to the <xref:System.Windows.DependencyProperty.Name%2A>, the property type of a dependency property is immutable after registration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-296">다음 예제 쿼리는 종속성 속성 식별자의 다양 한 특성 등을 <xref:System.Windows.DependencyProperty.PropertyType%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-296">The following example queries various characteristics of a dependency property identifier, including the <xref:System.Windows.DependencyProperty.PropertyType%2A>.</span></span> <span data-ttu-id="b3c0a-297">형식 이름 문자열을 <xref:System.Windows.DependencyProperty.PropertyType%2A> 가져온에서 반환 된 <xref:System.Type>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-297">The type name string of the <xref:System.Windows.DependencyProperty.PropertyType%2A> is obtained from the returned <xref:System.Type>.</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-298">이 <see cref="T:System.Windows.DependencyProperty" /> 인스턴스로 식별되는 종속성 속성이 읽기 전용 종속성 속성인지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-298">Gets a value that indicates whether the dependency property identified by this <see cref="T:System.Windows.DependencyProperty" /> instance is a read-only dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3c0a-299">종속성 속성이 읽기 전용이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-299">
              <see langword="true" /> if the dependency property is read-only; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-300">속성 시스템 내에서 호출 하 여 읽기 전용 종속성 속성을 등록 합니다 <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> 메서드가 아닌는 <xref:System.Windows.DependencyProperty.Register%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-300">Read-only dependency properties are registered within the property system by calling the <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> method as opposed to the <xref:System.Windows.DependencyProperty.Register%2A> method.</span></span> <span data-ttu-id="b3c0a-301">연결 된 속성 읽기 전용으로 등록할 수 있습니다. 참조 <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-301">Attached properties can also be registered as read-only; see <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</span></span>  
  
 <span data-ttu-id="b3c0a-302">읽기 전용 종속성 속성에는 필요는 <xref:System.Windows.DependencyPropertyKey> 식별자 대신 <xref:System.Windows.DependencyProperty> 메타 데이터 재정의 값을 설정 등의 메타 데이터 작업을 수행 하는 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-302">Read-only dependency properties require a <xref:System.Windows.DependencyPropertyKey> identifier rather than a <xref:System.Windows.DependencyProperty> identifier to perform metadata operations such as overriding the metadata or setting the value.</span></span> <span data-ttu-id="b3c0a-303">컬렉션을 가져온 경우 <xref:System.Windows.DependencyProperty> 호출을 통해 식별자 <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> 또는 다른 [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] 검사 식별자를 노출 하는 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 호출 하기 전에 값 <xref:System.Windows.DependencyObject.SetValue%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 는 사용 하 여 종속성 속성 식별자를 나타내는 읽기 전용이 아닌지 확인 하는 입력 매개 변수 종속성 속성 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-303">If you obtained a collection of <xref:System.Windows.DependencyProperty> identifiers through a call to <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> or another [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] that exposes identifiers, check the <xref:System.Windows.DependencyProperty.ReadOnly%2A> value before attempting to call <xref:System.Windows.DependencyObject.SetValue%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> using that dependency property identifier as an input parameter, to verify that the dependency property that the identifier represents is not read-only.</span></span> <span data-ttu-id="b3c0a-304">경우 값 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 됩니다 `true` 종속성 속성은 프로그래밍 방식에 대 한 참조를 가져올 수 없습니다는 <xref:System.Windows.DependencyPropertyKey> 메타 데이터에서 또는 해당 종속성 속성의 식별자는 <xref:System.Windows.DependencyProperty> 식별자; 식별자 호출 하려면 정적 필드로 사용할 수 있어야 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> 읽기 전용 종속성 속성에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-304">If the value of <xref:System.Windows.DependencyProperty.ReadOnly%2A> is `true` on a dependency property, there is no programmatic way to obtain a reference to the <xref:System.Windows.DependencyPropertyKey> identifier of that dependency property, from the metadata or from the <xref:System.Windows.DependencyProperty> identifier; the identifier must be available as a static field in order to call <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> against a read-only dependency property.</span></span>  
  
 <span data-ttu-id="b3c0a-305">사용자 지정 종속성 속성을 만들고 읽기 전용으로 등록할 때에 대 한 get 접근자만 정의 해야 합니다 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 래퍼 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-305">When you create a custom dependency property, and register it as read-only, you should define only a get accessor for the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper property.</span></span> <span data-ttu-id="b3c0a-306">그렇지 않으면 클래스 백업 종속성 속성에 대 한 액세스를 비교 하 여 속성 래퍼에 대 한 혼동을 줄 개체 모델을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-306">Otherwise, your class will have a confusing object model for the property wrapper as compared to the access to the backing dependency property.</span></span> <span data-ttu-id="b3c0a-307">자세한 내용은 참조 하세요 [사용자 지정 종속성 속성](~/docs/framework/wpf/advanced/custom-dependency-properties.md) 하거나 [읽기 전용 종속성 속성](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-307">For details, see [Custom Dependency Properties](~/docs/framework/wpf/advanced/custom-dependency-properties.md) or [Read-Only Dependency Properties](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-308">다음 예제에서는 다양 한 종속성 속성 필드에서 기본 메타 데이터 및 종속성 속성 식별자 속성을 가져옵니다 하 고 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-308">The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-309">종속성 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-309">Registers a dependency property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b3c0a-310">등록할 종속성 속성의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-310">The name of the dependency property to register.</span>
          </span>
          <span data-ttu-id="b3c0a-311">이름은은 소유자 형식의 등록 네임스페이스 내에서 고유해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-311">The name must be unique within the registration namespace of the owner type.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="b3c0a-312">속성의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-312">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-313">종속성 속성을 등록하는 소유자 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-313">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-314">지정된 속성 이름, 속성 형식 및 소유자 유형을 사용하여 종속성 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-314">Registers a dependency property with the specified property name, property type, and owner type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-315">클래스에서 <see langword="public static readonly" /> 필드 값을 설정하기 위해 사용해야 하는 종속성 속성 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-315">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="b3c0a-316">해당 식별자는 나중에 해당 값을 프로그래밍 방식으로 설정하거나 메타데이터를 가져오는 등의 작업에서 종속성 속성을 참조하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-316">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-317">종속성 속성 등록에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-317">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b3c0a-318">등록할 종속성 속성의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-318">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="b3c0a-319">속성의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-319">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-320">종속성 속성을 등록하는 소유자 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-320">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="b3c0a-321">종속성 속성의 속성 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-321">Property metadata for the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-322">지정된 속성 이름, 속성 형식, 소유자 유형 및 속성 메타데이터를 사용하여 종속성 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-322">Registers a dependency property with the specified property name, property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-323">클래스에서 <see langword="public static readonly" /> 필드 값을 설정하기 위해 사용해야 하는 종속성 속성 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-323">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="b3c0a-324">해당 식별자는 나중에 해당 값을 프로그래밍 방식으로 설정하거나 메타데이터를 가져오는 등의 작업에서 종속성 속성을 참조하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-324">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-325">종속성 속성 등록에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-325">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b3c0a-326">등록할 종속성 속성의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-326">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="b3c0a-327">속성의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-327">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-328">종속성 속성을 등록하는 소유자 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-328">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="b3c0a-329">종속성 속성의 속성 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-329">Property metadata for the dependency property.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="b3c0a-330">일반적인 형식 유효성 검사 이외에 종속성 속성 값의 사용자 지정 유효성 검사를 수행하는 콜백에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-330">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-331">속성에 대해 지정된 속성 이름, 속성 형식, 소유자 유형, 속성 메타데이터 및 값 유효성 검사 콜백을 사용하여 종속성 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-331">Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-332">클래스에서 <see langword="public static readonly" /> 필드 값을 설정하기 위해 사용해야 하는 종속성 속성 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-332">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="b3c0a-333">해당 식별자는 나중에 해당 값을 프로그래밍 방식으로 설정하거나 메타데이터를 가져오는 등의 작업에서 종속성 속성을 참조하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-333">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-334">종속성 속성 등록에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-334">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-335">다음 예에서는 유효성 검사 콜백을 포함 하 여 종속성 속성을 등록 (콜백 정의 표시 되지 않으면 콜백 정의에 대 한 세부 정보를 참조 하세요. <xref:System.Windows.ValidateValueCallback>).</span><span class="sxs-lookup"><span data-stu-id="b3c0a-335">The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-336">속성 시스템에 연결된 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-336">Registers an attached property with the property system.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b3c0a-337">등록할 종속성 속성의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-337">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="b3c0a-338">속성의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-338">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-339">종속성 속성을 등록하는 소유자 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-339">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-340">지정된 속성 이름, 속성 형식 및 소유자 유형을 사용하여 연결된 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-340">Registers an attached property with the specified property name, property type, and owner type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-341">클래스에서 <see langword="public static readonly" /> 필드 값을 설정하기 위해 사용해야 하는 종속성 속성 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-341">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="b3c0a-342">해당 식별자는 나중에 해당 값을 프로그래밍 방식으로 설정하거나 메타데이터를 가져오는 등의 작업에서 종속성 속성을 참조하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-342">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-343">연결된 된 속성으로 정의 된 속성 개념은 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-343">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b3c0a-344">종속성 속성으로 연결 된 속성을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-344"> implements attached properties as dependency properties.</span></span> <span data-ttu-id="b3c0a-345">때문에 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 연결 된 속성은 종속성 속성, 레이아웃 특성을 보고 하는 등의 작업에 대 한 일반 속성 시스템에서 사용할 수 있는 메타 데이터가 적용 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-345">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="b3c0a-346">자세한 내용은 [연결된 속성 개요](~/docs/framework/wpf/advanced/attached-properties-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-346">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="b3c0a-347">종속성 속성 등록에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-347">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-348">다음 예제에서는이 사용 하 여 추상 클래스에 연결된 된 속성 등록 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 서명 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-348">The following example registers an attached property on an abstract class using this <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b3c0a-349">등록할 종속성 속성의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-349">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="b3c0a-350">속성의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-350">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-351">종속성 속성을 등록하는 소유자 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-351">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="b3c0a-352">종속성 속성의 속성 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-352">Property metadata for the dependency property.</span>
          </span>
          <span data-ttu-id="b3c0a-353">여기에는 기본값뿐만 아니라 다른 특성도 포함될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-353">This can include the default value as well as other characteristics.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-354">지정된 속성 이름, 속성 형식, 소유자 유형 및 속성 메타데이터에 연결된 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-354">Registers an attached property with the specified property name, property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-355">클래스에서 <see langword="public static readonly" /> 필드 값을 설정하기 위해 사용해야 하는 종속성 속성 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-355">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="b3c0a-356">해당 식별자는 나중에 해당 값을 프로그래밍 방식으로 설정하거나 메타데이터를 가져오는 등의 작업에서 종속성 속성을 참조하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-356">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-357">연결된 된 속성으로 정의 된 속성 개념은 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-357">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b3c0a-358">종속성 속성으로 연결 된 속성을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-358"> implements attached properties as dependency properties.</span></span> <span data-ttu-id="b3c0a-359">때문에 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 연결 된 속성은 종속성 속성, 레이아웃 특성을 보고 하는 등의 작업에 대 한 일반 속성 시스템에서 사용할 수 있는 메타 데이터가 적용 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-359">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="b3c0a-360">자세한 내용은 [연결된 속성 개요](~/docs/framework/wpf/advanced/attached-properties-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-360">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="b3c0a-361">종속성 속성 등록에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-361">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="b3c0a-362">종속성 속성 값 상속을 사용 하 여 RegisterAttached</span><span class="sxs-lookup"><span data-stu-id="b3c0a-362">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="b3c0a-363">특정 시나리오 중 하나 사용 하 여 종속성 속성을 등록할 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 대신 <xref:System.Windows.DependencyProperty.Register%2A> 속성 값 상속을 지원 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-363">One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="b3c0a-364">사용 하 여 종속성 속성 값 상속을 등록 해야 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 클래스는 종속성 속성을 노출 하는 속성 래퍼 접근자를 정의 하는 경우에 및 숨기지 않으려면 제공 하는 Get \* 및 집합 \* 정적 메서드를 노출 하려면 true를 연결 하는 경우에 접근자 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-364">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="b3c0a-365">속성 값 상속은 연결 되지 않은 종속성 속성에 대 한 작업에 표시 될 수 있지만 런타임 트리의 특정 요소 경계를 통해 연결 되지 않은 속성에 대 한 상속 동작은 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-365">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="b3c0a-366">효과적으로 연결 속성을 등록 속성 시스템에 연결된 된 속성이 전역 속성으로 설정 및 속성 값 상속은 요소 트리에서 모든 경계에 걸쳐 작동 하는 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-366">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="b3c0a-367">항상 사용 하 여 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 지정 하는 속성을 등록 하려면 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 메타 데이터에서입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-367">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="b3c0a-368">자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-368">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b3c0a-369">등록할 종속성 속성의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-369">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="b3c0a-370">속성의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-370">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-371">종속성 속성을 등록하는 소유자 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-371">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="b3c0a-372">종속성 속성의 속성 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-372">Property metadata for the dependency property.</span>
          </span>
          <span data-ttu-id="b3c0a-373">여기에는 기본값뿐만 아니라 다른 특성도 포함될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-373">This can include the default value as well as other characteristics.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="b3c0a-374">일반적인 형식 유효성 검사 이외에 종속성 속성 값의 사용자 지정 유효성 검사를 수행하는 콜백에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-374">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-375">속성에 대해 지정된 속성 형식, 소유자 유형, 속성 메타데이터 및 값 유효성 검사 콜백에 연결된 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-375">Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-376">클래스에서 <see langword="public static readonly" /> 필드 값을 설정하기 위해 사용해야 하는 종속성 속성 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-376">A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class.</span>
          </span>
          <span data-ttu-id="b3c0a-377">해당 식별자는 나중에 해당 값을 프로그래밍 방식으로 설정하거나 메타데이터를 가져오는 등의 작업에서 종속성 속성을 참조하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-377">That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-378">연결된 된 속성으로 정의 된 속성 개념은 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-378">An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b3c0a-379">종속성 속성으로 연결 된 속성을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-379"> implements attached properties as dependency properties.</span></span> <span data-ttu-id="b3c0a-380">때문에 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 연결 된 속성은 종속성 속성, 레이아웃 특성을 보고 하는 등의 작업에 대 한 일반 속성 시스템에서 사용할 수 있는 메타 데이터가 적용 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-380">Because the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</span></span> <span data-ttu-id="b3c0a-381">자세한 내용은 [연결된 속성 개요](~/docs/framework/wpf/advanced/attached-properties-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-381">For more information, see [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="b3c0a-382">종속성 속성 등록에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-382">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="b3c0a-383">종속성 속성 값 상속을 사용 하 여 RegisterAttached</span><span class="sxs-lookup"><span data-stu-id="b3c0a-383">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="b3c0a-384">특정 시나리오 중 하나 사용 하 여 종속성 속성을 등록할 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 대신 <xref:System.Windows.DependencyProperty.Register%2A> 속성 값 상속을 지원 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-384">One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="b3c0a-385">사용 하 여 종속성 속성 값 상속을 등록 해야 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 클래스는 종속성 속성을 노출 하는 속성 래퍼 접근자를 정의 하는 경우에 및 숨기지 않으려면 제공 하는 Get \* 및 집합 \* 정적 메서드를 노출 하려면 true를 연결 하는 경우에 접근자 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-385">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="b3c0a-386">속성 값 상속은 연결 되지 않은 종속성 속성에 대 한 작업에 표시 될 수 있지만 런타임 트리의 특정 요소 경계를 통해 연결 되지 않은 속성에 대 한 상속 동작은 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-386">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="b3c0a-387">효과적으로 연결 속성을 등록 속성 시스템에 연결된 된 속성이 전역 속성으로 설정 및 속성 값 상속은 요소 트리에서 모든 경계에 걸쳐 작동 하는 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-387">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="b3c0a-388">항상 사용 하 여 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 지정 하는 속성을 등록 하려면 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 메타 데이터에서입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-388">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="b3c0a-389">자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-389">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-390">다음 예제에서는이 사용 하 여 추상 클래스에 연결된 된 속성 등록 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 서명 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-390">The following example registers an attached property on an abstract class using this <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature.</span></span> <span data-ttu-id="b3c0a-391">이 연결 된 속성에는 열거 형식 속성은 및 등록 과정에서 제공 된 값이 열거형의 값 임을 확인 하려면 유효성 검사 콜백을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-391">This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-392">읽기 전용 연결된 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-392">Registers a read-only attached property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b3c0a-393">등록할 종속성 속성의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-393">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="b3c0a-394">속성의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-394">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-395">종속성 속성을 등록하는 소유자 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-395">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="b3c0a-396">종속성 속성의 속성 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-396">Property metadata for the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-397">지정된 속성 형식, 소유자 유형 및 속성 메타데이터를 사용하여 읽기 전용 연결된 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-397">Registers a read-only attached property, with the specified property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-398">클래스의 정적 읽기 전용 필드 값을 설정하는 데 사용할 종속성 속성 키로, 나중에 종속성 속성을 참조하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-398">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-399">이 메서드는 형식을 반환 <xref:System.Windows.DependencyPropertyKey>반면 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 형식을 반환 <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-399">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="b3c0a-400">일반적으로 읽기 전용 속성을 나타내는 키 되지 공용를 호출 하 여 종속성 속성 값을 설정 하는 키를 사용할 수 있으므로 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-400">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="b3c0a-401">클래스 디자인 요구 사항에 영향이 있지만의 표시 유형 확인 하 고 액세스를 제한 하려면 일반적으로 좋습니다 <xref:System.Windows.DependencyPropertyKey> 클래스 또는 응용 프로그램 논리의 일부로 종속성 속성을 설정 하는 데 필요한 코드의 부분에 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-401">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="b3c0a-402">값을 노출 하 여 읽기 전용 종속성 속성에 대 한 종속성 속성 식별자를 노출 하는 것이 좋습니다 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> 으로 `public static readonly` 클래스에 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-402">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="b3c0a-403">연결된 된 속성에 대 한 기본 시나리오에서 사용 하는 중 이므로 읽기 전용으로 연결 된 속성은 드문 경우 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-403">Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="b3c0a-404">Public setter를 하지 않고 연결된 된 속성에 설정할 수 없습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-404">Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="b3c0a-405">종속성 속성 등록에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-405">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="b3c0a-406">종속성 속성 값 상속을 사용 하 여 RegisterAttached</span><span class="sxs-lookup"><span data-stu-id="b3c0a-406">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="b3c0a-407">종속성 속성으로 등록 하는 데 하나의 특정 시나리오는 연결 된 속성 값 상속을 지원입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-407">One particular scenario for registering a dependency property as attached is to support property value inheritance.</span></span> <span data-ttu-id="b3c0a-408">사용 하 여 종속성 속성 값 상속을 등록 해야 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 클래스는 종속성 속성을 노출 하는 속성 래퍼 접근자를 정의 하는 경우에 및 숨기지 않으려면 제공 하는 Get \* 및 집합 \* 정적 메서드를 노출 하려면 true를 연결 하는 경우에 접근자 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-408">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="b3c0a-409">속성 값 상속은 연결 되지 않은 종속성 속성에 대 한 작업에 표시 될 수 있지만 런타임 트리의 특정 요소 경계를 통해 연결 되지 않은 속성에 대 한 상속 동작은 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-409">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="b3c0a-410">효과적으로 연결 속성을 등록 속성 시스템에 연결된 된 속성이 전역 속성으로 설정 및 속성 값 상속은 요소 트리에서 모든 경계에 걸쳐 작동 하는 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-410">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="b3c0a-411">항상 사용 하 여 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 지정 하는 속성을 등록 하려면 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 메타 데이터에서입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-411">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="b3c0a-412">자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-412">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b3c0a-413">등록할 종속성 속성의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-413">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="b3c0a-414">속성의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-414">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-415">종속성 속성을 등록하는 소유자 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-415">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="defaultMetadata">
          <span data-ttu-id="b3c0a-416">종속성 속성의 속성 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-416">Property metadata for the dependency property.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="b3c0a-417">일반적인 형식 유효성 검사 이외에 종속성 속성 값의 사용자 지정 유효성 검사를 수행하는 사용자가 만든 콜백에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-417">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-418">지정된 속성 형식, 소유자 유형, 속성 메타데이터 및 유효성 검사 콜백을 사용하여 읽기 전용 연결된 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-418">Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-419">클래스의 정적 읽기 전용 필드 값을 설정하는 데 사용할 종속성 속성 키로, 나중에 종속성 속성을 참조하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-419">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-420">이 메서드는 형식을 반환 <xref:System.Windows.DependencyPropertyKey>반면 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 형식을 반환 <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-420">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="b3c0a-421">키 형식을 나타내는 일반적으로 <xref:System.Windows.DependencyProperty>입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-421">Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="b3c0a-422">일반적으로 읽기 전용 속성을 나타내는 키 되지 공용를 호출 하 여 종속성 속성 값을 설정 하는 키를 사용할 수 있으므로 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-422">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="b3c0a-423">클래스 디자인 요구 사항에 영향이 있지만의 표시 유형 확인 하 고 액세스를 제한 하려면 일반적으로 좋습니다 <xref:System.Windows.DependencyPropertyKey> 클래스 또는 응용 프로그램 논리의 일부로 종속성 속성을 설정 하는 데 필요한 코드의 부분에 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-423">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="b3c0a-424">값을 노출 하 여 읽기 전용 종속성 속성에 대 한 종속성 속성 식별자를 노출 하는 것이 좋습니다 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> 으로 `public static readonly` 클래스에 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-424">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="b3c0a-425">연결된 된 속성에 대 한 기본 시나리오에서 사용 하는 중 이므로 읽기 전용으로 연결 된 속성은 드문 경우 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-425">Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="b3c0a-426">Public setter를 하지 않고 연결된 된 속성에 설정할 수 없습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-426">Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="b3c0a-427">종속성 속성 등록에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-427">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a><span data-ttu-id="b3c0a-428">종속성 속성 값 상속을 사용 하 여 RegisterAttached</span><span class="sxs-lookup"><span data-stu-id="b3c0a-428">Use RegisterAttached for Value-inheriting Dependency Properties</span></span>  
 <span data-ttu-id="b3c0a-429">대신 연결 된 종속성 속성 등록에 대 한 한 가지 특정 시나리오 <xref:System.Windows.DependencyProperty.Register%2A> 속성 값 상속을 지원 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-429">One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance.</span></span> <span data-ttu-id="b3c0a-430">사용 하 여 종속성 속성 값 상속을 등록 해야 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 클래스는 종속성 속성을 노출 하는 속성 래퍼 접근자를 정의 하는 경우에 및 숨기지 않으려면 제공 하는 Get \* 및 집합 \* 정적 메서드를 노출 하려면 true를 연결 하는 경우에 접근자 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-430">You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get\* and Set\* static methods to provide true attached property support accessors.</span></span>   <span data-ttu-id="b3c0a-431">속성 값 상속은 연결 되지 않은 종속성 속성에 대 한 작업에 표시 될 수 있지만 런타임 트리의 특정 요소 경계를 통해 연결 되지 않은 속성에 대 한 상속 동작은 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-431">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</span></span> <span data-ttu-id="b3c0a-432">효과적으로 연결 속성을 등록 속성 시스템에 연결된 된 속성이 전역 속성으로 설정 및 속성 값 상속은 요소 트리에서 모든 경계에 걸쳐 작동 하는 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-432">Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</span></span> <span data-ttu-id="b3c0a-433">항상 사용 하 여 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 지정 하는 속성을 등록 하려면 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 메타 데이터에서입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-433">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span> <span data-ttu-id="b3c0a-434">자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-434">For more information, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-435">종속성 속성을 읽기 전용 종속성 속성으로 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-435">Registers a dependency property as a read-only dependency property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b3c0a-436">등록할 종속성 속성의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-436">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="b3c0a-437">속성의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-437">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-438">종속성 속성을 등록하는 소유자 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-438">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="b3c0a-439">종속성 속성의 속성 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-439">Property metadata for the dependency property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-440">지정된 속성 형식, 소유자 유형 및 속성 메타데이터를 사용하여 읽기 전용 종속성 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-440">Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-441">클래스의 정적 읽기 전용 필드 값을 설정하는 데 사용할 종속성 속성 키로, 나중에 종속성 속성을 참조하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-441">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-442">이 메서드는 형식을 반환 <xref:System.Windows.DependencyPropertyKey>반면 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 형식을 반환 <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-442">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="b3c0a-443">일반적으로 읽기 전용 속성을 나타내는 키 되지 공용를 호출 하 여 종속성 속성 값을 설정 하는 키를 사용할 수 있으므로 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-443">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="b3c0a-444">클래스 디자인 요구 사항에 영향이 있지만의 표시 유형 확인 하 고 액세스를 제한 하려면 일반적으로 좋습니다 <xref:System.Windows.DependencyPropertyKey> 클래스 또는 응용 프로그램 논리의 일부로 종속성 속성을 설정 하는 데 필요한 코드의 부분에 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-444">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="b3c0a-445">값을 노출 하 여 읽기 전용 종속성 속성에 대 한 종속성 속성 식별자를 노출 하는 것이 좋습니다 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> 으로 `public static readonly` 클래스에 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-445">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="b3c0a-446">읽기 전용 종속성 속성은 매우 일반적인 시나리오는 모두 기존 [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] 및 사용자 지정 시나리오를 때문에 다른 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 기능 속성으로 설정할 수 없는 경우에 종속성 속성을 필요할 수 있습니다 호출자입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-446">Read-only dependency properties are a fairly typical scenario both in the existing [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] and for customization scenarios, because other [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] features might require a dependency property even if that property is not intended to be settable by callers.</span></span> <span data-ttu-id="b3c0a-447">데이터베이스나 같은 종속성 속성을 사용 하는 다른 속성 시스템 작업에 대 한 기준으로 읽기 전용 종속성 속성의 값을 사용할 수 있습니다는 <xref:System.Windows.Trigger> 스타일의 종속성 속성에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-447">You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <xref:System.Windows.Trigger> on the dependency property in a style.</span></span>  
  
 <span data-ttu-id="b3c0a-448">종속성 속성 등록에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-448">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b3c0a-449">다음 예에서는 등록을 `AquariumSize` 읽기 전용 종속성 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-449">The following example registers an `AquariumSize` dependency property as read-only.</span></span> <span data-ttu-id="b3c0a-450">이 예제에서는 정의 `AquariumSizeKey` 내부 키 (따라서 다른 어셈블리의 클래스는 메타 데이터 재정의 될 수 있습니다) 및 종속성 속성 식별자와 해당 키에 따라 노출 `AquariumSizeProperty`합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-450">The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`.</span></span> <span data-ttu-id="b3c0a-451">또한 래퍼 만들어집니다 `AquariumSize`, get 접근자만 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-451">Also, a wrapper is created for `AquariumSize`, with only a get accessor.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b3c0a-452">등록할 종속성 속성의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-452">The name of the dependency property to register.</span>
          </span>
        </param>
        <param name="propertyType">
          <span data-ttu-id="b3c0a-453">속성의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-453">The type of the property.</span>
          </span>
        </param>
        <param name="ownerType">
          <span data-ttu-id="b3c0a-454">종속성 속성을 등록하는 소유자 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-454">The owner type that is registering the dependency property.</span>
          </span>
        </param>
        <param name="typeMetadata">
          <span data-ttu-id="b3c0a-455">종속성 속성의 속성 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-455">Property metadata for the dependency property.</span>
          </span>
        </param>
        <param name="validateValueCallback">
          <span data-ttu-id="b3c0a-456">일반적인 형식 유효성 검사 이외에 종속성 속성 값의 사용자 지정 유효성 검사를 수행하는 사용자가 만든 콜백에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-456">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b3c0a-457">지정된 속성 형식, 소유자 유형, 속성 메타데이터 및 유효성 검사 콜백을 사용하여 읽기 전용 종속성 속성을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-457">Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-458">클래스의 정적 읽기 전용 필드 값을 설정하는 데 사용할 종속성 속성 키로, 나중에 종속성 속성을 참조하는 데 사용됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-458">A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-459">이 메서드는 형식을 반환 <xref:System.Windows.DependencyPropertyKey>반면 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 형식을 반환 <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-459">This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="b3c0a-460">일반적으로 읽기 전용 속성을 나타내는 키 되지 공용를 호출 하 여 종속성 속성 값을 설정 하는 키를 사용할 수 있으므로 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-460">Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</span></span> <span data-ttu-id="b3c0a-461">클래스 디자인 요구 사항에 영향이 있지만의 표시 유형 확인 하 고 액세스를 제한 하려면 일반적으로 좋습니다 <xref:System.Windows.DependencyPropertyKey> 클래스 또는 응용 프로그램 논리의 일부로 종속성 속성을 설정 하는 데 필요한 코드의 부분에 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-461">Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</span></span> <span data-ttu-id="b3c0a-462">값을 노출 하 여 읽기 전용 종속성 속성에 대 한 종속성 속성 식별자를 노출 하는 것이 좋습니다 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> 으로 `public static readonly` 클래스에 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-462">It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> as a `public static readonly` field on your class.</span></span>  
  
 <span data-ttu-id="b3c0a-463">읽기 전용 종속성 속성은 매우 일반적인 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-463">Read-only dependency properties are a fairly typical scenario.</span></span> <span data-ttu-id="b3c0a-464">데이터베이스나 같은 종속성 속성을 사용 하는 다른 속성 시스템 작업에 대 한 기준으로 읽기 전용 종속성 속성의 값을 사용할 수 있습니다는 <xref:System.Windows.Trigger> 스타일의 종속성 속성에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-464">You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <xref:System.Windows.Trigger> on the dependency property in a style.</span></span>  
  
 <span data-ttu-id="b3c0a-465">종속성 속성 등록에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-465">For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.</span></span>  
  
 <span data-ttu-id="b3c0a-466">읽기 전용 종속성 속성에 대 한 유효성 검사는 덜 중요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-466">Validation on a read-only dependency property might be less important.</span></span> <span data-ttu-id="b3c0a-467">키 지정 public이 아닌 액세스 수준 임의의 잘못 된 입력에 대 한 가능성을 줄여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-467">The nonpublic access level you specify for the key reduces the likelihood for arbitrary invalid input.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-468">종속성 속성의 문자열 표현을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-468">Returns the string representation of the dependency property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b3c0a-469">종속성 속성의 문자열 표현입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-469">The string representation of the dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-470">이 구현은 반환 된 <xref:System.Windows.DependencyProperty.Name%2A> 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-470">This implementation returns the <xref:System.Windows.DependencyProperty.Name%2A> property value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-471">속성이 있지만 속성 시스템에 의해 값이 설정되지 않았음을 나타내기 위해 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 속성 시스템에서 <see langword="null" /> 대신 사용하는 정적 값을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-471">Specifies a static value that is used by the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system rather than <see langword="null" /> to indicate that the property exists, but does not have its value set by the property system.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-472"><xref:System.Windows.DependencyProperty.UnsetValue> 시나리오에 사용 되는 sentinel 값 위치를 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 속성 시스템에서 요청 된 결정할 수 없는 <xref:System.Windows.DependencyProperty> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-472"><xref:System.Windows.DependencyProperty.UnsetValue> is a sentinel value that is used for scenarios where the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system is unable to determine a requested <xref:System.Windows.DependencyProperty> value.</span></span> <span data-ttu-id="b3c0a-473"><xref:System.Windows.DependencyProperty.UnsetValue> 대신 `null`이므로 `null` 유효한 속성 값 뿐만 아니라 유효한 일 수 있습니다 (및 자주 사용 되는) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-473"><xref:System.Windows.DependencyProperty.UnsetValue> is used rather than `null`, because `null` could be a valid property value, as well as a valid (and frequently used) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</span></span>  
  
 <span data-ttu-id="b3c0a-474"><xref:System.Windows.DependencyProperty.UnsetValue> 반환 되지 않습니다 <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-474"><xref:System.Windows.DependencyProperty.UnsetValue> is never returned out of <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b3c0a-475">호출 하는 경우 <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> 에서 종속성 속성에 대 한 <xref:System.Windows.DependencyObject> 인스턴스를 다음 중 하나가 적용:</span><span class="sxs-lookup"><span data-stu-id="b3c0a-475">When you call <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> on a dependency property on a <xref:System.Windows.DependencyObject> instance, one of the following applies:</span></span>  
  
-   <span data-ttu-id="b3c0a-476">종속성 속성 메타 데이터에서 설정 된 기본 값이 고 해당 값이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-476">A dependency property has a default value established in metadata and that value is returned.</span></span> <span data-ttu-id="b3c0a-477">이 값에서 가져올 수 있습니다 <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-477">This value might come from <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</span></span>  
  
-   <span data-ttu-id="b3c0a-478">속성 시스템에 의해 설정 된 다른 값 및 기본값은 더 이상 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-478">Some other value was established by the property system, and the default value is no longer relevant.</span></span> <span data-ttu-id="b3c0a-479">자세한 내용은 [종속성 속성 값 우선 순위](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-479">For details, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 <span data-ttu-id="b3c0a-480">설정 된 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 의 <xref:System.Windows.DependencyProperty.UnsetValue> 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-480">Setting a <xref:System.Windows.PropertyMetadata.DefaultValue%2A> of <xref:System.Windows.DependencyProperty.UnsetValue> is specifically disallowed.</span></span>  
  
 <span data-ttu-id="b3c0a-481"><xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> 반환 <xref:System.Windows.DependencyProperty.UnsetValue> 때 요청된 된 속성이 설정 되지 않은 로컬입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-481"><xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> returns <xref:System.Windows.DependencyProperty.UnsetValue> when the requested property has not been locally set.</span></span>  
  
 <span data-ttu-id="b3c0a-482"><xref:System.Windows.DependencyProperty.UnsetValue> 반환 값으로 사용 되는 특별 한 의미를 <xref:System.Windows.CoerceValueCallback>입니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-482"><xref:System.Windows.DependencyProperty.UnsetValue> has a special meaning when used as the return value of a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="b3c0a-483">자세한 내용은 참조 하세요 [종속성 속성 콜백 및 유효성 검사](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-483">For details, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
 <span data-ttu-id="b3c0a-484">데이터베이스에 바인딩하는 경우 유의 <xref:System.Windows.DependencyProperty.UnsetValue> 동일 하지 않습니다 <xref:System.DBNull.Value>에 비슷한 방식으로 <xref:System.DBNull.Value> 는 동일 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-484">If you are binding to a database, note that <xref:System.Windows.DependencyProperty.UnsetValue> is not equivalent to <xref:System.DBNull.Value>, in a similar way to how <xref:System.DBNull.Value> is not equivalent to a true null.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b3c0a-485">종속성 속성의 값 유효성 검사 콜백을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-485">Gets the value validation callback for the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b3c0a-486">이 종속성 속성을 원래 등록할 때 <paramref name="validateValueCallback" /> 매개 변수로 제공된 값 유효성 검사 콜백입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b3c0a-486">The value validation callback for this dependency property, as provided for the <paramref name="validateValueCallback" /> parameter in the original dependency property registration.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b3c0a-487">이 속성에 포함 됩니다 `null` 없습니다 등록 된 유효성 검사 콜백 사용 하 여 모든 종속성 속성에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-487">This property will contain `null` for any dependency property with no registered validation callback.</span></span>  
  
 <span data-ttu-id="b3c0a-488">정적 방식으로 작동 해야 하는 값의 유효성을 검사: 유효성 검사를 통해 적용 된 <xref:System.Windows.ValidateValueCallback> 제공 된 값이 특정 인스턴스가 유효한 지 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-488">Validate value callbacks must act in a static sense: validation applied through the <xref:System.Windows.ValidateValueCallback> cannot determine whether the provided value is valid for any particular instance.</span></span> <span data-ttu-id="b3c0a-489">콜백은은 종속성 속성을 소유한 모든 개체는 유효한 것으로 제공 된 값을 받아들이지 않아야 하는지 여부에 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-489">The callback can only determine whether all objects that possess the dependency property should or should not accept the provided value as valid.</span></span> <span data-ttu-id="b3c0a-490">특정 인스턴스에서 사용 하 여 다른 종속성 속성의 값에 의존 하는 유효성 검사를 수행 해야 할 경우는 <xref:System.Windows.CoerceValueCallback> 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-490">If you need to perform validation that relies on knowing the values of other dependency properties on a particular instance, use a <xref:System.Windows.CoerceValueCallback> instead.</span></span> <span data-ttu-id="b3c0a-491"><xref:System.Windows.CoerceValueCallback> 종속성 속성 식별자 내에서 직접이 아닌 종속성 속성 메타 데이터의 일부로 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-491">The <xref:System.Windows.CoerceValueCallback> is registered as part of dependency property metadata, rather than directly within the dependency property identifier.</span></span> <span data-ttu-id="b3c0a-492">자세한 내용은 참조 하세요 [종속성 속성 콜백 및 유효성 검사](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b3c0a-492">For details, see [Dependency Property Callbacks and Validation](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>