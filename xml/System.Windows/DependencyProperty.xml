<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="de09d337e79e341ade969dc527e1b9b6c0b3d7c6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36461426" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.DependencyProperty> 의 다음 기능을 지 원하는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   스타일에서 속성을 설정할 수 있습니다. 자세한 내용은 [스타일 지정 및 템플릿](~/docs/framework/wpf/controls/styling-and-templating.md)을 참조하세요.  
  
-   데이터 바인딩을 통해 속성을 설정할 수 있습니다. 데이터 바인딩 종속성 속성에 대 한 자세한 내용은 참조 [하는 방법: 두 컨트롤 속성을 바인딩할](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)합니다.  
  
-   동적 리소스 참조와 속성을 설정할 수 있습니다. 자세한 내용은 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)를 참조하세요.  
  
-   속성 요소 트리의 부모 요소 로부터 자동으로 해당 값을 상속할 수 있습니다. 자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.  
  
-   속성에 애니메이션을 적용할 수 있습니다. 자세한 내용은 [애니메이션 개요](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)를 참조하세요.  
  
-   속성은 속성의 이전 값을 변경 했으며 새로 속성 값을 강제 변환할 수 있는 경우 보고할 수 있습니다. 자세한 내용은 [종속성 속성 콜백 및 유효성 검사](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)를 참조하세요.  
  
-   속성에 대 한 정보를 보고 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]여부 속성 값을 변경 해야 요소에 대 한 시각적 개체를 다시 구성 하기 위해이 레이아웃 시스템 등입니다.  
  
-   속성에서 지원을 받습니다는 [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]합니다.  속성에서 편집할 수는 예를 들어는 **속성** 창.  
  
 종속성 속성에 대 한 자세한 참조 [종속성 속성 개요](~/docs/framework/wpf/advanced/dependency-properties-overview.md)합니다. 앞의 목록에 기능을 지원 하도록 사용자 지정 형식에서 속성을 원하는 경우에 종속성 속성을 만들어야 합니다.  사용자 지정 종속성 속성을 만드는 방법을 알아보려면 참조 [종속성 속성을 사용자 지정](~/docs/framework/wpf/advanced/custom-dependency-properties.md)합니다.  
  
 연결된 된 속성은 모든 개체에 연결 된 속성을 정의 하는 형식 정보를 보고할 수 있도록 하는 속성입니다. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]에서 상속 된 모든 형식을 <xref:System.Windows.DependencyObject> 속성을 정의 하는 형식에서 상속 하는지 여부에 관계 없이 연결된 된 속성을 사용할 수 있습니다. 연결된 된 속성의 기능은 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 언어입니다.  연결된 된 속성을 설정 하려면 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]를 사용 하 여는 *ownerType*.* propertyName* 구문입니다. 연결된 된 속성의 예로 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 속성입니다. 모든에서 사용할 수 있는 속성을 만들려면 원하는 <xref:System.Windows.DependencyObject> 형식, 연결된 된 속성을 만들어야 합니다. 참조를 만드는 방법을 비롯 하 여 연결 된 속성에 대 한 자세한 내용을 보려면 [연결 된 속성 개요](~/docs/framework/wpf/advanced/attached-properties-overview.md)합니다.  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML 값  
 `dependencyPropertyName`  
 지정 하는 문자열의 <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> 원하는 종속성 속성입니다. 이 앞에 나와야 XML 네임 스페이스 접두사 속성 기본 XML 네임 스페이스에 없는 경우 (자세한 내용은 참조 [XAML 네임 스페이스 및 WPF XAML에 대 한 매핑 Namespace](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 점 (.), 종속성 속성의 소유자 형식을 지정 하는 문자열의 다음 <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>합니다. `ownerType` XML 네임 스페이스 접두사가 올 수도 있습니다. 이 사용은 런타임에 바인딩된 스타일 및 템플릿, 때문에 컨텍스트를 구문 분석에 대 한 종속성 속성의 소유자를 지정 해야 합니다는 `TargetType` 아직 알려지지 않은 합니다. 자세한 내용은 [스타일 지정 및 템플릿](~/docs/framework/wpf/controls/styling-and-templating.md)을 참조하세요.  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 연결된 된 속성 이름, 점 (.), 연결된 된 속성의 소유자를 지정 하는 문자열입니다. `attachedPropertyOwnerType` XML 네임 스페이스 접두사가 올 수도 있습니다.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds another type as an owner of a dependency property that has already been registered to a type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to add as an owner of this dependency property.</param>
        <summary>Adds another type as an owner of a dependency property that has already been registered.</summary>
        <returns>A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property. This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 해당 특정 종속성 속성을 초기에 등록 되지 않은 형식에서 종속성 속성을 인식 하도록 속성 시스템을 활성화 합니다.  
  
 일반적으로 <xref:System.Windows.DependencyProperty.AddOwner%2A> 이미 관리 되는 클래스 상속을 통해 해당 종속성 속성을 노출 하지 않는 클래스에 종속성 속성을 추가 하는 데 사용 됩니다 (클래스 상속으로 인해 파생된 클래스에서 상속 하는 래퍼 속성 이므로 일반 멤버 테이블에 액세스할 종속성 속성 이미). <xref:System.Windows.DependencyProperty.AddOwner%2A> 종속성 속성을 초기에 등록 하지 않은 형식에서 종속성 속성을 인식 하도록 속성 시스템을 수 있습니다.  
  
 이 서명을 메타 데이터를 지정 하는 데 허용 하지 않습니다.  이 방법을 사용 하면 메타 데이터는 자동으로 생성 새 <xref:System.Windows.DependencyProperty> 와 소유자 형식입니다. 자동 생성 된 메타 데이터에는이 속성이 정의 된 기본 형식의 모든 병합된 메타 데이터의 결과입니다. 병합 된 메타 데이터를 사용할 수 있는 속성에 대 한 기본 메타 데이터 사용 됩니다. 속성이 사용 하 여 등록 하는 경우는 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 메서드를 기본 메타 데이터는 때 생성 되는 메타 데이터와 동일 하 게 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 호출 되었습니다. 그렇지 않은 경우는 <xref:System.Windows.PropertyMetadata> 개체를 만든는 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 속성 형식의 기본값 및 다른 모든 속성을 설정 하는 속성의 <xref:System.Windows.PropertyMetadata> 로 설정 되어 `null`합니다. 사용 하 여는 <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> 서명이 제공 된 형식에 추가 되는 종속성 속성의 버전에 대 한 메타 데이터를 제공 하려는 경우.  
  
 이 메서드의 반환 값은 일반적으로 선언 하 고는 종속성 속성 식별자를 저장 하 여 종속성 속성을 노출 사용 됩니다. 식별자 속성 시스템 호출 하려는 경우 종속성 속성에 대 한 액세스를 제공 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 종속성 속성에 대해 특히 속성이 있을 때 추가 소유자 클래스에 있습니다. 원래 소유자와 추가 된 소유자에 대 한 속성 이름이 동일한 유사한 기능을 나타내는 데 사용할 해야 합니다. 사용 해야는 <xref:System.Windows.DependencyProperty> 의 반환 값은 <xref:System.Windows.DependencyProperty.AddOwner%2A> 종속성 속성의 식별자를 정의 하 고 선언 하는 메서드 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 속성 래퍼를 사용 하 여 형식에 추가 하는 종속성 속성에 대 한 <xref:System.Windows.DependencyProperty.AddOwner%2A>합니다.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> 내에 선언 된 종속성 속성을 만들 때 위에서 권장 방법론을 사용 하는 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]합니다. 예를 들어, 둘 다 <xref:System.Windows.Controls.Border> 및 <xref:System.Windows.Controls.Control> 정의 `BorderBrush` 유사한 기능을 포함 하는 종속성 속성입니다. <xref:System.Windows.Controls.Control> 정의 `BorderBrush` 속성을 호출 하 여 속성 시스템 <xref:System.Windows.DependencyProperty.AddOwner%2A> 원래 소유자에 따라 <xref:System.Windows.Controls.Border> 및 등록 된 <xref:System.Windows.Controls.Border.BorderBrushProperty> 종속성 속성 식별자입니다. <xref:System.Windows.DependencyProperty.AddOwner%2A> 반환 값을 설정 하는 새 정적 사용 다음 <xref:System.Windows.DependencyProperty> 필드 (<xref:System.Windows.Controls.Control.BorderBrushProperty>)의 해당 속성에 추가 된 소유자에 대 한 및 `BorderBrush` 속성 래퍼를 선언 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to add as owner of this dependency property.</param>
        <param name="typeMetadata">The metadata that qualifies the dependency property as it exists on the provided type.</param>
        <summary>Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</summary>
        <returns>A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property. This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 해당 특정 종속성 속성을 초기에 등록 되지 않은 형식에서 종속성 속성을 인식 하도록 속성 시스템을 활성화 합니다.  
  
 추가 소유자 클래스에 있는 것 처럼에 특히 선언 하 고 종속성 속성을 노출 합니다.이 메서드의 반환 값 사용 됩니다. 일반적으로 원래 소유자와 추가 된 소유자에 대 한 속성 이름이 동일한 유사한 기능을 나타내는 데 사용할 해야 합니다. 것이 좋습니다도 새 식별자를 노출 하도록 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 를 사용 하 여 형식에 추가 하는 종속성 속성에 대 한 속성 래퍼 <xref:System.Windows.DependencyProperty.AddOwner%2A>합니다.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> 위에서 권장 방법론은 만들 때 사용 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 내에 선언 된 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]합니다. 예를 들어, 둘 다 <xref:System.Windows.Controls.Border> 및 <xref:System.Windows.Controls.Control> 정의 `BorderBrush` 유사한 기능을 포함 하는 종속성 속성입니다. <xref:System.Windows.Controls.Control> 정의 `BorderBrush` 속성을 호출 하 여 속성 시스템 <xref:System.Windows.DependencyProperty.AddOwner%2A> 원래 소유자에 <xref:System.Windows.Controls.Border> 및 등록 된 <xref:System.Windows.Controls.Border.BorderBrushProperty> 종속성 속성 식별자입니다. <xref:System.Windows.DependencyProperty.AddOwner%2A> 반환 값을 설정 하는 정적 사용 다음 <xref:System.Windows.DependencyProperty> 필드 (<xref:System.Windows.Controls.Control.BorderBrushProperty>)의 해당 속성에 추가 된 소유자에 대 한 및 `BorderBrush` 속성 래퍼를 선언 합니다.  
  
 추가 된 소유자의 종속성 속성 식별자에 사용할 작업 같은 <xref:System.Windows.DependencyObject.GetValue%2A>합니다. 그러나 특정 형식의 작업 모두 관련 된 다른 메타 데이터와 소유자를 계속 추가 된 클래스의 인스턴스 반환할 경우에도 해당 예상된 결과 원래 (하지는 추가 된 소유자의)에 지정 된 종속성 속성 식별자 와 같은 메서드를 호출 <xref:System.Windows.DependencyObject.GetValue%2A> 또는 <xref:System.Windows.DependencyProperty.GetMetadata%2A>합니다. 추가 된 소유자에 대 한 메타 데이터는 적용 됩니다는 <xref:System.Windows.DependencyProperty.AddOwner%2A> 추가 소유자 클래스 식별자 필드에서 단독으로 참조 하지 않아도 자신을 호출 합니다. 그럼에도 불구 하 고 것이 좋습니다도 새 식별자를 노출 하도록 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 를 사용 하 여 형식에 추가 하는 종속성 속성에 대 한 속성 래퍼 <xref:System.Windows.DependencyProperty.AddOwner%2A>이렇게 정의 하면 간의 차이 만들기 때문에 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 및 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 의 속성이 표현 합니다.  
  
 제공 된 메타 데이터는 기본 소유자에 있는 종속성 속성에 대 한 속성 메타 데이터와 병합 됩니다. 원래 기본 메타 데이터에 지정 된 특성을 계속 유지 됩니다. 새 메타 데이터에서 특별히 변경 된 특성에만 기본 메타 데이터의 특성을 재정의 합니다. 일부 특징와 같은 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, 새 메타 데이터에서 지정 된 대체 됩니다. 다른 사용자와 같은 <xref:System.Windows.PropertyChangedCallback>, 결합 됩니다. 병합 동작을 사용 하는 override, 여기에 설명 된 동작이 사용 되는 기존 속성 메타 데이터 클래스에 대 한 속성 메타 데이터 형식에 따라 다르며 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 종속성 속성입니다. 자세한 내용은 참조 [종속성 속성 메타 데이터](~/docs/framework/wpf/advanced/dependency-property-metadata.md) 및 [프레임 워크 속성 메타 데이터](~/docs/framework/wpf/advanced/framework-property-metadata.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default metadata of the dependency property.</summary>
        <value>종속성 속성의 기본 메타 데이터입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 메타 데이터는 사용할 수 있는 특정 개체 또는 파생 형식인 개체에 명시적에서 대체 메타 데이터가 제공 된 이름에 속성 메타 데이터 <xref:System.Windows.DependencyProperty.Register%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 호출 합니다.  
  
 원래 소유자 첫 번째에 메타 데이터를 적용 하는 경우 <xref:System.Windows.DependencyProperty.Register%2A> 호출으로 반환 되 고 해당 메타 데이터 종속성 속성을 설정 하는 <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>합니다.  
  
 메타 데이터가 원래 적용 된 경우 <xref:System.Windows.DependencyProperty.Register%2A> 호출, 기본 메타 데이터 내에서 생성 되는 <xref:System.Windows.DependencyProperty.Register%2A> 호출 하 고이 값으로 반환 됩니다는 <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>합니다.  
  
 기본 메타 데이터와 연결 된의 주요 목적은 <xref:System.Windows.DependencyProperty> 에서이 속성에 대 한 기본값을 제공 하 여 <xref:System.Windows.DependencyObject> 또는 파생된 형식입니다.  
  
 연결 되지 않은 속성에 대 한이 속성에서 반환 되는 메타 데이터 형식으로 캐스팅할 수 없습니다 파생된 유형의 <xref:System.Windows.PropertyMetadata> 최초 속성 된 파생 된 메타 데이터 형식으로 등록 된 경우에 입력 합니다. 원래 등록 된 메타 데이터는 원래 수 있는 파생 된 메타 데이터 유형과 같은 호출 <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> 형식을 매개 변수로 대신 원래 등록을 전달 합니다.  
  
 연결 된 속성에 대 한이 속성에서 반환 된 메타 데이터 형식에는 원래에 지정 된 형식과 일치 합니다 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 등록 메서드.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash code for this <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>The hash code for this <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 시스템 자체 고유 식별자를 사용 하 여 <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, 해당 속성 값을 반환한 <xref:System.Windows.DependencyProperty.GetHashCode%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the metadata associated with this dependency property as it exists for a particular type. This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">The specific type from which to retrieve the dependency property metadata.</param>
        <summary>Returns the metadata for this dependency property as it exists on a specified existing type.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식 또는 개체 참조 메타 데이터를 원래 등록 시와에서 다를 수 있으므로 형식을 키가 필요한 데 지정 <xref:System.Windows.DependencyProperty.AddOwner%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 형식에 있는 종속성 속성의 메타 데이터를 변경 하는 호출 합니다.  
  
   
  
## Examples  
 다음 예제에서는 해당 형식에 따라 종속성 속성에 대 한 메타 데이터를 가져옵니다. 형식을 사용 하 여 한 `typeof` 연산자입니다.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</param>
        <summary>Returns the metadata for this dependency property as it exists on the specified object instance.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 하는 유형 또는 개체 참조가 필요한 특정된 종속성 속성의 메타 데이터를 원래 등록 시와에서 다를 수 있으므로 <xref:System.Windows.DependencyProperty.AddOwner%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 에 있는 속성 메타 데이터를 수정 하는 입력 합니다.  
  
 인스턴스에 따라 속성 메타 데이터를 요청할 때만 전달 하는 인스턴스가 해당 형식을 내부적으로 계산 될 수 있도록 합니다. 종속성 속성 메타 데이터 인스턴스; 별로 달라 지지 않습니다. 지정 된 type 속성 조합에 대해 일관성은 항상 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 특정에 기반 하는 종속성 속성에 대 한 메타 데이터를 가져옵니다 <xref:System.Windows.DependencyObject> 인스턴스.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">A specific object that records the dependency object type from which the dependency property metadata is desired.</param>
        <summary>Returns the metadata for this dependency property as it exists on a specified type.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 하는 유형 또는 개체 참조가 필요한 특정된 종속성 속성의 메타 데이터를 원래 등록 시와에서 다를 수 있으므로 <xref:System.Windows.DependencyProperty.AddOwner%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 에 있는 속성 메타 데이터를 수정 하는 입력 합니다.  
  
   
  
## Examples  
 다음 예제에서는 기반으로 하는 종속성 속성에 대 한 메타 데이터를 가져옵니다는 <xref:System.Windows.DependencyObjectType>합니다.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an internally generated value that uniquely identifies the dependency property.</summary>
        <value>고유 숫자 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 값은 정수 전역 고유 식별자 (GUID) 되지 않습니다. 일반적으로이 인덱스 값을 사용 하 여은 필요 하지 않으며 모든 종속성 속성의 테이블에 인덱스 액세스할 수 없습니다. 종속성 속성 식별자 필드에서 대신 참조 하도록 합니다.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> 사용 하는 데이터 구조에 대 한 빠른 액세스를 위해 내부적으로 사용 되며는 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> 에 0부터 시작 배열 인덱스입니다. 비슷한 사용 응용 프로그램 디자이너 또는 도구 있을 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to check.</param>
        <summary>Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</summary>
        <returns>
          <see langword="true" /> if the specified value is the registered property type or an acceptable derived type; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값이 `null` 올바른 형식이 또는 참조 형식 종속성 속성에 대 한는 <xref:System.Nullable%601> 종속성 속성을가 반환 `true` 이러한 경우에 대 한 합니다. 종속성 속성의 두 참조 되는 경우에는 나 <xref:System.Nullable%601> 형식 <xref:System.Windows.DependencyProperty.IsValidType%2A> 반환 됩니다 `false` 예외가 발생 하지 않고 null 값에 대 한 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Windows.DependencyProperty.IsValidType%2A> 호출 하기 전에 검사 방법으로 <xref:System.Windows.DependencyObject.SetValue%2A> 종속성 속성에 있습니다.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to check.</param>
        <summary>Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</summary>
        <returns>
          <see langword="true" /> if the value is acceptable and is of the correct type or a derived type; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 종속성 속성을 해당 형식에 대 한 값의 허용 되는 범위를 통해 지정할 수 있습니다는 <xref:System.Windows.ValidateValueCallback> 제공 하는 종속성 속성 등록에서 합니다.  
  
 이 메서드를 호출 <xref:System.Windows.DependencyProperty.IsValidType%2A> 내부적으로 합니다. 해당 종속성 속성에이 없는 경우 <xref:System.Windows.ValidateValueCallback>,이 메서드를 호출 하는 것은 효과적으로 호출에 해당 <xref:System.Windows.DependencyProperty.IsValidType%2A>합니다. 종속성 속성이 없는 경우는 <xref:System.Windows.ValidateValueCallback>, 경우에 한 <xref:System.Windows.DependencyProperty.IsValidType%2A> 반환는 `true`를 값으로 반환 되는 콜백을 구현 됩니다.  
  
 Null 값 또는 참조 형식 종속성 속성에 대 한 유효한 값은는 <xref:System.Nullable%601> 종속성 속성을 반환 하 고 `true` 이러한 경우에 대 한 합니다. 종속성 속성의 두 참조 되는 경우에는 나 <xref:System.Nullable%601> 형식 <xref:System.Windows.DependencyProperty.IsValidType%2A> 반환 됩니다 `false` 예외가 발생 하지 않고 null 값에 대 한 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Windows.DependencyProperty.IsValidValue%2A> 호출 하기 전에 검사 방법으로 <xref:System.Windows.DependencyObject.SetValue%2A> 종속성 속성에 있습니다.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the dependency property.</summary>
        <value>속성의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성으로 제공 된 이름을 가져옵니다는 `name` 종속성 속성 등록 하는 동안 매개 변수입니다. 이 이름은 변경할 수 및 커야 `null` 또는 빈 문자열입니다. 중복 이름 등록과 같은 소유자 형식에 허용 되지 않습니다 및 중복 등록 하려고 할 때 예외가 throw 됩니다.  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A> 의 종속성 속성의 "Property" 접미사-해당 종속성 속성 식별자의 이름과 일치 하는 규칙을 따라야 합니다. 자세한 내용은 [사용자 지정 종속성 속성](~/docs/framework/wpf/advanced/custom-dependency-properties.md)을 참조하세요.  
  
   
  
## Examples  
 다음 예에서는 쿼리는 종속성 속성 식별자의 다양 한 특성 등의 <xref:System.Windows.DependencyProperty.Name%2A>합니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</param>
        <param name="typeMetadata">The metadata to apply to the dependency property on the overriding type.</param>
        <summary>Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 종속성 속성 메타 데이터 속성 시스템 종속성 속성을 사용 하기 전에 재정의 해야 합니다. 이 종속성 속성을 등록 하는 클래스를 사용 하 여 특정 인스턴스를 만들 때마다 하는 것과 같습니다. 에 대 한 호출이 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 로 자신을 제공 하는 형식의 정적 생성자 내에서 수행할 수만 `forType` 비슷한 인스턴스화를 통해 또는이 메서드의 매개 변수입니다. 소유자 형식의 인스턴스가 후 메타 데이터를 변경 하는 예외를 발생 시 키 지 않습니다 이지만 속성 시스템에 일관성 없는 동작이 발생 됩니다.  
  
 특정 파생된 클래스 재정의 대 한 메타 데이터는이 방법으로 설정 되 면이 같은 파생된 클래스에서 메타 데이터 재정의 이후에 하려고 하면 예외가 발생 합니다.  
  
 제공 된 메타 데이터는 기본 소유자에 있는 종속성 속성에 대 한 속성 메타 데이터와 병합 됩니다. 원래 기본 메타 데이터에 지정 된 특성에 계속 유지 됩니다. 새 메타 데이터에서 특별히 변경 된 특성에만 기본 메타 데이터의 특성을 재정의 합니다. 와 같은 일부 특징 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 새 메타 데이터에 지정 된 경우 대체 됩니다. 다른 사용자와 같은 <xref:System.Windows.PropertyChangedCallback>, 결합 됩니다. 병합 동작을 사용 하는 override, 여기에 설명 된 동작이 사용 되는 기존 속성 메타 데이터 클래스에 대 한 속성 메타 데이터 형식에 따라 다르며 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 종속성 속성입니다. 자세한 내용은 참조 [종속성 속성 메타 데이터](~/docs/framework/wpf/advanced/dependency-property-metadata.md) 및 [프레임 워크 속성 메타 데이터](~/docs/framework/wpf/advanced/framework-property-metadata.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</exception>
        <exception cref="T:System.ArgumentException">Metadata was already established for the dependency property as it exists on the provided type.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</param>
        <param name="typeMetadata">The metadata to apply to the dependency property on the overriding type.</param>
        <param name="key">The access key for a read-only dependency property.</param>
        <summary>Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration. You must pass the <see cref="T:System.Windows.DependencyPropertyKey" /> for the read-only dependency property to avoid raising an exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 서명을 읽기 전용 종속성 속성 식별자에 대 한 기본 구현을 제공 (<xref:System.Windows.DependencyPropertyKey>) 메서드. 읽기 / 쓰기 종속성 속성의 메타 데이터 재정의 사용 하 여 <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>합니다.  
  
 종속성 속성 메타 데이터 속성 시스템 종속성 속성을 사용 하기 전에 재정의 해야 합니다. 이 종속성 속성을 등록 하는 클래스에 대 한 시간을 특정 개체 생성 하는 것과 같습니다. 에 대 한 호출이 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 로 자신을 제공 하는 형식의 정적 생성자 내에서 수행할 수만 `forType` 비슷한 인스턴스화를 통해 또는이 메서드의 매개 변수입니다. 소유자 형식의 인스턴스가 후 메타 데이터를 변경 하는 예외를 발생 시 키 지 않습니다 이지만 속성 시스템에 일관성 없는 동작이 발생 됩니다.  
  
 특정 파생된 클래스 재정의 대 한 메타 데이터는이 방법으로 설정 되 면이 같은 파생된 클래스에서 메타 데이터 재정의 이후에 하려고 하면 예외가 발생 합니다.  
  
 제공 된 메타 데이터는 기본 소유자에 있는 종속성 속성에 대 한 속성 메타 데이터와 병합 됩니다. 원래 기본 메타 데이터에 지정 된 특성에 계속 유지 됩니다. 새 메타 데이터에서 특별히 변경 된 특성에만 기본 메타 데이터의 특성을 재정의 합니다. 와 같은 일부 특징 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 새 메타 데이터에 지정 된 경우 대체 됩니다. 다른 사용자와 같은 <xref:System.Windows.PropertyChangedCallback>, 결합 됩니다. 병합 동작 재정의에 사용 되 고 속성 메타 데이터 형식에 따라 달라 집니다. 자세한 내용은 참조 [종속성 속성 메타 데이터](~/docs/framework/wpf/advanced/dependency-property-metadata.md) 및 [프레임 워크 속성 메타 데이터](~/docs/framework/wpf/advanced/framework-property-metadata.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</summary>
        <value>속성을 등록하거나 자체적으로 속성 소유자로 추가한 개체의 형식입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성을 등록할 때이 값이 제공 됩니다. 소유자 중 하나는 원래 등록 형식이의 경우 됩니다는 <xref:System.Windows.DependencyProperty> 에서 생성 된 식별자는 <xref:System.Windows.DependencyProperty.Register%2A> 통화 또는 형식 자체의 경우 소유자로 추가 <xref:System.Windows.DependencyProperty> 에서 생성 된 식별자는 <xref:System.Windows.DependencyProperty.AddOwner%2A> 호출 합니다.  
  
 <xref:System.Windows.DependencyProperty.OwnerType%2A> 에 지정 된 모든 <xref:System.Windows.DependencyProperty> 는 변경할 수 및 커야 `null` 에 유효한 <xref:System.Windows.DependencyProperty>합니다.  
  
   
  
## Examples  
 다음 예제는 종속성 속성 식별자에 따라 소유자 형식을 가져옵니다 `dp`를 보유 하 고 해당 식별자에 대 한 메타 데이터의 소유자 형식에 가져옵니다. 이 작업을 실제로 것은 <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> 에 `dp`합니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type that the dependency property uses for its value.</summary>
        <value>
          <see cref="T:System.Type" /> 속성 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 통해 원래 속성 등록 선언 된 속성의 값의 형식을 보고는 `propertyType` 매개 변수입니다. 비슷합니다는 <xref:System.Windows.DependencyProperty.Name%2A>, 등록 후 종속성 속성의 속성 형식을 변경할 수 없습니다.  
  
   
  
## Examples  
 다음 예에서는 쿼리는 종속성 속성 식별자의 다양 한 특성 등의 <xref:System.Windows.DependencyProperty.PropertyType%2A>합니다. 형식 이름 문자열은 <xref:System.Windows.DependencyProperty.PropertyType%2A> 가져온 반환 된 <xref:System.Type>합니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the dependency property identified by this <see cref="T:System.Windows.DependencyProperty" /> instance is a read-only dependency property.</summary>
        <value>
          <see langword="true" /> 종속성 속성은 읽기 전용 이면 하는 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 읽기 전용 종속성 속성을 호출 하 여 속성 시스템 내에서 등록 된 <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> 메서드가 아닌는 <xref:System.Windows.DependencyProperty.Register%2A> 메서드. 연결 된 속성 읽기 전용으로 등록할 수 있습니다. 참조 <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>합니다.  
  
 읽기 전용 종속성 속성에는 필요는 <xref:System.Windows.DependencyPropertyKey> 식별자 대신 <xref:System.Windows.DependencyProperty> 식별자 값을 설정 또는 메타 데이터 재정의 같은 메타 데이터 작업을 수행 합니다. 컬렉션을 구입한 경우 <xref:System.Windows.DependencyProperty> 식별자에 대 한 호출을 통해 <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> 또는 다른 [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] 검사 식별자를 노출 하는 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 호출 하기 전에 값 <xref:System.Windows.DependencyObject.SetValue%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 하를 사용 하 여 종속성 속성의 식별자를 나타내는 읽기 전용이 아닌지 확인 하려면 입력된 매개 변수로 종속성 속성 식별자입니다. 하는 경우의 값 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 은 `true` 에서 종속성 속성을 프로그래밍 방식으로 방법이 있으면에 대 한 참조를 가져올 수는 <xref:System.Windows.DependencyPropertyKey> 또는 메타 데이터에서 해당 종속성 속성의 식별자는 <xref:System.Windows.DependencyProperty> 식별자에 식별자 호출 하기 위해 정적 필드로 사용할 수 있어야 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> 읽기 전용 종속성 속성에 대해 합니다.  
  
 에 대 한 get 접근자만 정의 해야 읽기 전용으로 등록 하는 사용자 지정 종속성 속성을 만들는 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 래퍼 속성입니다. 그렇지 않은 경우 클래스 속성에 대 한 래퍼 보조 종속성 속성에 대 한 액세스에 대 한 혼란을 줄 개체 모델을 갖습니다. 자세한 내용은 참조 [사용자 지정 종속성 속성](~/docs/framework/wpf/advanced/custom-dependency-properties.md) 또는 [읽기 전용 종속성 속성](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 메타 데이터와 종속성 속성 식별자 속성 다양 한 종속성 속성 필드에서 가져오고 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register. The name must be unique within the registration namespace of the owner type.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <summary>Registers a dependency property with the specified property name, property type, and owner type.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 종속성 속성 등록에 대 한 자세한 내용은 참조 하십시오. <xref:System.Windows.DependencyProperty>합니다.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a dependency property with the specified property name, property type, owner type, and property metadata.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 종속성 속성 등록에 대 한 자세한 내용은 참조 하십시오. <xref:System.Windows.DependencyProperty>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 종속성 속성 등록에 대 한 자세한 내용은 참조 하십시오. <xref:System.Windows.DependencyProperty>합니다.  
  
   
  
## Examples  
 다음 예제에서는 유효성 검사 콜백을 포함 하 여 종속성 속성을 등록 (콜백 정의 표시 되지 않습니다; 콜백 정의 대 한 자세한 내용은 참조 <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers an attached property with the property system.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <summary>Registers an attached property with the specified property name, property type, and owner type.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결된 된 속성에 정의 된 속성 개념은 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]합니다. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 종속성 속성으로 연결 된 속성을 구현 합니다. 때문에 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 연결 된 속성은 종속성 속성, 레이아웃 특성을 보고 등의 작업에 대 한 일반 속성 시스템에서 사용할 수 있는 메타 데이터가 적용을 유지할 수 있습니다. 자세한 내용은 [연결된 속성 개요](~/docs/framework/wpf/advanced/attached-properties-overview.md)를 참조하세요.  
  
 종속성 속성 등록에 대 한 자세한 내용은 참조 하십시오. <xref:System.Windows.DependencyProperty>합니다.  
  
   
  
## Examples  
 다음 예제에서는이 사용 하 여 추상 클래스에 연결된 된 속성을 등록 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 서명 합니다.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property. This can include the default value as well as other characteristics.</param>
        <summary>Registers an attached property with the specified property name, property type, owner type, and property metadata.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결된 된 속성에 정의 된 속성 개념은 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]합니다. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 종속성 속성으로 연결 된 속성을 구현 합니다. 때문에 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 연결 된 속성은 종속성 속성, 레이아웃 특성을 보고 등의 작업에 대 한 일반 속성 시스템에서 사용할 수 있는 메타 데이터가 적용을 유지할 수 있습니다. 자세한 내용은 [연결된 속성 개요](~/docs/framework/wpf/advanced/attached-properties-overview.md)를 참조하세요.  
  
 종속성 속성 등록에 대 한 자세한 내용은 참조 하십시오. <xref:System.Windows.DependencyProperty>합니다.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>종속성 속성 값 상속 RegisterAttached를 사용 하 여  
 종속성 속성을 등록 하기 위한 한 가지 특정 시나리오 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 대신 <xref:System.Windows.DependencyProperty.Register%2A> 속성 값 상속을 지원 하는 것입니다. 사용 하 여 종속성 속성 값 상속을 등록 해야 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 클래스는 종속성 속성을 노출 하는 속성 래퍼 접근자를 정의 하는 경우에 그리고 하지 않으려면 제공 하는 Get * 및 집합 * 정적 메서드를 노출 하도록 true 이면 연결 된 경우에 속성 지원 접근자입니다.   속성 값 상속 나타날 수 있지만 연결 되지 않은 종속성 속성에 대해 작동 하도록를 런타임 트리에서 특정 요소 경계를 통해 연결 되지 않은 속성에 대 한 상속 동작이 정의 되지 않습니다. 속성으로 효과적으로 연결 된 등록 속성 시스템에 전역 속성을 연결 된 속성으로 설정 및 속성 값 상속 요소 트리에 있는 모든 경계에 걸쳐 작동 하는 사용 하 여 특정 합니다. 항상 사용 하 여 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 지정 하는 속성을 등록 하려면 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 메타 데이터에 있습니다. 자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property. This can include the default value as well as other characteristics.</param>
        <param name="validateValueCallback">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결된 된 속성에 정의 된 속성 개념은 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]합니다. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 종속성 속성으로 연결 된 속성을 구현 합니다. 때문에 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 연결 된 속성은 종속성 속성, 레이아웃 특성을 보고 등의 작업에 대 한 일반 속성 시스템에서 사용할 수 있는 메타 데이터가 적용을 유지할 수 있습니다. 자세한 내용은 [연결된 속성 개요](~/docs/framework/wpf/advanced/attached-properties-overview.md)를 참조하세요.  
  
 종속성 속성 등록에 대 한 자세한 내용은 참조 하십시오. <xref:System.Windows.DependencyProperty>합니다.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>종속성 속성 값 상속 RegisterAttached를 사용 하 여  
 종속성 속성을 등록 하기 위한 한 가지 특정 시나리오 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 대신 <xref:System.Windows.DependencyProperty.Register%2A> 속성 값 상속을 지원 하는 것입니다. 사용 하 여 종속성 속성 값 상속을 등록 해야 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 클래스는 종속성 속성을 노출 하는 속성 래퍼 접근자를 정의 하는 경우에 그리고 하지 않으려면 제공 하는 Get * 및 집합 * 정적 메서드를 노출 하도록 true 이면 연결 된 경우에 속성 지원 접근자입니다.   속성 값 상속 나타날 수 있지만 연결 되지 않은 종속성 속성에 대해 작동 하도록를 런타임 트리에서 특정 요소 경계를 통해 연결 되지 않은 속성에 대 한 상속 동작이 정의 되지 않습니다. 속성으로 효과적으로 연결 된 등록 속성 시스템에 전역 속성을 연결 된 속성으로 설정 및 속성 값 상속 요소 트리에 있는 모든 경계에 걸쳐 작동 하는 사용 하 여 특정 합니다. 항상 사용 하 여 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 지정 하는 속성을 등록 하려면 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 메타 데이터에 있습니다. 자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는이 사용 하 여 추상 클래스에 연결된 된 속성을 등록 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 서명 합니다. 이 연결 된 속성은 열거형 형식, 속성 및 등록 과정에서 제공된 된 값이 열거형의 값이 있는지 확인 하려면 유효성 검사 콜백을 추가 합니다.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a read-only attached property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a read-only attached property, with the specified property type, owner type, and property metadata.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 형식을 반환 <xref:System.Windows.DependencyPropertyKey>반면, <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 형식을 반환 <xref:System.Windows.DependencyProperty>합니다. 일반적으로 읽기 전용 속성을 나타내는 키 적용 되지 않습니다. 공용으로 호출 하 여 종속성 속성 값을 설정 하는 키를 사용할 수 있으므로 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>합니다. 클래스 디자인 요구 사항에 영향을 줍니다 없지만의 표시 여부 및 액세스 제한 하는 것이 좋습니다 일반적으로 <xref:System.Windows.DependencyPropertyKey> 클래스 또는 응용 프로그램 논리의 일부로 해당 종속성 속성을 설정 하는 데 필요한 코드의 부분에 합니다. 값을 노출 하 여 읽기 전용 종속성 속성에 대 한 종속성 속성 식별자를 노출 하는 것이 좋습니다 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> 로 `public static readonly` 클래스에 필드입니다.  
  
 연결된 된 속성에 대 한 주 시나리오에서의 사용 때문에 읽기 전용 연결 된 속성은 드문 시나리오 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다. 공용 연결된 된 속성에 설정할 수 없습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문입니다.  
  
 종속성 속성 등록에 대 한 자세한 내용은 참조 하십시오. <xref:System.Windows.DependencyProperty>합니다.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>종속성 속성 값 상속 RegisterAttached를 사용 하 여  
 종속성 속성을 등록 하기 위한 한 가지 특정 시나리오 연결 된 속성 값 상속을 지 원하는입니다. 사용 하 여 종속성 속성 값 상속을 등록 해야 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 클래스는 종속성 속성을 노출 하는 속성 래퍼 접근자를 정의 하는 경우에 그리고 하지 않으려면 제공 하는 Get * 및 집합 * 정적 메서드를 노출 하도록 true 이면 연결 된 경우에 속성 지원 접근자입니다.   속성 값 상속 나타날 수 있지만 연결 되지 않은 종속성 속성에 대해 작동 하도록를 런타임 트리에서 특정 요소 경계를 통해 연결 되지 않은 속성에 대 한 상속 동작이 정의 되지 않습니다. 속성으로 효과적으로 연결 된 등록 속성 시스템에 전역 속성을 연결 된 속성으로 설정 및 속성 값 상속 요소 트리에 있는 모든 경계에 걸쳐 작동 하는 사용 하 여 특정 합니다. 항상 사용 하 여 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 지정 하는 속성을 등록 하려면 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 메타 데이터에 있습니다. 자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 형식을 반환 <xref:System.Windows.DependencyPropertyKey>반면, <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 형식을 반환 <xref:System.Windows.DependencyProperty>합니다. 형식을 나타내는 키는 일반적으로 <xref:System.Windows.DependencyProperty>합니다. 일반적으로 읽기 전용 속성을 나타내는 키 적용 되지 않습니다. 공용으로 호출 하 여 종속성 속성 값을 설정 하는 키를 사용할 수 있으므로 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>합니다. 클래스 디자인 요구 사항에 영향을 줍니다 없지만의 표시 여부 및 액세스 제한 하는 것이 좋습니다 일반적으로 <xref:System.Windows.DependencyPropertyKey> 클래스 또는 응용 프로그램 논리의 일부로 해당 종속성 속성을 설정 하는 데 필요한 코드의 부분에 합니다. 값을 노출 하 여 읽기 전용 종속성 속성에 대 한 종속성 속성 식별자를 노출 하는 것이 좋습니다 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> 로 `public static readonly` 클래스에 필드입니다.  
  
 연결된 된 속성에 대 한 주 시나리오에서의 사용 때문에 읽기 전용 연결 된 속성은 드문 시나리오 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다. 공용 연결된 된 속성에 설정할 수 없습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문입니다.  
  
 종속성 속성 등록에 대 한 자세한 내용은 참조 하십시오. <xref:System.Windows.DependencyProperty>합니다.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>종속성 속성 값 상속 RegisterAttached를 사용 하 여  
 대신 연결 된 종속성 속성을 등록 하기 위한 한 가지 특정 시나리오 <xref:System.Windows.DependencyProperty.Register%2A> 속성 값 상속을 지원 하는 것입니다. 사용 하 여 종속성 속성 값 상속을 등록 해야 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 클래스는 종속성 속성을 노출 하는 속성 래퍼 접근자를 정의 하는 경우에 그리고 하지 않으려면 제공 하는 Get * 및 집합 * 정적 메서드를 노출 하도록 true 이면 연결 된 경우에 속성 지원 접근자입니다.   속성 값 상속 나타날 수 있지만 연결 되지 않은 종속성 속성에 대해 작동 하도록를 런타임 트리에서 특정 요소 경계를 통해 연결 되지 않은 속성에 대 한 상속 동작이 정의 되지 않습니다. 속성으로 효과적으로 연결 된 등록 속성 시스템에 전역 속성을 연결 된 속성으로 설정 및 속성 값 상속 요소 트리에 있는 모든 경계에 걸쳐 작동 하는 사용 하 여 특정 합니다. 항상 사용 하 여 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 지정 하는 속성을 등록 하려면 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 메타 데이터에 있습니다. 자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a dependency property as a read-only dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 형식을 반환 <xref:System.Windows.DependencyPropertyKey>반면, <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 형식을 반환 <xref:System.Windows.DependencyProperty>합니다. 일반적으로 읽기 전용 속성을 나타내는 키 적용 되지 않습니다. 공용으로 호출 하 여 종속성 속성 값을 설정 하는 키를 사용할 수 있으므로 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>합니다. 클래스 디자인 요구 사항에 영향을 줍니다 없지만의 표시 여부 및 액세스 제한 하는 것이 좋습니다 일반적으로 <xref:System.Windows.DependencyPropertyKey> 클래스 또는 응용 프로그램 논리의 일부로 해당 종속성 속성을 설정 하는 데 필요한 코드의 부분에 합니다. 값을 노출 하 여 읽기 전용 종속성 속성에 대 한 종속성 속성 식별자를 노출 하는 것이 좋습니다 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> 로 `public static readonly` 클래스에 필드입니다.  
  
 읽기 전용 종속성 속성은 매우 일반적인 시나리오 둘 다의 기존 [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] 및 사용자 지정 시나리오 때문에 다른 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 기능을 설정 하 여 해당 속성이 없는 경우에 종속성 속성을 필요할 수 있습니다 호출자입니다. 예를 종속성 속성을 사용 하는 다른 속성 시스템 작업에 대 한 기반으로 읽기 전용 종속성 속성의 값을 사용할 수 있습니다는 <xref:System.Windows.Trigger> 스타일에는 종속성 속성에 있습니다.  
  
 종속성 속성 등록에 대 한 자세한 내용은 참조 하십시오. <xref:System.Windows.DependencyProperty>합니다.  
  
   
  
## Examples  
 다음 예에서는 등록 된 `AquariumSize` 읽기 전용으로 종속성 속성입니다. 이 예제에서는 정의 `AquariumSizeKey` (따라서 다른 클래스는 어셈블리에서 메타 데이터를 재정의할 수)는 내부 키와 종속성 속성 식별자로 해당 키에 따라 노출 `AquariumSizeProperty`합니다. 래퍼에 대해 만들어집니다는 또한 `AquariumSize`, get 접근자만 사용 합니다.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 형식을 반환 <xref:System.Windows.DependencyPropertyKey>반면, <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 형식을 반환 <xref:System.Windows.DependencyProperty>합니다. 일반적으로 읽기 전용 속성을 나타내는 키 적용 되지 않습니다. 공용으로 호출 하 여 종속성 속성 값을 설정 하는 키를 사용할 수 있으므로 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>합니다. 클래스 디자인 요구 사항에 영향을 줍니다 없지만의 표시 여부 및 액세스 제한 하는 것이 좋습니다 일반적으로 <xref:System.Windows.DependencyPropertyKey> 클래스 또는 응용 프로그램 논리의 일부로 해당 종속성 속성을 설정 하는 데 필요한 코드의 부분에 합니다. 값을 노출 하 여 읽기 전용 종속성 속성에 대 한 종속성 속성 식별자를 노출 하는 것이 좋습니다 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> 로 `public static readonly` 클래스에 필드입니다.  
  
 읽기 전용 종속성 속성은 매우 일반적인 시나리오입니다. 예를 종속성 속성을 사용 하는 다른 속성 시스템 작업에 대 한 기반으로 읽기 전용 종속성 속성의 값을 사용할 수 있습니다는 <xref:System.Windows.Trigger> 스타일에는 종속성 속성에 있습니다.  
  
 종속성 속성 등록에 대 한 자세한 내용은 참조 하십시오. <xref:System.Windows.DependencyProperty>합니다.  
  
 읽기 전용 종속성 속성의 유효성 검사에 덜 중요할 수 있습니다. 키에 대해 지정 하는 public이 아닌 액세스 수준을 임의의 잘못 된 입력에 대 한 위험을 줄일 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the string representation of the dependency property.</summary>
        <returns>The string representation of the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 구현은 <xref:System.Windows.DependencyProperty.Name%2A> 속성 값입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a static value that is used by the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system rather than <see langword="null" /> to indicate that the property exists, but does not have its value set by the property system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> 센티널 값 시나리오에 사용 되는 위치는 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 속성 시스템에서 요청 된 확인할 수 없으면 <xref:System.Windows.DependencyProperty> 값입니다. <xref:System.Windows.DependencyProperty.UnsetValue> 사용 하지 않고 `null`때문에 `null` 유효한 속성 값으로 올바른 수 (및 자주 사용 되는) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>합니다.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 중 반환 되지 않고 <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>합니다. 호출 하는 경우 <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> 에서 종속성 속성에는 <xref:System.Windows.DependencyObject> 인스턴스를 다음 중 하나가 적용:  
  
-   종속성 속성의 기본값이 메타 데이터에서 설정 하 고 해당 값이 반환 됩니다. 이 값에서 가져올 수 있습니다 <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>합니다.  
  
-   속성 시스템에 의해 일부 다른 값으로 설정 되었습니다 및 기본 값은 더 이상 해당 됩니다. 자세한 내용은 [종속성 속성 값 우선 순위](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)를 참조하세요.  
  
 설정 된 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 의 <xref:System.Windows.DependencyProperty.UnsetValue> 수는 없습니다.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> 반환 <xref:System.Windows.DependencyProperty.UnsetValue> 때 요청된 된 속성이 설정 되지 않은 로컬입니다.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 특별 한 의미가의 반환 값으로 사용 되는 <xref:System.Windows.CoerceValueCallback>합니다. 자세한 내용은 참조 [종속성 속성의 콜백 및 유효성 검사](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)합니다.  
  
 데이터베이스에 바인딩하는 경우 유의 <xref:System.Windows.DependencyProperty.UnsetValue> 동일 하지 않습니다 <xref:System.DBNull.Value>, 하는 방법 유사한 방식에서 <xref:System.DBNull.Value> 는 동일 하지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value validation callback for the dependency property.</summary>
        <value>이 종속성 속성에 제공 된 값 유효성 검사 콜백을 <paramref name="validateValueCallback" /> 원래 종속성 속성 등록에서 매개 변수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 포함 됩니다 `null` 종속성 속성에 등록 된 유효성 검사 콜백 없습니다.  
  
 정적 방식으로 작동 해야 하는 값 유효성 검사: 유효성 검사를 통해 적용 되는 <xref:System.Windows.ValidateValueCallback> 제공 된 값에 특정 인스턴스가 올바른지 여부를 확인할 수 없습니다. 콜백은 종속성 속성을 소유 하는 모든 개체 해야 유효한 것으로 제공 된 값을 허용 하지 않아야 하는지 여부를 확인만 수 있습니다. 특정 인스턴스를 사용 하 여 다른 종속성 속성의 값을 사용 하는 유효성 검사를 수행 해야 할 경우는 <xref:System.Windows.CoerceValueCallback> 대신 합니다. <xref:System.Windows.CoerceValueCallback> 아닌 종속성 속성 식별자 바로 아래에 종속성 속성 메타 데이터의 일부로 등록 됩니다. 자세한 내용은 참조 [종속성 속성의 콜백 및 유효성 검사](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>