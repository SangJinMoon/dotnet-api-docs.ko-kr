<Type Name="Window" FullName="System.Windows.Window">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f805a8dedd189924a31c53379179c725286ba810" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695012" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>창과 대화 상자의 수명을 생성, 구성, 표시 및 관리하는 기능을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자와 독립 실행형 응용 프로그램 간의 상호 작용 지점 창입니다. A [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 창 두 고유 영역으로 구성 됩니다.  
  
-   호스팅하는 아이콘, 제목, 시스템 메뉴를 포함 하 여 창 장식을 비클라이언트 영역을 최소화 단추, 단추, 복원 단추, 닫기 단추 및 테두리를 최대화 합니다.  
  
-   응용 프로그램 관련 콘텐츠를 호스트 하는 클라이언트 영역입니다.  
  
 표준 창 다음 그림에 표시 됩니다.  
  
 ![창 요소](~/add/media/windowoverviewfigure1.PNG "창 요소")  
  
 <xref:System.Windows.Window> 만들기, 구성, 표시 및 창 및 대화 상자를 둘 다의 수명을 관리 하는 기능을 캡슐화 하 고 다음과 같은 핵심 서비스를 제공 합니다.  
  
 **수명 관리**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>합니다.  
  
 **창 관리**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>합니다.  
  
 **모양 및 동작**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **대화 상자**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>합니다.  
  
 또한 <xref:System.Windows.Application> 모든 응용 프로그램의 창 관리 하기 위한 특별 한 지원을 노출 합니다.  
  
-   응용 프로그램에는 현재 응용 프로그램에서 시작 된 모든 창의 목록을 유지 관리 합니다. 이 목록에 의해 노출 되는 <xref:System.Windows.Application.Windows%2A> 속성입니다.  
  
-   기본적으로 <xref:System.Windows.Application.MainWindow%2A> 는 자동으로 첫 번째에 대 한 참조 설정 <xref:System.Windows.Window> 응용 프로그램에서 인스턴스화됩니다. 따라서이 창을 기본 응용 프로그램 창.  
  
 A <xref:System.Windows.Window> 태그, 태그 및 코드 숨김 또는 코드를 사용 하 여 구현할 수 있습니다.  
  
 <xref:System.Windows.Window> 창 및 독립 실행형 응용 프로그램에 대 한 대화 상자를 표시 하려면 주로 사용 됩니다. 그러나 필요한 창 수준에서 탐색 응용 프로그램을 사용할 수 있습니다 <xref:System.Windows.Navigation.NavigationWindow> 대신; <xref:System.Windows.Navigation.NavigationWindow> 에서 파생 <xref:System.Windows.Window> 브라우저 스타일 탐색 지원을 사용 하도록 확장 합니다.  
  
> [!NOTE]
>  탐색 가능한 콘텐츠의 제도 사용 하 여 다른 콘텐츠 및 콘텐츠 컨테이너에 통합할 수 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Window> 필요한 `UnmanagedCode` 인스턴스화할 수 있는 보안 권한이 있습니다. 여기에 다음과 같은 결과가 발생에 있습니다.  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-배포 된 독립 실행형 응용 프로그램은 인터넷 또는 로컬 인트라넷 영역에서 시작 하는 경우 권한 상승을 요청 합니다.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 보다 낮은 권한을 요청 대 한 모든 권한을 창 또는 대화 상자를 인스턴스화할 수 없습니다.  
  
 독립 실행형 응용 프로그램 배포 및 보안 고려 사항에 대 한 정보를 참조 하십시오. [WPF 보안 전략-플랫폼 보안](~/docs/framework/wpf/wpf-security-strategy-platform-security.md)합니다.  
  
 A <xref:System.Windows.Window> 는 <xref:System.Windows.Controls.ContentControl>, 즉, 모든 형식 (예: 문자열, 이미지 또는 패널)의 단일 개체가 포함 될 수 있습니다. 자세한 내용은 <xref:System.Windows.Controls.ContentControl> 클래스를 참조하세요. 또한 <xref:System.Windows.Window> 루트 요소 이며 따라서 다른 요소의 콘텐츠가 포함 될 수 없습니다.  
  
> [!NOTE]
>  <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, 및 <xref:System.Windows.Window.Left%2A> 에 속성이 설정 된 <xref:System.Windows.Window> 스타일을 통해 적용 되지 것입니다 런타임 시.  
  
## <a name="customizing-the-window-control"></a>창 컨트롤을 사용자 지정  
 여러 동일한 속성 설정을 적용 하려면 <xref:System.Windows.Window> 컨트롤을 사용 하 여는 <xref:System.Windows.FrameworkElement.Style%2A> 속성입니다. 기본값을 수정할 수 <xref:System.Windows.Controls.ControlTemplate> 고유한 모양을 제어할 수 있습니다. 만들기에 대 한 자세한 내용은 <xref:System.Windows.Controls.ControlTemplate>, 참조 [는 ControlTemplate을 만들어 기존 컨트롤의 모양 사용자 지정](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)합니다.  부분 및 관련 된 상태를 보려면는 <xref:System.Windows.Window>, 참조 [창 스타일 및 템플릿](~/docs/framework/wpf/controls/window-styles-and-templates.md)합니다.  
  
 종속성 속성을이 컨트롤은 컨트롤의 기본 스타일으로 설정할 수 있습니다.  기본 스타일 속성은 응용 프로그램에이 컨트롤이 표시 하는 경우 속성이 기본값에서 변경 될 수 있습니다. 기본 스타일 응용 프로그램이 실행 중인 때 사용 되는 데스크톱 테마에 따라 결정 됩니다.  자세한 내용은 참조 [기본 WPF 테마](http://go.microsoft.com/fwlink/?LinkID=158252)합니다.  
  
> [!NOTE]
>  시각적 속성을 설정만 영향을 미칠 경우 해당 속성을 둘 다에 <xref:System.Windows.Window> 컨트롤의 기본 템플릿에 하 고 사용 하 여 설정 됩니다는 합니다. "변경의 시각적 구조의 정도 제어" 섹션의 시각적 속성 목록을 찾을 수 있습니다 [는 ControlTemplate을 만들어 기존 컨트롤의 모양 사용자 지정](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 표준 창 어떤가요 태그만 사용 하 여 정의 합니다.  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 다음 예제에서는 표준 창을 사용 하 여 정의 된 코드만 방법을.  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 다음 예제에서는 표준 창 어떤가요 태그 및 코드 숨김의 조합을 사용 하 여 정의 합니다.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Window" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 생성자가 초기화 하는 <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, 및 <xref:System.Windows.Window.Left%2A> 속성을 기본 <xref:System.Windows.Window> 값입니다.  
  
 창 내에서 만들어진 경우는 <xref:System.AppDomain> 올려진는 <xref:System.Windows.Application> 개체를 추가 하는 생성자는 <xref:System.Windows.Window> 개체 집합에 <xref:System.Windows.Application>-windows를 통해 관리 되는 <xref:System.Windows.Application.Windows%2A> 속성은 <xref:System.Windows.Application> 개체입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">안전 하지 않은 네이티브 메서드를 호출 하기 위해이 개체에 대 한 필요한 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>창을 전경으로 가져오고 활성화하려고 합니다.</summary>
        <returns>
          <see cref="T:System.Windows.Window" />가 활성화된 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창이 활성화 여부를 결정 하는 규칙에서 사용 하는 것과 동일는 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` 함수 (User32.dll).  
  
 창이 전경 응용 프로그램이 사용자의 Windows Presentation Foundation 응용 프로그램에서 활성화 하는 경우 <xref:System.Windows.Application.Activated> 이벤트가 발생 합니다.  
  
> [!NOTE]
>  창을 브라우저에서 호스팅되는 경우이 메서드를 호출할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">창을 활성화할 수 있는 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 전경 창이 되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창이 활성화 될 (전경 창이 되) 경우:  
  
-   창이 처음 열릴 합니다.  
  
-   ALT + TAB을 눌러 마우스를 사용 하거나 작업 관리자에서 선택 하 여 사용자는 창으로 전환 합니다.  
  
-   사용자가 창의 작업 표시줄 단추를 클릭 합니다.  
  
 활성화 되는 경우를 감지 해야 하는 Windows에서 처리할 수는 <xref:System.Windows.Window.Activated> 이벤트입니다.  
  
 창이 처음 활성화 된 후 비활성화 하 고 해당 수명 동안 여러 번 다시 활성화 될 수 있습니다. 활성화 상태에 종속 되는 응용 프로그램의 동작 또는 상태를 검사할 수 <xref:System.Windows.Window.IsActive%2A> 에 정품 인증 상태를 확인 하려면.  
  
 응용 프로그램 일 수도 있습니다 <xref:System.Windows.Application.Activated>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 클라이언트 영역에서 투명도를 지원하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          창에서 투명도를 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Controls.Control.Background%2A> 창의 속성을 투명 한 색을 사용 하 여 <xref:System.Windows.Media.Brushes.Transparent%2A> 예를 들어 창을 불투명 하 게 유지 합니다. 즉, 바탕 화면 및 "beneath" 창의 실행 중인 응용 프로그램을 볼 수 없습니다. 이 형식의 투명도 사용 하도록 설정 하려면 <xref:System.Windows.Window.AllowsTransparency%2A> 로 설정 해야 `true`합니다.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> 사각형이 아닌 창 편리 하 게 존재 영역이 때 <xref:System.Windows.Window.AllowsTransparency%2A> 로 설정 된 `true`, 창의 <xref:System.Windows.Window.WindowStyle%2A> 속성으로 설정 되어 있어야 <xref:System.Windows.WindowStyle.None>합니다.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">창의 <see cref="P:System.Windows.Window.WindowStyle" /> 값이 <see cref="F:System.Windows.WindowStyle.None" />이 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.AllowsTransparency" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">창이 해당 창과 자식을 정렬하는 데 사용해야 하는 최종 크기를 반영하는 <see cref="T:System.Windows.Size" />입니다.</param>
        <summary>이 메서드를 재정의하여 창과 자식 요소를 정렬하고 크기를 조정합니다.</summary>
        <returns>사용된 실제 크기를 반영하는 <see cref="T:System.Windows.Size" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> 가 호출 되지 않습니다는 <xref:System.Windows.UIElement.Visibility%2A> 속성의 값은 <xref:System.Windows.Visibility.Collapsed>합니다. 하는 경우의 값은 <xref:System.Windows.UIElement.Visibility%2A> 속성이 <xref:System.Windows.Visibility.Hidden> 또는 <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> 호출 됩니다.  
  
> [!NOTE]
>  경우 중 하나 <xref:System.Windows.Window.Show%2A> 또는 <xref:System.Windows.Window.ShowDialog%2A> 호출 됩니다는 <xref:System.Windows.UIElement.Visibility%2A> 속성은 <xref:System.Windows.Window> 로 설정 된 <xref:System.Windows.Visibility.Visible>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>수동으로 <see cref="T:System.Windows.Window" />를 닫습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Window> , 여러 가지 방법 중 하나를 사용 하 여 닫아야 잘 알려진 시스템 제공 메커니즘 있는 제목 표시줄을 포함 하 여에:  
  
-   ALT + F 4입니다.  
  
-   시스템 메뉴 &#124; **닫기**합니다.  
  
-   **닫기** 단추입니다.  
  
 A <xref:System.Windows.Window> 포함 하 여 개발자가 제공 하는 클라이언트 영역 내에서 잘 알려진 몇 가지 메커니즘 중 하나를 사용 하 여 닫을 수도 있습니다.  
  
-   **파일** &#124; **종료** 주 창에서.  
  
-   **파일** &#124; **닫기** 또는 **닫기** 자식 창에서 단추입니다.  
  
> [!NOTE]
>  **정상** 및 **취소** 대화 상자 단추는 또한 개발자가 제공한, 있지만 설정할 가능성이 <xref:System.Windows.Window.DialogResult%2A>, 자동으로 호출 하 여 열려 있는 창을 닫는 <xref:System.Windows.Window.ShowDialog%2A>합니다.  
  
 이러한 메커니즘을 사용 하면를 명시적으로 호출 해야 <xref:System.Windows.Window.Close%2A> 하는 창을 닫습니다.  
  
> [!NOTE]
>  호출 하 여 창에서 열린 경우 <xref:System.Windows.Window.ShowDialog%2A>, 및는 <xref:System.Windows.Controls.Button> 와 해당 <xref:System.Windows.Controls.Button.IsCancel%2A> 단추를 클릭 하거나, 또는 esc 키를 누를 때에 자동으로 속성이 true로 설정 닫힙니다. 사용 하 여 창이 열린 경우 <xref:System.Windows.Window.Show%2A>그러나 <xref:System.Windows.Window.Close%2A> 으로, 명시적으로 호출 해야 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 에 대 한 이벤트 처리기는 <xref:System.Windows.Controls.Button>합니다.  
  
 창을 닫으면는 <xref:System.Windows.Window.Closing> 이벤트를 발생 합니다. 경우는 <xref:System.Windows.Window.Closing> 이벤트 취소 하지 않으면 다음이 수행 됩니다.  
  
-   <xref:System.Windows.Window> 에서 제거 <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (하는 경우는 <xref:System.Windows.Application> 개체가).  
  
-   <xref:System.Windows.Window> 소유자에서 제거 됩니다 <xref:System.Windows.Window> 소유자/소유 관계가 설정 된 경우 소유 된 전에 <xref:System.Windows.Window> 표시 된 소유자 후 <xref:System.Windows.Window> 열렸습니다.  
  
-   <xref:System.Windows.Window.Closed> 이벤트가 발생합니다.  
  
-   관리 되지 않는 리소스를에서 만든는 <xref:System.Windows.Window> 삭제 됩니다.  
  
-   경우 <xref:System.Windows.Window.ShowDialog%2A> 이 호출 되어 표시를 <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> 반환 합니다.  
  
 닫기는 <xref:System.Windows.Window> 닫힌다고 소유 하는 모든 창이 있습니다. 또한 닫기는 <xref:System.Windows.Window> 방식에 따라 실행이 중지 될 수 있습니다 <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> 속성을 설정 합니다.  
  
> [!NOTE]
>  창을 브라우저에서 호스팅되는 경우이 메서드를 호출할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 한 **파일** &#124; **종료** 를 명시적으로 호출 처리 되 고 메뉴 <xref:System.Windows.Window.Close%2A>합니다.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">모든 창과 사용자 입력된 이벤트를 제한 없이 사용할 수 있는 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 닫히려고 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 발생 되 면 창은 닫는에서 제한할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          창이 닫히는 동안 <see cref="P:System.Windows.UIElement.Visibility" />, <see cref="M:System.Windows.Window.Show" /> 또는 <see cref="M:System.Windows.Window.ShowDialog" />가 호출되거나 <see cref="M:System.Windows.Window.Hide" />가 설정된 경우</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Windows.Window.Close" />가 호출된 직후에 발생하며 창 닫기를 취소하도록 처리할 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> 검색 창의 닫을 때 처리 될 수 있습니다 (예를 들어 때 <xref:System.Windows.Window.Close%2A> 라고). 또한 <xref:System.Windows.Window.Closing> 를 닫지 창을 방지 하기 위해 사용할 수 있습니다. 창을를 닫지 않으려면 설정할 수 있습니다는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 의 속성은 <xref:System.ComponentModel.CancelEventArgs> 인수를 `true`합니다.  
  
 <xref:System.Windows.Window.Closing> 이벤트가 발생할 때 <xref:System.Windows.Window.Close%2A> 창의 닫기 단추를 클릭 하면 또는 ALT + F4 키를 누를 경우 호출 됩니다.  
  
 소유 된 창을 사용 하 여 해당 소유자 창에서 열린 경우 <xref:System.Windows.Window.Show%2A>, 소유자 창이 닫힌 경우 소유 된 창 <xref:System.Windows.Window.Closing> 이벤트가 발생 하지 않습니다. 창의 소유자 닫혀 있으면 (참조 <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> 소유 된 창에서 발생 하지 않습니다.  
  
 경우 <xref:System.Windows.Application.Shutdown%2A> 호출 되는 <xref:System.Windows.Window.Closing> 각 창에 대 한 이벤트가 발생 합니다. 그러나 경우 <xref:System.Windows.Window.Closing> 가 취소 취소가 무시 됩니다.  
  
 세션 사용자가 로그 오프 하거나 종료 하기 때문에 종료 되 면 <xref:System.Windows.Window.Closing> 발생 하지 않으면 처리할 <xref:System.Windows.Application.SessionEnding> 응용 프로그램 종료를 취소 하는 코드를 구현 합니다.  
  
 창 될 때마다 다시 인스턴스화하는 데 사용 하지을 표시 하 고 응용 프로그램의 수명 동안 여러 번 창이 숨길를 표시할 때마다 처리할 수 있습니다는 <xref:System.Windows.Window.Closing> 이벤트를 취소 하 고 호출에서 <xref:System.Windows.Window.Hide%2A> 메서드. 그런 다음 호출할 수 있습니다 <xref:System.Windows.Window.Show%2A> 파일을 다시 동일한 인스턴스에 있습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Windows.Window> 를 닫으려면 사용자 개입이 필요한 지 여부를 결정 하는 합니다.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          창이 닫히는 동안 <see cref="P:System.Windows.UIElement.Visibility" />, <see cref="M:System.Windows.Window.Show" /> 또는 <see cref="M:System.Windows.Window.ShowDialog" />가 호출되거나 <see cref="M:System.Windows.Window.Close" />가 설정된 경우</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 콘텐츠가 렌더링된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창에 콘텐츠가 없는 경우이 이벤트가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 배경 창이 되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비활성화 됩니다 (배경 창이 되) 경우:  
  
-   사용자는 현재 응용 프로그램의 다른 창으로 전환합니다.  
  
-   사용자가 ALT + TAB을 사용 하 여 또는 작업 관리자를 사용 하 여 다른 응용 프로그램의 창으로 전환 합니다.  
  
-   사용자가 다른 응용 프로그램의 창에 대 한 작업 표시줄 단추를 클릭 합니다.  
  
 처리 하 여 비활성화 되는 경우를 감지 해야 하는 Windows에서 <xref:System.Windows.Window.Deactivated> 이벤트입니다.  
  
 창이 처음 비활성화 된 후 다시 활성화 하 고 해당 수명 동안 여러 번 비활성화 될 수 있습니다. 활성화 상태에 종속 되는 응용 프로그램의 동작 또는 상태를 검사할 수 <xref:System.Windows.Window.IsActive%2A> 에 정품 인증 상태를 확인 하려면.  
  
 응용 프로그램 일 수도 있습니다 <xref:System.Windows.Application.Deactivated>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Windows.Window.ShowDialog" /> 메서드에서 반환된 값인 대화 상자 결과 값을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Nullable`1" /> 형식의 <see cref="T:System.Boolean" /> 값입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> 사용자 허용 하는지 여부를 확인 하려면 대화 상자를 표시 하는 코드에서 사용할 수 있습니다 (`true`) 또는 취소 (`false`) 대화 상자. 대화 상자, 허용 되 면이 열은 대화 상자를 사용자에 의해 수집 된 데이터를 검색 하 고 처리 하는 코드를 의미 합니다. 그러나 대화 상자를 취소 되 면 것을 의미는 코드를 호출 해야 처리를 중지 합니다.  
  
 기본적으로 대화 상자는 사용자가 다음 중 하나를 수행 하는 경우 취소 됩니다.  
  
-   PressesALT+F4.  
  
-   클릭는 **닫기** 단추입니다.  
  
-   선택 **닫기** 시스템 메뉴에서 합니다.  
  
 이러한 경우 모든 <xref:System.Windows.Window.DialogResult%2A> 은 `false` 기본적으로 합니다.  
  
 대화 상자 단추로 사용 되는 대화 상자를 취소 하는 특수 단추는 일반적으로 제공 된 <xref:System.Windows.Controls.Button.IsCancel%2A> 속성이로 설정 된 `true`합니다. 이러한 방식으로 구성 하는 단추를 자동으로 닫힙니다 창을 누른 하거나 때나 ESC 키를 누를 때. 이러한 경우 모두 <xref:System.Windows.Window.DialogResult%2A> 남아 `false`합니다.  
  
 대화 상자에는 일반적으로 단추의 적용 단추, 제공 된 <xref:System.Windows.Controls.Button.IsDefault%2A> 속성이로 설정 된 `true`합니다. 이러한 방식으로 구성 하는 단추에서 발생 하는 해당 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 것 또는 ENTER 키를 누를 때 이벤트입니다. 그러나 대화 상자에서 자동으로 닫히지 않고 제대로 설정 됩니다 <xref:System.Windows.Window.DialogResult%2A> 를 `true`합니다. 수동으로이 코드에서 일반적으로 기록해 야 하는 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 기본 단추에 대 한 이벤트 처리기입니다.  
  
 <xref:System.Windows.Window.DialogResult%2A> `null` 대화 상자가 표시 될 때 하지만 모두 허용 되거나 취소 합니다.  
  
 대화 상자가 닫힌 후에서 반환한 값에서 대화 상자 결과 얻을 수 있습니다 <xref:System.Windows.Window.ShowDialog%2A> 메서드를 검사 하 여 또는 <xref:System.Windows.Window.DialogResult%2A> 속성입니다.  
  
 <xref:System.Windows.Window.DialogResult%2A> 만 경우 설정할 수는 <xref:System.Windows.Window> 호출 하 여 열린 해당 <xref:System.Windows.Window.ShowDialog%2A> 메서드.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
   
  
## Examples  
 확인 단추와 적절 한 돌아가려면 취소 단추를 구성 하는 방법을 보여 주는 다음 예제 <xref:System.Windows.Window.DialogResult%2A>합니다.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.DialogResult" />는 <see cref="M:System.Windows.Window.ShowDialog" />를 호출하여 창이 열리기 전에 설정됩니다.  
  
 또는  
  
 <see cref="P:System.Windows.Window.DialogResult" />는 <see cref="M:System.Windows.Window.Show" />를 호출하여 창이 열릴 때 설정됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 표시되는 화면 DPI가 변경된 후에 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 화면 DPI가 변경 중일 때의 <see cref="T:System.Windows.RoutedEvent" />입니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>마우스 왼쪽 단추를 누른 상태로 창 클라이언트 영역의 노출된 영역에서 창을 끌 수 있게 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 마우스 왼쪽된 단추를 누른 상태로 해야 <xref:System.Windows.Window.DragMove%2A> 라고 합니다. 마우스 왼쪽된 단추를 누를 때 검색 하는 한 가지 방법은 처리 하기 위한 것은 <xref:System.Windows.UIElement.MouseLeftButtonDown> 이벤트입니다.  
  
 때 <xref:System.Windows.Window.DragMove%2A> 호출 되는 왼쪽 창의 클라이언트 영역의 노출 된 영역 마우스 단추를 누를 해야 합니다.  
  
> [!NOTE]
>  창을 브라우저에서 호스팅되는 경우이 메서드를 호출할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 재정의 하는 방법을 보여 줍니다. <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> 호출할 <xref:System.Windows.Window.DragMove%2A>합니다.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">왼쪽 마우스 단추를 누르지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">창을 끌 수 있는 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">종속성 개체입니다.</param>
        <summary>종속성 개체가 위치한 콘텐츠 트리를 호스팅하는 <see cref="T:System.Windows.Window" /> 개체에 대한 참조를 반환합니다.</summary>
        <returns>호스트 창에 대한 <see cref="T:System.Windows.Window" /> 참조입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" />가 null인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>창이 표시되지 않게 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 숨겨져 창이 닫힐 않으며는 <xref:System.Windows.Window.Closing> 나 <xref:System.Windows.Window.Closed> 이벤트가 발생 합니다. 대신, 창의 <xref:System.Windows.UIElement.Visibility%2A> 속성이 <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>합니다.  
  
 창을 응용 프로그램의 경우 <xref:System.Windows.Application.MainWindow%2A> 및 응용 프로그램의 <xref:System.Windows.Application.ShutdownMode%2A> 은 <xref:System.Windows.ShutdownMode.OnMainWindowClose>, 응용 프로그램 종료 되지 않습니다. 마찬가지로, 응용 프로그램 종료 하지 않은 경우 유일한 창입니다는 응용 프로그램의 종료 모드 <xref:System.Windows.ShutdownMode.OnLastWindowClose>합니다.  
  
 표시 하 고 응용 프로그램의 수명 동안 여러 번 창이 숨길 하 고 다시 창을 인스턴스화할 때마다 하지 않을 경우 표시할 때마다 처리할 수 있습니다는 <xref:System.Windows.Window.Closing> 이벤트를 취소 하 고 호출에서 <xref:System.Windows.Window.Hide%2A> 메서드. 그런 다음 호출할 수 있습니다 <xref:System.Windows.Window.Show%2A> 를 다시 열려면 동일한 인스턴스에 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          닫히고 있는 창(<see cref="M:System.Windows.Window.Hide" />) 또는 닫힌 창(<see cref="E:System.Windows.Window.Closing" />)에서 <see cref="E:System.Windows.Window.Closed" />가 호출된 경우</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 아이콘을 가져오거나 설정합니다.</summary>
        <value>아이콘을 나타내는 <see cref="T:System.Windows.Media.ImageSource" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Presentation Foundation (WPF) 독립 실행형 응용 프로그램에는 두 가지 유형의 아이콘:  
  
-   사용 하 여 지정 된 어셈블리 아이콘은 `<ApplicationIcon>` 응용 프로그램의 프로젝트 속성 파일을 작성 합니다. 이 아이콘은 어셈블리에 대 한 바탕 화면 아이콘으로 사용 됩니다.  
  
    > [!NOTE]
    >  Visual Studio의 디버깅 프로그램 아이콘 호스팅 프로세스로 인해 나타나지 않을 수 있습니다. 실행 파일을 실행 하는 경우에 아이콘이 표시 됩니다. 자세한 내용은 [호스팅 프로세스(vshost.exe)](http://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b)를 참조하세요.  
  
-   설정 하 여 지정 된 창당 하나 아이콘 <xref:System.Windows.Window.Icon%2A>합니다. 각 창에 대해 해당 작업 표시줄 단추가 제목 표시줄에 있는 및의 ALT + TAB 응용 프로그램 선택 목록 항목에이 아이콘이 사용 됩니다.  
  
 항상 WPF 창 아이콘을 표시 합니다. 설정 하 여 하지 제공 된 경우 <xref:System.Windows.Window.Icon%2A>, WPF는 다음 규칙에 따라 표시할 아이콘을 선택 합니다.  
  
1.  지정 된 경우에 어셈블리 아이콘을 사용 합니다.  
  
2.  어셈블리 아이콘을 지정 하지 않으면 기본 Microsoft Windows 아이콘을 사용 합니다.  
  
 사용 하는 경우 <xref:System.Windows.Window.Icon%2A> 사용자 지정 창 아이콘을 지정 하려면 기본 응용 프로그램 아이콘을 설정 하 여 복원할 수 있습니다 <xref:System.Windows.Window.Icon%2A> 를 `null`합니다.  
  
 단일 아이콘은 여러 가지 방법으로 창, 창, ALT + TAB 파일 선택 목록에 대 한 작업 표시줄의 제목 표시줄에 표시 하는 등 Windows에서 사용할 수 있습니다. 다른 크기;를 사용 하 여 아이콘을 표시 이러한 각 ALT + TAB 파일 선택 목록에 표시 되는 32 x 32 픽셀 아이콘 동안 16 x 16 픽셀 아이콘은 창의 제목 표시줄에 하 고 작업 표시줄에 표시 됩니다. 와 같은 일부 응용 프로그램 [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], 제공는 **보기** 메뉴를 보려면 원하는 아이콘의 크기를 선택할 수 있도록 합니다.  
  
 다양 한 표시 크기에 맞도록, 아이콘 파일 각각 특정 크기 및 색 농도 대상으로 하는 아이콘의 버전을 나타냅니다는 하나 이상의 실제 아이콘으로 구성 됩니다. 예를 들어 한 아이콘 반면 다른 16 색와 256 색 모두 32 x 32 픽셀 아이콘과 16 x 16 픽셀 16 색으로 단일 16 x 16 픽셀 아이콘을 하나만 포함할 수 있습니다.  
  
 아이콘 파일 내에 모든 가능한 크기 및 색 농도 아이콘이 있을 경우 <xref:System.Windows.Window> 해당 아이콘을 사용 합니다. 아이콘 파일에는 가능한 모든 아이콘의 하위 집합만 포함 되어 있으면 <xref:System.Windows.Window> 의 크기 및 색 농도 내림차순 다음 가장 적합 한 아이콘을 사용 합니다.  
  
 결과 아이콘 항상에서 사용할 수는 <xref:System.Windows.Window>사용 되는 아이콘 필요한 크기와 색 농도 대상 하지 않더라도, 합니다. 예를 들어를 16 색 16 x 16 픽셀 아이콘 256 개 색을 가진 32 x 32 픽셀 아이콘으로 표시 하기 위해 사용 될 수 있습니다. 이 픽셀화가, 예: 바람직하지 않은 시각 효과 발생할 수 있습니다 하지만 모든 대상된 크기와 색상에 대 한 아이콘을 만들어이 피할 수 있습니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.IconProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 창 아이콘을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">아이콘을 설정할 수 있는 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.Icon" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 활성 상태인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          창이 활성 상태이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 활성 창에는 사용자의 현재 전경 창을 이며에서 포커스가 있는 제목 표시줄의 활성 모양으로 표시 합니다. 활성 창도 명시적으로 설정 하지 않은 모든 최상위 창의 최상위 됩니다는 <xref:System.Windows.Window.Topmost%2A> 속성입니다.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.IsActiveProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.IsActive" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>바탕 화면과 관련해서 창의 왼쪽 가장자리 위치를 가져오거나 설정합니다.</summary>
        <value>논리 단위(1인치의 1/96)로 지정된 창의 왼쪽 가장자리 위치입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Window> 최대화 되거나 최소화, 복원의 왼쪽된 가장자리에 대 한 지점의이 값 나타냅니다는 <xref:System.Windows.Window>합니다.  
  
 스타일을 통해이 속성을 설정할 수 없습니다.  
  
 값을 지정 하지 않으면 <xref:System.Windows.Window.Left%2A> 시스템 기본 값으로 설정 됩니다. 설정 하 여 시스템 기본값을 지정할 수도 있습니다 <xref:System.Windows.Window.Left%2A> 를 <xref:System.Double.NaN>합니다. 모두 <xref:System.Double.NegativeInfinity> 나 <xref:System.Double.PositiveInfinity> 에 대 한 유효한 값인지 <xref:System.Windows.Window.Left%2A>합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.LeftProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.Left" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 위치가 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창의 위치를 변경 하는 경우:  
  
-   창의 제목 표시줄으로 드래그 하 여 창을 이동 하는 사용자입니다.  
  
-   창이 이동 하는 후 <xref:System.Windows.Window.DragMove%2A> 호출 됩니다.  
  
-   중 하나는 <xref:System.Windows.Window.Left%2A> 또는 <xref:System.Windows.Window.Top%2A> 속성을 프로그래밍 방식으로 설정 합니다.  
  
-   **이동** 창의 시스템 메뉴의 메뉴 항목을 선택 합니다.  
  
-   <xref:System.Windows.Window.WindowState%2A> 속성을 변경 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 논리적 자식 요소에 대한 열거자를 가져옵니다.</summary>
        <value>창의 논리적 자식 요소에 대한 <see cref="T:System.Collections.IEnumerator" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">이 창에서 자식에 사용할 수 있는 크기를 반영하는 <see cref="T:System.Windows.Size" />입니다. 창의 크기를 사용할 수 있는 콘텐츠에 맞게 조정할 수 있음을 나타내려면 값을 무한대로 지정할 수 있습니다.</param>
        <summary>이 메서드를 재정의하여 창의 크기를 측정합니다.</summary>
        <returns>이 창에서 자식의 크기 계산을 기반으로 레이아웃 중에 필요한 것으로 확인된 크기를 반영하는 <see cref="T:System.Windows.Size" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> 가 호출 되지 않습니다는 <xref:System.Windows.UIElement.Visibility%2A> 속성의 값은 <xref:System.Windows.Visibility.Collapsed>합니다. 하는 경우의 값은 <xref:System.Windows.UIElement.Visibility%2A> 속성이 <xref:System.Windows.Visibility.Hidden> 또는 <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> 호출 됩니다.  
  
> [!NOTE]
>  경우 중 하나 <xref:System.Windows.Window.Show%2A> 또는 <xref:System.Windows.Window.ShowDialog%2A> 호출 됩니다는 <xref:System.Windows.UIElement.Visibility%2A> 속성은 <xref:System.Windows.Window> 로 설정 된 <xref:System.Windows.Visibility.Visible>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Window.Activated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A>는 <xref:System.Windows.Window.Activated> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnActivated%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Window.OnActivated%2A> 기본 클래스에서 경우 <xref:System.Windows.Window.Activated> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Window.Closed" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A>는 <xref:System.Windows.Window.Closed> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnClosed%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Window.OnClosed%2A> 기본 클래스에서 경우 <xref:System.Windows.Window.Closed> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.ComponentModel.CancelEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Window.Closing" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A>는 <xref:System.Windows.Window.Closing> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnClosing%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Window.OnClosing%2A> 기본 클래스에서 경우 <xref:System.Windows.Window.Closing> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">이전 콘텐츠 트리의 루트에 대한 참조입니다.</param>
        <param name="newContent">새 콘텐츠 트리의 루트에 대한 참조입니다.</param>
        <summary>
          <see cref="P:System.Windows.Controls.ContentControl.Content" /> 속성이 변경되면 호출됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Window.ContentRendered" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A>는 <xref:System.Windows.Window.ContentRendered> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnContentRendered%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Window.OnContentRendered%2A> 기본 클래스에서 경우 <xref:System.Windows.Window.ContentRendered> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" />에 대한 <see cref="T:System.Windows.Window" /> 개체를 만들어 반환합니다.</summary>
        <returns>이 <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" />에 대한 <see cref="T:System.Windows.Window" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>를 재정의합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Window.Deactivated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A>는 <xref:System.Windows.Window.Deactivated> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnDeactivated%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Window.OnDeactivated%2A> 기본 클래스에서 경우 <xref:System.Windows.Window.Deactivated> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">이전 DPI 배율 설정입니다.</param>
        <param name="newDpi">새 DPI 배율 설정입니다.</param>
        <summary>이 창이 렌더링되는 DPI가 변경될 때 호출됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Window.LocationChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A>는 <xref:System.Windows.Window.LocationChanged> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnLocationChanged%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Window.OnLocationChanged%2A> 기본 클래스에서 경우 <xref:System.Windows.Window.LocationChanged> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary>
          <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> 이벤트가 발생할 때 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 구현은 처리 상태를 변경 되지 않습니다 (의 <xref:System.Windows.RoutedEventArgs.Handled%2A> 속성)의 <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> 이벤트 데이터입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, 항상 기본 구현을 호출 프로그램 <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> 구현 합니다. 기본 구현을 호출 하지 않으면 최종 클래스의 런타임 동작을 변경할 수 있는 이벤트를 처리 하는에서 기본 클래스를 방지 합니다. 요구 사항에 따라 앞 이나 뒤를 별도로 처리 하는 기본 구현을 호출할 수 있습니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Window.SourceInitialized" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A>는 <xref:System.Windows.Window.SourceInitialized> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnSourceInitialized%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Window.OnSourceInitialized%2A> 기본 클래스에서 경우 <xref:System.Windows.Window.SourceInitialized> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Window.StateChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A>는 <xref:System.Windows.Window.StateChanged> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnStateChanged%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Window.OnStateChanged%2A> 기본 클래스에서 경우 <xref:System.Windows.Window.StateChanged> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">이전 부모입니다. <see cref="T:System.Windows.DependencyObject" />에 이전 부모가 없는 경우 null로 설정됩니다.</param>
        <summary>창의 부모가 변경될 때 호출됩니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 창이 소유자인 창의 컬렉션을 가져옵니다.</summary>
        <value>이 창이 소유자인 창에 대한 참조가 들어 있는 <see cref="T:System.Windows.WindowCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하나인 소유 된 창을 인 <xref:System.Windows.Window.Owner%2A> 소유자 창으로 알려진 다른 창에 대 한 참조로 속성을 설정 합니다. 소유 하는 소유자 창이 있는 모든 창을 찾기 위해 열거할 수 있습니다 <xref:System.Windows.WindowCollection> 에서 반환 하는 <xref:System.Windows.Window.OwnedWindows%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 열거 하는 방법을 보여 줍니다. <xref:System.Windows.Window.OwnedWindows%2A>합니다.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Windows.Window" />를 소유하는<see cref="T:System.Windows.Window" />를 가져오거나 설정합니다.</summary>
        <value>이 <see cref="T:System.Windows.Window" />의 소유자를 나타내는 <see cref="T:System.Windows.Window" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하 여 자식 창의 부모 창에서 열 때 <xref:System.Windows.Window.ShowDialog%2A>, 부모와 자식 창 간에 암시적 관계가 설정 됩니다. 이 관계는 최소화, 최대화 및 복원에 대해 포함 하 여 특정 동작을 적용 합니다.  
  
 그러나 호출 하 여 자식 창의 부모 창에서 만들 때 <xref:System.Windows.Window.Show%2A>, 자식 창에 관계가 설정 되어 있지 부모 창입니다. 이는 다음을 의미합니다.  
  
-   자식 창에는 부모 창에 대 한 참조가 없습니다.  
  
-   자식 창의 동작 부모 창의 동작에 종속 되지 않습니다. 두 창 중 하나를 포함할 수 또는 최소화, 최대화 및 서로 독립적으로 복원 합니다.  
  
 부모 창의 자식 창 사이의 관계를 만들 수 있도록 <xref:System.Windows.Window> 소유권의 개념을 지원 합니다. 소유권이 설정 된 경우는 <xref:System.Windows.Window.Owner%2A> 창 (소유한 창)의 속성은 다른 창 (소유자 창)에 대 한 참조입니다.  
  
 이 관계 설정 되 면 다음 동작이 표시 됩니다.  
  
-   소유자 창이 최소화 하는 경우 소유 된 모든 창도 최소화 됩니다.  
  
-   소유 된 창을 최소화 하면 소유자 최소화 되지 않습니다.  
  
-   소유자 창이 최대화 되 면 소유자 창 및 소유 된 창 모두 복원 됩니다.  
  
-   소유자 창 소유 된 창을 포함할 수 없습니다.  
  
-   사용 하 여 열려 있지 않은 windows 소유 <xref:System.Windows.Window.ShowDialog%2A> 는 모달 대화 상자가 있습니다. 사용자는 소유자 창이 여전히 작용할 수 있습니다.  
  
-   소유자 창을 닫은 경우 소유 된 창도 닫힙니다.  
  
-   소유 된 창을 사용 하 여 해당 소유자 창에서 열린 경우 <xref:System.Windows.Window.Show%2A>, 소유자 창이 닫힌 경우 소유 된 창 <xref:System.Windows.Window.Closing> 이벤트가 발생 하지 않습니다.  
  
 호출 하 여 자식 창을 열 때 <xref:System.Windows.Window.ShowDialog%2A>를 설정 해야는 <xref:System.Windows.Window.Owner%2A> 자식 창의 속성입니다. 이렇게 하지 않으면 사용자가 작업 표시줄 단추를 눌러 자식 창과 부모 창으로 돌아갈 수 수 없습니다. 대신, 작업 표시줄 단추를 누르면를 생성 하 여 s e l e 부모와 자식 창을 포함 하 여 창의 목록을 선택한 기간만 복원 됩니다.  
  
> [!IMPORTANT]
>  설정 해야는 <xref:System.Windows.Window.Owner%2A> 를 호출 하 여 열 창에서 속성 <xref:System.Windows.Window.ShowDialog%2A> 에 올바른 동작을 보장 합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
   
  
## Examples  
 다음 예제에는 소유자/소유 하 고 관계를 설정 하는 방법을 보여 줍니다.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">창이 자신을 소유하려고 하는 경우  
  
 또는  
  
 두 개의 창이 서로를 소유하려고 하는 경우</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.Owner" />를 사용하여 표시된 창에서 <see cref="M:System.Windows.Window.ShowDialog" /> 속성이 설정된 경우  
  
 또는  
  
 이전에 표시되지 않은 창에서 <see cref="P:System.Windows.Window.Owner" /> 속성이 설정된 경우</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">모든 창과 사용자 입력된 이벤트를 제한 없이 사용할 수 있는 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>크기 조정 모드를 가져오거나 설정합니다.</summary>
        <value>크기 조정 모드를 지정하는 <see cref="T:System.Windows.ResizeMode" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음과 같은 네 가지가 있습니다.  
  
-   **NoResize**합니다. 사용자는 창의 크기를 조정할 수 없습니다. 최대화, 최소화 상자 표시 되지 않습니다.  
  
-   **CanMinimize**합니다. 만 사용자 창을 최소화 하 고 작업 표시줄에서 복원할 수 있습니다. 최소화 및 최대화 상자 모두 표시 되지만 최소화 상자만 사용 하도록 설정 합니다.  
  
-   **CanResize**합니다. 사용자에 게 창 주변의 최소화 및 최대화 상자 및 draggable 개요를 사용 하는 창의 크기를 조정할 수 있습니다. 최소화 및 최대화 상자를 표시 하 고 사용 됩니다. (기본값).  
  
-   **CanResizeWithGrip**. 이 옵션은 동일한 기능을 <xref:System.Windows.ResizeMode.CanResize>, 하지만 창의 오른쪽 맨 아래에 "크기 조정 그립"를 추가 합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.ResizeModeProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.ResizeMode" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>최소화 또는 최대화하기 전의 창의 크기와 위치를 가져옵니다.</summary>
        <value>최소화 또는 최대화하기 전의 창의 크기와 위치를 지정하는 <see cref="T:System.Windows.Rect" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복원 사각형은 지역 창에 최소화 또는 최대화 전에 사용 합니다. 사용할 수 있습니다 <xref:System.Windows.Window.RestoreBounds%2A> 응용 프로그램을 닫기 전에 마지막 크기 및 창 위치를 저장 하 고 응용 프로그램이 시작 하 여 사용자는 방식과 창을 복원 하려면 다음에 해당 값을 검색 합니다.  
  
 쿼리 하는 경우 <xref:System.Windows.Window.RestoreBounds%2A> 는 window가 표시 되기 전에 또는 종료 된 <xref:System.Windows.Rect.Empty%2A> 반환 됩니다.  
  
> [!NOTE]
>  창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Windows.Window.RestoreBounds%2A> 격리 된 저장소 크기 및 창 위치는은 창이 표시 되기 이전 시간 상태로 동일 하 게 되 고 있습니다.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">크기와 창의 위치에 쿼리할 수 있는 권한이 대 한 경계 사각형입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>창을 연 후 새로 열린 창이 닫힐 때까지 기다리지 않고 반환됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Window> 클래스가 인스턴스화되면, 기본적으로 표시 되지 않습니다. <xref:System.Windows.Window.Show%2A> 창을 표시 하 고 창이 닫힐 때까지 기다리지 않고 즉시 결과 반환 합니다. 따라서 열린된 창 응용 프로그램에서 다른 windows와 상호 작용에서 사용자가 방해 되지는 않습니다. 이러한 형식의 라고는 *모덜리스* 창. 일반적인 모덜리스 창은 속성 창과 도구 상자 팔레트 있습니다. 특정 창 상호 작용 하는 사용자를 제한 하는 창을 호출 하 여 열 해야 <xref:System.Windows.Window.ShowDialog%2A>합니다.  
  
 호출 하 여 열려 있는 창을 <xref:System.Windows.Window.Show%2A> 않습니다 것 연 창에 관계가 정의 되어 자동으로; 구체적으로 열린된 창을 알지 못하고 메서드. 사용 하 여이 관계를 설정할 수는 <xref:System.Windows.Window.Owner%2A> 속성과 관리 되는 사용 하는 <xref:System.Windows.Window.OwnedWindows%2A> 속성입니다.  
  
 호출 <xref:System.Windows.Window.Show%2A> 설정으로 동일한 최종 결과 달성 <xref:System.Windows.UIElement.Visibility%2A> 의 속성은 <xref:System.Windows.Window> 개체를 <xref:System.Windows.Visibility.Visible>합니다. 그러나 타이밍 관점에서 둘 사이 차이가 있습니다.  
  
 호출 <xref:System.Windows.Window.Show%2A> 후에 반환 하는 동기 작업은 <xref:System.Windows.FrameworkElement.Loaded> 자식 창에 이벤트가 발생 합니다.  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 설정 <xref:System.Windows.UIElement.Visibility%2A>, 인데 즉시 반환 하는 비동기 작업:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 설정할 때 <xref:System.Windows.UIElement.Visibility%2A>를 설정 하기 전에 등록 한 모든 창 이벤트가 <xref:System.Windows.UIElement.Visibility%2A> 을 설정한 메서드 지날 때까지 발생할 수 있습니다 <xref:System.Windows.UIElement.Visibility%2A> 실행을 완료 합니다.  
  
   
  
## Examples  
 다음 샘플 모덜리스 창을 여는 방법을 보여 줍니다.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          닫히고 있는 창(<see cref="M:System.Windows.Window.Show" />) 또는 닫힌 창(<see cref="E:System.Windows.Window.Closing" />)에서 <see cref="E:System.Windows.Window.Closed" />가 호출된 경우</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 처음 표시될 때 활성화되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          창이 처음 표시될 때 활성화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창을 해당 <xref:System.Windows.Window.ShowActivated%2A> 속성이로 설정 `false` 은 열, 창이 활성화 되지 않으면 및 해당 <xref:System.Windows.Window.Activated> 선택 하 여 창을 수동으로 활성화 될 때까지 이벤트가 발생 하지 않습니다. 창의 선택 된 후 활성화 되거나 정상적으로 비활성화 합니다.  
  
 창이 열릴 때 활성화 되 고 되지 않도록 하려면는 <xref:System.Windows.Window.ShowActivated%2A> 속성으로 설정 되어 있어야 `false` 창이 표시 되기 전에 (호출 하 여 <xref:System.Windows.Window.Show%2A>) 설정 <xref:System.Windows.Window.ShowActivated%2A> 를 `false` 아무 효과가 창이 표시 되기 후입니다.  
  
 설정 <xref:System.Windows.Window.ShowActivated%2A> 를 `false` 모달 형식으로 호출 하 여 열려 있는 창에 <xref:System.Windows.Window.ShowDialog%2A>, 실제 영향을 주지 않습니다. 모달 창이 활성화 되지 않지만 모달 창 사용자 다른 열려 있는 응용 프로그램 창을 활성화 수 없게 됩니다.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.ShowActivatedProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 태그를 사용 하 여 창이 활성화 되지 않고 열 수를 구성 하는 방법을 보여 줍니다.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 다음 예제에서는 코드를 사용 하 여 창이 활성화 되지 않고 열 수를 구성 하는 방법을 보여 줍니다.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.ShowActivated" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>창을 연 후 새로 열린 창이 닫힌 경우에만 반환됩니다.</summary>
        <returns>작업이 받아들여졌는지(<see langword="true" /> 또는 취소되었는지(<see langword="false" />) 여부를 지정하는 <see cref="T:System.Nullable`1" /> 유형의 <see cref="T:System.Boolean" /> 값입니다. 반환 값은 창이 닫히기 전의 <see cref="P:System.Windows.Window.DialogResult" /> 속성 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Window> 클래스가 인스턴스화되면, 기본적으로 표시 되지 않습니다. <xref:System.Windows.Window.ShowDialog%2A> 창을 보여, 응용 프로그램에서 다른 모든 창을 사용 하지 않도록 설정 하 고 창이 닫혀 있는 경우에를 반환 합니다. 이러한 형식의 라고는 *모달* 창.  
  
 모달 창은 대화 상자로 주로 사용 됩니다. 대화 상자는 특수 한 유형의 응용 프로그램 파일을 열거나 문서 인쇄 등의 작업을 완료 하는 사용자 상호 작용 하는 데 사용 하는 창입니다. 대화 상자는 일반적으로 적용 하거나 취소할 작업을 표시 된 대화 상자를 닫기 전에 사용자가 허용 합니다. <xref:System.Windows.Window.ShowDialog%2A> 반환 된 <xref:System.Nullable%601> <xref:System.Boolean> 활동 적용 하거나 취소 여부를 지정 하는 값입니다. 반환 값은 창이 닫히기 전의 <xref:System.Windows.Window.DialogResult%2A> 속성 값입니다. 자세한 내용은 <xref:System.Windows.Window.DialogResult%2A>을 참조하세요.  
  
 호출 하 여 열려 있는 창에서 <xref:System.Windows.Window.ShowDialog%2A> 메서드에 자동으로 그 연 창에 관계가 없으므로 구체적으로 열린된 창을 알지 못하고 창을 연 합니다. 사용 하 여이 관계를 설정할 수는 <xref:System.Windows.Window.Owner%2A> 속성과 관리 되는 사용 하는 <xref:System.Windows.Window.OwnedWindows%2A> 속성입니다. 지원 하기 위해 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 자동화 (참조 [UI 자동화 개요](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> 호출 하 여 연 창에 대 한 설정 되어 있어야 <xref:System.Windows.Window.ShowDialog%2A>합니다.  
  
 모달 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 창 (창을 호출 하 여 열린 <xref:System.Windows.Window.ShowDialog%2A>)가 닫힌 경우 이전에 활성화 된 창이 다시 활성화 됩니다. 경우 모달 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 창에 소유자 (참조 <xref:System.Windows.Window.Owner%2A>), 소유자 창이 때 다시 활성화 modal [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 이전에 활성화 된 창 않은 창이 닫혀 있습니다.  
  
> [!NOTE]
>  창을 브라우저에서 호스팅되는 경우이 메서드를 호출할 수 없습니다.  
  
   
  
## Examples  
 다음 샘플에는 모달 창을 여는 방법을 보여 줍니다.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          닫히고 있는 창(<see cref="M:System.Windows.Window.ShowDialog" />) 또는 닫힌 창(<see cref="E:System.Windows.Window.Closing" />)에서 <see cref="E:System.Windows.Window.Closed" />가 호출된 경우</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">창을 활성화할 수 있는 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창에 작업 표시줄 단추가 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          창에 작업 표시줄 단추가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 창이 브라우저에서 호스팅될 때는 적용하지 마십시오.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 <xref:System.Windows.Window.ShowInTaskbar%2A> 로 설정 된 `true`, ALT + TAB 응용 프로그램 선택 목록에도 창이 나타납니다.  
  
 작업 표시줄 단추와 ALT + TAB 응용 프로그램 선택 목록에 사용 되는 아이콘의 값인는 <xref:System.Windows.Window.Icon%2A> 속성입니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.ShowInTaskbar" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>콘텐츠 크기에 맞게 창의 크기를 자동으로 조정할지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.SizeToContent" /> 값입니다. 기본값은 <see cref="F:System.Windows.SizeToContent.Manual" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Windows.Window.SizeToContent%2A> 로 설정 된 <xref:System.Windows.SizeToContent.WidthAndHeight>, 설정 <xref:System.Windows.FrameworkElement.Height%2A> 또는 <xref:System.Windows.FrameworkElement.Width%2A> 아무 효과가; 두 속성을 설정할 수 있지만 설정 값 창에 적용 되지 않습니다.  
  
 때 <xref:System.Windows.Window.SizeToContent%2A> 로 설정 된 <xref:System.Windows.SizeToContent.Height>설정 <xref:System.Windows.FrameworkElement.Height%2A> 창의 높이 변경 되지 않습니다.  
  
 때 <xref:System.Windows.Window.SizeToContent%2A> 로 설정 된 <xref:System.Windows.SizeToContent.Width>설정 <xref:System.Windows.FrameworkElement.Width%2A> 창의 너비를 변경 되지 않습니다.  
  
 경우 <xref:System.Windows.Window.SizeToContent%2A> 이외의 값을 가지 <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> 으로 자동 설정 <xref:System.Windows.SizeToContent.Manual> 사용자가 창의 크기 조정 그립을 사용 하거나 테두리를 끌어 합니다.  
  
-   콘텐츠 크기를 자체를 조정할 경우 창이 하는 방식으로 변경 되 면 <xref:System.Windows.FrameworkElement.SizeChanged> 발생 합니다.  
  
 창이 투명 한 경우 (참조 <xref:System.Windows.Window.AllowsTransparency%2A>), 설정을 고려해 야 <xref:System.Windows.Window.SizeToContent%2A> 를 <xref:System.Windows.SizeToContent.WidthAndHeight> 표시 된 콘텐츠를 보다 작은 창이 되는지 합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.SizeToContentProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 설정 하는 방법을 보여 주는 다음 예제는 <xref:System.Windows.Window.SizeToContent%2A> 창의 내용에 맞게 크기 조정 하는 방법을 지정 하는 코드에서 속성입니다.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.SizeToContent" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 이벤트는 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]와의 상호 운용성을 지원하기 위해 발생합니다. <see cref="T:System.Windows.Interop.HwndSource" />을 참조하세요.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 <see cref="P:System.Windows.Window.WindowState" /> 속성이 변경될 때 발생합니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Window" />에 [!INCLUDE[win7](~/includes/win7-md.md)] 작업 표시줄 썸네일을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.Window" />의 [!INCLUDE[win7](~/includes/win7-md.md)] 작업 표시줄 축소판 그림입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하는 방법에 대 한 자세한 내용은 [!INCLUDE[win7](~/includes/win7-md.md)] 작업 표시줄, 축소판 그림 참조는 <xref:System.Windows.Shell.TaskbarItemInfo> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.TaskbarItemInfo" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 제목을 가져오거나 설정합니다.</summary>
        <value>창의 제목이 들어 있는 <see cref="T:System.String" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제목은 <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, 또는 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]를 사용 하 여 설정할 수도 있습니다 <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>합니다.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.TitleProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.Title" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>바탕 화면과 관련해서 창의 맨 위 가장자리 위치를 가져오거나 설정합니다.</summary>
        <value>논리 단위(1/96인치)로 지정된 창의 맨 위 위치입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Window> 최대화 되거나 최소화, 복원의 위쪽 가장자리에 대 한 지점의이 값 나타냅니다는 <xref:System.Windows.Window>합니다.  
  
 스타일을 통해이 속성을 설정할 수 없습니다.  
  
 값을 지정 하지 않으면 <xref:System.Windows.Window.Top%2A> 시스템 기본 값으로 설정 됩니다. 설정 하 여 시스템 기본값을 지정할 수도 있습니다 <xref:System.Windows.Window.Top%2A> 를 <xref:System.Double.NaN>합니다. 모두 <xref:System.Double.NegativeInfinity> 나 <xref:System.Double.PositiveInfinity> 에 대 한 유효한 값인지 <xref:System.Windows.Window.Top%2A>합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.TopProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창을 맨 위 z 순서에 표시할지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          창이 맨 위에 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창 인 <xref:System.Windows.Window.Topmost%2A> 속성이 `true` 갖는 모든 창 위에 표시 <xref:System.Windows.Window.Topmost%2A> 속성으로 설정 됩니다 `false`합니다.  
  
 이 있는 windows 그룹에 <xref:System.Windows.Window.Topmost%2A> 속성이 `true`, 현재 활성화 된의 맨 위에 있는 창입니다. 마찬가지로 있는 windows 그룹에 대 한 <xref:System.Windows.Window.Topmost%2A> 속성이 `false`합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.TopmostProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.Topmost" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.Top" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>처음 표시될 때 창의 위치를 가져오거나 설정합니다.</summary>
        <value>처음 표시될 때의 창의 맨 위/왼쪽 위치를 지정하는 <see cref="T:System.Windows.WindowStartupLocation" /> 값입니다. 기본값은 <see cref="F:System.Windows.WindowStartupLocation.Manual" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 <xref:System.Windows.WindowStartupLocation> 를 <xref:System.Windows.WindowStartupLocation.Manual> 설정에 따라 배치 된 창은 해당 <xref:System.Windows.Window.Left%2A> 및 <xref:System.Windows.Window.Top%2A> 속성 값입니다. 경우는 <xref:System.Windows.Window.Left%2A> 또는 <xref:System.Windows.Window.Top%2A> 을 속성 지정 하지 않으면 해당 값은 Windows에 의해 결정 됩니다.  
  
 설정 <xref:System.Windows.WindowStartupLocation.CenterScreen> 창이 마우스 커서가 포함 된 화면 가운데에 배치 되어야 합니다.  
  
 설정 <xref:System.Windows.WindowStartupLocation> 를 <xref:System.Windows.WindowStartupLocation.CenterOwner> 소유자 창의 가운데에 배치 될 창이 (참조 <xref:System.Windows.Window.Owner%2A>), 지정 된 경우. 다른 WPF 창 또는 비 WPF 창 소유자 창이 될 수 있습니다.  
  
> [!NOTE]
>  비 WPF windows와 함께 WPF 기간에 대 한 자세한 내용은 참조 [WPF 및 Win32 상호 운용](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) 및 <xref:System.Windows.Interop.WindowInteropHelper>합니다.  
  
 창의 위치가 같은 방식으로 결정 됩니다 소유자 창이 지정 되지 않은 경우 처럼 <xref:System.Windows.WindowStartupLocation> 로 설정 된 <xref:System.Windows.WindowStartupLocation.Manual>합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성의 값을 가져올 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창을 복원, 최소화 또는 최대화할지 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>창을 복원, 최소화 또는 최대화할지 결정하는 <see cref="T:System.Windows.WindowState" />입니다. 기본값은 <see cref="F:System.Windows.WindowState.Normal" />(복원됨)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 크기와 위치에 저장 된 창이 최소화 되거나 최대화 된, 전에 <xref:System.Windows.Window.RestoreBounds%2A>합니다. 창을 복원 후, 해당 크기와 위치 값의 값으로 복원 됩니다 <xref:System.Windows.Window.RestoreBounds%2A>합니다.  
  
 경우는 <xref:System.Windows.Window.WindowState%2A> 속성이 변경 되 면 <xref:System.Windows.Window.StateChanged> 발생 합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.WindowStateProperty>|  
|로 메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.WindowState" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 테두리 스타일을 가져오거나 설정합니다.</summary>
        <value>창의 테두리 스타일을 지정하는 <see cref="T:System.Windows.WindowStyle" />입니다. 기본값은 <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> 중 하나일 수 있습니다는 <xref:System.Windows.WindowStyle> 열거 값을 포함 하 여 <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (기본값), 및 <xref:System.Windows.WindowStyle.ThreeDBorderWindow>합니다.  
  
 다음 그림에 창 스타일은 [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (투명 효과 사용 하도록 설정 된 Windows Vista Aero 테마):  
  
 ![창 스타일](~/add/media/windowoverviewfigure6.PNG "창 스타일")  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에서 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.WindowStyleProperty>|  
|로 메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Window.WindowStyle" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>