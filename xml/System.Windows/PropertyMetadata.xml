<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d5daa22a17865585b968dc18b13a70072a0600df" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36457945" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="98208-101">등록하는 조건을 포함하여 특정 형식에 적용될 때 종속성 속성의 특정 동작 측면을 정의합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="98208-101">Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98208-102">속성 메타 데이터를 정의 하 고 호출 하는 경우 종속성 속성을 등록할 때 사용 될 수는 <xref:System.Windows.DependencyProperty.Register%2A> 메서드 (또는 연결 된 속성 또는 읽기 전용 종속성 속성에 대 한 변형) 또는 를호출할때원래소유자등록후<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="98208-102">Property metadata can be defined and used during dependency property registration when calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> method.</span></span> <span data-ttu-id="98208-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> 또한 속성 메타 데이터를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> also takes property metadata.</span></span>  
  
 <span data-ttu-id="98208-104">이 클래스는 이러한 각 호출에 사용할 수 있는 구체적 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="98208-104">This class is a concrete base class that can be used in each of these calls.</span></span> <span data-ttu-id="98208-105">그러나 것은 매우 일반적와 같은 파생된 클래스 중 하나를 사용 하는 메타 데이터를 지정할 <xref:System.Windows.FrameworkPropertyMetadata>합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-105">However, it is very common to specify metadata using one of the derived classes such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="98208-106">이러한 파생된 클래스는 감지 또는에 구현 되는 일부 속성 시스템 및 레이아웃 동작을 사용 하도록 설정 하는 데 필요한 부울 속성 값으로 전달 하는 보다 자세한 메타 데이터 지원의 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 프레임 워크 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="98208-106">These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework level.</span></span>  
  
 <span data-ttu-id="98208-107">이 클래스의 몇 가지 속성을와 같은 속성 시스템 작업에 사용 되는 인스턴스가 이전에 쓸 수 있지만 개체 모델에 읽기 / 쓰기 <xref:System.Windows.DependencyProperty.Register%2A> 또는 <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-107">Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span></span> <span data-ttu-id="98208-108">이러한 각 속성 또한 설정 될 수는 생성자가 있지만 표시 됩니다 되도록 <xref:System.Windows.PropertyMetadata.Merge%2A> 메서드 구현에서는 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98208-108">Each of these properties could also have been set by the constructor but are exposed so that <xref:System.Windows.PropertyMetadata.Merge%2A> method implementations can set them.</span></span>  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="98208-109">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="98208-109">XAML Text Usage</span></span>  
 <span data-ttu-id="98208-110">이 형식과이 형식의 멤버 일반적으로에서 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-110">This type, and members of this type, are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="98208-111">
            <see cref="T:System.Windows.PropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-111">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="98208-112">
            <see cref="T:System.Windows.PropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-112">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="98208-113">종속성 속성에 대해 지정할 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-113">The default value to specify for a dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98208-114">이 메타데이터가 적용될 종속성 속성에 대한 지정된 기본값을 사용하여 <see cref="T:System.Windows.PropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-114">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with a specified default value for the dependency property that this metadata will be applied to.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98208-115">제공 된 값의 형식 `defaultValue` 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-115">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="98208-116">메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 불일치 (일치 하지 않는 런타임 예외가 발생 합니다) 컴파일하는 동안 불일치를 감지할 수 없기 때문에 디버깅을 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98208-116">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="98208-117">매개 변수가 없는 생성자에 대해 기본값으로 있지만 `defaultValue` 의 <xref:System.Windows.DependencyProperty.UnsetValue> 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="98208-117">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="98208-118">이렇게 하면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-118">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98208-119">
            <paramref name="defaultValue" />는 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> 값으로 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-119">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">
          <span data-ttu-id="98208-120">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-120">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98208-121">지정된 <see cref="T:System.Windows.PropertyMetadata" /> 구현 참조를 사용하여 <see cref="T:System.Windows.PropertyChangedCallback" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-121">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="98208-122">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-122">The default value of the dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="98208-123">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-123">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98208-124">제공된 기본값 및 <see cref="T:System.Windows.PropertyMetadata" /> 구현 참조를 사용하여 <see cref="T:System.Windows.PropertyChangedCallback" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-124">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98208-125">제공 된 값 형식 `defaultValue` 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-125">The type of the value provided `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="98208-126">메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 불일치 (일치 하지 않는 런타임 예외가 발생 합니다) 컴파일하는 동안 불일치를 감지할 수 없기 때문에 디버깅을 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98208-126">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="98208-127">매개 변수가 없는 생성자에 대해 기본값으로 있지만 `defaultValue` 의 <xref:System.Windows.DependencyProperty.UnsetValue> 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="98208-127">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="98208-128">이렇게 하면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-128">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98208-129">
            <paramref name="defaultValue" />는 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> 값으로 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-129">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="98208-130">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-130">The default value of the dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="98208-131">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-131">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="98208-132">속성 시스템에서 이 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-132">Reference to a handler implementation that is to be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98208-133">지정된 기본값 및 콜백을 사용하여 <see cref="T:System.Windows.PropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-133">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and callbacks.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98208-134">지정 하려는 경우는 <xref:System.Windows.CoerceValueCallback> 하지 않고는 <xref:System.Windows.PropertyChangedCallback>를 전달할 수 있습니다 `null` 에 대 한는 `propertyChangedCallback` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="98208-134">If you want to specify a <xref:System.Windows.CoerceValueCallback> but not a <xref:System.Windows.PropertyChangedCallback>, you can pass `null` for the `propertyChangedCallback` parameter.</span></span>  
  
 <span data-ttu-id="98208-135">제공 된 값의 형식 `defaultValue` 일치 하거나이 메타 데이터가 적용 하는 종속성 속성의 원본 등록에 지정 된 형식과 연관 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-135">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="98208-136">메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식이 불일치 (일치 하지 않는 런타임 예외가 발생 합니다) 컴파일하는 동안 불일치를 감지할 수 없기 때문에 디버깅을 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="98208-136">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="98208-137">매개 변수가 없는 생성자에 대해 기본값으로 있지만 `defaultValue` 의 <xref:System.Windows.DependencyProperty.UnsetValue> 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="98208-137">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="98208-138">이렇게 하면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-138">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98208-139">
            <paramref name="defaultValue" />는 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> 값으로 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-139">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="98208-140">이 메타데이터에 지정되어 있는 <see cref="T:System.Windows.CoerceValueCallback" /> 구현에 대한 참조를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-140">Gets or sets a reference to a <see cref="T:System.Windows.CoerceValueCallback" /> implementation specified in this metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="98208-141">
            <see cref="T:System.Windows.CoerceValueCallback" /> 구현 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-141">A <see cref="T:System.Windows.CoerceValueCallback" /> implementation reference.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98208-142">속성 메타 데이터에 대 한 콜백이 되지 않으므로 일반적으로 public 멤버를 포함 하는 형식,이 속성의 값은 기존 종속성 속성의 메타 데이터를 사용 하는 대부분의 시나리오에 대 한 중요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="98208-142">The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="98208-143">이 속성을 노출 하는 한 가지 이유는 메타 데이터의 하위 클래스는 기본 메타 데이터와 메타 데이터 재정의/추가 지정 하는 경우 원하는 병합 논리를 수행할 수 있도록는 <xref:System.Windows.CoerceValueCallback>합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-143">One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="98208-144">그러나 기본 병합에 대 한 논리는 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 이전을 대체 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="98208-144">However, the default merge logic for a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is to replace the previous one.</span></span>  
  
 <span data-ttu-id="98208-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98208-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="98208-146">따라서 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 초기화 한 후 조정 될 수 있습니다는 <xref:System.Windows.PropertyMetadata> 개체 자체입니다.</span><span class="sxs-lookup"><span data-stu-id="98208-146">This is so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="98208-147">그러나 메타 데이터에 대 한 호출의 일부로 사용 된 경우 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 현재 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98208-147">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="98208-148">설정 하는 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 면 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="98208-148">Attempting to set <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="98208-149">종속성 속성 작업에 적용된 후에는 메타데이터 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-149">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="98208-150">종속성 속성의 기본값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-150">Gets or sets the default value of the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="98208-151">속성의 기본값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-151">The default value of the property.</span>
          </span>
          <span data-ttu-id="98208-152">값에서 기본값을 <see cref="T:System.Windows.PropertyMetadata" /> 인스턴스가 매개 변수가 없는 생성자를 사용 하 여 만든 됩니다 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-152">The default value on a <see cref="T:System.Windows.PropertyMetadata" /> instance created with the parameterless constructor will be <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98208-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98208-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="98208-154">따라서 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 초기화 한 후 조정 될 수 있습니다는 <xref:System.Windows.PropertyMetadata> 개체 자체입니다.</span><span class="sxs-lookup"><span data-stu-id="98208-154">This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="98208-155">그러나 메타 데이터에 대 한 호출의 일부로 사용 된 경우 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 현재 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98208-155">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="98208-156">설정 하는 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 면 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="98208-156">Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 <span data-ttu-id="98208-157">매개 변수가 없는 생성자에 대해 기본값으로 있지만 `defaultValue` 의 <xref:System.Windows.DependencyProperty.UnsetValue> 중 하나를 사용 하 여 설정할 수 없습니다 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 또는 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="98208-157">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor.</span></span> <span data-ttu-id="98208-158">이렇게 하면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-158">Attempting to do so will raise an exception.</span></span>  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="98208-159">XAML 텍스트 사용</span><span class="sxs-lookup"><span data-stu-id="98208-159">XAML Text Usage</span></span>  
 <span data-ttu-id="98208-160">이 형식의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-160">Members of this type are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98208-161">만든 후에는 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> 값으로 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-161">Cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> once created.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="98208-162">종속성 속성 작업에 적용된 후에는 메타데이터 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-162">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="98208-163">메타데이터가 속성에 적용되어 해당 메타데이터 인스턴스가 변경될 수 없는 상태가 되었는지 여부를 결정하는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-163">Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="98208-164">메타데이터 인스턴스를 변경할 수 없으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-164">
              <see langword="true" /> if the metadata instance is immutable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98208-165">다양 한 속성을 <xref:System.Windows.PropertyMetadata>와 같은 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98208-165">Various properties of <xref:System.Windows.PropertyMetadata>, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are defined in the object model as read-write.</span></span> <span data-ttu-id="98208-166">따라서 초기화 한 후 해당 속성을 조정할 수는 <xref:System.Windows.PropertyMetadata> 개체 자체입니다.</span><span class="sxs-lookup"><span data-stu-id="98208-166">This is so those properties can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="98208-167">그러나 메타 데이터에 대 한 호출의 일부로 종속성 속성에 적용 되 고 나면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 현재 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98208-167">However, once the metadata is applied to a dependency property as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="98208-168">이러한 호출 중 하나의 시 <xref:System.Windows.PropertyMetadata.OnApply%2A> 를 호출 하 고이 속성의 값 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-168">At the time of one of these calls, <xref:System.Windows.PropertyMetadata.OnApply%2A> is called, and the value of this property is set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98208-169">다음 예제에서는 검사 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 사용자 지정 메타 데이터 속성의 set 작업 이전 합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-169">The following example  checks <xref:System.Windows.PropertyMetadata.IsSealed%2A> prior to a set operation of a custom metadata property.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">
          <span data-ttu-id="98208-170">이 인스턴스의 값과 병합할 기본 메타데이터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-170">The base metadata to merge with this instance's values.</span>
          </span>
        </param>
        <param name="dp">
          <span data-ttu-id="98208-171">이 메타데이터를 적용하는 종속성 속성입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-171">The dependency property to which this metadata is being applied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98208-172">이 메타데이터를 기본 메타데이터와 병합합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-172">Merges this metadata with the base metadata.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98208-173">이 메서드는 메타 데이터 재정의 될 때 내부적으로 사용 됩니다 (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 메서드).</span><span class="sxs-lookup"><span data-stu-id="98208-173">This method is used internally when metadata is being overridden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98208-174">다음 예제에서는 속성 메타 데이터에 추가 속성을 추가 하는 사용자 지정 메타 데이터 형식에 대 한 병합을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-174">The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="98208-175">
            <para>클래스에서 파생 되는 구현은 <see cref="T:System.Windows.PropertyMetadata" /> 구현에서 추가한 모든 메타 데이터 속성을 설명 하기 위해이 메서드를 재정의 해야 합니다. 예를 들어, 구현 추가 했을 수는 새 플래그 열거형 값 및 <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 구현을 올바르게 이러한 플래그를 결합 할 수 있어야 합니다.  항상 기본 구현을 구현 코드를 이전에 이미 정의 된 모든 속성을 병합 해 주므로 때문에 <see cref="T:System.Windows.PropertyMetadata" /> 유형입니다.  병합의 정확한 동작은 사용자의 책임입니다. 값을 병합, 파생 된 메타 데이터는 기본 또는 특정 메타 데이터 클래스 및 해당 의미에 추가한 속성의 유형을 기반으로 하는 다른 여러 동작 유지 되는 경우 기준 값으로 되돌립니다 하도록 선택할 수 있습니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-175">
              <para>Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations. For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.  Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.  The exact behavior of the merge is up to you. You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="98208-176">메타데이터를 적용한 종속성 속성입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-176">The dependency property to which the metadata has been applied.</span>
          </span>
        </param>
        <param name="targetType">
          <span data-ttu-id="98208-177">형식별 메타데이터인 경우 이 메타데이터에 연결된 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-177">The type associated with this metadata if this is type-specific metadata.</span>
          </span>
          <span data-ttu-id="98208-178">기본 메타데이터의 경우 이 값은 null 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-178">If this is default metadata, this value is a null reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98208-179">이 메타데이터가 속성에 적용되어 메타데이터가 봉인될 때 호출됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-179">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98208-180">서브 클래스 해야 속하는 어떠한 방법으로의 데이터 구조는 <xref:System.Windows.PropertyMetadata> 하위 클래스 표시 해야 변경할 수 없는 것 한 번 <xref:System.Windows.PropertyMetadata.OnApply%2A> 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-180">Subclasses should assure that any mutability of the data structure of a <xref:System.Windows.PropertyMetadata> subclass should be marked as immutable once <xref:System.Windows.PropertyMetadata.OnApply%2A> is called.</span></span> <span data-ttu-id="98208-181">메타 데이터 속성 시스템 작업에 적용 된 후 호출 됩니다 (등록, 소유자를 추가, 메타 데이터 재정의).</span><span class="sxs-lookup"><span data-stu-id="98208-181">This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="98208-182">이 메타데이터에 지정되어 있는 <see cref="T:System.Windows.PropertyChangedCallback" /> 구현에 대한 참조를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-182">Gets or sets a reference to a <see cref="T:System.Windows.PropertyChangedCallback" /> implementation specified in this metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="98208-183">
            <see cref="T:System.Windows.PropertyChangedCallback" /> 구현 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-183">A <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98208-184">속성 메타 데이터의 콜백은 되지 않으므로 정의 형식에 대해 일반적으로 public 멤버가이 속성의 값은 기존 종속성 속성의 메타 데이터를 사용 하는 대부분의 시나리오에 대 한 중요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="98208-184">The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="98208-185">이 속성을 노출 하는 한 가지 이유는 메타 데이터 클래스는 기본 메타 데이터와 메타 데이터 재정의/추가 지정 하는 경우 원하는 병합 논리를 수행할 수 있도록는 <xref:System.Windows.PropertyChangedCallback>합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-185">One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="98208-186">모든 유지 관리 하는 기본 병합 논리는 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 테이블을 각 호출의 첫 번째 실행 하는 계층 구조에서 가장 깊은 클래스에 설정 된 콜백이 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="98208-186">The default merge logic for is to maintain all <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</span></span>  
  
 <span data-ttu-id="98208-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 읽기 / 쓰기 가능으로 개체 모델에서 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98208-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="98208-188">따라서 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 초기화 한 후 조정 될 수 있습니다는 <xref:System.Windows.PropertyMetadata> 개체 자체입니다.</span><span class="sxs-lookup"><span data-stu-id="98208-188">This is so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="98208-189">그러나 메타 데이터에 대 한 호출의 일부로 사용 된 경우 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템은 해당 메타 데이터 인스턴스 및 봉인 속성 현재 변경할 수 없는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="98208-189">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="98208-190">설정 하는 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 면 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 은 `true` 이 메타 데이터 인스턴스 예외를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="98208-190">Attempting to set <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="98208-191">종속성 속성 작업에 적용된 후에는 메타데이터 속성을 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98208-191">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>