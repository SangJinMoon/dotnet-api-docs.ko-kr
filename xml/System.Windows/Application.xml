<Type Name="Application" FullName="System.Windows.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b524996378b2882f342e465d834a727cafe277d6" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695090" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Windows Presentation Foundation 응용 프로그램을 캡슐화합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 가 캡슐화 하는 클래스 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 을 다음을 비롯 한 응용 프로그램 관련 기능:  
  
-   **응용 프로그램 수명**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>, <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>, <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>합니다.  
  
-   **응용 프로그램 범위 창, 속성 및 리소스 관리**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>, <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>합니다.  
  
-   **명령줄 매개 변수 및 종료 코드 처리**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>합니다.  
  
-   **탐색**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>합니다.  
  
 <xref:System.Windows.Application> 해당 창, 속성 및 리소스 범위 서비스에 대 한 공유 액세스를 제공 하는 singleton 패턴을 구현 합니다. 따라서 인스턴스가 하나만 <xref:System.Windows.Application> 당 클래스를 만들 수 있습니다 <xref:System.AppDomain>합니다.  
  
 구현할 수는 <xref:System.Windows.Application> 태그, 태그 및 코드 숨김 또는 코드를 사용 합니다. 경우 <xref:System.Windows.Application> 태그 또는 태그 및 코드 숨김, 태그 파일으로 구성 해야 하는지 여부를 태그를 사용 하 여 구현 되는 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` 항목입니다.  
  
> [!NOTE]
>  독립 실행형 응용 프로그램 필요 하지 않습니다는 <xref:System.Windows.Application> 개체 사용자 지정을 구현 하는 것이 불가능 `static` 진입점 메서드 (`Main`)의 인스턴스를 만들지 않고 창을 엽니다.이 <xref:System.Windows.Application>합니다. 그러나 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] 필요는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 표준 응용 프로그램을 하는 방법을 보여 줍니다. 태그만 사용 하 여 정의 합니다.  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 다음 예제에서는 표준 응용 프로그램은 코드만 정의 방법을 사용 하 여:  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 다음 예제에서는 표준 응용 프로그램을 하는 방법을 보여 줍니다. 태그 및 코드 숨김의 조합을 사용 하 여 정의 합니다.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>공용 <see langword="static" /> (<see langword="Shared" /> Visual basic에서)이 형식의 멤버는 스레드로부터 안전 합니다. 또한는 <see cref="M:System.Windows.Application.FindResource(System.Object)" /> 및 <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> 메서드 및 <see cref="P:System.Windows.Application.Properties" /> 및 <see cref="P:System.Windows.Application.Resources" /> 속성은 스레드로부터 안전 합니다.</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Application" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스가 하나만 <xref:System.Windows.Application> 당 클래스를 만들 수 있습니다 <xref:System.AppDomain>, 응용 프로그램 범위 창, 속성 및 리소스 데이터의 단일 집합에 대 한 공유 액세스 되도록 합니다. 따라서의 기본 생성자는 <xref:System.Windows.Application> 클래스의 첫 번째 인스턴스가 초기화 되는 인스턴스 인지 검색는 <xref:System.AppDomain>정상이 아닌 경우는 <xref:System.InvalidOperationException> throw 됩니다.  
  
 <xref:System.Windows.Application> 현재에 대 한 개체 <xref:System.AppDomain> 정적에서 노출 <xref:System.Windows.Application.Current%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Application" />당 <see cref="T:System.AppDomain" /> 클래스 인스턴스가 두 개 이상 만들어지는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 포그라운드 응용 프로그램이 될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하나 이상의 열려 있는 창이 Windows Presentation Foundation 응용 프로그램을 활성화 (포그라운드로 됨) 창 중 하나는 활성화 된 경우 처음으로 응용 프로그램이 시작 된 이후 또는 windows 중 하나가 활성화 되는 동안 응용 프로그램이 아니기 때문에: 프로그램이 경우:  
  
-   응용 프로그램의 첫 번째 창을 시작 합니다.  
  
-   사용자가 ALT + TAB을 사용 하 여 또는 작업 관리자를 사용 하 여 응용 프로그램으로 전환 합니다.  
  
-   사용자가 응용 프로그램의 창 중 하나에 대 한 작업 표시줄 단추를 클릭 합니다.  
  
 활성화 되는 시기를 검색 하는 응용 프로그램에서 처리할 수는 <xref:System.Windows.Application.Activated> 이벤트입니다.  
  
 응용 프로그램 처음 활성화 된 후 비활성화 하 고 해당 수명 동안 여러 번 다시 활성화 될 수 있습니다. 모두 처리할 수는 응용 프로그램의 동작이 나 상태가 활성화 상태에 따라 달라 지, <xref:System.Windows.Application.Activated> 및 <xref:System.Windows.Application.Deactivated> 이벤트를 상태를 확인 합니다.  
  
 응용 프로그램 활성화 되 면 <xref:System.Windows.Application.Activated> 응용 프로그램이 활성 상태인 동안 응용 프로그램 내에서 개수 창이 활성화 될에 관계 없이 응용 프로그램이 비활성화 될 때까지 다시 발생 하지 것입니다.  
  
 <xref:System.Windows.Application.Activated> 에 대 한 끝나면 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에는 독립 실행형 응용 프로그램 활성화 및 비활성화 하는 시기를 감지 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Windows.Application" />에 대한 <see cref="T:System.AppDomain" /> 개체를 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Windows.Application" />에 대한 <see cref="T:System.AppDomain" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 이 당-<xref:System.AppDomain> 정적을 구현 하는 단일 형식 <xref:System.Windows.Application.Current%2A> 속성에 대 한 공유 액세스를 제공 하는 <xref:System.Windows.Application> 현재에 대 한 인스턴스 <xref:System.AppDomain>합니다. 이 디자인 하 여 관리 되는 상태에서는 <xref:System.Windows.Application>, 공유 리소스 및 상태를 포함 하 여, 하나의 공유 위치에서 제공 됩니다.  
  
 이 속성은 스레드로부터 안전 하 고 모든 스레드에서 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 더 이상 포그라운드 응용 프로그램이 아닐 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 (포그라운드 응용 프로그램이 중지 됨)를 비활성화 하는 하나 이상의 열려 있는 창이 하는 Windows Presentation Foundation 응용 프로그램 사용자가 다음을 수행 하는 경우:  
  
-   ALT + TAB을 사용 하 여 또는 작업 관리자를 사용 하 여 다른 응용 프로그램으로 전환 합니다.  
  
-   다른 응용 프로그램의 창에 대 한 작업 표시줄 단추를 클릭합니다.  
  
 비활성화를 처리할 수를 검색 하는 응용 프로그램의 <xref:System.Windows.Application.Deactivated> 이벤트입니다.  
  
 응용 프로그램 처음 활성화 된 후 비활성화 하 고 해당 수명 동안 여러 번 다시 활성화 될 수 있습니다. 모두 처리할 수는 응용 프로그램의 동작이 나 상태가 활성화 상태에 따라 달라 지, <xref:System.Windows.Application.Deactivated> 및 <xref:System.Windows.Application.Activated> 이벤트를 상태를 확인 합니다.  
  
 <xref:System.Windows.Application.Deactivated> 에 대 한 끝나면 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에는 독립 실행형 응용 프로그램을 비활성화 및 활성화 하는 시기를 감지 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램에서 예외가 throw되었지만 처리되지 않은 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 Windows Presentation Foundation 처리 되지 않은 예외를 catch, 예외 (올은 예외를 보고할 수) 대화 상자에서 사용자에 게 알려줍니다 및 응용 프로그램을 자동으로 종료 합니다.  
  
 그러나 응용 프로그램 중앙된 위치에서 처리 되지 않은 사용자 지정 예외 처리를 수행 하는 경우를 처리 해야 <xref:System.Windows.Application.DispatcherUnhandledException>합니다.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> 에 의해 발생 한 <xref:System.Windows.Application> 주 UI 스레드에서 실행 되는 코드에서 처리 되지 않은 각 예외에 대 한 합니다.  
  
 예외가 처리 되지 않은 경우에 UI 스레드 백그라운드 (자체로 스레드 <xref:System.Windows.Threading.Dispatcher>) 또는 백그라운드 작업자 스레드 (없는 스레드는 <xref:System.Windows.Threading.Dispatcher>), 예외는 주 UI 스레드에 전달 되지 않습니다. 따라서 <xref:System.Windows.Application.DispatcherUnhandledException> 발생 하지 않습니다. 이러한 상황에서는 다음을 수행 하는 코드를 작성 해야 합니다.  
  
1.  백그라운드 스레드에서 예외를 처리 합니다.  
  
2.  이러한 주 UI 스레드가 예외를 발송 합니다.  
  
3.  허용 하도록 처리 하지 않고 주 UI 스레드에서 재발생 <xref:System.Windows.Application.DispatcherUnhandledException> 발생 합니다.  
  
 자세한 내용은 참조는 [스레딩 모델](~/docs/framework/wpf/advanced/threading-model.md) 개요입니다.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> 이벤트 처리기에 전달 되는 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> 인수는 예외에 대 한 컨텍스트 정보를 포함 하는 포함 하 여:  
  
-   예외 (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   <xref:System.Windows.Threading.Dispatcher> 예외가 시작 된 (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).  
  
 예외를 복구할 수 있는지 여부를 확인 하려면이 정보를 사용할 수 있습니다. 복구 가능한 예외는 <xref:System.IO.FileNotFoundException>, 예를 들어 복구할 수 없는 예외 수 있지만 <xref:System.StackOverflowException>, 예를 들어 있습니다.  
  
 처리 되지 않은 예외를 처리 하는 경우 <xref:System.Windows.Application.DispatcherUnhandledException>, 않으려면 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 설정 해야 처리를 계속 하려면는 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> 속성을 `true`합니다.  
  
 다른 이벤트와 달리는 <xref:System.Windows.Application> 를 시키면 <xref:System.Windows.Application.DispatcherUnhandledException> 않습니다 없습니다가 일치 하는 보호 가상 구현 (OnDispatcherUnhandledException). 따라서 클래스에서 파생 되는 <xref:System.Windows.Application> 항상와 이벤트 처리기를 등록 해야 <xref:System.Windows.Application.DispatcherUnhandledException> 처리 되지 않은 예외를 처리 합니다.  
  
   
  
## Examples  
 처리 하 여 처리 되지 않은 예외를 처리 하는 방법을 보여 주는 다음 예제는 <xref:System.Windows.Application.DispatcherUnhandledException> 이벤트입니다.  
  
 [!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]
 [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  
[!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]
[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 종료되기 직전에 발생하며 취소할 수 없습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 이유 중 하나에 대 한 응용 프로그램이 종료 수 있습니다.  
  
-   <xref:System.Windows.Application.Shutdown%2A> 의 메서드는 <xref:System.Windows.Application> 의해 명시적으로 또는 결정 된 대로 개체 호출 됩니다는 <xref:System.Windows.Application.ShutdownMode%2A> 속성입니다.  
  
-   사용자 로그 오프 하거나 종료 하는 세션을 종료 합니다.  
  
 처리 하 여 응용 프로그램 종료가 발생할 때를 감지할 수 있습니다는 <xref:System.Windows.Application.Exit> 이벤트를 필요에 따라 추가 처리를 수행 합니다.  
  
 처리할 수도 있습니다 <xref:System.Windows.Application.Exit> 검사 하거나를 호출할 필요 하지 않을 때 응용 프로그램 종료 코드를 변경 하려면 <xref:System.Windows.Application.Shutdown%2A> 명시적으로 합니다. 종료 코드에서 노출 되는 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 속성의는 <xref:System.Windows.ExitEventArgs> 에 전달 되는 인수는 <xref:System.Windows.Application.Exit> 이벤트 처리기입니다. 응용 프로그램 실행을 중지, 종료 코드 후속 처리에 대 한 운영 체제에 전달 됩니다.  
  
 응용 프로그램에서 처리 하는 경우는 <xref:System.Windows.Application.SessionEnding> 이벤트 한 후 취소 <xref:System.Windows.Application.Exit> 발생 하지 않습니다 하 고 응용 프로그램에 따라 종료 모드에서에서 실행을 계속 합니다.  
  
 종료 코드에서 설정할 수 있습니다는 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]있지만 값이 무시 됩니다.  
  
 에 대 한 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], <xref:System.Windows.Application.Exit> 는 다음과 같은 경우에 발생 합니다.  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 에서 멀리 이동 하 게 됩니다.  
  
-   [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]때 호스팅하는 탭의 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 닫힙니다.  
  
-   브라우저가 닫힌 경우  
  
 모든 경우의 값에는 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 속성은 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 하는 방법:  
  
-   처리는 <xref:System.Windows.Application.Exit> 이벤트입니다.  
  
-   검사 하 고 업데이트는 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 의 속성은 <xref:System.Windows.ExitEventArgs>합니다.  
  
-   격리 된 저장소에서 응용 프로그램 로그에 항목을 기록 합니다.  
  
-   격리 된 저장소를 응용 프로그램 상태를 유지 합니다.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">찾을 리소스 이름입니다.</param>
        <summary>지정된 키를 사용하여 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 리소스(예: <see cref="T:System.Windows.Style" /> 또는 <see cref="T:System.Windows.Media.Brush" />)를 검색하고 요청된 리소스가 없으면 예외를 throw합니다([XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md) 참조).</summary>
        <returns>요청된 리소스 개체입니다. 요청된 리소스가 없으면 <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" />이 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> 지정된 된 리소스에 대 한 응용 프로그램 범위 리소스에서 소개 됩니다. 응용 프로그램 범위 리소스 관리 <xref:System.Windows.Application>에서 노출 하 고는 <xref:System.Windows.Application.Resources%2A> 속성입니다. 지정된 된 리소스는 응용 프로그램 범위 리소스 집합에 없는 경우 <xref:System.Windows.Application.FindResource%2A> 다음 시스템 리소스를 검색 합니다. 시스템 리소스는 사용자가 정의한 shell 리소스 있으며 색, 글꼴 및 셸 구성을 포함 합니다. 노출 된 <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, 및 <xref:System.Windows.SystemParameters> 각각 정적 속성입니다. 사용 하도록 <xref:System.Windows.Application.FindResource%2A> 을 얻은를 이러한 형식 속성을 노출 리소스 키를 전달 하도록 디자인 된 <xref:System.Windows.Application.FindResource%2A>등 <xref:System.Windows.SystemParameters.IconWidthKey%2A>합니다.  
  
 때문에 <xref:System.Windows.Application.FindResource%2A> 개체를 반환 리소스를 찾을 경우 적절 한 형식으로 반환된 된 값을 캐스팅 해야 합니다.  
  
> [!IMPORTANT]
>  이 메서드를 찾을 수 없는 키에 대 한를 호출 하면 예외가 throw 됩니다. 호출에서 발생 하는 예외를 처리 하기 원하는 경우 하지 <xref:System.Windows.Application.FindResource%2A>, 호출 <xref:System.Windows.Application.TryFindResource%2A> 대신; <xref:System.Windows.Application.TryFindResource%2A> 반환는 `null` 참조할 때 요청 된 리소스를 찾을 수 없으면 예외를 throw 하지 않습니다.  
  
 이 메서드는 스레드로부터 안전 하 고 모든 스레드에서 호출할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다. <xref:System.Windows.Application.FindResource%2A> 하 고 처리 하는 리소스를 찾을 <xref:System.Windows.ResourceReferenceKeyNotFoundException> 리소스를 찾을 수 없는 경우.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">리소스를 찾을 수 없습니다.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 탐색기에서 콘텐츠 조각 탐색을 시작할 때 발생합니다. 원하는 조각이 현재 콘텐츠에 있으면 즉시 탐색이 발생하고, 원하는 조각이 다른 콘텐츠에 있으면 소스 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 콘텐츠가 로드된 후에 탐색이 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">느슨한 리소스에 매핑되는 상대 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 <see cref="T:System.Uri" />에 있는 콘텐츠 데이터 파일에 대한 리소스 스트림을 반환합니다([WPF 응용 프로그램 리소스, 콘텐츠 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) 참조).</summary>
        <returns>지정된 <see cref="T:System.Windows.Resources.StreamResourceInfo" />에 있는 콘텐츠 데이터 파일이 들어 있는 <see cref="T:System.Uri" />입니다. 느슨한 리소스가 없으면 null이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" />가 절대 <see cref="T:System.Uri" />인 경우</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">쿠키가 만들어진 위치를 지정하는 <see cref="T:System.Uri" />입니다.</param>
        <summary>
          <see cref="T:System.Uri" />에 의해 지정된 위치에 대한 쿠키를 검색합니다.</summary>
        <returns>쿠키가 있으면 <see cref="T:System.String" /> 값이고, 그렇지 않으면 <see cref="T:System.ComponentModel.Win32Exception" />이 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> 지정 된 쿠키를 검색 <xref:System.Uri>합니다. 쿠키를 검색할 수 없는 경우는 <xref:System.ComponentModel.Win32Exception> throw 됩니다. 이름/값 쌍의 목록 쿠키 문자열 구문 분석 하는 코드를 작성 해야 합니다.  
  
 쿠키에 대 한 개요 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], 참조 [탐색 개요](~/docs/framework/wpf/app-development/navigation-overview.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">지정된 쿠키를 검색하는 동안 문제가 발생하면 <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />에서 호출된 <see langword="InternetGetCookie" /> 함수에 의해 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 오류가 발생합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 기반에 대 한 쿠키를 가져오기 위한 <see cref="T:System.Uri" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">비-파일 기반에 대 한 쿠키를 가져오기 위한 <see cref="T:System.Uri" />합니다. 연결 된 열거형의 경우: <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">원본 사이트의 느슨한 리소스에 매핑되는 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 <see cref="T:System.Uri" />에 있는 원본 사이트 데이터 파일에 대한 리소스 스트림을 반환합니다([WPF 응용 프로그램 리소스, 콘텐츠 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) 참조).</summary>
        <returns>지정된 <see cref="T:System.Windows.Resources.StreamResourceInfo" />에 있는 원본 사이트 데이터 파일에 대한 리소스 스트림이 들어 있는 <see cref="T:System.Uri" />입니다. 느슨한 리소스가 없으면 <see langword="null" />이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />가 상대 경로가 아니거나 절대 경로이지만 <c>pack://siteoforigin:,,,/</c> 형태가 아닌 경우</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">포함된 리소스로 매핑되는 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 <see cref="T:System.Uri" />에 있는 리소스 데이터 파일에 대한 리소스 스트림을 반환합니다([WPF 응용 프로그램 리소스, 콘텐츠 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) 참조).</summary>
        <returns>지정된 <see cref="T:System.Windows.Resources.StreamResourceInfo" />에 있는 리소스 데이터 파일에 대한 리소스 스트림이 들어 있는 <see cref="T:System.Uri" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />가 상대 경로가 아니거나 절대 경로이지만 <c>pack://application:,,,/</c> 형태가 아닌 경우</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />를 발견할 수 없습니다.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 탐색기에서 탐색한 콘텐츠가 로드 및 구문 분석되었으며 렌더링을 시작한 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>을 참조하세요.  
  
> [!NOTE]
>  와 같은 이벤트 탐색된 된 콘텐츠를 수신 대기는 <xref:System.Windows.FrameworkElement.Loaded> 이벤트에 <xref:System.Windows.Controls.Page> 탐색 콘텐츠의 속성에 액세스 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]에 있는 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 파일을 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 파일에는 응용 프로그램 코드 파일 일 수 있습니다 (으로 구성 된는 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] 페이지 항목) 또는 응용 프로그램 데이터 파일 (리소스 파일, 콘텐츠 파일 또는의 원본 사이트 파일; 참조 [WPF 응용 프로그램 리소스, 내용 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">상대 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 파일에 매핑되는 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]에 있는 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 파일을 로드하고 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 파일의 루트 요소에 의해 지정된 개체의 인스턴스로 변환합니다.</summary>
        <returns>로드한 XAML 파일에 지정된 루트 요소의 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 값의 루트 요소와 동일한 형식으로 명시적으로 변환 해야 합니다는 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 파일입니다.  
  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 파일에는 응용 프로그램 코드 파일 일 수 있습니다 (으로 구성 된는 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] 페이지 항목) 또는 응용 프로그램 데이터 파일 (리소스 파일, 콘텐츠 파일 또는의 원본 사이트 파일; 참조 [WPF 응용 프로그램 리소스, 내용 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" />가 절대 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]인 경우</exception>
        <exception cref="T:System.Exception">파일이 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 파일이 아닌 경우</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 파일의 루트 요소와 같은 형식의 개체입니다.</param>
        <param name="resourceLocator">상대 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 파일에 매핑되는 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]에 있는 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 파일을 로드하고 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 파일의 루트 요소가 지정하는 개체의 인스턴스로 변환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 파일에는 응용 프로그램 코드 파일 일 수 있습니다 (으로 구성 된는 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] 페이지 항목) 또는 응용 프로그램 데이터 파일 (리소스 파일, 콘텐츠 파일 또는의 원본 사이트 파일; 참조 [WPF 응용 프로그램 리소스, 내용 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" />가 절대 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]인 경우</exception>
        <exception cref="T:System.Exception">
          <paramref name="component" />가 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 파일의 루트 요소와 일치하지 않는 형식인 경우</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 주 창을 가져오거나 설정합니다.</summary>
        <value>주 응용 프로그램 창으로 지정된 <see cref="T:System.Windows.Window" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> 자동으로 첫 번째에 대 한 참조 설정 <xref:System.Windows.Window> 에서 인스턴스화할 수 있는 개체는 <xref:System.AppDomain>합니다.  
  
 다른 주 창을 설정 하 여 지정할 수 있습니다 <xref:System.Windows.Application.MainWindow%2A> 다른 할당 <xref:System.Windows.Application.Windows%2A> 개체는 <xref:System.Windows.Application.MainWindow%2A> 속성입니다.  
  
 경우는 <xref:System.Windows.Application.ShutdownMode%2A> 속성은 <xref:System.Windows.Application> 개체로 설정 되어 <xref:System.Windows.ShutdownMode.OnMainWindowClose>, 주 창을 닫으면 응용 프로그램을 종료 합니다.  
  
 설정할 수는 <xref:System.Windows.Application.MainWindow%2A> 속성 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]응용 프로그램의 주 창 설정 하 여 생성 되는 창이 아닌 경우는 <xref:System.Windows.Application.StartupUri%2A> 속성에 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]합니다. 두 가지 제한 된 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 접근 방식이 됩니다:  
  
-   하나만 지정할 수 있습니다는 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-만 <xref:System.Windows.Window> 또는 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-만 <xref:System.Windows.Navigation.NavigationWindow> 주 창으로 합니다.  
  
-   설정 해야 합니다는 <xref:System.Windows.UIElement.Visibility%2A> 지정할 속성 창, 그렇지 않으면 표시 되지 않게 합니다.  
  
 첫 번째에 대 한 참조 <xref:System.Windows.Window> 개체를 인스턴스화할 수에 첫 번째 항목으로 추가 됩니다는 <xref:System.Windows.Application.Windows%2A> 컬렉션입니다. 경우 <xref:System.Windows.Application.MainWindow%2A> 다른에 대 한 참조도 설정한 <xref:System.Windows.Window>에 있는 항목의 순서는 동안 주 창에 대 한 참조 항목의 위치가 변경 됩니다 <xref:System.Windows.Application.Windows%2A> 동일 하 게 유지 합니다. 따라서 항상 사용할 <xref:System.Windows.Application.MainWindow%2A> 주 창에서 첫 번째 항목 대신 참조 하려면 <xref:System.Windows.Application.Windows%2A>합니다.  
  
> [!NOTE]
>  주 창이 없으면는 <xref:System.Windows.Navigation.NavigationWindow>, 특정 액세스 해야 하 고 <xref:System.Windows.Navigation.NavigationWindow> 멤버의 값을 캐스팅 해야 합니다 <xref:System.Windows.Application.MainWindow%2A> 를 <xref:System.Windows.Navigation.NavigationWindow>합니다.  
>   
>  이 속성은 작성 된 스레드에서 에서만 사용할 수는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 응용 프로그램 창을 찾는 방법을 보여 줍니다.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 다음 예제에서는 설정 하는 방법을 보여 줍니다. <xref:System.Windows.Application.MainWindow%2A> 를 사용 하 여 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]합니다.  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 다음 예제에서는 인스턴스화하는 방법을 보여 줍니다.는 <xref:System.Windows.Application.MainWindow%2A> 응용 프로그램 시작 시 코드에서.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Application.MainWindow" />가 브라우저에서 호스팅된 응용 프로그램(예: [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)])에서 설정된 경우</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 탐색기에서 탐색 중인 콘텐츠를 찾은 경우에 발생합니다. 콘텐츠가 완전히 로드되지 않았을 수도 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 탐색기에서 새 탐색이 요청된 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 탐색기에서 요청된 내용을 탐색하는 동안 오류가 표시될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>탐색 진행률 정보를 제공하기 위해 응용 프로그램의 탐색기에서 관리되는 다운로드 중에 정기적으로 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 탐색기의 <see langword="StopLoading" /> 메서드가 호출되거나 현재 탐색이 진행되는 동안 탐색기에서 새 탐색이 요청된 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.Activated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A>는 <xref:System.Windows.Application.Activated> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnActivated%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Application.OnActivated%2A> 기본 클래스의 경우 <xref:System.Windows.Application.Activated> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.Deactivated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A>는 <xref:System.Windows.Application.Deactivated> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnDeactivated%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Application.OnDeactivated%2A> 기본 클래스의 경우 <xref:System.Windows.Application.Deactivated> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.ExitEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.Exit" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A>는 <xref:System.Windows.Application.Exit> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다는 <xref:System.Windows.Application.OnExit%2A> 메서드. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Application.OnExit%2A> 기본 클래스의 경우 <xref:System.Windows.Application.Exit> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.FragmentNavigation" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>는 <xref:System.Windows.Application.FragmentNavigation> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnFragmentNavigation%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Application.OnFragmentNavigation%2A> 기본 클래스의 경우 <xref:System.Windows.Application.FragmentNavigation> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.LoadCompleted" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A>는 <xref:System.Windows.Application.LoadCompleted> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnLoadCompleted%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Application.OnLoadCompleted%2A> 기본 클래스의 경우 <xref:System.Windows.Application.LoadCompleted> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.Navigated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A>는 <xref:System.Windows.Application.Navigated> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnNavigated%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Application.OnNavigated%2A> 기본 클래스의 경우 <xref:System.Windows.Application.Navigated> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.Navigating" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A>는 <xref:System.Windows.Application.Navigating> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnNavigating%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Application.OnNavigating%2A> 기본 클래스의 경우 <xref:System.Windows.Application.Navigating> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.NavigationFailed" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A>는 <xref:System.Windows.Application.NavigationFailed> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnNavigationFailed%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Application.OnNavigationFailed%2A> 기본 클래스의 경우 <xref:System.Windows.Application.NavigationFailed> 발생 해야 합니다.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.NavigationProgress" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A>는 <xref:System.Windows.Application.NavigationProgress> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnNavigationProgress%2A>합니다. 재정의 된 메서드가 명시적으로 호출 해야 <xref:System.Windows.Application.OnNavigationProgress%2A> 기본 클래스의 경우 <xref:System.Windows.Application.NavigationProgress> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.NavigationStopped" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A>는 <xref:System.Windows.Application.NavigationStopped> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnNavigationStopped%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Application.OnNavigationStopped%2A> 기본 클래스의 경우 <xref:System.Windows.Application.NavigationStopped> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.SessionEndingCancelEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.SessionEnding" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A>는 <xref:System.Windows.Application.SessionEnding> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnSessionEnding%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Application.OnSessionEnding%2A> 기본 클래스의 경우 <xref:System.Windows.Application.SessionEnding> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.StartupEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Windows.Application.Startup" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A>는 <xref:System.Windows.Application.Startup> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnStartup%2A>합니다. 재정의 된 메서드를 호출 해야 <xref:System.Windows.Application.OnStartup%2A> 기본 클래스의 경우는 <xref:System.Windows.Application.Startup> 이벤트 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 범위 속성의 컬렉션을 가져옵니다.</summary>
        <value>응용 프로그램 범위 속성이 들어 있는 <see cref="T:System.Collections.IDictionary" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 사전을 통해 노출 <xref:System.Windows.Application.Properties%2A> 는 응용 프로그램 범위의 속성을 저장 하는 데 사용할 수 있습니다. 모든 코드에서 상태를 공유할 수 있습니다는 <xref:System.AppDomain> 고유한 상태 코드를 작성할 필요 없이 스레드로부터 안전한 방식입니다.  
  
 속성에 저장 된 <xref:System.Windows.Application.Properties%2A> 반환 되는 적절 한 형식으로 변환 해야 합니다.  
  
 <xref:System.Windows.Application.Properties%2A> 속성은 스레드로부터 안전 하 고 모든 스레드에서 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 어떻게 만들고 사용 하 여 응용 프로그램 범위의 속성을 사용 하 여 <xref:System.Windows.Application.Properties%2A>합니다.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] 응용 프로그램의 리소스에 대한 팩 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]를 제공하는 <see cref="T:System.Reflection.Assembly" />를 가져오거나 설정합니다.</summary>
        <value>[!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] 응용 프로그램의 리소스에 대한 팩 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]를 제공하는 <see cref="T:System.Reflection.Assembly" />에 대한 참조입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 리소스가 반환 되는 값으로 식별 되는 항목 어셈블리와 관련 하 여 실행 시 확인 되는 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 메서드.  
  
 진입 어셈블리에서 반환 되는 어셈블리는 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 다음 될 수 있습니다.  
  
-   기본 응용 프로그램 도메인에서 실행 가능한 어셈블리입니다.  
  
-   호출 하 여 실행할 첫 번째 어셈블리 <xref:System.AppDomain.ExecuteAssembly%2A>합니다.  
  
 그러나 다음과 같은 경우에는 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 어셈블리 항목 어셈블리에 대 한 참조를 가져올 수 없습니다.  
  
-   관리 되지 않는 (네이티브) 응용 프로그램 호스트는 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 어셈블리입니다.  
  
-   관리 되는 응용 프로그램 호스트는 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 이외의 메서드를 사용 하 여 새 응용 프로그램 도메인에 로드 하 여 어셈블리 <xref:System.AppDomain.ExecuteAssembly%2A>합니다.  
  
 이러한 경우 모두 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 반환 `null`, 및 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 어셈블리의 리소스를 확인할 수 없습니다. 이러한 경우 <xref:System.Windows.Application.ResourceAssembly%2A> 한 번만 리소스를 확인 하는 데 사용 해야 하는 어셈블리에 대 한 참조로 설정할 수 있습니다.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> 리소스 어셈블리가 후 변경 될 가능성이 없기 때문에 한 번 설정만 수는 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 어셈블리가 로드 합니다.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> 설정할 수 없습니다는 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 어셈블리 항목 어셈블리를 검색할 수 있습니다-즉, <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 어셈블리에 대 한 참조를 반환 하지 않고 `null`합니다.  
  
 이 속성은 스레드로부터 안전 하 고 모든 스레드에서 사용할 수 있습니다.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> .NET Framework 버전 3.5에서에서 도입 되었습니다.  자세한 내용은 [버전 및 종속성](~/docs/framework/migration-guide/versions-and-dependencies.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 응용 프로그램에 진입 어셈블리가 있거나 <see cref="P:System.Windows.Application.ResourceAssembly" />가 이미 설정된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 범위 리소스(예: 스타일 및 브러시)의 컬렉션을 가져오거나 설정합니다.</summary>
        <value>0개 이상의 응용 프로그램 범위 리소스가 들어 있는 <see cref="T:System.Windows.ResourceDictionary" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A> 속성 창과 응용 프로그램의 요소 간에 리소스를 공유 데 사용할 수 있습니다. 또한는 <xref:System.Windows.Application.Resources%2A> 속성 다음과 같은 순서로 트래버스 리소스 조회 경로에 포함 되어 있습니다.  
  
1.  요소  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  시스템  
  
 따라서 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 요소는 응용 프로그램 범위 리소스에 바인딩될 수 있습니다. 또한, 리소스 변경, 리소스 시스템 해당 요소 되도록 해당 리소스에 바인딩되는 속성의 변경 내용을 반영 하도록 자동으로 업데이트 됩니다.  
  
 응용 프로그램 범위 리소스 응용 프로그램 전체에서 일관 된 테마를 지원 하는 간단한 방법을 제공 합니다. 에 테마를 쉽게 만들 수 있습니다 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 를 사용 하 여는 `Application.Resources` 태그입니다. 그러나 응용 프로그램이 많은 테마 요소를 포함할 수도 있는 여러 테마를 지원 하기 쉬울 수 있습니다 하나를 사용 하 여 관리 <xref:System.Windows.ResourceDictionary> 각 테마에 대 한 인스턴스. 이러한 방식으로 새 테마에 적절 한 리소스 속성을 설정 하 여 적용 될 수 있는 <xref:System.Windows.ResourceDictionary>합니다.  
  
 사용 하는 경우를 확인 하려면 두 가지 고려 사항을 <xref:System.Windows.Application.Resources%2A>합니다. 먼저, 사전 *키* 은 개체를 설정 하 고 (참고는 문자열을 사용 하는 경우 키가 대/소문자 구분) 속성 값을 가져올 경우 정확히 동일한 개체 인스턴스를 사용 해야 합니다. 두 번째, 사전 *값* 개체 이므로 속성 값을 가져올 때 값을 원하는 형식으로 변환 해야 합니다.  
  
 <xref:System.Windows.Application.Resources%2A> 스레드로부터 안전 하 고 모든 스레드에서 사용할 수 있습니다.  
  
   
  
## Examples  
 사용 하는 방법을 보여 주는이 예제 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 일관성 있는 시각적 모양을 만들려는 응용 프로그램 범위 리소스와 함께 합니다.  
  
 [!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
 [!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml1)]  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml2)]  
  
 다음 예제 코드 및 XAML에서 응용 프로그램 리소스를 설정 하는 방법을 보여 줍니다.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml#setapplicationscoperesourcexaml)]  
  
 다음 예제에서는 코드에서 응용 프로그램 리소스를 가져오는 방법을 보여 줍니다.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Windows Presentation Foundation 응용 프로그램을 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Windows Presentation Foundation 응용 프로그램을 시작합니다.</summary>
        <returns>응용 프로그램이 종료될 때 운영 체제로 반환되는 <see cref="T:System.Int32" /> 응용 프로그램 종료 코드입니다. 기본적으로 종료 코드 값은 0입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> 시작 하기 위해 호출 됩니다는 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 응용 프로그램입니다. 정의 하는 경우 프로그램 <xref:System.Windows.Application> 태그 또는 태그 및 코드 숨김을 사용 하 여 <xref:System.Windows.Application.Run%2A> 암시적으로 호출 됩니다. 그러나 정의 하는 경우 프로그램 <xref:System.Windows.Application> 코드를 사용 해야 합니다를 명시적으로 호출 <xref:System.Windows.Application.Run%2A>합니다.  
  
 때 <xref:System.Windows.Application.Run%2A> 호출 <xref:System.Windows.Application> 새 연결 <xref:System.Windows.Threading.Dispatcher> 을 UI 스레드에 인스턴스. 다음으로 <xref:System.Windows.Threading.Dispatcher> 개체의 <xref:System.Windows.Threading.Dispatcher.Run%2A> windows 메시지를 처리 하는 메시지 펌프를 시작 하는 메서드가 호출 됩니다. 마지막으로,는 <xref:System.Windows.Threading.Dispatcher> 호출 개체는 <xref:System.Windows.Application> 개체의는 <xref:System.Windows.Application.OnStartup%2A> 를 발생 시키는 메서드는 <xref:System.Windows.Application.Startup> 이벤트입니다. 따라서 응용 프로그램 실행 모델 이미 처리할 때 설정 되었으며 <xref:System.Windows.Application.Startup>, 이때 응용 프로그램에 실행 되 고 것으로 간주 합니다.  
  
 응용 프로그램의 경우 실행이 중지 <xref:System.Windows.Application.Shutdown%2A> 버전이 호출 됩니다; 값은 <xref:System.Windows.Application.ShutdownMode%2A> 속성 시기를 결정 합니다. <xref:System.Windows.Application.Shutdown%2A> 호출 되 고 자동으로 수행 됨 또는 명시적으로 해야 하는지 여부를 호출 합니다.  
  
 <xref:System.Windows.Application.Run%2A> 만들어진 스레드에서만에서 호출할 수는 <xref:System.Windows.Application> 개체입니다. 또한 <xref:System.Windows.Application.Run%2A> 에서 호출할 수 없습니다는 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자 지정을 사용 하는 응용 프로그램 <xref:System.Windows.Application> 명시적으로 호출 해야 하므로 <xref:System.Windows.Application.Run%2A>합니다.  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          브라우저에서 호스팅된 응용 프로그램(예: [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)])에서 <see cref="M:System.Windows.Application.Run" />이 호출되는 경우</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">응용 프로그램이 시작될 때 자동으로 열리는 <see cref="T:System.Windows.Window" />입니다.</param>
        <summary>Windows Presentation Foundation 응용 프로그램을 시작하고 지정된 창을 엽니다.</summary>
        <returns>응용 프로그램이 종료될 때 운영 체제로 반환되는 <see cref="T:System.Int32" /> 응용 프로그램 종료 코드입니다. 기본적으로 종료 코드 값은 0입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드 확장은 <xref:System.Windows.Application.Run%2A> 메서드를 실행 중인 응용 프로그램이 시작 된 후 지정 된 창을 엽니다.  
  
 코드를 정의 하는 경우 <xref:System.Windows.Application> 하는 창을 엽니다.이 실행을 시작한 경우, 명시적으로 호출 <xref:System.Windows.Application.Run%2A>합니다.  
  
 만들면 사용자 <xref:System.Windows.Application> 태그 또는 태그 및 관련 코드를 사용 하 여 자동으로 창을 열 수 있습니다는 다음 방법 중 하나를 사용 하는 동안:  
  
-   설정 하 여 선언적 <xref:System.Windows.Application.StartupUri%2A>합니다.  
  
-   프로그래밍 방식으로 처리 하 여 <xref:System.Windows.Application.Startup>합니다.  
  
   
  
## Examples  
 다음 예제를 인스턴스화하는 정적 진입점 수동으로 만든 메서드를 응용 프로그램에서는 <xref:System.Windows.Application>를 호출 하기 전에 <xref:System.Windows.Application.Run%2A>합니다.  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          브라우저에서 호스팅된 응용 프로그램(예: [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)])에서 <see cref="M:System.Windows.Application.Run" />이 호출되는 경우</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 로그오프하거나 운영 체제를 종료하여 Windows 세션을 끝낼 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 응용 프로그램이 종료 될 때 사용자가 로그 오프 하거나 종료 되었을 때 발생 하는 Windows 세션이 종료 됩니다. 이 경우 Windows를 종료 하려면 각 열려 있는 응용 프로그램을 요청 합니다. 그러나 있기 응용 프로그램이 발생 하는 때를 종료할 준비가 되어 있지 않을 수 있습니다. 예를 들어 응용 프로그램 또는 장기 실행 작업 중에 일관성이 없는 상태에 있는 데이터가 있을 수 있습니다. 이러한 상황에서 세션 종료를 방지 하는 것이 바람직 수 있으며 사용자가 세션을 종료 여부를 결정 하는 옵션을 허용 하는 것이 더 효율적일 수 있습니다.  
  
 처리 하 여 세션이 끝날 때를 감지할 수 있습니다는 <xref:System.Windows.Application.SessionEnding> 이벤트입니다. 응용 프로그램 세션 종료 하지 못하도록 해야 하는 경우는 <xref:System.Windows.SessionEndingCancelEventArgs> 노출 하는 이벤트 처리기에 전달 되는 인수는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 로 설정 하는 `true` (기본값은 `false`) 합니다.  
  
 경우 <xref:System.Windows.Application.SessionEnding> 처리 되지 않은 또는 취소 하지 않고 처리 <xref:System.Windows.Application.Shutdown%2A> 라고 및 <xref:System.Windows.Application.Exit> 이벤트가 발생 합니다.  
  
 세션이 종료 되는 이유는 방법에 대 한 자세한 정보를 얻으려면 응용 프로그램을 검사할 수 <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, 중 하나인는 <xref:System.Windows.ReasonSessionEnding> 값 (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> 및 <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Application.SessionEnding> 콘솔 응용 프로그램에서 발생 하지 않습니다.  
  
 <xref:System.Windows.Application.SessionEnding> 만드는 스레드는에 발생 하는 <xref:System.Windows.Application> 개체입니다.  
  
 <xref:System.Windows.Application.SessionEnding> XAML 브라우저 응용 프로그램 (Xbap)에 대 한 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 <xref:System.Windows.Application.SessionEnding> 이벤트 취소 하 고 사용자입니다.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">쿠키를 만들어야 하는 위치를 지정하는 <see cref="T:System.Uri" />입니다.</param>
        <param name="value">쿠키 데이터가 들어 있는 <see cref="T:System.String" />입니다.</param>
        <summary>
          <see cref="T:System.Uri" />에 의해 지정된 위치에 대한 쿠키를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 쿠키는 응용 프로그램에서 클라이언트 컴퓨터에 응용 프로그램 세션 (세션 쿠키) 중 또는 응용 프로그램 세션 (영구 쿠키) 간에 저장 될 수 있는 데이터의 일부를 임의로. 호출 하 여 두 종류의 쿠키를 만들 수 있습니다 <xref:System.Windows.Application.SetCookie%2A>합니다.  
  
 쿠키 데이터는 일반적으로 다음과 같은 형식 이름/값 쌍 형식의 가집니다.  
  
 `Name=Value`  
  
 이 형식의 문자열을 전달 하면 <xref:System.Windows.Application.SetCookie%2A>와 함께 <xref:System.Uri> 쿠키를 설정 해야 하는 위치 (일반적으로 응용 프로그램 도메인).  
  
 에 전달 하는 쿠키는 세션 쿠키 또는 영구 쿠키 쿠키 문자열 여부에 따라 달라 집니다 <xref:System.Windows.Application.SetCookie%2A> 만료 날짜를 포함 합니다. 세션 쿠키에 대 한 문자열에서 한 만료 날짜를 포함 하지 않습니다. 영구 쿠키의 문자열에는 다음과 같은 형식 이어야 합니다.  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 영구 쿠키는 현재에서 저장 된 [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] 설치의 임시 인터넷 파일 폴더 만료 될 때까지,이 경우 삭제 됩니다. 만료 날짜가 과거 날짜/시간 값으로 설정 하 여 응용 프로그램에서 영구 쿠키를 삭제할 수 있습니다.  
  
 쿠키에 대 한 개요 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], 참조 [탐색 개요](~/docs/framework/wpf/app-development/navigation-overview.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">지정된 쿠키를 만드는 동안 문제가 발생하면 <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />에서 호출된 <see langword="InternetSetCookie" /> 함수에 의해 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 오류가 발생합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 기반에 대 한 쿠키를 가져오기 위한 <see cref="T:System.Uri" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">비-파일 기반에 대 한 쿠키를 가져오기 위한 <see cref="T:System.Uri" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>응용 프로그램을 종료합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램을 종료합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Windows.Application.Shutdown%2A> 호출 되는 응용 프로그램 실행을 중지 합니다. 처리할 수는 <xref:System.Windows.Application.Exit> 응용 프로그램은 적절 한 처리를 수행 하 고, 실행이 중지 시기를 감지 하는 이벤트입니다.  
  
 <xref:System.Windows.Application.Shutdown%2A> 가 암시적으로 호출 Windows Presentation Foundation에서 다음과 같은 경우:  
  
-   때 <xref:System.Windows.Application.ShutdownMode%2A> 로 설정 된 <xref:System.Windows.ShutdownMode.OnLastWindowClose>합니다.  
  
-   경우는 <xref:System.Windows.Application.ShutdownMode%2A> 로 설정 된 <xref:System.Windows.ShutdownMode.OnMainWindowClose>합니다.  
  
-   사용자 세션을 종료 하는 경우 및 <xref:System.Windows.Application.SessionEnding> 이벤트, 처리 되지 않은 또는 취소 하지 않고 처리 합니다.  
  
 호출 <xref:System.Windows.Application.Shutdown%2A> 명시적으로 응용 프로그램을 종료 하면에 관계 없이 <xref:System.Windows.Application.ShutdownMode%2A> 설정 합니다. 그러나 경우 <xref:System.Windows.Application.ShutdownMode%2A> 로 설정 되어 <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, 호출 해야 <xref:System.Windows.Application.Shutdown%2A> 응용 프로그램을 종료 합니다.  
  
> [!IMPORTANT]
>  때 <xref:System.Windows.Application.Shutdown%2A> 는 호출 응용 프로그램에서 종료 여부에 관계 없이 <xref:System.Windows.Window.Closing> 열린 창의 이벤트를 취소 합니다.  
  
 이 메서드를 만든 스레드가 에서만 호출할 수 있습니다는 <xref:System.Windows.Application> 개체입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">모든 창과 사용자 입력된 이벤트를 제한 없이 사용할 수 있는 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">응용 프로그램에 대한 정수 종료 코드입니다. 기본 종료 코드는 0입니다.</param>
        <summary>지정된 종료 코드를 운영 체제에 반환하는 응용 프로그램을 종료합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처리할 수는 <xref:System.Windows.Application.Exit> 종료 코드를 설정 하는 이벤트입니다. 그러나 명시적으로 호출 <xref:System.Windows.Application.Shutdown%2A>를 처리 하 고 <xref:System.Windows.Application.Exit> 만 호출할 수는 종료 코드를 설정 하려면 <xref:System.Windows.Application.Shutdown%2A> 대신 합니다.  
  
 이 메서드를 만든 스레드가 에서만 호출할 수 있습니다는 <xref:System.Windows.Application> 개체입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">모든 창과 사용자 입력된 이벤트를 제한 없이 사용할 수 있는 권한입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Windows.Application.Shutdown" /> 메서드가 호출되게 하는 조건을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Windows.ShutdownMode" /> 열거형 값입니다. 기본값은 <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램의 경우에만 실행이 중지 된 <xref:System.Windows.Application.Shutdown%2A> 응용 프로그램의 메서드가 호출 됩니다. 암시적 또는 명시적 값에 의해 지정 된 대로 종료 발생할 수 있습니다는 <xref:System.Windows.Application.ShutdownMode%2A> 속성입니다.  
  
 설정한 경우 <xref:System.Windows.Application.ShutdownMode%2A> 를 <xref:System.Windows.ShutdownMode.OnLastWindowClose>, Windows Presentation Foundation (WPF) 암시적으로 호출 <xref:System.Windows.Application.Shutdown%2A> 응용 프로그램의 마지막 창의 닫을 때, 현재 인스턴스화된 창이 주 창으로 설정 된 경우에 (참조 <xref:System.Windows.Application.MainWindow%2A>).  
  
 A <xref:System.Windows.Application.ShutdownMode%2A> 의 <xref:System.Windows.ShutdownMode.OnMainWindowClose> 암시적으로 호출 하는 wpf <xref:System.Windows.Application.Shutdown%2A> 때는 <xref:System.Windows.Application.MainWindow%2A> 다른 창이 현재 열려 있는 경우에 닫힙니다.  
  
 일부 응용 프로그램의 수명 때 주 창 또는 마지막 창이 닫혀 또는 데이터에 종속 되지 않을 수 있습니다 windows에 종속 전혀 아닐 수도 있습니다. 이러한 시나리오에 대해 설정 해야는 <xref:System.Windows.Application.ShutdownMode%2A> 속성을 <xref:System.Windows.ShutdownMode.OnExplicitShutdown>를 요구 하는 명시적 <xref:System.Windows.Application.Shutdown%2A> 메서드를 호출 하는 응용 프로그램을 중지 합니다. 그렇지 않으면 응용 프로그램이 백그라운드에서 실행을 계속 합니다.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> 선언적으로 구성할 수 있습니다 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 또는 코드에서 프로그래밍 방식으로 합니다.  
  
 이 속성은 작성 된 스레드에서 에서만 사용할 수는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 구성 방법을 보여 줍니다. <xref:System.Windows.Application.ShutdownMode%2A> 응용 프로그램을 명시적으로 닫아야를 지정할 수 있습니다.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Windows.Application.Run" /> 개체의 <see cref="T:System.Windows.Application" /> 메서드가 호출될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적인 Windows Presentation Foundation 응용 프로그램은 시작 될 때를 포함 하 여 다양 한 초기화 작업을 수행할 수 있습니다.  
  
-   명령줄 매개 변수를 처리 합니다.  
  
-   주 창 열기  
  
-   응용 프로그램 범위 리소스를 초기화 합니다.  
  
-   응용 프로그램 범위의 속성을 초기화 합니다.  
  
 주 창 및 사용 하 여 응용 프로그램 범위 리소스를 선언적으로 지정할 수 있습니다 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> 및 <xref:System.Windows.Application.Resources%2A>각각). 그러나 경우에 따라 리소스 또는 응용 프로그램의 주 창 수만 결정 되는 프로그래밍 방식으로 런타임에 합니다. 또한 응용 프로그램 범위의 속성 및 명령줄 매개 변수 에서만 사용할 수 있습니다 프로그래밍 방식으로. 처리 하 여 프로그래밍 방식으로 초기화를 수행할 수는 <xref:System.Windows.Application.Startup> 다음을 포함 한 이벤트:  
  
-   가져오고 처리에서 사용할 수 있는 명령줄 매개 변수는 <xref:System.Windows.StartupEventArgs.Args%2A> 속성은 <xref:System.Windows.StartupEventArgs> 에 전달 되는 클래스는 <xref:System.Windows.Application.Startup> 이벤트 처리기입니다.  
  
-   응용 프로그램 범위 리소스를 사용 하 여 초기화 된 <xref:System.Windows.Application.Resources%2A> 속성입니다.  
  
-   응용 프로그램 범위의 속성을 사용 하 여 초기화 된 <xref:System.Windows.Application.Properties%2A> 속성입니다.  
  
-   인스턴스화하고 (일부) 창을 표시 합니다.  
  
> [!NOTE]
>  명령줄 매개 변수는 정적을 호출 하 여 가져올 수도 있습니다 <xref:System.Environment.GetCommandLineArgs%2A> 의 메서드는 <xref:System.Environment> 개체입니다. 그러나 <xref:System.Environment.GetCommandLineArgs%2A> 실행 되려면 완전 신뢰가 필요 합니다.  
  
 설정 하는 경우 <xref:System.Windows.Application.StartupUri%2A> 를 사용 하 여 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], 만들어지는 주 창에서 사용할 수 없는 <xref:System.Windows.Application.MainWindow%2A> 속성 또는 <xref:System.Windows.Application.Windows%2A> 의 속성은 <xref:System.Windows.Application> 후 될 때까지 개체는 <xref:System.Windows.Application.Startup> 이벤트가 처리 됩니다. 시작 하는 동안 주 창에 대 한 액세스를 해야 하는 경우 수동으로에서 새 창 개체를 만들어야 할 프로그램 <xref:System.Windows.Application.Startup> 이벤트 처리기입니다.  
  
> [!NOTE]
>  응용 프로그램을 사용 하는 경우 <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> 자격 증명 정책을 지정 하려면 설정 해야 <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> 후 <xref:System.Windows.Application.Startup> 발생 되지 않았으면, [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 기본 내부 정책에 직접 후 설정는 <xref:System.Windows.Application.Startup> 이벤트가 발생 합니다.  
  
 에 전달 되는 명령줄 인수는 <xref:System.Windows.Application.Startup> 이벤트 처리기와 동일 하지 않은 [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] 쿼리에 전달 되는 문자열 매개 변수는 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제를 획득 하 고 독립 실행형 응용 프로그램에서 명령줄 옵션을 처리 하는 방법을 보여 줍니다. 경우는 **/StartMinimized** 명령줄 매개 변수가 제공 된, 응용 프로그램 최소화 된 상태로 주 창을 엽니다.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] 검색 및 사용 시작 되기 때문에 명령줄 인수를 처리할 수 없습니다 [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] 배포 (참조 [WPF 응용 프로그램 (WPF) 배포](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)). 그러나 XBAP를 시작하는 데 사용되는 URL에서 쿼리 문자열 매개 변수를 검색하고 처리할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 시작될 때 자동으로 표시되는 UI를 가져오거나 설정합니다.</summary>
        <value>A <see cref="T:System.Uri" /> 참조 하는 UI를 응용 프로그램 시작 될 때 자동으로 열립니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수 있습니다 <xref:System.Windows.Application.StartupUri%2A> 응용 프로그램이 시작 될 때 자동으로 UI 리소스를 로드 합니다.  
  
 다음 표에서 로드할 수 있는 UI 리소스의 형식, 열리는 창 유형 및 이러한 리소스도 설정할 수 있는 응용 프로그램 종류는 <xref:System.Windows.Application.StartupUri%2A>합니다.  
  
|형식|창|응용 프로그램 유형|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|독립 실행형만|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|독립 실행형만|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|독립 실행형/브라우저 호스팅|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|독립 실행형/브라우저 호스팅|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|독립 실행형/브라우저 호스팅|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|독립 실행형/브라우저 호스팅|  
  
 일반적으로 설정 된 <xref:System.Windows.Application.StartupUri%2A> 속성에서 선언적으로 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]합니다. 설정할 수 있습니다 <xref:System.Windows.Application.StartupUri%2A> 프로그래밍 방식으로 <xref:System.Windows.Application.Startup> 이벤트 처리기를 실행할 때만 필수 UI 리소스를 로드할 수 있는 응용 프로그램에 있는 경우 유용 합니다. 예를 들어 응용 프로그램 UI 리소스의 이름을 구성 파일에 저장 되는 경우 해당 리소스를 로드 하는 런타임이 될 때까지 기다릴 수 있습니다.  
  
 설정 여부 <xref:System.Windows.Application.StartupUri%2A> 될 때까지 해당 하는 UI 리소스 로드 되지 않았습니다. 프로그래밍 방식으로 또는 선언적으로 후의 <xref:System.Windows.Application.Startup> 이벤트를 처리 합니다. 따라서 액세스할 수 없습니다 결과 창에 중 하 나와 <xref:System.Windows.Application.Windows%2A> 속성 또는 <xref:System.Windows.Application.MainWindow%2A> 속성을 처리할 때 <xref:System.Windows.Application.Startup>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Windows.Application.StartupUri" />가 null 값으로 설정된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">요청된 앰비언트 속성의 이름입니다.</param>
        <summary>지정된 앰비언트 속성을 현재 범위에서 사용할 수 있는지 여부에 대한 쿼리입니다.</summary>
        <returns>
          요청된 앰비언트 속성을 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.Application> 인스턴스가 <xref:System.Windows.Markup.IQueryAmbient> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">찾을 리소스 이름입니다.</param>
        <summary>지정된 리소스를 검색합니다.</summary>
        <returns>요청된 리소스 개체입니다. 요청된 리소스가 없으면 null 참조가 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> 지정된 된 리소스에 대 한 응용 프로그램 범위 리소스에서 소개 됩니다. 응용 프로그램 범위 리소스 관리 <xref:System.Windows.Application>에서 노출 하 고는 <xref:System.Windows.Application.Resources%2A> 속성입니다. 지정된 된 리소스는 응용 프로그램 범위 리소스 집합에 없는 경우 <xref:System.Windows.Application.TryFindResource%2A> 다음 시스템 리소스를 검색 합니다. 시스템 리소스는 사용자가 정의한 shell 리소스 있으며 색, 글꼴 및 셸 구성을 포함 합니다. 노출 된 <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, 및 <xref:System.Windows.SystemParameters> 각각 정적 속성입니다. 사용 하도록 <xref:System.Windows.Application.TryFindResource%2A> 을 얻은를 이러한 형식 속성을 노출 리소스 키를 전달 하도록 디자인 된 <xref:System.Windows.Application.TryFindResource%2A>등 <xref:System.Windows.SystemParameters.IconWidthKey%2A>합니다.  
  
 때문에 <xref:System.Windows.Application.TryFindResource%2A> 개체를 반환 리소스를 찾을 경우 적절 한 형식으로 반환된 된 값을 캐스팅 해야 합니다.  
  
 이 메서드는 스레드로부터 안전 하 고 모든 스레드에서 호출할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다. <xref:System.Windows.Application.TryFindResource%2A> 리소스 획득 합니다.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 인스턴스화된 창을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Windows.WindowCollection" />의 모든 창 개체에 대한 참조가 들어 있는 <see cref="T:System.AppDomain" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Window> 참조가에 자동으로 추가 됩니다 <xref:System.Windows.Application.Windows%2A> 창이 인스턴스화됩니다으로 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 스레드; windows 스레드는 추가 작업자에 의해 만들어진 합니다. A <xref:System.Windows.Window> 참조 한 후 자동으로 제거 됩니다 해당 <xref:System.Windows.Window.Closing> 이벤트를 처리 하기 전에 해당 <xref:System.Windows.Window.Closed> 이벤트가 발생 합니다.  
  
 기본적으로 첫 번째 항목에 추가 <xref:System.Windows.Application.Windows%2A> 속성이 하 게 되는 <xref:System.Windows.Application.MainWindow%2A>합니다.  
  
 이 속성은 작성 된 스레드에서 에서만 사용할 수는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 열거 하는 방법을 <xref:System.Windows.Application.Windows%2A> 속성에 공통적인 최상위 창 메뉴를 만들려는 [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] 와 같은 응용 프로그램이 [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)]와 같은 다중 인스턴스 인터페이스 SDI (단일 문서) 응용 프로그램 또는 [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>