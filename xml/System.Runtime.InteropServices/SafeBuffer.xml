<Type Name="SafeBuffer" FullName="System.Runtime.InteropServices.SafeBuffer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="75b109650bc09c5660bda32818a0982011ca6ad0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SafeBuffer : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SafeBuffer extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeBuffer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeBuffer&#xA;Inherits SafeHandleZeroOrMinusOneIsInvalid" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeBuffer abstract : Microsoft::Win32::SafeHandles::SafeHandleZeroOrMinusOneIsInvalid" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.InteropServices.SafeHandle</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="8b1e6-101">읽기 및 쓰기에 사용할 수 있는 제어되는 메모리 버퍼를 제공합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8b1e6-101">Provides a controlled memory buffer that can be used for reading and writing.</span>
      </span>
      <span data-ttu-id="8b1e6-102">제어되는 버퍼 외부의 메모리에 액세스(언더런 및 오버런)하려고 하면 예외가 발생합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8b1e6-102">Attempts to access memory outside the controlled buffer (underruns and overruns) raise exceptions.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b1e6-103">호출 해야 합니다는 <xref:System.Runtime.InteropServices.SafeBuffer.Initialize%2A?displayProperty=nameWithType> 메서드의 모든 인스턴스를 사용 하기 전에 <xref:System.Runtime.InteropServices.SafeBuffer>합니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-103">You must call the <xref:System.Runtime.InteropServices.SafeBuffer.Initialize%2A?displayProperty=nameWithType> method before you use any instance of <xref:System.Runtime.InteropServices.SafeBuffer>.</span></span> <span data-ttu-id="8b1e6-104">인스턴스를 저장 하는 경우 경합을 방지 하기 위해는 <xref:System.Runtime.InteropServices.SafeBuffer> 개체를 정적 변수에 다음 방법 중 하나를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-104">To avoid races when you store an instance of a <xref:System.Runtime.InteropServices.SafeBuffer> object in a static variable, you should use one of the following approaches:</span></span>  
  
-   <span data-ttu-id="8b1e6-105">게시할 때 잠금을 만듭니다는 <xref:System.Runtime.InteropServices.SafeBuffer>합니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-105">Create a lock when publishing the <xref:System.Runtime.InteropServices.SafeBuffer>.</span></span>  
  
-   <span data-ttu-id="8b1e6-106">로컬 변수를 초기화할 만들기는 <xref:System.Runtime.InteropServices.SafeBuffer>, 한 다음 할당는 <xref:System.Runtime.InteropServices.SafeBuffer> 를 정적 변수에 예를 들어, 사용 하 여는 <xref:System.Threading.Interlocked.CompareExchange%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-106">Create a local variable, initialize the <xref:System.Runtime.InteropServices.SafeBuffer>, and then assign the <xref:System.Runtime.InteropServices.SafeBuffer> to the static variable, for example, by using the <xref:System.Threading.Interlocked.CompareExchange%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8b1e6-107">정적 클래스 생성자에서 암시적으로 잠깁니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-107">Assignments in a static class constructor are implicitly locked.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.SecurityCriticalAttribute">
      <span data-ttu-id="8b1e6-108">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8b1e6-108">requires full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="8b1e6-109">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8b1e6-109">This member cannot be used by partially trusted or transparent code.</span>
      </span>
    </permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeBuffer (bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeBuffer(bool ownsHandle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ownsHandle">
          <span data-ttu-id="8b1e6-110">종료 단계에서 안정적으로 핸들을 해제하려면 <see langword="true" />이고, 안정적으로 해제되지 않게 하려면 <see langword="false" />입니다(권장되지 않음).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-110">
              <see langword="true" /> to reliably release the handle during the finalization phase; <see langword="false" /> to prevent reliable release (not recommended).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b1e6-111">
            <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 클래스의 새 인스턴스를 만들고 버퍼 핸들이 안정적으로 해제될지 여부를 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-111">Creates a new instance of the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> class, and specifies whether the buffer handle is to be reliably released.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8b1e6-112">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-112">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8b1e6-113">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-113">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="AcquirePointer">
      <MemberSignature Language="C#" Value="public void AcquirePointer (ref byte* pointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquirePointer(unsigned int8*&amp; pointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.AcquirePointer(System.Byte*@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquirePointer(System::Byte* % pointer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="8b1e6-114">
            <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 개체 내부에서 포인터를 받기 위해 참조에서 전달하는 바이트 포인터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-114">A byte pointer, passed by reference, to receive the pointer from within the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> object.</span>
          </span>
          <span data-ttu-id="8b1e6-115">이 메서드를 호출하기 전에 이 포인터를 <see langword="null" />로 설정해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-115">You must set this pointer to <see langword="null" /> before you call this method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b1e6-116">
            <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 개체에서 메모리 블록에 대한 포인터를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-116">Obtains a pointer from a <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> object for a block of memory.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b1e6-117">때 <xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> 반환 범위 있는지 확인 하 여 검사를 수행 해야는 `pointer` 매개 변수는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-117">When <xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> returns, you should perform bounds checking by verifying that the `pointer` parameter is `null`.</span></span> <span data-ttu-id="8b1e6-118">없으면 `null`를 호출 해야 합니다는 <xref:System.Runtime.InteropServices.SafeBuffer.ReleasePointer%2A?displayProperty=nameWithType> (CER) 제약이 있는 실행 영역에는 메서드.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-118">If it is not `null`, you must call the <xref:System.Runtime.InteropServices.SafeBuffer.ReleasePointer%2A?displayProperty=nameWithType> method in a constrained execution region (CER).</span></span>  
  
 <span data-ttu-id="8b1e6-119"><xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> 호출 된 <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A?displayProperty=nameWithType> 메서드 포인터를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-119"><xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> calls the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A?displayProperty=nameWithType> method and exposes the pointer.</span></span> <span data-ttu-id="8b1e6-120">와 달리는 <xref:System.Runtime.InteropServices.SafeBuffer.Read%2A> 메서드, 포인터의 현재 위치를 변경 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-120">Unlike the <xref:System.Runtime.InteropServices.SafeBuffer.Read%2A> method, it does not change the current position of the pointer.</span></span>  
  
 <span data-ttu-id="8b1e6-121">다음 exampledemonstrates 사용 하는 방법의 <xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> 메서드:</span><span class="sxs-lookup"><span data-stu-id="8b1e6-121">The following exampledemonstrates how to use the <xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> method:</span></span>  
  
```  
byte* pointer = null;  
RuntimeHelpers.PrepareConstrainedRegions();  
try {  
    MySafeBuffer.AcquirePointer(ref pointer);  
    // Use pointer here, with your own bounds checking.  
    }  
finally {  
    if (pointer != null)  
        MySafeBuffer.ReleasePointer();  
    }  
```  
  
 <span data-ttu-id="8b1e6-122">캐스팅 하는 경우 `pointer` (되는 바이트에 대 한 포인터)를 다른 유형 (T \*) 포인터로 포인터 맞춤 문제가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-122">If you cast `pointer` (which is a pointer to a byte) as a pointer to a different type (T\*), you may have pointer alignment issues.</span></span>  
  
 <span data-ttu-id="8b1e6-123">이 포인터를 확인 하 여 모든 범위에 대 한 책임을 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-123">You must take responsibility for all bounds checking with this pointer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b1e6-124">
            <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 메서드가 호출되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-124">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ByteLength">
      <MemberSignature Language="C#" Value="public ulong ByteLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int64 ByteLength" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeBuffer.ByteLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ByteLength As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::UInt64 ByteLength { System::UInt64 get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b1e6-125">버퍼의 크기(바이트)를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-125">Gets the size of the buffer, in bytes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b1e6-126">메모리 버퍼의 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-126">The number of bytes in the memory buffer.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b1e6-127">
            <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 메서드가 호출되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-127">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Initialize">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8b1e6-128">할당할 메모리 버퍼의 크기를 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-128">Specifies the size of the memory buffer to allocate.</span>
          </span>
          <span data-ttu-id="8b1e6-129">
            <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 인스턴스를 사용하려면 먼저 이 메서드를 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-129">You must call this method before you use the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> instance.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize (ulong numBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize(unsigned int64 numBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Initialize(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize (numBytes As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize(System::UInt64 numBytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numBytes" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="numBytes">
          <span data-ttu-id="8b1e6-130">버퍼의 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-130">The number of bytes in the buffer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b1e6-131">메모리 영역의 할당 크기(바이트)를 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-131">Defines the allocation size of the memory region in bytes.</span>
          </span>
          <span data-ttu-id="8b1e6-132">
            <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 인스턴스를 사용하려면 먼저 이 메서드를 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-132">You must call this method before you use the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> instance.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8b1e6-133">
            <paramref name="numBytes" />가 0보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-133">
              <paramref name="numBytes" /> is less than zero.</span>
          </span>
          <span data-ttu-id="8b1e6-134">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-134">-or-</span>
          </span>
          <span data-ttu-id="8b1e6-135">
            <paramref name="numBytes" />가 사용 가능한 주소 공간보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-135">
              <paramref name="numBytes" /> is greater than the available address space.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize (uint numElements, uint sizeOfEachElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize(unsigned int32 numElements, unsigned int32 sizeOfEachElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Initialize(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize (numElements As UInteger, sizeOfEachElement As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize(System::UInt32 numElements, System::UInt32 sizeOfEachElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numElements" Type="System.UInt32" />
        <Parameter Name="sizeOfEachElement" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="numElements">
          <span data-ttu-id="8b1e6-136">버퍼의 요소 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-136">The number of elements in the buffer.</span>
          </span>
        </param>
        <param name="sizeOfEachElement">
          <span data-ttu-id="8b1e6-137">버퍼의 각 요소 크기입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-137">The size of each element in the buffer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b1e6-138">지정된 요소 수 및 요소 크기를 사용하여 메모리 버퍼의 할당 크기를 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-138">Specifies the allocation size of the memory buffer by using the specified number of elements and element size.</span>
          </span>
          <span data-ttu-id="8b1e6-139">
            <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 인스턴스를 사용하려면 먼저 이 메서드를 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-139">You must call this method before you use the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b1e6-140">이 메서드는 각 요소의 크기와 곱하면 배열의 요소 수와 필요한 크기의 메모리 영역을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-140">This method defines the required size of the memory region as the number of elements in an array multiplied by the size of each element.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8b1e6-141">
            <paramref name="numElements" />가 0보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-141">
              <paramref name="numElements" /> is less than zero.</span>
          </span>
          <span data-ttu-id="8b1e6-142">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-142">-or-</span>
          </span>
          <span data-ttu-id="8b1e6-143">
            <paramref name="sizeOfEachElement" />가 0보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-143">
              <paramref name="sizeOfEachElement" /> is less than zero.</span>
          </span>
          <span data-ttu-id="8b1e6-144">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-144">-or-</span>
          </span>
          <span data-ttu-id="8b1e6-145">
            <paramref name="numElements" />에 <paramref name="sizeOfEachElement" />를 곱한 크기가 사용 가능한 주소 공간보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-145">
              <paramref name="numElements" /> multiplied by <paramref name="sizeOfEachElement" /> is greater than the available address space.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Initialize&lt;T&gt; (uint numElements) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int32 numElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Initialize``1(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize(Of T As Structure) (numElements As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void Initialize(System::UInt32 numElements);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="numElements" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="8b1e6-146">메모리를 할당할 값 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-146">The value type to allocate memory for.</span>
          </span>
        </typeparam>
        <param name="numElements">
          <span data-ttu-id="8b1e6-147">메모리를 할당할 값 형식의 요소 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-147">The number of elements of the value type to allocate memory for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b1e6-148">값 형식의 수를 지정하여 메모리 영역의 할당 크기를 정의합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-148">Defines the allocation size of the memory region by specifying the number of value types.</span>
          </span>
          <span data-ttu-id="8b1e6-149">
            <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 인스턴스를 사용하려면 먼저 이 메서드를 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-149">You must call this method before you use the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> instance.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8b1e6-150">
            <paramref name="numElements" />가 0보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-150">
              <paramref name="numElements" /> is less than zero.</span>
          </span>
          <span data-ttu-id="8b1e6-151">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-151">-or-</span>
          </span>
          <span data-ttu-id="8b1e6-152">
            <paramref name="numElements" />는 각 요소의 크기를 곱한 것으로 사용 가능한 주소 공간보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-152">
              <paramref name="numElements" /> multiplied by the size of each element is greater than the available address space.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public override bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeBuffer.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsInvalid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T Read&lt;T&gt; (ulong byteOffset) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T Read&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Read``1(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read(Of T As Structure) (byteOffset As ULong) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class T Read(System::UInt64 byteOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="8b1e6-153">읽을 값 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-153">The value type to read.</span>
          </span>
        </typeparam>
        <param name="byteOffset">
          <span data-ttu-id="8b1e6-154">값 형식을 읽어올 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-154">The location from which to read the value type.</span>
          </span>
          <span data-ttu-id="8b1e6-155">정렬 문제를 고려해야 할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-155">You may have to consider alignment issues.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b1e6-156">메모리의 지정된 오프셋 위치에서 값 형식을 읽습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-156">Reads a value type from memory at the specified offset.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b1e6-157">메모리에서 읽어온 값 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-157">The value type that was read from memory.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b1e6-158">
            <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 메서드가 호출되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-158">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span>
          </span>
        </exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.Write``1(System.UInt64,``0)" />
      </Docs>
    </Member>
    <Member MemberName="ReadArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void ReadArray&lt;T&gt; (ulong byteOffset, T[] array, int index, int count) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadArray&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset, !!T[] array, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.ReadArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadArray(Of T As Structure) (byteOffset As ULong, array As T(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void ReadArray(System::UInt64 byteOffset, cli::array &lt;T&gt; ^ array, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="8b1e6-159">읽을 값 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-159">The value type to read.</span>
          </span>
        </typeparam>
        <param name="byteOffset">
          <span data-ttu-id="8b1e6-160">읽기를 시작할 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-160">The location from which to start reading.</span>
          </span>
        </param>
        <param name="array">
          <span data-ttu-id="8b1e6-161">쓸 출력 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-161">The output array to write to.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="8b1e6-162">출력 배열에서 쓰기를 시작할 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-162">The location in the output array to begin writing to.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="8b1e6-163">입력 배열에서 읽어서 출력 배열에 쓸 값 형식의 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-163">The number of value types to read from the input array and to write to the output array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b1e6-164">메모리의 오프셋 시작 위치에서 지정된 수의 값 형식을 읽어서 이를 배열의 인덱스 시작 위치에 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-164">Reads the specified number of value types from memory starting at the offset, and writes them into an array starting at the index.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8b1e6-165">
            <paramref name="index" />가 0보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-165">
              <paramref name="index" /> is less than zero.</span>
          </span>
          <span data-ttu-id="8b1e6-166">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-166">-or-</span>
          </span>
          <span data-ttu-id="8b1e6-167">
            <paramref name="count" />가 0보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-167">
              <paramref name="count" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b1e6-168">
            <paramref name="array" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-168">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8b1e6-169">배열에서 인덱스를 뺀 길이가 <paramref name="count" />보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-169">The length of the array minus the index is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b1e6-170">
            <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 메서드가 호출되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-170">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span>
          </span>
        </exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.WriteArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReleasePointer">
      <MemberSignature Language="C#" Value="public void ReleasePointer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleasePointer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.ReleasePointer" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleasePointer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleasePointer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b1e6-171">
            <see cref="M:System.Runtime.InteropServices.SafeBuffer.AcquirePointer(System.Byte*@)" /> 메서드에서 가져온 포인터를 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-171">Releases a pointer that was obtained by the <see cref="M:System.Runtime.InteropServices.SafeBuffer.AcquirePointer(System.Byte*@)" /> method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b1e6-172">이 메서드가 반환 된 후 포인터를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-172">After this method returns, the pointer cannot be used.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b1e6-173">
            <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 메서드가 호출되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-173">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Write&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Write&lt;T&gt; (ulong byteOffset, T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Write``1(System.UInt64,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write(Of T As Structure) (byteOffset As ULong, value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void Write(System::UInt64 byteOffset, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="8b1e6-174">쓸 값 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-174">The value type to write.</span>
          </span>
        </typeparam>
        <param name="byteOffset">
          <span data-ttu-id="8b1e6-175">쓰기를 시작할 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-175">The location at which to start writing.</span>
          </span>
          <span data-ttu-id="8b1e6-176">정렬 문제를 고려해야 할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-176">You may have to consider alignment issues.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b1e6-177">작성할 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-177">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b1e6-178">메모리의 지정된 위치에 값 형식을 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-178">Writes a value type to memory at the given location.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b1e6-179">이 메서드는 다음 코드와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-179">This method is equivalent to the following code:</span></span>  
  
```  
*(T*)(bytePtr + byteOffset) = value;  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b1e6-180">
            <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 메서드가 호출되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-180">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span>
          </span>
        </exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.Read``1(System.UInt64)" />
      </Docs>
    </Member>
    <Member MemberName="WriteArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void WriteArray&lt;T&gt; (ulong byteOffset, T[] array, int index, int count) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteArray&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset, !!T[] array, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.WriteArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteArray(Of T As Structure) (byteOffset As ULong, array As T(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void WriteArray(System::UInt64 byteOffset, cli::array &lt;T&gt; ^ array, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="8b1e6-181">쓸 값 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-181">The value type to write.</span>
          </span>
        </typeparam>
        <param name="byteOffset">
          <span data-ttu-id="8b1e6-182">메모리에서 쓸 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-182">The location in memory to write to.</span>
          </span>
        </param>
        <param name="array">
          <span data-ttu-id="8b1e6-183">입력 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-183">The input array.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="8b1e6-184">배열에서 읽기를 시작할 오프셋입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-184">The offset in the array to start reading from.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="8b1e6-185">쓸 값 형식의 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-185">The number of value types to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b1e6-186">입력 배열의 지정된 위치에서 시작하여 바이트를 읽어 메모리 위치에 지정된 수의 값 형식을 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-186">Writes the specified number of value types to a memory location by reading bytes starting from the specified location in the input array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b1e6-187">클래스의 제네릭 값 형식 입력된 배열의 각 요소에에서 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b1e6-187">Each element in the input array consists of the generic value type of the class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b1e6-188">
            <paramref name="array" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-188">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8b1e6-189">
            <paramref name="index" /> 또는 <paramref name="count" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-189">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8b1e6-190">입력 배열에서 <paramref name="index" />를 뺀 길이가 <paramref name="count" />보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-190">The length of the input array minus <paramref name="index" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b1e6-191">
            <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 메서드가 호출되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b1e6-191">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span>
          </span>
        </exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.ReadArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>