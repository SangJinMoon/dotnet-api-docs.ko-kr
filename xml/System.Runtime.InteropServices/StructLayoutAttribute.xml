<Type Name="StructLayoutAttribute" FullName="System.Runtime.InteropServices.StructLayoutAttribute">
  <TypeSignature Language="C#" Value="public sealed class StructLayoutAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit StructLayoutAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.StructLayoutAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StructLayoutAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class StructLayoutAttribute sealed : Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="e66bf-101">메모리에 있는 클래스 또는 구조체의 데이터 필드에 대한 실제 레이아웃을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-101">Lets you control the physical layout of the data fields of a class or structure in memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e66bf-102">이 특성은 클래스 또는 구조체에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-102">You can apply this attribute to classes or structures.</span></span>  
  
 <span data-ttu-id="e66bf-103">공용 언어 런타임 클래스 또는 구조체의 관리 되는 메모리의 데이터 필드의 실제 레이아웃을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-103">The common language runtime controls the physical layout of the data fields of a class or structure in managed memory.</span></span> <span data-ttu-id="e66bf-104">그러나 해당 형식을 관리 되지 않는 코드에 전달 하려는 경우 사용할 수 있습니다는 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 특성 형식이 관리 되지 않는 레이아웃을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-104">However, if you want to pass the type to unmanaged code, you can use the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute to control the unmanaged layout of the type.</span></span> <span data-ttu-id="e66bf-105">가 있는 특성을 사용 하 여 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 하며 멤버 순서 대로 순차적으로 레이아웃 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-105">Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> to force the members to be laid out sequentially in the order they appear.</span></span> <span data-ttu-id="e66bf-106"><xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 모두 관리 되는 메모리의 레이아웃 및 관리 되지 않는 메모리의 레이아웃을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-106">For , <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> controls both the layout in managed memory and the layout in unmanaged memory.</span></span> <span data-ttu-id="e66bf-107">비 blittable 형식 레이아웃 클래스 또는 구조체 비관리 코드로 마샬링되 하지만 관리 되는 메모리의 레이아웃을 제어 하지는 않습니다 때 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-107">For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory.</span></span> <span data-ttu-id="e66bf-108">가 있는 특성을 사용 하 여 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 각 데이터 멤버의 정확한 위치를 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-108">Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> to control the precise position of each data member.</span></span> <span data-ttu-id="e66bf-109">이 둘 다 blittable 형식 및 비 blittable 형식에 대 한 관리 되는 관리 되지 않는 레이아웃을 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-109">This affects both managed and unmanaged layout, for both blittable and non-blittable types.</span></span> <span data-ttu-id="e66bf-110">사용 하 여 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 사용 해야 하는 <xref:System.Runtime.InteropServices.FieldOffsetAttribute> 형식 내에서 각 필드의 위치를 나타내는 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-110">Using <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> requires that you use the <xref:System.Runtime.InteropServices.FieldOffsetAttribute> attribute to indicate the position of each field within the type.</span></span>  
  
 <span data-ttu-id="e66bf-111">C#, Visual Basic 및 c + + 컴파일러에서 적용 된 <xref:System.Runtime.InteropServices.LayoutKind.Sequential> 기본적으로 구조에 레이아웃 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-111">C#, Visual Basic, and C++ compilers apply the <xref:System.Runtime.InteropServices.LayoutKind.Sequential> layout value to structures by default.</span></span> <span data-ttu-id="e66bf-112">클래스에 대 한 적용 해야 합니다는 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 값을 명시적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-112">For classes, you must apply the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> value explicitly.</span></span> <span data-ttu-id="e66bf-113">[Tlbimp.exe (형식 라이브러리 가져오기)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) 도 적용 됩니다는 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 특성; 항상 적용는 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 형식 라이브러리를 가져올 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-113">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) also applies the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute; it always applies the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> value when it imports a type library.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e66bf-114">다음 예제에서는 관리 되는 선언 된 `GetSystemTime` 작동 하 고 정의 `MySystemTime` 클래스와 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 레이아웃 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-114">The following example demonstrates a managed declaration of the `GetSystemTime` function and defines `MySystemTime` class with <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> layout.</span></span> <span data-ttu-id="e66bf-115">`GetSystemTime` 시스템 시간을 가져오고 콘솔에 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-115">`GetSystemTime` gets the system time and prints to the console.</span></span>  
  
 [!code-cpp[StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/StructLayoutAttribute/CPP/structlayoutattribute.cpp#1)]
 [!code-csharp[StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/StructLayoutAttribute/CS/structlayoutattribute.cs#1)]
 [!code-vb[StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StructLayoutAttribute/VB/structlayoutattribute.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e66bf-116"><see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-116">Initalizes a new instance of the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StructLayoutAttribute (short layoutKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int16 layoutKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (layoutKind As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StructLayoutAttribute(short layoutKind);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="layoutKind" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="layoutKind"><span data-ttu-id="e66bf-117">클래스나 구조체의 정렬 방법을 지정하는 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 값 중 하나를 나타내는 16비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-117">A 16-bit integer that represents one of the <see cref="T:System.Runtime.InteropServices.LayoutKind" /> values that specifes how the class or structure should be arranged.</span></span></param>
        <summary><span data-ttu-id="e66bf-118">지정된 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 열거형 멤버를 사용하여 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-118">Initalizes a new instance of the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> class with the specified <see cref="T:System.Runtime.InteropServices.LayoutKind" /> enumeration member.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e66bf-119">이 생성자는 기본 16 비트 정수를 각각 나타내는 <xref:System.Runtime.InteropServices.LayoutKind> 열거형 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-119">This constructor takes an underlying 16-bit integer that represents each <xref:System.Runtime.InteropServices.LayoutKind> enumeration member.</span></span> <span data-ttu-id="e66bf-120">[Tlbimp.exe (형식 라이브러리 가져오기)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) 이 생성자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-120">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) uses this constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.LayoutKind" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StructLayoutAttribute (System.Runtime.InteropServices.LayoutKind layoutKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Runtime.InteropServices.LayoutKind layoutKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StructLayoutAttribute(System::Runtime::InteropServices::LayoutKind layoutKind);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="layoutKind" Type="System.Runtime.InteropServices.LayoutKind" />
      </Parameters>
      <Docs>
        <param name="layoutKind"><span data-ttu-id="e66bf-121">클래스나 구조체의 정렬 방법을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-121">One of the enumeration values that specifes how the class or structure should be arranged.</span></span></param>
        <summary><span data-ttu-id="e66bf-122">지정된 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 열거형 멤버를 사용하여 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-122">Initalizes a new instance of the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> class with the specified <see cref="T:System.Runtime.InteropServices.LayoutKind" /> enumeration member.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e66bf-123">오류가 발생할 가능성이 감소 되는 읽을 수 있는 코드에 대 한 항상이 생성자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-123">For readable code that is less prone to error, always use this constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.LayoutKind" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e66bf-124">클래스 내의 문자열 데이터 필드가 기본적으로 <see langword="LPWSTR" /> 또는 <see langword="LPSTR" />(으)로 마샬링되어야 하는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-124">Indicates whether string data fields within the class should be marshaled as <see langword="LPWSTR" /> or <see langword="LPSTR" /> by default.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e66bf-125">경우는 `CharSet` 필드가로 설정 된 <xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType>, 모든 문자열 인수는 유니코드 문자로 변환 되는지 (`LPWSTR`) 관리 되지 않는 구현에 전달 하기 전에.</span><span class="sxs-lookup"><span data-stu-id="e66bf-125">If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType>, all string arguments are converted to Unicode characters (`LPWSTR`) before they are passed to the unmanaged implementation.</span></span> <span data-ttu-id="e66bf-126">필드 설정 된 경우 <xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType>, ANSI 문자열로 변환 됩니다 (`LPSTR`).</span><span class="sxs-lookup"><span data-stu-id="e66bf-126">If the field is set to <xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType>, the strings are converted to ANSI strings (`LPSTR`).</span></span> <span data-ttu-id="e66bf-127">경우는 `CharSet` 필드가로 설정 된 <xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType>, 플랫폼별 변환이 (Windows 98 및 Windows Me, 및 이후 버전에는 유니코드에서 ANSI)입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-127">If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="Pack">
      <MemberSignature Language="C#" Value="public int Pack;" />
      <MemberSignature Language="ILAsm" Value=".field public int32 Pack" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack" />
      <MemberSignature Language="VB.NET" Value="Public Pack As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: int Pack;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e66bf-128">메모리에 있는 클래스 또는 구조체의 데이터 필드 맞춤을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-128">Controls the alignment of data fields of a class or structure in memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e66bf-129"><xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> 필드 형식의 필드에 메모리의 맞춤을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-129">The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field controls the alignment of a type's fields in memory.</span></span>  <span data-ttu-id="e66bf-130">둘 다에 영향을 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 및 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-130">It affects both <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e66bf-131">기본적으로 값은 0, 압축 크기는 현재 플랫폼에 대 한 기본값을 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-131">By default, the value is 0, indicating the default packing size for the current platform.</span></span> <span data-ttu-id="e66bf-132">값 <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> 0, 1, 2, 4, 8, 16, 32, 64, 또는 128 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-132">The value of <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:</span></span>  
  
 <span data-ttu-id="e66bf-133">다음 규칙을 사용 하 여 형식 인스턴스 필드 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-133">The fields of a type instance are aligned by using the following rules:</span></span>  
  
-   <span data-ttu-id="e66bf-134">형식의 맞춤의 가장 큰 요소의 크기입니다 (1, 2, 4, 8, 바이트 이상) 또는 지정한 압축 크기 중 더 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-134">The alignment of the type is the size of its largest element (1, 2, 4, 8, etc., bytes) or the specified packing size, whichever is smaller.</span></span>  
  
-   <span data-ttu-id="e66bf-135">각 필드는 자체 크기의 필드와 일치 해야 합니다 (1, 2, 4, 8, 바이트 이상) 또는 형식의 맞춤 중 더 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-135">Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.</span></span>  <span data-ttu-id="e66bf-136">형식의 기본 맞춤은 다른 모든 필드 길이 보다 크거나 같은 경우이 가장 큰 요소의 크기 때문에 일반적으로 즉 필드의 크기에 따라 정렬 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-136">Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size.</span></span> <span data-ttu-id="e66bf-137">64 비트 (8 바이트) 정수 또는 팩 필드 형식에서 가장 큰 필드는 경우에 8로 설정 되어 예를 들어 <xref:System.Byte> 1 바이트 경계에 정렬 필드 <xref:System.Int16> 필드 2 바이트 경계에 정렬 및 <xref:System.Int32> 필드는 4 바이트 경계에 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-137">For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <xref:System.Byte> fields align on 1-byte boundaries, <xref:System.Int16> fields align on 2-byte boundaries, and <xref:System.Int32> fields align on 4-byte boundaries.</span></span>  
  
-   <span data-ttu-id="e66bf-138">안쪽 여백 맞춤 요구 사항을 만족 하도록 필드 사이 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-138">Padding is added between fields to satisfy the alignment requirements.</span></span>  
  
 <span data-ttu-id="e66bf-139">예를 들어 두 개의 구성 된 다음과 같은 구조를 <xref:System.Byte> 필드와 한 <xref:System.Int32> 필드에 대 한 다양 한 값을 함께 사용 하는 경우는 <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-139">For example, consider the following structure, which consists of two <xref:System.Byte> fields and one <xref:System.Int32> field, when it is used with various values for the <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex0.cs#1)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="e66bf-140">C# 예제를 성공적으로 컴파일하려면 지정 해야 합니다는 `/unsafe` 컴파일러 스위치입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-140">To successfully compile the C# examples, you must specify the `/unsafe` compiler switch.</span></span>  
  
 <span data-ttu-id="e66bf-141">기본 압축 크기를 지정 하는 구조체의 크기는 8 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-141">If you specify the default packing size, the size of the structure is 8 bytes.</span></span> <span data-ttu-id="e66bf-142">바이트는 1 바이트 경계에 정렬 해야 하기 때문에 메모리의 처음 2 바이트를 차지 하는 2 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-142">The two bytes occupy the first two bytes of memory, because bytes must align on one-byte boundaries.</span></span> <span data-ttu-id="e66bf-143">형식의 기본 맞춤은 4 바이트는 가장 큰 필드 크기 때문에 `i3`, 없는 2 바이트 정수 필드 뒤 안쪽 여백입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-143">Because the default alignment of the type is 4 bytes, which is the size of its largest fields, `i3`, there are two bytes of padding followed by the integer field.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex1.cs#2)]  
  
 <span data-ttu-id="e66bf-144">경우 <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> 설정 된 구조체의 크기는 6 바이트를 2로 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-144">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 6 bytes.</span></span> <span data-ttu-id="e66bf-145">로 이전에 2 바이트를 차지 하므로 메모리의 처음 두 바이트.</span><span class="sxs-lookup"><span data-stu-id="e66bf-145">As before, the two bytes occupy the first two bytes of memory.</span></span> <span data-ttu-id="e66bf-146">필드는 이제 2 바이트 경계에 맞춤, 때문에 두 번째 바이트와 정수 간의 채우지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-146">Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex2.cs#3)]  
  
 <span data-ttu-id="e66bf-147">경우 <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> 설정 된 구조체의 크기는 기본적으로, 해당 형식의 맞춤의 가장 큰 필드의 크기에 따라 정의 된 위치, 동일 4로, `i3`은 4입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-147">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 4, the size of the structure is the same as in the default case, where the type's alignment was defined by the size of its largest field, `i3`, which is 4.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex3.cs#4)]  
  
 <span data-ttu-id="e66bf-148">경우 <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> 설정 된 구조체의 크기는 여전히 8, 기본 에서도 동일 경우 때문에 `i3` 필드 팩 필드로 지정 된 8 바이트 경계 보다 작은 4 바이트 경계에 맞춥니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-148">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the still same as in the default case, because the `i3` field aligns on a 4-byte boundary, which is smaller than the 8-byte boundary specified by the Pack field.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex4.cs#5)]  
  
 <span data-ttu-id="e66bf-149">또 다른 예로, 2 바이트 필드, 하나의 32 비트 부호 있는 정수 필드, 하나의 단일 요소 바이트 배열 및 10 진수 값으로 구성 되는 다음과 같은 구조를 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-149">To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value.</span></span> <span data-ttu-id="e66bf-150">기본값은 압축 크기 구조체의 크기는 28 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-150">With the default packing size, the size of the structure is 28 bytes.</span></span> <span data-ttu-id="e66bf-151">메모리에 2 바이트 정수 뒤 안쪽 뒤의 처음 두 바이트를 차지 하는 2 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-151">The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer.</span></span> <span data-ttu-id="e66bf-152">다음은 세 가지 바이트의 패딩이 이어서 1 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-152">Next is the one-byte array, followed by three bytes of padding.</span></span> <span data-ttu-id="e66bf-153">마지막으로 <xref:System.Decimal> 4의 10 진수 값을 구성 하기 때문에 4 바이트 경계에 정렬 되는 필드, d5, <xref:System.Int32> 있으므로 해당 맞춤은 위에 가장 큰 값의 크기에 따라 필드의 크기 보다는 필드의는 <xref:System.Decimal> 전체 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-153">Finally, the <xref:System.Decimal> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <xref:System.Int32> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <xref:System.Decimal> structure as a whole.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex5.cs#6)]  
  
 <span data-ttu-id="e66bf-154">경우 <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> 설정 된 구조체의 크기는 24 바이트 2로 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-154">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 24 bytes.</span></span> <span data-ttu-id="e66bf-155">기본 맞춤 비해 형식의 맞춤은 2가 아닌 4 이제 때문에 2 바이트와 정수 사이의 여백 2 바이트 없어졌습니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-155">In comparison with the default alignment, the two bytes of padding between the two bytes and the integer have been removed because the type's alignment is now 4 rather than 2.</span></span> <span data-ttu-id="e66bf-156">및 이후 안쪽 3 바이트 `a4` 이후로 1 바이트의 안쪽 여백으로 대체 되었습니다 `d5` 이제 4 바이트 경계 보다는 2 바이트 경계에 맞춥니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-156">And the three bytes of padding after `a4` have been replaced by one byte of padding, since `d5` now aligns on a 2-byte boundary rather than a 4-byte boundary.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex6.cs#7)]  
  
 <span data-ttu-id="e66bf-157">경우 <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> 설정의 8, 구조체의 크기는 기본적인 경우 처럼 동일한이 구조에서는 모든 맞춤 요구 사항은 8 보다 작으면 때문에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-157">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex7.cs#8)]  
  
 <span data-ttu-id="e66bf-158"><xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> 필드는 / 네트워크 쓰기 작업을 하는 동안 디스크에 구조체를 내보낼 때 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-158">The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field is frequently used when structures are exported during disk and network write operations.</span></span> <span data-ttu-id="e66bf-159">필드는 또한 자주 사용 하는 플랫폼 중 호출 및 interop 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-159">The field is also frequently used during platform invoke and interop operations.</span></span>  
  
 <span data-ttu-id="e66bf-160">경우에 따라서는 필드 보다 엄격한 압축 크기를 생성 하 여 메모리 요구 사항을 줄이기 위해 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-160">Occasionally, the field is used to reduce memory requirements by producing a tighter packing size.</span></span> <span data-ttu-id="e66bf-161">그러나이 사용량 실제 하드웨어 제약 조건을 신중 하 게 고려해 야 하 고 실제로 성능이 저하 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-161">However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size;" />
      <MemberSignature Language="ILAsm" Value=".field public int32 Size" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.Size" />
      <MemberSignature Language="VB.NET" Value="Public Size As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: int Size;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e66bf-162">클래스나 구조체의 절대적인 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-162">Indicates the absolute size of the class or structure.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e66bf-163">이 필드는 클래스 또는 구조체의 멤버를 바이트 단위로 전체 크기 보다 크거나 같은 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-163">This field must be equal or greater than the total size, in bytes, of the members of the class or structure.</span></span> <span data-ttu-id="e66bf-164">이 필드는 직접, 관리 되지 않는 액세스에 대 한 구조에서 사용한 메모리를 확장 하려는 컴파일러 작성기에 대 한 주로입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-164">This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access.</span></span> <span data-ttu-id="e66bf-165">예를 들어 직접 메타 데이터로 표현 되지 않는 공용 구조체를 작업할 때이 필드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-165">For example, you can use this field when working with unions that are not represented in metadata directly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.LayoutKind Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.InteropServices.LayoutKind Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.StructLayoutAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As LayoutKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::InteropServices::LayoutKind Value { System::Runtime::InteropServices::LayoutKind get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.LayoutKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e66bf-166">클래스나 구조의 배열 방법을 지정하는 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-166">Gets the <see cref="T:System.Runtime.InteropServices.LayoutKind" /> value that specifies how the class or structure is arranged.</span></span></summary>
        <value><span data-ttu-id="e66bf-167">클래스나 구조체의 정렬 방법을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="e66bf-167">One of the enumeration values that specifies how the class or structure is arranged.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>