<Type Name="Marshal" FullName="System.Runtime.InteropServices.Marshal">
  <TypeSignature Language="C#" Value="public static class Marshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Marshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.Marshal" />
  <TypeSignature Language="VB.NET" Value="Public Class Marshal" />
  <TypeSignature Language="C++ CLI" Value="public ref class Marshal abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="f799e-101">관리되지 않는 메모리를 할당하고, 관리되지 않는 메모리 블록을 복사하고, 관리되는 형식을 관리되지 않는 형식으로 변환하는 메서드의 컬렉션 및 비관리 코드와 상호 작용할 때 사용되는 기타 메서드의 컬렉션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-101">Provides a collection of methods for allocating unmanaged memory, copying unmanaged memory blocks, and converting managed to unmanaged types, as well as other miscellaneous methods used when interacting with unmanaged code.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-102">`static` 에 정의 된 메서드는 <xref:System.Runtime.InteropServices.Marshal> 클래스는 비관리 코드와 작업에 반드시 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-102">The `static` methods defined on the <xref:System.Runtime.InteropServices.Marshal> class are essential to working with unmanaged code.</span></span> <span data-ttu-id="f799e-103">이 클래스에 정의 된 대부분의 메서드는 일반적으로 관리 되는 관리 되지 않는 프로그래밍 모델 간의 다리 제공 하려는 개발자가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-103">Most methods defined in this class are typically used by developers who want to provide a bridge between the managed and unmanaged programming models.</span></span> <span data-ttu-id="f799e-104">예를 들어는 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> 메서드 (관리 되는 힙)에 지정된 된 문자열에서 ANSI 문자 버퍼 관리 되지 않는 힙에 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-104">For example, the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> method copies ANSI characters from a specified string (in the managed heap) to a buffer in the unmanaged heap.</span></span> <span data-ttu-id="f799e-105">또한 올바른 크기의 대상 힙을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-105">It also allocates the target heap of the right size.</span></span>  
  
 <span data-ttu-id="f799e-106">공용 언어 런타임 마샬링 특정 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-106">The common language runtime provides specific marshaling capabilities.</span></span> <span data-ttu-id="f799e-107">마샬링 동작에 대 한 세부 정보를 참조 하십시오. [Interop 마샬링](~/docs/framework/interop/interop-marshaling.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-107">For details on marshaling behavior, see [Interop Marshaling](~/docs/framework/interop/interop-marshaling.md).</span></span>  
  
 <span data-ttu-id="f799e-108">`Read` 및 `Write` 의 메서드는 <xref:System.Runtime.InteropServices.Marshal> 클래스 정렬 및 정렬 되지 않은 액세스를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-108">The `Read` and `Write` methods in the <xref:System.Runtime.InteropServices.Marshal> class support both aligned and unaligned access.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-109">다음 예제에서 정의 된 다양 한 메서드를 사용 하는 방법을 보여 줍니다는 <xref:System.Runtime.InteropServices.Marshal> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-109">The following example shows how to use various methods defined by the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#1)]
 [!code-csharp[Marshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#1)]
 [!code-vb[Marshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddRef">
      <MemberSignature Language="C#" Value="public static int AddRef (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddRef(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddRef (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddRef(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="f799e-110">증가시킬 인터페이스 참조 횟수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-110">The interface reference count to increment.</span></span></param>
        <summary><span data-ttu-id="f799e-111">지정된 인터페이스의 참조 횟수를 증가시킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-111">Increments the reference count on the specified interface.</span></span></summary>
        <returns><span data-ttu-id="f799e-112"><paramref name="pUnk" /> 매개 변수에 대한 참조 횟수의 새 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-112">The new value of the reference count on the <paramref name="pUnk" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-113">공용 언어 런타임에서이 메서드를 직접 사용 하는 불필요 한 하므로 사용자에 대 한 COM 개체의 참조 횟수를 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-113">The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</span></span> <span data-ttu-id="f799e-114">드문 경우 이지만 사용자 지정 마샬러 테스트와 같이 필요할 수 있습니다 것 개체의 수명을 직접 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-114">In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</span></span> <span data-ttu-id="f799e-115">호출한 후 <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, 같은 메서드를 사용 하 여 참조 횟수를 감소 해야 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-115">After calling <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, you must decrement the reference count by using a method such as <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f799e-116">반환 값에 의존 하지 마십시오 <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>수 있으므로 하지 안정적인 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-116">Do not rely on the return value of <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, as it can sometimes be unstable.</span></span>  
  
 <span data-ttu-id="f799e-117">호출할 수 있습니다 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, 또는 <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> 얻으려고는 <xref:System.IntPtr> 를 나타내는 값은 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 인터페이스 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-117">You can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to obtain an <xref:System.IntPtr> value that represents an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer.</span></span> <span data-ttu-id="f799e-118">이러한 메서드를 사용할 수도 및 <xref:System.Runtime.InteropServices.Marshal.AddRef%2A> 메서드를 나타내는 관리 되는 개체의 COM 호출 가능 래퍼 COM 인터페이스를 가져올 관리 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-118">You can also use these methods and the <xref:System.Runtime.InteropServices.Marshal.AddRef%2A> method on managed objects to obtain the COM interfaces represented by the managed object's COM callable wrapper.</span></span> <span data-ttu-id="f799e-119">이 래퍼 형식에 대 한 세부 정보를 잘 모르는 경우 참조 [COM 호출 가능 래퍼](~/docs/framework/interop/com-callable-wrapper.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-119">If you are not familiar with the details of this wrapper type, see [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-120">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-120">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-121">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-121">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr AllocCoTaskMem (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocCoTaskMem(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocCoTaskMem (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocCoTaskMem(int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb"><span data-ttu-id="f799e-122">할당될 메모리 블록 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-122">The size of the block of memory to be allocated.</span></span></param>
        <summary><span data-ttu-id="f799e-123">COM 작업 메모리 할당자에서 지정된 크기의 메모리 블록을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-123">Allocates a block of memory of specified size from the COM task memory allocator.</span></span></summary>
        <returns><span data-ttu-id="f799e-124">할당된 메모리 블록 주소를 나타내는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-124">An integer representing the address of the block of memory allocated.</span></span> <span data-ttu-id="f799e-125">이 메모리는 <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />을 사용하여 해제되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-125">This memory must be released with <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-126"><xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> API 메서드는 두 개의 메모리 할당 중 하나는 <xref:System.Runtime.InteropServices.Marshal> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-126"><xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> is one of two memory allocation API methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="f799e-127">(<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> 다른 됩니다.) 초기 메모리 내용이 반환이 정의 되지 않습니다 및 할당 된 메모리 요청 된 바이트 수보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-127">(<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> is the other.) The initial memory content returned is undefined, and the allocated memory can be larger than the requested number of bytes.</span></span> <span data-ttu-id="f799e-128">이 메서드는 COM 노출 [CoTaskMemAlloc](http://go.microsoft.com/fwlink/?LinkId=148626) COM 작업 메모리 할당자 라고 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-128">This method exposes the COM [CoTaskMemAlloc](http://go.microsoft.com/fwlink/?LinkId=148626) function, which is referred to as the COM task memory allocator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-129">메모리가 부족하여 요청을 만족시킬 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-129">There is insufficient memory to satisfy the request.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-130">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-130">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-131">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-131">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AllocHGlobal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-132">프로세스의 관리되지 않는 메모리에서 메모리를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-132">Allocates memory from the unmanaged memory of the process.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb"><span data-ttu-id="f799e-133">메모리에서 필요한 바이트 수 입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-133">The required number of bytes in memory.</span></span></param>
        <summary><span data-ttu-id="f799e-134">지정된 바이트 수를 사용하여 프로세스의 관리되지 않는 메모리에서 메모리를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-134">Allocates memory from the unmanaged memory of the process by using the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="f799e-135">새로 할당된 메모리에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-135">A pointer to the newly allocated memory.</span></span> <span data-ttu-id="f799e-136">이 메모리는 <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> 메서드를 사용하여 해제되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-136">This memory must be released using the <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-137"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 두 개의 메모리 할당 메서드 중 하나는 <xref:System.Runtime.InteropServices.Marshal> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-137"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> is one of two memory allocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="f799e-138">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> 다른 됩니다.) 이 메서드는 Win32 노출 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkId=148628) Kernel32.dll에서 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-138">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> is the other.) This method exposes the Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkId=148628) function from Kernel32.dll.</span></span>  
  
 <span data-ttu-id="f799e-139">때 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 호출 `LocalAlloc`, 전달 된 `LMEM_FIXED` 플래그를 할당된 된 메모리를 잠그는 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-139">When <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> calls `LocalAlloc`, it passes a `LMEM_FIXED` flag, which causes the allocated memory to be locked in place.</span></span> <span data-ttu-id="f799e-140">또한 할당 된 메모리가 0-채워지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-140">Also, the allocated memory is not zero-filled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-141">다음 예제에서는 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 메서드를 호출하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-141">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> method.</span></span> <span data-ttu-id="f799e-142">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Runtime.InteropServices.Marshal> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-142">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-143">메모리가 부족하여 요청을 만족시킬 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-143">There is insufficient memory to satisfy the request.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-144">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-144">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-145">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-145">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(IntPtr cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="cb"><span data-ttu-id="f799e-146">메모리에서 필요한 바이트 수 입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-146">The required number of bytes in memory.</span></span></param>
        <summary><span data-ttu-id="f799e-147">지정된 바이트 수에 대한 포인터를 사용하여 프로세스의 관리되지 않는 메모리에서 메모리를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-147">Allocates memory from the unmanaged memory of the process by using the pointer to the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="f799e-148">새로 할당된 메모리에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-148">A pointer to the newly allocated memory.</span></span> <span data-ttu-id="f799e-149">이 메모리는 <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> 메서드를 사용하여 해제되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-149">This memory must be released using the <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-150"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 두 개의 메모리 할당 메서드 중 하나는 <xref:System.Runtime.InteropServices.Marshal> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-150"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> is one of two memory allocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="f799e-151">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> 다른 됩니다.) 이 메서드는 Win32 노출 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkID=148628) Kernel32.dll에서 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-151">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> is the other.) This method exposes the Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkID=148628) function from Kernel32.dll.</span></span>  
  
 <span data-ttu-id="f799e-152">때 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 호출 `LocalAlloc`, 전달 된 `LMEM_FIXED` 플래그를 할당된 된 메모리를 잠그는 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-152">When <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> calls `LocalAlloc`, it passes a `LMEM_FIXED` flag, which causes the allocated memory to be locked in place.</span></span> <span data-ttu-id="f799e-153">또한 할당 된 메모리가 0-채워지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-153">Also, the allocated memory is not zero-filled.</span></span>  
  
 <span data-ttu-id="f799e-154">예제 코드는 <xref:System.Runtime.InteropServices.Marshal> 및 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f799e-154">For example code, see <xref:System.Runtime.InteropServices.Marshal> and <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-155">메모리가 부족하여 요청을 만족시킬 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-155">There is insufficient memory to satisfy the request.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-156">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-156">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-157">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-157">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AreComObjectsAvailableForCleanup">
      <MemberSignature Language="C#" Value="public static bool AreComObjectsAvailableForCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool AreComObjectsAvailableForCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AreComObjectsAvailableForCleanup () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool AreComObjectsAvailableForCleanup();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f799e-158">어떤 컨텍스트에서 RCW(런타임 호출 가능 래퍼)를 정리에 사용할 수 있는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-158">Indicates whether runtime callable wrappers (RCWs) from any context are available for cleanup.</span></span></summary>
        <returns>
          <span data-ttu-id="f799e-159">정리에 사용할 수 있는 RCW가 하나라도 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-159"><see langword="true" /> if there are any RCWs available for cleanup; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-160">다양 한 상세한 종속성 그래프를 사용 하 여 관리 / 네이티브 코드 간의 참조 하는 경우 모든 개체를 정리 하려면 시간이 오래 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-160">If there are a lot of references between managed and native code with deep dependency graphs it can take a long time for all the objects to clean up.</span></span> <span data-ttu-id="f799e-161">GC 실행 될 때마다 몇 개의 기본 COM 개체에 출시 될 Rcw 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-161">Each time a GC runs it will free up some number of RCWs, which will in turn release the underlying COM objects.</span></span> <span data-ttu-id="f799e-162">이러한 COM 개체의 관리 되는 참조를 해제 한 더 많은 개체에 사용할 수 있도록 정리 다음에 프로세스를 시작 하는 gc가 실행 될 다음 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-162">Those COM objects will then release their managed references and make more objects available for cleanup the next time a GC runs, which starts the process over again.</span></span>  
  
 <span data-ttu-id="f799e-163"><xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A> 메서드 GC의 주기 수 수를 확인 하려면 응용 프로그램에 대 한 방법을 제공 합니다. 수집 및 GC 합니다. WaitForPendingFinalizers 모든 항목을 정리 하기 위해 발생 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-163">The <xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A> method provides a way for the application to determine how many cycles of GC.Collect and GC.WaitForPendingFinalizers need to happen in order to clean everything up.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-164">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-164">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-165">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-165">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BindToMoniker">
      <MemberSignature Language="C#" Value="public static object BindToMoniker (string monikerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object BindToMoniker(string monikerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindToMoniker (monikerName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ BindToMoniker(System::String ^ monikerName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="monikerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="monikerName"><span data-ttu-id="f799e-166">원하는 인터페이스 포인터에 해당하는 모니커입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-166">The moniker corresponding to the desired interface pointer.</span></span></param>
        <summary><span data-ttu-id="f799e-167">지정된 모니커로 식별되는 인터페이스 포인터를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-167">Gets an interface pointer identified by the specified moniker.</span></span></summary>
        <returns><span data-ttu-id="f799e-168"><paramref name="monikerName" /> 매개 변수로 식별되는 인터페이스 포인터에 대한 참조가 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-168">An object containing a reference to the interface pointer identified by the <paramref name="monikerName" /> parameter.</span></span> <span data-ttu-id="f799e-169">모니커는 이름이며 이 경우에는 인터페이스로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-169">A moniker is a name, and in this case, the moniker is defined by an interface.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-170"><xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A> COM 노출 `BindToMoniker` 메서드를 사용 해야 하는 COM 인터페이스로 캐스팅할 수 있는 개체를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-170"><xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A> exposes the COM `BindToMoniker` method, which produces an object that you can cast to any COM interface you require.</span></span> <span data-ttu-id="f799e-171">이 메서드는 동일한 기능을 제공 된 `GetObject` Visual Basic 6.0에서 메서드 및 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-171">This method provides the same functionality as the `GetObject` method in Visual Basic 6.0 and [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="f799e-172">인식할 수 없는 HRESULT가 관리되지 않는 <see langword="BindToMoniker" /> 메서드에서 반환되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-172">An unrecognized HRESULT was returned by the unmanaged <see langword="BindToMoniker" /> method.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-173">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-173">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-174">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-174">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BufferToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr BufferToBSTR (Array ptr, int slen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int BufferToBSTR(class System.Array ptr, int32 slen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BufferToBSTR(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BufferToBSTR (ptr As Array, slen As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr BufferToBSTR(Array ^ ptr, int slen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Array" />
        <Parameter Name="slen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="slen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeWrapperHandleStrength">
      <MemberSignature Language="C#" Value="public static void ChangeWrapperHandleStrength (object otp, bool fIsWeak);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangeWrapperHandleStrength(object otp, bool fIsWeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangeWrapperHandleStrength (otp As Object, fIsWeak As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangeWrapperHandleStrength(System::Object ^ otp, bool fIsWeak);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otp" Type="System.Object" />
        <Parameter Name="fIsWeak" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="otp"><span data-ttu-id="f799e-175">CCW에 참조 횟수가 계산된 핸들이 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-175">The object whose CCW holds a reference counted handle.</span></span> <span data-ttu-id="f799e-176">CCW의 참조 횟수가 0보다 크면 핸들이 강하고, 그렇지 않으면 핸들이 약합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-176">The handle is strong if the reference count on the CCW is greater than zero; otherwise, it is weak.</span></span></param>
        <param name="fIsWeak">
          <span data-ttu-id="f799e-177">참조 횟수에 관계없이 <c>otp</c> 매개 변수에 대한 핸들 강도를 약하게 변경하려면 <see langword="true" />이고, 참조 횟수가 계산될 <c>otp</c>에 대한 핸들 강도를 다시 설정하려면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-177"><see langword="true" /> to change the strength of the handle on the <c>otp</c> parameter to weak, regardless of its reference count; <see langword="false" /> to reset the handle strength on <c>otp</c> to be reference counted.</span></span></param>
        <summary><span data-ttu-id="f799e-178">개체의 [CCW(COM Callable Wrapper)](~/docs/framework/interop/com-callable-wrapper.md) 핸들 강도를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-178">Changes the strength of an object's [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) (CCW) handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-179"><xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A> 개체 풀링 기능에 사용 되 고 호출 되 면 안 사용자 코드에서 직접 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-179"><xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A> is used for object pooling functionality and should never be called by user code directly.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-180">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-180">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-181">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-181">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CleanupUnusedObjectsInCurrentContext">
      <MemberSignature Language="C#" Value="public static void CleanupUnusedObjectsInCurrentContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CleanupUnusedObjectsInCurrentContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CleanupUnusedObjectsInCurrentContext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CleanupUnusedObjectsInCurrentContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f799e-182">현재 컨텍스트에서 할당된 모든 [RCW(런타임 호출 가능 래퍼)](~/docs/framework/interop/runtime-callable-wrapper.md)를 정리하도록 런타임에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-182">Notifies the runtime to clean up all [Runtime Callable Wrappers](~/docs/framework/interop/runtime-callable-wrapper.md) (RCWs) allocated in the current context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-183">Interop 시스템 Rcw를 정리 하려고 하는 동안 메시지를 펌핑 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-183">The interop system pumps messages while it attempts to clean up RCWs.</span></span> <span data-ttu-id="f799e-184">이렇게 하면 모든 응용 프로그램에서 충분히 자주 펌프 하지 않는 응용 프로그램을 포함 하 여 발생 하는 단일 스레드 아파트 (STA) Rcw 정리 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-184">This ensures that cleanup for single-threaded apartment (STA) RCWs happens in all applications, including applications that do not pump often enough.</span></span> <span data-ttu-id="f799e-185">그러나 적절 하 게 펌프 하지 않는 일부 응용 프로그램은 펌프 발생에 매우 민감합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-185">However, some applications that do pump appropriately are very sensitive to where pumping occurs.</span></span> <span data-ttu-id="f799e-186">때 예기치 않은 위치에서 이러한 응용 프로그램에서 메시지를 펌핑 interop 시스템, 응용 프로그램 진단 하기 어려운 재진입 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-186">When the interop system pumps messages in these applications, in places that are unexpected, , the application can encounter reentrancy issues that are difficult to diagnose.</span></span> <span data-ttu-id="f799e-187">따라서 응용 프로그램에 대 한 특정 STA 및 Rcw 정리 제어 고유한 펌프를 제어할 수 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-187">Therefore, applications need to be able to control their own pumping for a particular STA and to control the clean-up of RCWs.</span></span>  
  
 <span data-ttu-id="f799e-188">그러나 개발자가 응용 프로그램의 스레드 하위 집합인 제어 하 고 모든 스레드가 적절 하 게 펌프 하는 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-188">However, developers often only control a subset of the threads in their application and thus cannot ensure that all threads are pumping appropriately.</span></span>  
  
 <span data-ttu-id="f799e-189">이 문제를 해결 하려면</span><span class="sxs-lookup"><span data-stu-id="f799e-189">To solve this problem:</span></span>  
  
1.  <span data-ttu-id="f799e-190">사용 하 여는 <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType> Rcw를 및 스레드 단위 별로 발생 하는 메시지 펌프의 자동 정리를 해제 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-190">Use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType> method to turn off automatic cleanup of RCWs, and the message pumping that occurs, on a per-thread basis.</span></span> <span data-ttu-id="f799e-191">자동 정리 하 고 해당 메시지 펌프를 취소 하기 위해 개발자를 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-191">This allows developers to opt out of automatic clean-up, and the corresponding message pumping.</span></span>  
  
2.  <span data-ttu-id="f799e-192">사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A> 메서드를 현재 컨텍스트에 할당 되는 모든 Rcw 정리를 알립니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-192">Use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A> method to notify the runtime to clean up all RCWs that are allocated in the current context.</span></span> <span data-ttu-id="f799e-193">이 도우미 메서드를 사용 하면 개발자가 런타임은 현재 컨텍스트에서 정리를 수행 하는 경우 정확 하 게 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-193">This companion method allows developers to precisely control when the runtime performs cleanup in the current context.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-194">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-194">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-195">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-195">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-196">관리되는 배열에서 관리되지 않는 메모리 포인터로 데이터를 복사하거나 관리되지 않는 메모리 포인터에서 관리되는 배열로 데이터를 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-196">Copies data from a managed array to an unmanaged memory pointer, or from an unmanaged memory pointer to a managed array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (byte[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(unsigned int8[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Byte(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;System::Byte&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-197">복사할 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-197">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-198">소스 배열에서 복사를 시작해야 할 인덱스(0부터 시작)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-198">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-199">복사할 대상 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-199">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-200">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-200">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-201">관리되는 8비트 부호 없는 1차원 정수 배열의 데이터를 관리되지 않는 메모리 포인터로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-201">Copies data from a one-dimensional, managed 8-bit unsigned integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-202">관리 되는 1 차원 배열의 하위 집합 관리 되지 않는 C 스타일 배열에 복사 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-202">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-203">다음 예제에서는 배열을 관리 되지 않는 메모리를 사용 하 여 복사는 <xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29> 오버 로드 하 고 다음 사용 하 여 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사는 <xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-203">The following example copies an array to unmanaged memory by using the <xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29> overload, and then copies the unmanaged array back to managed memory by using the <xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f799e-204"><paramref name="startIndex" /> 및 <paramref name="length" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-204"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-205"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-205"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-206">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-206">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-207">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-207">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (char[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(char[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Char(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;char&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-208">복사할 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-208">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-209">소스 배열에서 복사를 시작해야 할 인덱스(0부터 시작)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-209">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-210">복사할 대상 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-210">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-211">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-211">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-212">관리되는 1차원 문자 배열의 데이터를 관리되지 않는 메모리 포인터로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-212">Copies data from a one-dimensional, managed character array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-213">관리 되는 1 차원 배열의 하위 집합 관리 되지 않는 C 스타일 배열에 복사 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-213">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-214">다음 예제에서는 배열을 관리 되지 않는 메모리에 복사한 다음 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-214">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f799e-215"><paramref name="startIndex" /> 및 <paramref name="length" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-215"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-216"><paramref name="startIndex" />, <paramref name="destination" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-216"><paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-217">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-217">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-218">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-218">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (double[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Double(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;double&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-219">복사할 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-219">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-220">소스 배열에서 복사를 시작해야 할 인덱스(0부터 시작)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-220">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-221">복사할 대상 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-221">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-222">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-222">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-223">관리되는 1차원 배정밀도 부동 소수점 수 배열의 데이터를 관리되지 않는 메모리 포인터로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-223">Copies data from a one-dimensional, managed double-precision floating-point number array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-224">관리 되는 1 차원 배열의 하위 집합 관리 되지 않는 C 스타일 배열에 복사 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-224">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-225">다음 예제에서는 배열을 관리 되지 않는 메모리에 복사한 다음 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-225">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f799e-226"><paramref name="startIndex" /> 및 <paramref name="length" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-226"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-227"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-227"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-228">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-228">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-229">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-229">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (short[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int16[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Short(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;short&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-230">복사할 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-230">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-231">소스 배열에서 복사를 시작해야 할 인덱스(0부터 시작)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-231">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-232">복사할 대상 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-232">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-233">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-233">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-234">관리되는 16비트 부호 있는 1차원 정수 배열의 데이터를 관리되지 않는 메모리 포인터로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-234">Copies data from a one-dimensional, managed 16-bit signed integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-235">관리 되는 1 차원 배열의 하위 집합 관리 되지 않는 C 스타일 배열에 복사 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-235">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-236">다음 예제에서는 배열을 관리 되지 않는 메모리에 복사한 다음 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-236">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f799e-237"><paramref name="startIndex" /> 및 <paramref name="length" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-237"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-238"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-238"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-239">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-239">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-240">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-240">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (int[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Integer(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;int&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-241">복사할 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-241">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-242">소스 배열에서 복사를 시작해야 할 인덱스(0부터 시작)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-242">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-243">복사할 대상 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-243">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-244">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-244">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-245">관리되는 32비트 부호 있는 1차원 정수 배열의 데이터를 관리되지 않는 메모리 포인터로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-245">Copies data from a one-dimensional, managed 32-bit signed integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-246">관리 되는 1 차원 배열의 하위 집합 관리 되지 않는 C 스타일 배열에 복사 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-246">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-247">다음 예제에서는 배열을 관리 되지 않는 메모리에 복사한 다음 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-247">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f799e-248"><paramref name="startIndex" /> 및 <paramref name="length" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-248"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-249"><paramref name="startIndex" /> 또는 <paramref name="length" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-249"><paramref name="startIndex" /> or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-250">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-250">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-251">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-251">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (long[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Long(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;long&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-252">복사할 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-252">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-253">소스 배열에서 복사를 시작해야 할 인덱스(0부터 시작)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-253">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-254">복사할 대상 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-254">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-255">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-255">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-256">관리되는 64비트 부호 있는 1차원 정수 배열의 데이터를 관리되지 않는 메모리 포인터로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-256">Copies data from a one-dimensional, managed 64-bit signed integer array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-257">관리 되는 1 차원 배열의 하위 집합 관리 되지 않는 C 스타일 배열에 복사 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-257">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-258">다음 예제에서는 배열을 관리 되지 않는 메모리에 복사한 다음 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-258">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f799e-259"><paramref name="startIndex" /> 및 <paramref name="length" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-259"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-260"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-260"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-261">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-261">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-262">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-262">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, byte[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, unsigned int8[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Byte(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;System::Byte&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-263">복사할 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-263">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-264">복사할 대상 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-264">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-265">대상 배열에서 복사를 시작해야 할 0부터 시작하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-265">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-266">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-266">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-267">관리되지 않는 메모리 포인터의 데이터를 관리되는 8비트 부호 없는 정수 배열로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-267">Copies data from an unmanaged memory pointer to a managed 8-bit unsigned integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-268">관리 되지 않는 리소스를 C 스타일 배열에 들어 있는 것을 방지 하는 경계 정보는 `startIndex` 및 `length` 매개 변수 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-268">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="f799e-269">해당 하는 관리 되지 않는 데이터 따라서는 `source` 매개 변수 유용성에 관계 없이 관리 되는 배열을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-269">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="f799e-270">이 메서드를 호출 하기 전에 적절 한 크기로 관리 되는 배열을 초기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-270">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-271">다음 예제에서는 배열을 관리 되지 않는 메모리에 복사한 다음 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-271">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-272"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-272"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-273">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-273">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-274">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-274">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, char[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, char[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;char&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-275">복사할 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-275">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-276">복사할 대상 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-276">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-277">대상 배열에서 복사를 시작해야 할 0부터 시작하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-277">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-278">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-278">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-279">관리되지 않는 메모리 포인터의 데이터를 관리되는 문자 배열로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-279">Copies data from an unmanaged memory pointer to a managed character array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-280">관리 되지 않는 리소스를 C 스타일 배열에 들어 있는 것을 방지 하는 경계 정보는 `startIndex` 및 `length` 매개 변수 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-280">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="f799e-281">해당 하는 관리 되지 않는 데이터 따라서는 `source` 매개 변수 유용성에 관계 없이 관리 되는 배열을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-281">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="f799e-282">이 메서드를 호출 하기 전에 적절 한 크기로 관리 되는 배열을 초기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-282">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-283">다음 예제에서는 배열을 관리 되지 않는 메모리에 복사한 다음 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-283">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-284"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-284"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-285">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-285">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-286">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-286">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, double[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Double(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;double&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-287">복사할 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-287">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-288">복사할 대상 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-288">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-289">대상 배열에서 복사를 시작해야 할 0부터 시작하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-289">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-290">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-290">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-291">관리되지 않는 메모리 포인터의 데이터를 관리되는 배정밀도 부동 소수점 수 배열로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-291">Copies data from an unmanaged memory pointer to a managed double-precision floating-point number array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-292">관리 되지 않는 리소스를 C 스타일 배열에 들어 있는 것을 방지 하는 경계 정보는 `startIndex` 및 `length` 매개 변수 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-292">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="f799e-293">해당 하는 관리 되지 않는 데이터 따라서는 `source` 매개 변수 유용성에 관계 없이 관리 되는 배열을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-293">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="f799e-294">이 메서드를 호출 하기 전에 적절 한 크기로 관리 되는 배열을 초기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-294">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-295">다음 예제에서는 배열을 관리 되지 않는 메모리에 복사한 다음 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-295">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-296"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-296"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-297">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-297">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-298">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-298">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, short[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int16[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Short(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;short&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-299">복사할 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-299">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-300">복사할 대상 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-300">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-301">대상 배열에서 복사를 시작해야 할 0부터 시작하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-301">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-302">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-302">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-303">관리되지 않는 메모리 포인터의 데이터를 관리되는 16비트 부호 있는 정수 배열로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-303">Copies data from an unmanaged memory pointer to a managed 16-bit signed integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-304">관리 되지 않는 리소스를 C 스타일 배열에 들어 있는 것을 방지 하는 경계 정보는 `startIndex` 및 `length` 매개 변수 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-304">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="f799e-305">해당 하는 관리 되지 않는 데이터 따라서는 `source` 매개 변수 유용성에 관계 없이 관리 되는 배열을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-305">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="f799e-306">이 메서드를 호출 하기 전에 적절 한 크기로 관리 되는 배열을 초기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-306">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-307">다음 예제에서는 배열을 관리 되지 않는 메모리에 복사한 다음 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-307">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-308"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-308"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-309">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-309">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-310">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-310">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, int[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Integer(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;int&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-311">복사할 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-311">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-312">복사할 대상 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-312">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-313">대상 배열에서 복사를 시작해야 할 0부터 시작하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-313">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-314">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-314">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-315">관리되지 않는 메모리 포인터의 데이터를 관리되는 32비트 부호 있는 정수 배열로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-315">Copies data from an unmanaged memory pointer to a managed 32-bit signed integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-316">관리 되지 않는 리소스를 C 스타일 배열에 들어 있는 것을 방지 하는 경계 정보는 `startIndex` 및 `length` 매개 변수 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-316">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="f799e-317">해당 하는 관리 되지 않는 데이터 따라서는 `source` 매개 변수 유용성에 관계 없이 관리 되는 배열을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-317">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="f799e-318">이 메서드를 호출 하기 전에 적절 한 크기로 관리 되는 배열을 초기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-318">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-319">다음 예제에서는 배열을 관리 되지 않는 메모리에 복사한 다음 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-319">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-320"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-320"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-321">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-321">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-322">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-322">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, long[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Long(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;long&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-323">복사할 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-323">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-324">복사할 대상 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-324">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-325">대상 배열에서 복사를 시작해야 할 0부터 시작하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-325">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-326">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-326">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-327">관리되지 않는 메모리 포인터의 데이터를 관리되는 64비트 부호 있는 정수 배열로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-327">Copies data from an unmanaged memory pointer to a managed 64-bit signed integer array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-328">관리 되지 않는 리소스를 C 스타일 배열에 들어 있는 것을 방지 하는 경계 정보는 `startIndex` 및 `length` 매개 변수 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-328">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="f799e-329">해당 하는 관리 되지 않는 데이터 따라서는`source` 매개 변수 유용성에 관계 없이 관리 되는 배열을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-329">Thus, the unmanaged data corresponding to the`source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="f799e-330">이 메서드를 호출 하기 전에 적절 한 크기로 관리 되는 배열을 초기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-330">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-331">다음 예제에서는 배열을 관리 되지 않는 메모리에 복사한 다음 관리 되지 않는 배열을 관리 되는 메모리에 다시 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-331">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-332"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-332"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-333">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-333">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-334">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-334">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, IntPtr[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, native int[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As IntPtr(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;IntPtr&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-335">복사할 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-335">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-336">복사할 대상 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-336">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-337">대상 배열에서 복사를 시작해야 할 0부터 시작하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-337">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-338">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-338">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-339">관리되지 않는 메모리 포인터의 데이터를 관리되는 <see cref="T:System.IntPtr" /> 배열에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-339">Copies data from an unmanaged memory pointer to a managed <see cref="T:System.IntPtr" /> array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-340">관리 되지 않는 리소스를 C 스타일 배열에 들어 있는 것을 방지 하는 경계 정보는 `startIndex` 및 `length` 매개 변수 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-340">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="f799e-341">해당 하는 관리 되지 않는 데이터 따라서는 `source` 매개 변수 유용성에 관계 없이 관리 되는 배열을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-341">Therefore, the unmanaged data that corresponds to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="f799e-342">적절 한 크기로 호출 하기 전에 관리 되는 배열을 초기화 해야는 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-342">You must initialize the managed array with the appropriate size before calling the <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-343"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-343"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-344">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-344">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-345">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-345">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, float[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Single(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;float&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-346">복사할 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-346">The memory pointer to copy from.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-347">복사할 대상 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-347">The array to copy to.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-348">대상 배열에서 복사를 시작해야 할 0부터 시작하는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-348">The zero-based index in the destination array where copying should start.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-349">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-349">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-350">관리되지 않는 메모리 포인터의 데이터를 관리되는 단정밀도 부동 소수점 수 배열로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-350">Copies data from an unmanaged memory pointer to a managed single-precision floating-point number array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-351">관리 되지 않는 리소스를 C 스타일 배열에 들어 있는 것을 방지 하는 경계 정보는 `startIndex` 및 `length` 매개 변수 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-351">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="f799e-352">해당 하는 관리 되지 않는 데이터 따라서는 `source` 매개 변수 유용성에 관계 없이 관리 되는 배열을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-352">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="f799e-353">이 메서드를 호출 하기 전에 적절 한 크기로 관리 되는 배열을 초기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-353">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-354"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-354"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-355">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-355">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-356">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-356">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;IntPtr&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-357">복사할 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-357">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-358">소스 배열에서 복사를 시작해야 할 인덱스(0부터 시작)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-358">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-359">복사할 대상 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-359">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-360">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-360">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-361">관리되는 <see cref="T:System.IntPtr" /> 배열의 데이터를 관리되지 않는 메모리 포인터에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-361">Copies data from a one-dimensional, managed <see cref="T:System.IntPtr" /> array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-362">이 메서드를 사용 하 여 관리 되는 1 차원 하위 집합을 복사 하려면 <xref:System.IntPtr> 관리 되지 않는 C 스타일 배열에는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-362">You can use this method to copy a subset of a one-dimensional managed <xref:System.IntPtr> array to an unmanaged C-style array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-363"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-363"><paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-364">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-364">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-365">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-365">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (float[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Single(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;float&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="f799e-366">복사할 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-366">The one-dimensional array to copy from.</span></span></param>
        <param name="startIndex"><span data-ttu-id="f799e-367">소스 배열에서 복사를 시작해야 할 인덱스(0부터 시작)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-367">The zero-based index in the source array where copying should start.</span></span></param>
        <param name="destination"><span data-ttu-id="f799e-368">복사할 대상 메모리 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-368">The memory pointer to copy to.</span></span></param>
        <param name="length"><span data-ttu-id="f799e-369">복사할 배열 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-369">The number of array elements to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-370">관리되는 1차원 단정밀도 부동 소수점 수 배열의 데이터를 관리되지 않는 메모리 포인터로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-370">Copies data from a one-dimensional, managed single-precision floating-point number array to an unmanaged memory pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-371">관리 되는 1 차원 배열의 하위 집합 관리 되지 않는 C 스타일 배열에 복사 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-371">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f799e-372"><paramref name="startIndex" /> 및 <paramref name="length" />가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-372"><paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-373"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> 또는 <paramref name="length" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-373"><paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-374">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-374">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-375">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-375">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject (IntPtr pOuter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject(native int pOuter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject (pOuter As IntPtr, o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="pOuter"><span data-ttu-id="f799e-376">외부 <see langword="IUnknown" /> 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-376">The outer <see langword="IUnknown" /> pointer.</span></span></param>
        <param name="o"><span data-ttu-id="f799e-377">집계할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-377">An object to aggregate.</span></span></param>
        <summary><span data-ttu-id="f799e-378">지정된 COM 개체를 사용하여 관리되는 개체를 집계합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-378">Aggregates a managed object with the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="f799e-379">관리되는 개체의 내부 <see langword="IUnknown" /> 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-379">The inner <see langword="IUnknown" /> pointer of the managed object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-380"><xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> 메서드 지정된 된 외부 포인터와 관리 되는 개체의 내부 관리 되는 포인터를 집계 하 고 다음는 내부 조인 반환 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 관리 되는 개체의 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-380">The <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> method aggregates the inner managed pointer of a managed object with the specified outer pointer, and then returns an inner [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer of the managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-381"><paramref name="o" />가 [!INCLUDE[wrt](~/includes/wrt-md.md)] 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-381"><paramref name="o" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-382">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-382">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-383">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-383">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject&lt;T&gt; (IntPtr pOuter, T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject&lt;T&gt;(native int pOuter, !!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject(Of T) (pOuter As IntPtr, o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-384">집계할 관리되는 개체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-384">The type of the managed object to aggregate.</span></span></typeparam>
        <param name="pOuter"><span data-ttu-id="f799e-385">외부 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-385">The outer [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer.</span></span></param>
        <param name="o"><span data-ttu-id="f799e-386">집계할 관리되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-386">The managed object to aggregate.</span></span></param>
        <summary><span data-ttu-id="f799e-387">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-387">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-388">지정된 COM 개체를 사용하여 지정된 형식의 관리되는 개체를 집계합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-388">Aggregates a managed object of the specified type with the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="f799e-389">관리되는 개체의 내부 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-389">The inner [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer of the managed object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-390"><xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> 메서드는 지정된 된 외부 포인터와 지정 된 형식의 관리 되는 개체의 내부 관리 되는 포인터를 집계 하 고는 내부 조인 반환 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 관리 되는 개체의 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-390">The <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> method aggregates the inner managed pointer of a managed object of a specified type with the specified outer pointer, and returns an inner [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer of the managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-391"><paramref name="o" />가 [!INCLUDE[wrt](~/includes/wrt-md.md)] 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-391"><paramref name="o" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-392">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-392">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-393">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-393">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType">
      <MemberSignature Language="C#" Value="public static object CreateWrapperOfType (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateWrapperOfType(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType (o As Object, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateWrapperOfType(System::Object ^ o, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f799e-394">래핑될 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-394">The object to be wrapped.</span></span></param>
        <param name="t"><span data-ttu-id="f799e-395">만들 래퍼의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-395">The type of wrapper to create.</span></span></param>
        <summary><span data-ttu-id="f799e-396">지정된 형식의 개체에 지정된 COM 개체를 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-396">Wraps the specified COM object in an object of the specified type.</span></span></summary>
        <returns><span data-ttu-id="f799e-397">원하는 형식의 인스턴스인 새로 래핑된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-397">The newly wrapped object that is an instance of the desired type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-398"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A> COM 클래스 유형에서는 일반적으로 기본 변환 `__ComObject` 다른 COM 클래스 형식에 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-398"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A> converts one COM class type, typically the base `__ComObject` type, to another COM class type.</span></span> <span data-ttu-id="f799e-399">매개 변수가 나타내는 입력된 COM 개체 `o`,이 [런타임 호출 가능 래퍼](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span><span class="sxs-lookup"><span data-stu-id="f799e-399">The input COM object, represented by parameter `o`, is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span></span>  
  
 <span data-ttu-id="f799e-400">둘 다는 `t` 및 `o` 매개 변수 시그니처 특성으로 지정 된 클래스 여야 합니다. <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-400">Both the `t` and `o` parameters must be classes whose signatures are attributed with <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f799e-401">[Tlbimp.exe (형식 라이브러리 가져오기)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) 도구 형식 라이브러리를 가져올 때이 특성을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-401">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span> <span data-ttu-id="f799e-402">소스 코드에서 수동으로 RCW를 만들면 원본 coclass를 여는 COM의 원본임을 나타내는 관리 되는 서명에이 특성을 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-402">If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</span></span>  
  
 <span data-ttu-id="f799e-403">Tlbimp.exe 가져오는 COM [coclass](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) 관리 되는 클래스 및 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-403">Tlbimp.exe imports a COM [coclass](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) as a managed class and an interface.</span></span> <span data-ttu-id="f799e-404">Coclass 인터페이스에 동일한 이름으로 원본 coclass와 관리 되는 클래스 이름이 원래 coclass "Class"로 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-404">The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</span></span> <span data-ttu-id="f799e-405">예를 들면 coclass 라는 `MyCoclass` 되 호출을 coclass 인터페이스 `MyCoclass` 라는 관리 되는 클래스 및 `MyCoclassClass`합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-405">For example, a coclass called `MyCoclass` becomes a coclass interface called `MyCoclass` and a managed class called `MyCoclassClass`.</span></span> <span data-ttu-id="f799e-406">이후 `t` 관리 되는 클래스를 지정 하는 클래스 인터페이스가 아닌 반드시 이어야 합니다 (`MyCoclassClass`) 및 coclass 인터페이스를 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-406">Since `t` must be a class, not an interface, be sure to specify the managed class (`MyCoclassClass`) and not the coclass interface.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f799e-407">COM 개체 새 RCW 인스턴스를 래핑하기 때문에 입력의 id를 손실는 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 원래 RCW에 의해 노출 되는 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-407">You lose the identity of the input COM object because a new RCW instance wraps the [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer exposed by the original RCW.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-408"><paramref name="t" />는 <see langword="__ComObject" />에서 파생되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-408"><paramref name="t" /> must derive from <see langword="__ComObject" />.</span></span>  
  
 <span data-ttu-id="f799e-409">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-409">-or-</span></span>  
  
 <span data-ttu-id="f799e-410"><paramref name="t" />가 [!INCLUDE[wrt](~/includes/wrt-md.md)] 형식인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-410"><paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-411"><paramref name="t" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-411">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="f799e-412"><paramref name="o" />는 필요한 모든 인터페이스를 지원하지는 않으므로 대상 개체로 변환될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-412"><paramref name="o" /> cannot be converted to the destination type because it does not support all required interfaces.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-413">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-413">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-414">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-414">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType&lt;T,TWrapper&gt;">
      <MemberSignature Language="C#" Value="public static TWrapper CreateWrapperOfType&lt;T,TWrapper&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TWrapper CreateWrapperOfType&lt;T, TWrapper&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType(Of T, TWrapper) (o As T) As TWrapper" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TWrapper&gt;&#xA; static TWrapper CreateWrapperOfType(T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TWrapper</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TWrapper" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-415">래핑할 개체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-415">The type of object to wrap.</span></span></typeparam>
        <typeparam name="TWrapper"><span data-ttu-id="f799e-416">반환할 개체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-416">The type of object to return.</span></span></typeparam>
        <param name="o"><span data-ttu-id="f799e-417">래핑될 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-417">The object to be wrapped.</span></span></param>
        <summary><span data-ttu-id="f799e-418">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-418">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-419">지정된 형식의 개체에 지정된 COM 개체를 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-419">Wraps the specified COM object in an object of the specified type.</span></span></summary>
        <returns><span data-ttu-id="f799e-420">새로 래핑된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-420">The newly wrapped object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-421"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29> 형식의 COM 개체를 변환 `T` 에 `TWrapper` COM 클래스 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-421"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29> converts a COM object of type `T` to the `TWrapper` COM class type.</span></span> <span data-ttu-id="f799e-422">매개 변수가 나타내는 입력된 COM 개체 `o`,이 [런타임 호출 가능 래퍼](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span><span class="sxs-lookup"><span data-stu-id="f799e-422">The input COM object, represented by parameter `o`, is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span></span>  
  
 <span data-ttu-id="f799e-423">두는 `T` 제네릭 형식 매개 변수 및 `o` 매개 변수 시그니처 특성으로 지정 된 클래스 여야 합니다.는 <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-423">Both the `T` generic type parameter and the `o` parameter must be classes whose signatures are attributed with the <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="f799e-424">[Tlbimp.exe (형식 라이브러리 가져오기)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) 도구 형식 라이브러리를 가져올 때이 특성을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-424">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span> <span data-ttu-id="f799e-425">소스 코드에서 수동으로 RCW를 만들면 원본 coclass를 여는 COM의 원본임을 나타내는 관리 되는 서명에이 특성을 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-425">If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</span></span>  
  
 <span data-ttu-id="f799e-426">Tlbimp.exe 가져오는 COM [coclass](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) 관리 되는 클래스 및 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-426">Tlbimp.exe imports a COM [coclass](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) as a managed class and an interface.</span></span> <span data-ttu-id="f799e-427">Coclass 인터페이스에 동일한 이름으로 원본 coclass와 관리 되는 클래스 이름이 원래 coclass "Class"로 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-427">The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</span></span> <span data-ttu-id="f799e-428">예를 들면 coclass 라는 `MyCoclass` 되 호출을 coclass 인터페이스 `MyCoclass` 라는 관리 되는 클래스 및 `MyCoclassClass`합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-428">For example, a coclass called `MyCoclass` becomes a coclass interface called `MyCoclass` and a managed class called `MyCoclassClass`.</span></span> <span data-ttu-id="f799e-429">때문에`T` 관리 되는 클래스를 지정 하는 클래스 인터페이스가 아닌 반드시 이어야 합니다 (`MyCoclassClass`) 및 not는 `coclass` 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-429">Because`T` must be a class, not an interface, be sure to specify the managed class (`MyCoclassClass`) and not the `coclass` interface.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f799e-430">새 RCW 인스턴스를 래핑하기 때문에 입력된 하는 COM 개체의 id를 손실 된 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 원래 RCW에 의해 노출 되는 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-430">You lose the identity of the input COM object, because a new RCW instance wraps the [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer exposed by the original RCW.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-431"><typeparamref name="T" />는 <see langword="__ComObject" />에서 파생되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-431"><typeparamref name="T" /> must derive from <see langword="__ComObject" />.</span></span>  
  
 <span data-ttu-id="f799e-432">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-432">-or-</span></span>  
  
 <span data-ttu-id="f799e-433"><typeparamref name="T" />가 [!INCLUDE[wrt](~/includes/wrt-md.md)] 형식인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-433"><typeparamref name="T" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="f799e-434"><paramref name="o" />가 원하는 모든 인터페이스를 지원하지 않으므로 <paramref name="TWrapper" />으로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-434"><paramref name="o" /> cannot be converted to the <paramref name="TWrapper" /> because it does not support all required interfaces.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-435">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-435">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-436">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-436">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure">
      <MemberSignature Language="C#" Value="public static void DestroyStructure (IntPtr ptr, Type structuretype);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure(native int ptr, class System.Type structuretype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure (ptr As IntPtr, structuretype As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DestroyStructure(IntPtr ptr, Type ^ structuretype);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structuretype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-437">관리되지 않는 메모리 블록에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-437">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structuretype"><span data-ttu-id="f799e-438">형식이 지정된 클래스의 형식으로,</span><span class="sxs-lookup"><span data-stu-id="f799e-438">Type of a formatted class.</span></span> <span data-ttu-id="f799e-439"><c>ptr</c> 매개 변수에 있는 버퍼를 삭제하는 데 필요한 레이아웃 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-439">This provides the layout information necessary to delete the buffer in the <c>ptr</c> parameter.</span></span></param>
        <summary><span data-ttu-id="f799e-440">지정된 관리되지 않는 메모리 블록이 가리키는 모든 하위 구조체를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-440">Frees all substructures that the specified unmanaged memory block points to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-441">이 메서드는 관리 되지 않는 구조의 문자열과 같은 참조 형식 필드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-441">You can use this method to free reference-type fields, such as strings, of an unmanaged structure.</span></span> <span data-ttu-id="f799e-442">해당 필드와 달리 구조체는 값 형식 또는 참조 형식 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-442">Unlike its fields, a structure can be a value type or a reference type.</span></span> <span data-ttu-id="f799e-443">값 형식 필드 (모든 blittable)를 포함 하는 값 형식 구조 있어야 해당 메모리를 해제 해야 하는 참조가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-443">Value-type structures that contain value-type fields (all blittable) have no references whose memory must be freed.</span></span> <span data-ttu-id="f799e-444"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> 메서드는 구조체에서 사용한 메모리를 다시 사용할 때 메모리 누수를 방지 하기 위해이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-444">The <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</span></span>  
  
 <span data-ttu-id="f799e-445"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> COM 호출 [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) 함수를 다시 할당 된 문자열을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-445"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> calls the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) function, which, in turn, frees an allocated string.</span></span>  
  
 <span data-ttu-id="f799e-446">외에 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>, <xref:System.Runtime.InteropServices.Marshal> 클래스에서는 두 가지 다른 메모리 할당 해제 방법: <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> 및 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-446">In addition to <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation methods: <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-447"><paramref name="structureType" />에 Auto 레이아웃이 지정된 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-447"><paramref name="structureType" /> has an automatic layout.</span></span> <span data-ttu-id="f799e-448">대신 Sequential 또는 Explicit 레이아웃을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-448">Use sequential or explicit instead.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-449">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-449">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-450">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-450">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DestroyStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure(Of T) (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void DestroyStructure(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-451">형식이 지정된 구조체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-451">The type of the formatted structure.</span></span> <span data-ttu-id="f799e-452"><c>ptr</c> 매개 변수에 있는 버퍼를 삭제하는 데 필요한 레이아웃 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-452">This provides the layout information necessary to delete the buffer in the <c>ptr</c> parameter.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="f799e-453">관리되지 않는 메모리 블록에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-453">A pointer to an unmanaged block of memory.</span></span></param>
        <summary><span data-ttu-id="f799e-454">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-454">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-455">지정된 관리되지 않는 메모리 블록이 가리키는 지정된 형식의 모든 하위 구조체를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-455">Frees all substructures of a specified type that the specified unmanaged memory block points to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-456">이 메서드는 관리 되지 않는 구조의 문자열과 같은 참조 형식 필드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-456">You can use this method to free reference type fields, such as strings, of an unmanaged structure.</span></span> <span data-ttu-id="f799e-457">해당 필드와 달리 구조체는 값 형식 또는 참조 형식 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-457">Unlike its fields, a structure can be a value type or a reference type.</span></span> <span data-ttu-id="f799e-458">값 형식 필드 (모든 blittable)를 포함 하는 값 형식 구조 있어야 해당 메모리를 해제 해야 하는 참조가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-458">Value type structures that contain value type fields (all blittable) have no references whose memory must be freed.</span></span> <span data-ttu-id="f799e-459"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> 메서드는 구조체에서 사용한 메모리를 다시 사용할 때 메모리 누수를 방지 하기 위해이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-459">The <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</span></span>  
  
 <span data-ttu-id="f799e-460"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> COM 호출 [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) 함수를 다시 할당 된 문자열을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-460"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> calls the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) function, which, in turn, frees an allocated string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-461"><typeparamref name="T" />에 Auto 레이아웃이 지정된 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-461"><typeparamref name="T" /> has an automatic layout.</span></span> <span data-ttu-id="f799e-462">대신 Sequential 또는 Explicit 레이아웃을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-462">Use sequential or explicit instead.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-463">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-463">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-464">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-464">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="FinalReleaseComObject">
      <MemberSignature Language="C#" Value="public static int FinalReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FinalReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FinalReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FinalReleaseComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f799e-465">해제할 RCW입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-465">The RCW to be released.</span></span></param>
        <summary><span data-ttu-id="f799e-466">참조 횟수를 0으로 설정하여 [RCW(런타임 호출 가능 래퍼)](~/docs/framework/interop/runtime-callable-wrapper.md)에 대한 모든 참조를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-466">Releases all references to a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) by setting its reference count to 0.</span></span></summary>
        <returns><span data-ttu-id="f799e-467"><paramref name="o" /> 매개 변수에 연결된 RCW의 새 참조 횟수 값입니다. 해제 작업을 성공적으로 마치면 값이 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-467">The new value of the reference count of the RCW associated with the <paramref name="o" /> parameter, which is 0 (zero) if the release is successful.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-468"><xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> 메서드는 COM 개체에 대 한 관리 되는 참조를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-468">The <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method releases the managed reference to a COM object.</span></span> <span data-ttu-id="f799e-469">이 메서드를 호출 하는 것은 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 0 (영)을 반환 될 때까지 루프에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-469">Calling this method is equivalent to calling the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method in a loop until it returns 0 (zero).</span></span>  
  
 <span data-ttu-id="f799e-470">COM 개체의 참조 횟수가 0이 되 면 때 COM 개체는 일반적으로 COM 개체의 구현에 따라이 고 런타임에 제어할 수 없는 해제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-470">When the reference count on the COM object becomes 0, the COM object is usually freed, although this depends on the COM object's implementation and is beyond the control of the runtime.</span></span> <span data-ttu-id="f799e-471">그러나 RCW 수 여전히 존재 가비지 수집 될 때까지 기다려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-471">However, the RCW can still exist, waiting to be garbage-collected.</span></span>  
  
 <span data-ttu-id="f799e-472">기본 RCW에서 분리 된 후에 COM 개체를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-472">The COM object cannot be used after it has been separated from its underlying RCW.</span></span> <span data-ttu-id="f799e-473">참조 횟수가 0 이면 후 RCW에서 메서드를 호출 하려고 하면는 <xref:System.Runtime.InteropServices.InvalidComObjectException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-473">If you try to call a method on the RCW after its reference count becomes 0, a <xref:System.Runtime.InteropServices.InvalidComObjectException> will be thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-474"><paramref name="o" />가 올바른 개체 범위가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-474"><paramref name="o" /> is not a valid COM object.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-475"><paramref name="o" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-475"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-476">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-476">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-477">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-477">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="FreeBSTR">
      <MemberSignature Language="C#" Value="public static void FreeBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeBSTR (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeBSTR(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-478">해제할 BSTR의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-478">The address of the BSTR to be freed.</span></span></param>
        <summary><span data-ttu-id="f799e-479">COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) 함수를 사용하여 <see langword="BSTR" />을 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-479">Frees a <see langword="BSTR" /> using the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-480">마찬가지로 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType> 및 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>, 메모리 할당을 취소 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-480">Like <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>, you can use this method to deallocate memory.</span></span> <span data-ttu-id="f799e-481"><xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A> COM 호출 [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) 다음과 같은 관리 되지 않는 메서드에 의해 할당 된 메모리를 해제 하는 함수를: `SysAllocString`, `SysAllocStringByteLen`, `SysAllocStringLen`, `SysReAllocString`, `SysReAllocStringLen`합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-481"><xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A> calls the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) function, which frees memory allocated by any of the following unmanaged methods: `SysAllocString`, `SysAllocStringByteLen`, `SysAllocStringLen`, `SysReAllocString`, `SysReAllocStringLen`.</span></span> <span data-ttu-id="f799e-482">플랫폼에서 이러한 호출 같은 관리 되지 않는 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-482">You can call unmanaged methods such as these with platform invoke.</span></span> <span data-ttu-id="f799e-483">자세한 내용은 참조 [관리 되지 않는 DLL 함수를 사용해](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-483">For details, see [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-484">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-484">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-485">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-485">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeCoTaskMem">
      <MemberSignature Language="C#" Value="public static void FreeCoTaskMem (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeCoTaskMem(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeCoTaskMem (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeCoTaskMem(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-486">해제할 메모리의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-486">The address of the memory to be freed.</span></span></param>
        <summary><span data-ttu-id="f799e-487">관리되지 않는 COM 작업 메모리 할당자에서 할당한 메모리 블록을 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-487">Frees a block of memory allocated by the unmanaged COM task memory allocator.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-488">사용할 수 있습니다 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> 의해 할당 된 메모리를 비우는 <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>, 또는 이와 동등한 관리 되지 않는 메서드에 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-488">You can use <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> to free any memory allocated by <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>, or any equivalent unmanaged method.</span></span> <span data-ttu-id="f799e-489">경우는 `ptr` 매개 변수는 `null`, 메서드는 아무 작업도 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-489">If the `ptr` parameter is `null`, the method does nothing.</span></span>  
  
 <span data-ttu-id="f799e-490"><xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> COM 노출 [CoTaskMemFree](http://go.microsoft.com/fwlink/?LinkId=148638) 함수는 메모리를 더 이상 사용할 수 있도록 모든 바이트를 해제 하는 `ptr` 매개 변수를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-490"><xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> exposes the COM [CoTaskMemFree](http://go.microsoft.com/fwlink/?LinkId=148638) function, which frees all bytes so that you can no longer use the memory that the `ptr` parameter points to.</span></span>  
  
 <span data-ttu-id="f799e-491">외에 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal> 클래스에서는 두 가지 다른 메모리 할당 해제 방법: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> 및 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-491">In addition to <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation methods: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-492">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-492">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-493">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-493">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeHGlobal">
      <MemberSignature Language="C#" Value="public static void FreeHGlobal (IntPtr hglobal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeHGlobal(native int hglobal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeHGlobal (hglobal As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeHGlobal(IntPtr hglobal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hglobal" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hglobal"><span data-ttu-id="f799e-494"><see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> 호출과 일치하는 원본 호출에서 반환되는 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-494">The handle returned by the original matching call to <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span></span></param>
        <summary><span data-ttu-id="f799e-495">프로세스의 관리되지 않는 메모리에서 이전에 할당한 메모리를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-495">Frees memory previously allocated from the unmanaged memory of the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-496">사용할 수 있습니다 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> 의해 할당 된 전역 힙에서 메모리를 비우는 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>, 또는 이와 동등한 API 메서드가 관리 되지 않는 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-496">You can use <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> to free any memory from the global heap allocated by <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>, or any equivalent unmanaged API method.</span></span> <span data-ttu-id="f799e-497">경우는 `hglobal` 매개 변수는 <xref:System.IntPtr.Zero?displayProperty=nameWithType> 메서드는 아무 작업도 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-497">If the `hglobal` parameter is <xref:System.IntPtr.Zero?displayProperty=nameWithType> the method does nothing.</span></span>  
  
 <span data-ttu-id="f799e-498"><xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> 노출 된 [LocalFree](http://go.microsoft.com/fwlink/?LinkId=148640) 가리키는 메모리를 더 이상 사용할 수 있도록 모든 바이트를 해제 하는 kernel32.dll 함수 `hglobal`합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-498"><xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> exposes the [LocalFree](http://go.microsoft.com/fwlink/?LinkId=148640) function from Kernel32.DLL, which frees all bytes so that you can no longer use the memory pointed to by `hglobal`.</span></span>  
  
 <span data-ttu-id="f799e-499">외에 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal> 클래스는 두 개의 다른 메모리 할당 해제 API 메서드를 제공: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> 및 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-499">In addition to <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation API methods: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-500">다음 예제에서는 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> 메서드를 호출하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-500">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> method.</span></span> <span data-ttu-id="f799e-501">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Runtime.InteropServices.Marshal> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-501">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 <span data-ttu-id="f799e-502">다음 예제에서는 관리 되는 콘텐츠를 변환 하는 방법을 <xref:System.String> 관리 되지 않는 메모리에 클래스를 한 다음 완료 한 후에 관리 되지 않는 메모리의 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-502">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-503">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-503">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-504">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-504">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GenerateGuidForType">
      <MemberSignature Language="C#" Value="public static Guid GenerateGuidForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GenerateGuidForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GenerateGuidForType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="f799e-505">GUID를 생성할 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-505">The type to generate a GUID for.</span></span></param>
        <summary><span data-ttu-id="f799e-506">지정된 형식에 대한 GUID(Globally Unique Identifier)를 반환하거나 형식 라이브러리 내보내기(TlbExp.exe)에 사용되는 알고리즘을 사용하여 GUID를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-506">Returns the globally unique identifier (GUID) for the specified type, or generates a GUID using the algorithm used by the Type Library Exporter (Tlbexp.exe).</span></span></summary>
        <returns><span data-ttu-id="f799e-507">지정된 형식의 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-507">An identifier for the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-508">메타 데이터에는 GUID를 형식이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-508">If the type has a GUID in the metadata, it is returned.</span></span> <span data-ttu-id="f799e-509">그렇지 않은 경우 GUID는 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-509">Otherwise, a GUID is automatically generated.</span></span> <span data-ttu-id="f799e-510">프로그래밍 방식으로 COM에서 볼 수 없는 형식을 포함 하 여, 관리 되는 모든 형식에 대 한 COM GUID를 확인 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-510">You can use this method to programmatically determine the COM GUID for any managed type, including COM-invisible types.</span></span> <span data-ttu-id="f799e-511">관리 되는 형식에 맞지 않는 클래스 인터페이스는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-511">Class interfaces are the only exception because they do not correspond to a managed type.</span></span> <span data-ttu-id="f799e-512"><xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A> 와 동일한 기능을 제공 된 <xref:System.Type.GUID%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-512"><xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A> provides the same functionality as the <xref:System.Type.GUID%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-513">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-513">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-514">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-514">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.Type.GUID" />
      </Docs>
    </Member>
    <Member MemberName="GenerateProgIdForType">
      <MemberSignature Language="C#" Value="public static string GenerateProgIdForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GenerateProgIdForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GenerateProgIdForType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="f799e-515">ProgID를 가져올 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-515">The type to get a ProgID for.</span></span></param>
        <summary><span data-ttu-id="f799e-516">지정된 형식에 대한 ProgID(프로그래밍 식별자)를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-516">Returns a programmatic identifier (ProgID) for the specified type.</span></span></summary>
        <returns><span data-ttu-id="f799e-517">지정된 형식의 ProgID입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-517">The ProgID of the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-518">형식에 ProgID 반환 되는 메타 데이터에 ProgID가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-518">If the type has a ProgID in the metadata, that ProgID is returned.</span></span> <span data-ttu-id="f799e-519">그렇지 않으면 ProgID는 사용 하는 형식의 정규화 된 이름을 기반으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-519">Otherwise, a ProgID is generated based on the fully qualified name of the type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-520"><paramref name="type" /> 매개 변수가 COM에서 만들 수 없는 클래스인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-520">The <paramref name="type" /> parameter is not a class that can be create by COM.</span></span> <span data-ttu-id="f799e-521">이 클래스는 공용이며, 공용 기본 생성자를 가지며, COM에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-521">The class must be public, have a public default constructor, and be COM visible.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-522"><paramref name="type" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-522">The <paramref name="type" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-523">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-523">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-524">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-524">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetActiveObject">
      <MemberSignature Language="C#" Value="public static object GetActiveObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetActiveObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActiveObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetActiveObject(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="f799e-525">요청된 개체의 ProgID(프로그래밍 식별자)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-525">The programmatic identifier (ProgID) of the object that was requested.</span></span></param>
        <summary><span data-ttu-id="f799e-526">ROT(실행 개체 테이블)에서 지정된 개체의 실행 중인 인스턴스를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-526">Obtains a running instance of the specified object from the running object table (ROT).</span></span></summary>
        <returns><span data-ttu-id="f799e-527">요청된 개체입니다. 그렇지 않으면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-527">The object that was requested; otherwise <see langword="null" />.</span></span> <span data-ttu-id="f799e-528">이 개체를 지원되는 COM 인터페이스로 캐스팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-528">You can cast this object to any COM interface that it supports.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-529"><xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> COM 노출 [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) 함수가 OLEAUT32 되지 않도록에서 합니다. DLL; 그러나 필요 하지만 두 번째는 CLSID (클래스 식별자)의 프로그래밍 방식 식별자 (`ProgID`)이 메서드가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-529"><xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> exposes the COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) function from OLEAUT32.DLL; however, the latter expects a class identifier (CLSID) instead of the programmatic identifier (`ProgID`) expected by this method.</span></span> <span data-ttu-id="f799e-530">없이 등록 된 COM 개체의 실행 중인 인스턴스를 가져오는 `ProgID`를 사용 하 여 플랫폼 호출을 COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-530">To obtain a running instance of a COM object without a registered `ProgID`, use platform invoke to define the COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) function.</span></span> <span data-ttu-id="f799e-531">에 대 한 설명은 플랫폼 호출을 참조 [관리 되지 않는 DLL 함수를 사용해](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-531">For a description of platform invoke, see [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span></span>  
  
## <a name="progid-and-clsid"></a><span data-ttu-id="f799e-532">ProgID 및 CLSID</span><span class="sxs-lookup"><span data-stu-id="f799e-532">ProgID and CLSID</span></span>  
 <span data-ttu-id="f799e-533">키 레지스트리의 HKEY_CLASSES_ROOT 하위 트리에 다양 한 형식 하위 키를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-533">Keys in the HKEY_CLASSES_ROOT subtree of the registry contain a variety of subkey types.</span></span> <span data-ttu-id="f799e-534">하위 키 대부분은 사용자에 게 친숙 한 문자열 CLSID에 매핑되는 Progid입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-534">Most of the subkeys are ProgIDs, which map a user-friendly string to a CLSID.</span></span> <span data-ttu-id="f799e-535">응용 프로그램 숫자 Clsid 대신 이러한 읽을 문자열을 사용 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-535">Applications often use these human-readable strings instead of the numeric CLSIDs.</span></span> <span data-ttu-id="f799e-536">구성 요소에 최신 버전의 시스템에 설치 하는 구성 요소에 매핑되는 버전 독립 ProgID 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-536">Often, a component has a version-independent ProgID that is mapped to the latest version of the component that is installed on the system.</span></span>  
  
 <span data-ttu-id="f799e-537">응용 프로그램 및 구성 주로 Progid 사용 하 여 해당의 Clsid를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-537">Applications and components primarily use ProgIDs to retrieve their corresponding CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-538">다음 예제를 Microsoft Word의 실행 인스턴스를 사용 하 여 구성 된 하는 컴퓨터에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-538">The following example was run on a computer that was configured with a running instance of Microsoft Word.</span></span> <span data-ttu-id="f799e-539">실행 하는 Microsoft Excel의 인스턴스인 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-539">There were no instances of Microsoft Excel running.</span></span>  
  
 <span data-ttu-id="f799e-540">예제에서는 호출 <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> 두 번입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-540">The example calls <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> twice.</span></span> <span data-ttu-id="f799e-541">Microsoft Word의 인스턴스에 대 한 참조를 검색 하려고 하면 첫 번째 호출 (의 인스턴스는 `Word.Application` 개체).</span><span class="sxs-lookup"><span data-stu-id="f799e-541">The first call tries to retrieve a reference to an instance of Microsoft Word (an instance of the `Word.Application` object).</span></span> <span data-ttu-id="f799e-542">Microsoft Excel의 인스턴스에 대 한 참조를 검색 하려고 하면 두 번째 호출 (의 인스턴스는 `Excel.Application` 개체).</span><span class="sxs-lookup"><span data-stu-id="f799e-542">The second call tries to retrieve a reference to an instance of Microsoft Excel (an instance of an `Excel.Application` object).</span></span>  
  
 <span data-ttu-id="f799e-543">코드는 Microsoft Word의 인스턴스에 대 한 참조를 성공적으로 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-543">The code retrieves a reference to an instance of Microsoft Word successfully.</span></span> <span data-ttu-id="f799e-544">그러나 Microsoft Excel 실행 중이 아니므로 두 번째 개체를 검색 하려는 시도가 발생 한 <xref:System.Runtime.InteropServices.COMException>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-544">However, because Microsoft Excel is not running, the attempt to retrieve the second object raises a <xref:System.Runtime.InteropServices.COMException>.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/cs/marshal.getactiveobject.cs#1)]
 [!code-vb[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/vb/marshal.getactiveobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="f799e-545">개체를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-545">The object was not found.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-546">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-546">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-547">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-547">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetComInterfaceForObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-548">개체의 인터페이스를 나타내는 인터페이스 포인터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-548">Returns an interface pointer that represents an interface for an object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f799e-549">인터페이스를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-549">The object that provides the interface.</span></span></param>
        <param name="T"><span data-ttu-id="f799e-550">요청된 인터페이스의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-550">The type of interface that is requested.</span></span></param>
        <summary><span data-ttu-id="f799e-551">지정된 개체의 지정된 인터페이스를 나타내는 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 인터페이스에 대한 포인터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-551">Returns a pointer to an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface that represents the specified interface on the specified object.</span></span> <span data-ttu-id="f799e-552">사용자 지정 쿼리 인터페이스 액세스가 기본적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-552">Custom query interface access is enabled by default.</span></span></summary>
        <returns><span data-ttu-id="f799e-553">개체에 대해 지정된 인터페이스를 나타내는 인터페이스 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-553">The interface pointer that represents the specified interface for the object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-554">이 메서드는 지정된 된 개체에 요청 된 인터페이스를 나타내는 인터페이스 포인터를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-554">This method returns an interface pointer that represents the requested interface on the specified object.</span></span> <span data-ttu-id="f799e-555">인터페이스 포인터를 전달 해야 하는 관리 되지 않는 메서드가 있는 경우에 특히 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-555">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span> <span data-ttu-id="f799e-556">이 방법으로 개체를 호출 하면의 참조 횟수를 반환 되기 전에 포인터에 인터페이스 포인터 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-556">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="f799e-557">항상 사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 포인터 작업이 완료 되 면 참조 횟수를 감소 시키기 위해.</span><span class="sxs-lookup"><span data-stu-id="f799e-557">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="f799e-558">원시 COM 인터페이스 포인터를 사용 하는 경우 COM에 정의 된 규칙을 준수 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-558">You must adhere to the rules defined by COM when using raw COM interface pointers.</span></span>  
  
 <span data-ttu-id="f799e-559"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> 으로 COM 개체 매개 변수를 노출 하는 메서드를 호출할 때 유용 프로그램 <xref:System.IntPtr> 형식 또는 사용자 지정 마샬링을 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-559"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="f799e-560">개체의 COM 호출 가능 래퍼에 대 한 포인터를 가져올 수 있지만 흔한 경우는 관리 되는 개체에이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-560">Although less common, you can use this method on a managed object to obtain a pointer to the object's COM callable wrapper.</span></span> <span data-ttu-id="f799e-561">사용할 수는 예를 들어 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> com 인터페이스 포인터에 대 한으로 내보낸 관리 되는 개체가 <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-561">For example, you can use <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> on a managed object that is exported to COM to obtain an interface pointer for <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f799e-562">두 번째 매개 변수를 전달 하 고 해당 형식이 없으므로 클래스에는 클래스 인터페이스에 대 한 포인터를 가져올 수 없습니다 (`t`).</span><span class="sxs-lookup"><span data-stu-id="f799e-562">You cannot obtain a pointer to a class interface since a class interface lacks the corresponding type to pass to the second parameter (`t`).</span></span> <span data-ttu-id="f799e-563">대신를 사용 하 여 <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> COM 호출 가능 래퍼가 일반적으로 자동 디스패치 클래스 인터페이스의 기본 인터페이스에 멤버를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-563">Instead, use <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to invoke the members on the default interface of the COM callable wrapper, which is usually an auto-dispatch class interface.</span></span>  
  
 <span data-ttu-id="f799e-564"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> 메서드 오버 로드는 기본적으로 쿼리 인터페이스 사용자 지정을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-564">The <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> method overload allows query interface customization by default.</span></span> <span data-ttu-id="f799e-565">쿼리 인터페이스 사용자 지정을 적용할지 여부를 지정 하려면 사용 된 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-565">To specify whether to apply query interface customization, use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> method overload.</span></span>  
  
 <span data-ttu-id="f799e-566">자세한 내용은 참조는 [COM 호출 가능 래퍼](~/docs/framework/interop/com-callable-wrapper.md), [런타임 호출 가능 래퍼](~/docs/framework/interop/runtime-callable-wrapper.md), 및 [클래스 인터페이스 소개](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-566">For additional information, see the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), and [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) topics.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-567"><typeparamref name="T" /> 매개 변수가 인터페이스가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-567">The <typeparamref name="T" /> parameter is not an interface.</span></span>  
  
 <span data-ttu-id="f799e-568">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-568">-or-</span></span>  
  
 <span data-ttu-id="f799e-569">COM에 해당 형식이 표시되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-569">The type is not visible to COM.</span></span>  
  
 <span data-ttu-id="f799e-570">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-570">-or-</span></span>  
  
 <span data-ttu-id="f799e-571"><typeparamref name="T" /> 매개 변수는 제네릭 형식 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-571">The <typeparamref name="T" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="f799e-572"><paramref name="o" /> 매개 변수가 요청된 인터페이스를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-572">The <paramref name="o" /> parameter does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-573"><paramref name="o" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-573">The <paramref name="o" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-574">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-574">-or-</span></span>  
  
 <span data-ttu-id="f799e-575"><typeparamref name="T" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-575">The <typeparamref name="T" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-576">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-576">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-577">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-577">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T, System.Runtime.InteropServices.CustomQueryInterfaceMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T, valuetype System.Runtime.InteropServices.CustomQueryInterfaceMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type, mode As CustomQueryInterfaceMode) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T, System::Runtime::InteropServices::CustomQueryInterfaceMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
        <Parameter Name="mode" Type="System.Runtime.InteropServices.CustomQueryInterfaceMode" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f799e-578">인터페이스를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-578">The object that provides the interface.</span></span></param>
        <param name="T"><span data-ttu-id="f799e-579">요청된 인터페이스의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-579">The type of interface that is requested.</span></span></param>
        <param name="mode"><span data-ttu-id="f799e-580"><see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" />에서 제공하는 <see langword="IUnknown::QueryInterface" /> 사용자 지정을 적용하는지 여부를 나타내는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-580">One of the enumeration values that indicates whether to apply an <see langword="IUnknown::QueryInterface" /> customization that is supplied by an <see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" />.</span></span></param>
        <summary><span data-ttu-id="f799e-581">지정된 개체의 지정된 인터페이스를 나타내는 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 인터페이스에 대한 포인터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-581">Returns a pointer to an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface that represents the specified interface on the specified object.</span></span> <span data-ttu-id="f799e-582">사용자 지정 쿼리 인터페이스 액세스는 지정된 사용자 지정 모드에 의해 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-582">Custom query interface access is controlled by the specified customization mode.</span></span></summary>
        <returns><span data-ttu-id="f799e-583">개체에 대한 인터페이스를 나타내는 인터페이스 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-583">The interface pointer that represents the interface for the object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-584"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> 쿼리 인터페이스 사용자 지정을 적용할지 여부를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-584"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> lets you specify whether to apply query interface customization.</span></span> <span data-ttu-id="f799e-585">사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> 오버 로드를 기본적으로 쿼리 인터페이스 사용자 지정을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-585">Use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> overload to apply query interface customization by default.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-586"><typeparamref name="T" /> 매개 변수가 인터페이스가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-586">The <typeparamref name="T" /> parameter is not an interface.</span></span>  
  
 <span data-ttu-id="f799e-587">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-587">-or-</span></span>  
  
 <span data-ttu-id="f799e-588">COM에 해당 형식이 표시되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-588">The type is not visible to COM.</span></span>  
  
 <span data-ttu-id="f799e-589">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-589">-or-</span></span>  
  
 <span data-ttu-id="f799e-590"><typeparamref name="T" /> 매개 변수는 제네릭 형식 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-590">The <typeparamref name="T" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="f799e-591"><paramref name="o" /> 개체가 요청된 인터페이스를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-591">The object <paramref name="o" /> does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-592"><paramref name="o" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-592">The <paramref name="o" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-593">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-593">-or-</span></span>  
  
 <span data-ttu-id="f799e-594"><typeparamref name="T" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-594">The <typeparamref name="T" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-595">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-595">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-596">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-596">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject&lt;T,TInterface&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject&lt;T,TInterface&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject&lt;T, TInterface&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject(Of T, TInterface) (o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TInterface&gt;&#xA; static IntPtr GetComInterfaceForObject(T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TInterface" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-597">유형의 <c>o</c>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-597">The type of <c>o</c>.</span></span></typeparam>
        <typeparam name="TInterface"><span data-ttu-id="f799e-598">반환할 인터페이스의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-598">The type of interface to return.</span></span></typeparam>
        <param name="o"><span data-ttu-id="f799e-599">인터페이스를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-599">The object that provides the interface.</span></span></param>
        <summary><span data-ttu-id="f799e-600">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-600">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-601">지정된 형식의 개체에 지정된 인터페이스를 나타내는 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 인터페이스에 대한 포인터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-601">Returns a pointer to an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface that represents the specified interface on an object of the specified type.</span></span> <span data-ttu-id="f799e-602">사용자 지정 쿼리 인터페이스 액세스가 기본적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-602">Custom query interface access is enabled by default.</span></span></summary>
        <returns><span data-ttu-id="f799e-603"><paramref name="TInterface" /> 인터페이스를 나타내는 인터페이스 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-603">The interface pointer that represents the <paramref name="TInterface" /> interface.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-604">이 메서드를 나타내는 인터페이스 포인터를 반환 합니다.는 `TInterface` 지정된 된 개체에 대 한 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-604">This method returns an interface pointer that represents the `TInterface` interface on the specified object.</span></span> <span data-ttu-id="f799e-605">인터페이스 포인터를 전달 해야 하는 관리 되지 않는 메서드가 있는 경우에 특히 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-605">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span> <span data-ttu-id="f799e-606">이 방법으로 개체를 호출 하면의 참조 횟수를 반환 되기 전에 포인터에 인터페이스 포인터 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-606">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="f799e-607">항상 사용 하는 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 포인터 작업이 완료 되는 경우 참조 횟수를 감소 시키기 위해 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-607">Always use the <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> method to decrement the reference count when you have finished with the pointer.</span></span> <span data-ttu-id="f799e-608">원시 COM 인터페이스 포인터를 사용 하는 경우 COM에 정의 된 규칙을 준수 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-608">You must adhere to the rules defined by COM when using raw COM interface pointers.</span></span>  
  
 <span data-ttu-id="f799e-609"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> 으로 COM 개체 매개 변수를 노출 하는 메서드를 호출할 때 유용 프로그램 <xref:System.IntPtr> 형식 또는 사용자 지정 마샬링을 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-609"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="f799e-610">이 일반적이 지는 개체의 COM 호출 가능 래퍼에 대 한 포인터를 가져올 수 관리 되는 개체에이 방법을 사용도 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-610">You can also use this method on a managed object to obtain a pointer to the object's COM callable wrapper, although this is less common.</span></span> <span data-ttu-id="f799e-611">사용할 수는 예를 들어 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> com 인터페이스 포인터에 대 한으로 내보낸 관리 되는 개체가 <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-611">For example, you can use <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> on a managed object that is exported to COM to obtain an interface pointer for <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f799e-612"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> 메서드 오버 로드는 기본적으로 쿼리 인터페이스 사용자 지정을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-612">The <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> method overload allows query interface customization by default.</span></span> <span data-ttu-id="f799e-613">쿼리 인터페이스 사용자 지정을 적용할지 여부를 지정 하려면 사용 된 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-613">To specify whether to apply query interface customization, use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> method overload.</span></span>  
  
 <span data-ttu-id="f799e-614">자세한 내용은 참조는 [COM 호출 가능 래퍼](~/docs/framework/interop/com-callable-wrapper.md), [런타임 호출 가능 래퍼](~/docs/framework/interop/runtime-callable-wrapper.md), 및 [클래스 인터페이스 소개](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-614">For additional information, see the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), and [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) topics.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-615"><paramref name="TInterface" /> 매개 변수가 인터페이스가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-615">The <paramref name="TInterface" /> parameter is not an interface.</span></span>  
  
 <span data-ttu-id="f799e-616">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-616">-or-</span></span>  
  
 <span data-ttu-id="f799e-617">COM에 해당 형식이 표시되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-617">The type is not visible to COM.</span></span>  
  
 <span data-ttu-id="f799e-618">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-618">-or-</span></span>  
  
 <span data-ttu-id="f799e-619"><typeparamref name="T" /> 매개 변수는 개방형 제네릭 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-619">The <typeparamref name="T" /> parameter is an open generic type.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="f799e-620"><paramref name="o" /> 매개 변수가 <paramref name="TInterface" /> 인터페이스를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-620">The <paramref name="o" /> parameter does not support the <paramref name="TInterface" /> interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-621"><paramref name="o" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-621">The <paramref name="o" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-622">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-622">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-623">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-623">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObjectInContext (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObjectInContext(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObjectInContext (o As Object, t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObjectInContext(System::Object ^ o, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f799e-624">인터페이스를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-624">The object that provides the interface.</span></span></param>
        <param name="t"><span data-ttu-id="f799e-625">요청된 인터페이스의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-625">The type of interface that is requested.</span></span></param>
        <summary><span data-ttu-id="f799e-626">호출자가 개체와 같은 컨텍스트에 있는 경우 해당 개체에 대해 지정된 인터페이스를 나타내는 인터페이스 포인터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-626">Returns an interface pointer that represents the specified interface for an object, if the caller is in the same context as that object.</span></span></summary>
        <returns><span data-ttu-id="f799e-627">지정된 개체에 대한 인터페이스를 나타내는 <paramref name="t" />가 지정하는 인터페이스 포인터이거나, 호출자가 개체와 같은 컨텍스트에 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-627">The interface pointer specified by <paramref name="t" /> that represents the interface for the specified object, or <see langword="null" /> if the caller is not in the same context as the object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-628">이 메서드는 동일 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A> 반환 한다는 점을 제외 하 고 `null` 개체와 같은 컨텍스트에 호출자에 게 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-628">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span> <span data-ttu-id="f799e-629">인터페이스 포인터를 전달 해야 하는 관리 되지 않는 메서드가 있는 경우에 특히 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-629">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-630"><paramref name="t" />가 인터페이스가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-630"><paramref name="t" /> is not an interface.</span></span>  
  
 <span data-ttu-id="f799e-631">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-631">-or-</span></span>  
  
 <span data-ttu-id="f799e-632">COM에 해당 형식이 표시되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-632">The type is not visible to COM.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="f799e-633"><paramref name="o" />가 요청된 인터페이스를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-633"><paramref name="o" /> does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-634"><paramref name="o" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-634"><paramref name="o" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-635">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-635">-or-</span></span>  
  
 <span data-ttu-id="f799e-636"><paramref name="t" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-636"><paramref name="t" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-637">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-637">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-638">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-638">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComObjectData">
      <MemberSignature Language="C#" Value="public static object GetComObjectData (object obj, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetComObjectData(object obj, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComObjectData (obj As Object, key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetComObjectData(System::Object ^ obj, System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="f799e-639">필요한 데이터가 들어 있는 COM 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-639">The COM object that contains the data that you want.</span></span></param>
        <param name="key"><span data-ttu-id="f799e-640">데이터를 검색할 <c>obj</c>의 내부 해시 테이블에 있는 키입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-640">The key in the internal hash table of <c>obj</c> to retrieve the data from.</span></span></param>
        <summary><span data-ttu-id="f799e-641">지정된 COM 개체에서 지정된 키를 사용하여 참조되는 데이터를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-641">Retrieves data that is referenced by the specified key from the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="f799e-642"><paramref name="obj" /> 매개 변수의 내부 해시 테이블에서 <paramref name="key" /> 매개 변수가 나타내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-642">The data represented by the <paramref name="key" /> parameter in the internal hash table of the <paramref name="obj" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-643">모든 COM 개체에 래핑되는 [런타임 호출 가능 래퍼](~/docs/framework/interop/runtime-callable-wrapper.md) 연결 해 시도 테이블 <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A> 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-643">All COM objects wrapped in a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) have an associated hash table, which <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A> retrieves.</span></span> <span data-ttu-id="f799e-644"><xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType> 해시 테이블에 데이터를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-644"><xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType> adds data to the hash table.</span></span> <span data-ttu-id="f799e-645">코드에서 두 방법 중 하나를 호출을 수행할 필요는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-645">You should never have to call either method from your code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-646"><paramref name="obj" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-646"><paramref name="obj" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-647">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-647">-or-</span></span>  
  
 <span data-ttu-id="f799e-648"><paramref name="key" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-648"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-649"><paramref name="obj" />가 COM 개체가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-649"><paramref name="obj" /> is not a COM object.</span></span>  
  
 <span data-ttu-id="f799e-650">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-650">-or-</span></span>  
  
 <span data-ttu-id="f799e-651"><paramref name="obj" />가 [!INCLUDE[wrt](~/includes/wrt-md.md)] 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-651"><paramref name="obj" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-652">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-652">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-653">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-653">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComSlotForMethodInfo">
      <MemberSignature Language="C#" Value="public static int GetComSlotForMethodInfo (System.Reflection.MemberInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetComSlotForMethodInfo(class System.Reflection.MemberInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComSlotForMethodInfo (m As MemberInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetComSlotForMethodInfo(System::Reflection::MemberInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="f799e-654">인터페이스 메서드를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-654">An object that represents an interface method.</span></span></param>
        <summary><span data-ttu-id="f799e-655">지정된 <see cref="T:System.Reflection.MemberInfo" /> 형식이 COM에 노출될 때 이 형식에 대한 가상 함수 테이블(v-table 또는 VTBL) 슬롯을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-655">Retrieves the virtual function table (v-table or VTBL) slot for a specified <see cref="T:System.Reflection.MemberInfo" /> type when that type is exposed to COM.</span></span></summary>
        <returns><span data-ttu-id="f799e-656">COM에 노출될 때의 VTBL 슬롯 <paramref name="m" /> 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-656">The VTBL slot <paramref name="m" /> identifier when it is exposed to COM.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-657">에 대 한이 메서드 계정에 의해 반환 되는 0부터 시작 슬롯 수 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 가능 4 [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) 메서드를 사용 가능한 첫 번째 슬롯의 값 중 하나가 3 또는 7입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-657">The zero-based slot number returned by this method accounts for three [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) and possibly four [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) methods, making the value of the first available slot either 3 or 7.</span></span> <span data-ttu-id="f799e-658"><xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> 반대 되는 기능을 제공 <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-658"><xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f799e-659">COM에 표시 되지 않는 인터페이스의 멤버 및 개인 인터페이스의 멤버에 대 한 슬롯 번호를 검색 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-659">You can use this method to retrieve slot numbers for members of interfaces that are not visible from COM and for members of private interfaces.</span></span> <span data-ttu-id="f799e-660">Com 형식을 노출 되었을 때 예약 되는 v 테이블 번호에 해당 하는 반환 된 슬롯 번호</span><span class="sxs-lookup"><span data-stu-id="f799e-660">The slot numbers returned correspond to the v-table numbers that would be reserved if the type was exposed to COM.</span></span> <span data-ttu-id="f799e-661">COM에서 볼 수 없는 멤버 COM 클라이언트는 슬롯을 사용할 수 없는 경우에 실제로 노출 된 v 테이블의 슬롯을 차지 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-661">COM-invisible members actually occupy a slot in an exposed v-table, even though the COM client cannot use the slot.</span></span> <span data-ttu-id="f799e-662">사용할 수 없습니다 <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> 전달 하 여 클래스 인터페이스에서 <xref:System.Reflection.MemberInfo> 클래스에서입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-662">You cannot use <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> on a class interface by passing <xref:System.Reflection.MemberInfo> from a class.</span></span> <span data-ttu-id="f799e-663">자세한 내용은 참조 하십시오. [클래스 인터페이스 소개](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-663">For additional information, see [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-664"><paramref name="m" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-664">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-665"><paramref name="m" /> 매개 변수가 <see cref="T:System.Reflection.MemberInfo" /> 개체가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-665">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MemberInfo" /> object.</span></span>  
  
 <span data-ttu-id="f799e-666">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-666">-or-</span></span>  
  
 <span data-ttu-id="f799e-667"><paramref name="m" /> 매개 변수가 인터페이스 메서드가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-667">The <paramref name="m" /> parameter is not an interface method.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-668">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-668">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-669">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-669">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer">
      <MemberSignature Language="C#" Value="public static Delegate GetDelegateForFunctionPointer (IntPtr ptr, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate GetDelegateForFunctionPointer(native int ptr, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer (ptr As IntPtr, t As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ GetDelegateForFunctionPointer(IntPtr ptr, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-670">변환할 관리되지 않는 함수 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-670">The unmanaged function pointer to be converted.</span></span></param>
        <param name="t"><span data-ttu-id="f799e-671">반환될 대리자의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-671">The type of the delegate to be returned.</span></span></param>
        <summary><span data-ttu-id="f799e-672">관리되지 않는 함수 포인터를 대리자로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-672">Converts an unmanaged function pointer to a delegate.</span></span></summary>
        <returns><span data-ttu-id="f799e-673">적절한 대리자 형식으로 캐스팅될 수 있는 대리자 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-673">A delegate instance that can be cast to the appropriate delegate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-674">버전 1.0 및 1.1의.NET Framework에서는 함수 포인터를 통해 관리 되는 메서드를 호출 하려면 비관리 코드에 함수 포인터로 비관리 코드에 관리 되는 메서드를 나타내는 대리자 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-674">In versions 1.0 and 1.1 of the .NET Framework, it was possible to pass a delegate representing a managed method to unmanaged code as a function pointer, allowing the unmanaged code to call the managed method through the function pointer.</span></span> <span data-ttu-id="f799e-675">관리 코드에 다시 해당 함수 포인터를 전달 하는 관리 되지 않는 코드에 대 한도 있었습니다 및 기본 관리 되는 메서드의 포인터 제대로 확인 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-675">It was also possible for the unmanaged code to pass that function pointer back to the managed code, and the pointer was resolved properly to the underlying managed method.</span></span>  
  
 <span data-ttu-id="f799e-676">.NET Framework 2.0 및 이후 버전에서는 사용할 수 있습니다는 <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> 및 <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> 대리자를 양방향 마샬링해야 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-676">In the .NET Framework 2.0 and later versions, you can use the <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> and <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> methods to marshal delegates in both directions.</span></span> <span data-ttu-id="f799e-677">와 <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>, `ptr` 가져옵니다는 <xref:System.IntPtr?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-677">With <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>, `ptr` is imported as a <xref:System.IntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f799e-678">A <xref:System.IntPtr?displayProperty=nameWithType> 관리 되는 대리자를 호출 하 여 얻을 수 <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> ; 매개 변수로 전달 된 후 호출할 수 있습니다에서 관리 되지 않는 메서드 내부 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-678">A <xref:System.IntPtr?displayProperty=nameWithType> can be obtained for a managed delegate by calling <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> and passed as a parameter; it can then be called from inside the unmanaged method.</span></span> <span data-ttu-id="f799e-679">참고 매개 변수 마샬러.NET Framework 2.0 이상 버전에서 대리자에 대 한 함수 포인터를 마샬링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-679">Note that the parameter marshaler can also marshal function pointers to delegates in the .NET Framework 2.0 and later versions.</span></span>  
  
 <span data-ttu-id="f799e-680"><xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> 메서드는 다음과 같은 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-680">The <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> method has the following restrictions:</span></span>  
  
-   <span data-ttu-id="f799e-681">제네릭 interop 시나리오에서 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-681">Generics are not supported in interop scenarios.</span></span>  
  
-   <span data-ttu-id="f799e-682">이 메서드에 잘못 된 함수 포인터를 전달할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-682">You cannot pass an invalid function pointer to this method.</span></span>  
  
-   <span data-ttu-id="f799e-683">이 메서드는 순수 관리 되지 않는 함수 포인터에 대해서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-683">You can use this method only for pure unmanaged function pointers.</span></span>  
  
-   <span data-ttu-id="f799e-684">이 메서드 또는 c + +를 통해 가져온 함수 포인터를 사용할 수 없습니다는 <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-684">You cannot use this method with function pointers obtained through C++ or from the <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> method.</span></span>  
  
-   <span data-ttu-id="f799e-685">대리자를 만드는 함수 포인터에서 관리 되는 다른 대리자에 게이 메서드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-685">You cannot use this method to create a delegate from a function pointer to another managed delegate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-686"><paramref name="t" /> 매개 변수가 대리자가 아니거나 제네릭인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-686">The <paramref name="t" /> parameter is not a delegate or is generic.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-687"><paramref name="ptr" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-687">The <paramref name="ptr" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-688">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-688">-or-</span></span>  
  
 <span data-ttu-id="f799e-689"><paramref name="t" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-689">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-690">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-690">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-691">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-691">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer(Of TDelegate) (ptr As IntPtr) As TDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="f799e-692">반환할 대리자의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-692">The type of the delegate to return.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="f799e-693">변환할 관리되지 않는 함수 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-693">The unmanaged function pointer to convert.</span></span></param>
        <summary><span data-ttu-id="f799e-694">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-694">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-695">관리되지 않는 함수 포인터를 지정된 형식의 대리자로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-695">Converts an unmanaged function pointer to a delegate of a specified type.</span></span></summary>
        <returns><span data-ttu-id="f799e-696">지정된 대리자 형식의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-696">A instance of the specified delegate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-697">사용할 수는 <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> 및 <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29> 대리자를 양방향 마샬링해야 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-697">You can use the <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> and <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29> methods to marshal delegates in both directions.</span></span>  
  
 <span data-ttu-id="f799e-698"><xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> 메서드는 다음과 같은 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-698">The <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> method has the following restrictions:</span></span>  
  
-   <span data-ttu-id="f799e-699">이 메서드에 잘못 된 함수 포인터를 전달할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-699">You cannot pass an invalid function pointer to this method.</span></span>  
  
-   <span data-ttu-id="f799e-700">이 메서드는 순수 관리 되지 않는 함수 포인터에 대해서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-700">You can use this method only for pure unmanaged function pointers.</span></span>  
  
-   <span data-ttu-id="f799e-701">이 메서드 또는 c + +를 통해 가져온 함수 포인터를 사용할 수 없습니다는 <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-701">You cannot use this method with function pointers obtained through C++ or from the <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> method.</span></span>  
  
-   <span data-ttu-id="f799e-702">대리자를 만드는 함수 포인터에서 관리 되는 다른 대리자에 게이 메서드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-702">You cannot use this method to create a delegate from a function pointer to another managed delegate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-703"><paramref name="TDelegate" /> 제네릭 매개 변수가 대리자가 아니거나 개방형 제네릭 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-703">The <paramref name="TDelegate" /> generic parameter is not a delegate, or it is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-704"><paramref name="ptr" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-704">The <paramref name="ptr" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-705">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-705">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-706">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-706">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEndComSlot">
      <MemberSignature Language="C#" Value="public static int GetEndComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetEndComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEndComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetEndComSlot(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="f799e-707">인터페이스나 클래스를 나타내는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-707">A type that represents an interface or class.</span></span></param>
        <summary><span data-ttu-id="f799e-708">COM에 노출될 때 형식의 가상 함수 테이블(v-table 또는 VTBL)에서 마지막 슬롯을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-708">Retrieves the last slot in the virtual function table (v-table or VTBL) of a type when exposed to COM.</span></span></summary>
        <returns><span data-ttu-id="f799e-709">COM에 노출될 때 인터페이스의 마지막 VTBL 슬롯입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-709">The last VTBL slot of the interface when exposed to COM.</span></span> <span data-ttu-id="f799e-710"><paramref name="t" /> 매개 변수가 클래스인 경우 반환된 VTBL 슬롯은 클래스에서 생성되는 인터페이스에 있는 마지막 슬롯입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-710">If the <paramref name="t" /> parameter is a class, the returned VTBL slot is the last slot in the interface that is generated from the class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-711">이 메서드는 인터페이스 또는 클래스에 대 한 0부터 시작, v 테이블 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-711">This method returns the zero-based, v-table number for an interface or a class.</span></span> <span data-ttu-id="f799e-712">클래스를 사용 하면 반환 되는 슬롯 수의 클래스 인터페이스는 클래스를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-712">When used on a class, the slot number returned refers to the class interface for the class.</span></span> <span data-ttu-id="f799e-713">클래스 인터페이스 자동 이중 이면이 메서드는 항상 디스패치 전용 인터페이스 v-table 관리 되는 클라이언트에 노출 하지 않음을 나타내는-1을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-713">If the class interface is auto-dual, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</span></span> <span data-ttu-id="f799e-714">사용할 수 있습니다 <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A> 및 <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> 함께에서 <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> 지정된 된 범위 내에서 슬롯을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-714">You can use <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A> and <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> to pass slots within a specified range.</span></span> <span data-ttu-id="f799e-715">자세한 내용은 참조 하십시오. [클래스 인터페이스 소개](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-715">For additional information, see [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-716">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-716">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-717">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-717">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionCode">
      <MemberSignature Language="C#" Value="public static int GetExceptionCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetExceptionCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetExceptionCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f799e-718">발생한 예외의 형식을 식별하는 코드를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-718">Retrieves a code that identifies the type of the exception that occurred.</span></span></summary>
        <returns><span data-ttu-id="f799e-719">예외의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-719">The type of the exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-720"><xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A> 구조적 예외 처리 (SEH)를만 컴파일러 지원에 대 한 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-720"><xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A> is exposed for compiler support of structured exception handling (SEH) only.</span></span> <span data-ttu-id="f799e-721">예외가 발생 하기 전에이 메서드가 호출 되는 경우 0x0 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-721">If this method is called before an exception is thrown, it returns 0x0.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-722">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-722">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-723">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-723">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-724">HRESULT 오류 코드를 해당하는 <see cref="T:System.Exception" /> 개체로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-724">Converts an HRESULT error code to a corresponding <see cref="T:System.Exception" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="f799e-725">변환할 HRESULT입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-725">The HRESULT to be converted.</span></span></param>
        <summary><span data-ttu-id="f799e-726">지정된 HRESULT 오류 코드를 해당하는 <see cref="T:System.Exception" /> 개체로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-726">Converts the specified HRESULT error code to a corresponding <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="f799e-727">변환된 HRESULT를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-727">An object that represents the converted HRESULT.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-728">사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> 가져올 메서드를 한 <xref:System.Exception> 호출할 필요 없이 HRESULT 값에 따라는 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 메서드 및 예외를 catch 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-728">Use the <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> method to get an <xref:System.Exception> based on an HRESULT without having to call the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method and catch the exception.</span></span>  
  
 <span data-ttu-id="f799e-729">현재 [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) 인터페이스는 예외를 생성 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-729">The current [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) interface is used to construct the exception.</span></span>  
  
 <span data-ttu-id="f799e-730">.NET Framework에서 해당 예외 클래스를 각 hresult에서는 매핑에 대 한 참조 [하는 방법: 지도 Hresult 및 예외](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-730">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-731">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-731">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-732">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-732">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer, errorInfo As IntPtr) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="f799e-733">변환할 HRESULT입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-733">The HRESULT to be converted.</span></span></param>
        <param name="errorInfo"><span data-ttu-id="f799e-734">오류에 대한 추가 정보를 제공하는 <see langword="IErrorInfo" /> 인터페이스에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-734">A pointer to the <see langword="IErrorInfo" /> interface that provides more information about the error.</span></span> <span data-ttu-id="f799e-735">현재 <see langword="IErrorInfo" /> 인터페이스를 사용하려면 <c>IntPtr(0)</c>을 지정하고, 현재 <see langword="IErrorInfo" /> 인터페이스를 무시하고 오류 코드에서만 예외를 생성하려면 <c>IntPtr(-1)</c>을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-735">You can specify <c>IntPtr(0)</c> to use the current <see langword="IErrorInfo" /> interface, or <c>IntPtr(-1)</c> to ignore the current <see langword="IErrorInfo" /> interface and construct the exception just from the error code.</span></span></param>
        <summary><span data-ttu-id="f799e-736">예외 개체에 대한 [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) 인터페이스에 전달된 추가 오류 정보를 사용하여 지정된 HRESULT 오류 코드를 해당하는 <see cref="T:System.Exception" /> 개체로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-736">Converts the specified HRESULT error code to a corresponding <see cref="T:System.Exception" /> object, with additional error information passed in an [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) interface for the exception object.</span></span></summary>
        <returns><span data-ttu-id="f799e-737">변환된 HRESULT와 <paramref name="errorInfo" />에서 가져온 정보를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-737">An object that represents the converted HRESULT and information obtained from <paramref name="errorInfo" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-738">사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> 가져올 메서드를 한 <xref:System.Exception> 호출할 필요 없이 HRESULT 값에 따라는 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 메서드와 (필요 없도록 해당 성능 오버 헤드) 예외를 catch 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-738">Use the <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> method to get an <xref:System.Exception> based on an HRESULT without having to call the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method and catch the exception (thus avoiding the corresponding performance overhead).</span></span> <span data-ttu-id="f799e-739">`errorInfo` 매개 변수에서 오류를 정의한 인터페이스에 대 한 전역 고유 식별자 (GUID)의 텍스트 설명 등 오류에 대 한 추가 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-739">The `errorInfo` parameter supplies additional information about the error, such as its textual description and the globally unique identifier (GUID) for the interface that defined the error.</span></span>  
  
 <span data-ttu-id="f799e-740">변환에 제공 해야 하는 사용자 지정 오류 정보가 있는 경우이 메서드 오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-740">Use this method overload if you have custom error information that you have to supply in the conversion.</span></span>  
  
 <span data-ttu-id="f799e-741">.NET Framework에서 해당 예외 클래스를 각 hresult에서는 매핑에 대 한 참조 [하는 방법: 지도 Hresult 및 예외](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-741">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-742">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-742">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-743">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-743">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionPointers">
      <MemberSignature Language="C#" Value="public static IntPtr GetExceptionPointers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetExceptionPointers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionPointers () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetExceptionPointers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f799e-744">예외에 대한 컴퓨터 독립적 설명과 예외가 발생할 때 스레드에 대해 존재하는 컴퓨터 상태에 대한 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-744">Retrieves a computer-independent description of an exception, and information about the state that existed for the thread when the exception occurred.</span></span></summary>
        <returns><span data-ttu-id="f799e-745">[EXCEPTION_POINTERS](http://go.microsoft.com/fwlink/?LinkId=148648) 구조체에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-745">A pointer to an [EXCEPTION_POINTERS](http://go.microsoft.com/fwlink/?LinkId=148648) structure.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-746"><xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A> 구조적 예외 처리 (SEH)를만 컴파일러 지원에 대 한 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-746"><xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A> is exposed for compiler support of structured exception handling (SEH) only.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-747">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-747">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-748">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-748">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate (d As Delegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetFunctionPointerForDelegate(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="f799e-749">비관리 코드에 전달할 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-749">The delegate to be passed to unmanaged code.</span></span></param>
        <summary><span data-ttu-id="f799e-750">대리자를 비관리 코드에서 호출할 수 있는 함수 포인터로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-750">Converts a delegate into a function pointer that is callable from unmanaged code.</span></span></summary>
        <returns><span data-ttu-id="f799e-751">비관리 코드에 전달할 수 있는 값입니다. 비관리 코드에서는 이 값을 사용하여 관리되는 내부 대리자를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-751">A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-752">대리자 `d` 사용 하 여 관리 되지 않는 코드에 전달 될 수 있는 함수 포인터로 변환 된 [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) 호출 규칙입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-752">The delegate `d` is converted to a function pointer that can be passed to unmanaged code using the [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) calling convention.</span></span>  
  
 <span data-ttu-id="f799e-753">관리 코드에서 가비지 수집기가 수집 되지 않도록 대리자를 수동으로 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-753">You must manually keep the delegate from being collected by the garbage collector from managed code.</span></span> <span data-ttu-id="f799e-754">가비지 수집기는 관리 되지 않는 코드에 대 한 참조를 추적 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-754">The garbage collector does not track references to unmanaged code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-755"><paramref name="d" /> 매개 변수는 제네릭 형식 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-755">The <paramref name="d" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-756"><paramref name="d" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-756">The <paramref name="d" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-757">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-757">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-758">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-758">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate&lt;TDelegate&gt; (TDelegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate&lt;TDelegate&gt;(!!TDelegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate(Of TDelegate) (d As TDelegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static IntPtr GetFunctionPointerForDelegate(TDelegate d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="d" Type="TDelegate" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="f799e-759">변환할 대리자의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-759">The type of delegate to convert.</span></span></typeparam>
        <param name="d"><span data-ttu-id="f799e-760">비관리 코드에 전달할 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-760">The delegate to be passed to unmanaged code.</span></span></param>
        <summary><span data-ttu-id="f799e-761">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-761">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-762">지정된 형식의 대리자를 관리되지 않는 코드에서 호출할 수 있는 함수 포인터로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-762">Converts a delegate of a specified type to a function pointer that is callable from unmanaged code.</span></span></summary>
        <returns><span data-ttu-id="f799e-763">비관리 코드에 전달할 수 있는 값입니다. 비관리 코드에서는 이 값을 사용하여 관리되는 내부 대리자를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-763">A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-764">대리자 `d` 를 사용 하 여 비관리 코드에 전달 될 수 있는 함수 포인터로 변환 되는 [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) 호출 규칙입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-764">The delegate `d` is converted to a function pointer that can be passed to unmanaged code by using the [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) calling convention.</span></span>  
  
 <span data-ttu-id="f799e-765">관리 코드에서 가비지 수집기가 수집 되지 않도록 대리자를 수동으로 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-765">You must manually keep the delegate from being collected by the garbage collector from managed code.</span></span> <span data-ttu-id="f799e-766">가비지 수집기는 관리 되지 않는 코드에 대 한 참조를 추적 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-766">The garbage collector does not track references to unmanaged code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-767"><paramref name="d" /> 매개 변수는 제네릭 형식 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-767">The <paramref name="d" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-768"><paramref name="d" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-768">The <paramref name="d" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-769">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-769">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-770">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-770">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetHINSTANCE">
      <MemberSignature Language="C#" Value="public static IntPtr GetHINSTANCE (System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHINSTANCE(class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHINSTANCE (m As Module) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetHINSTANCE(System::Reflection::Module ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="f799e-771">HINSTANCE가 필요한 모듈입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-771">The module whose HINSTANCE is desired.</span></span></param>
        <summary><span data-ttu-id="f799e-772">지정된 모듈의 인스턴스 핸들(HINSTANCE)을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-772">Returns the instance handle (HINSTANCE) for the specified module.</span></span></summary>
        <returns><span data-ttu-id="f799e-773"><paramref name="m" />에 대한 HINSTANCE이거나 모듈에 HINSTANCE가 없을 경우는 -1입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-773">The HINSTANCE for <paramref name="m" />; or -1 if the module does not have an HINSTANCE.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-774">동적 메모리를 하거나 모듈에서는 HINSTANCE를 갖지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-774">When dynamic or in-memory, modules do not have an HINSTANCE.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-775"><paramref name="m" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-775">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-776">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-776">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-777">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-777">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetHRForException">
      <MemberSignature Language="C#" Value="public static int GetHRForException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForException(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForException (e As Exception) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForException(Exception ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f799e-778">HRESULT로 변환할 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-778">The exception to convert to an HRESULT.</span></span></param>
        <summary><span data-ttu-id="f799e-779">지정된 예외를 HRESULT로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-779">Converts the specified exception to an HRESULT.</span></span></summary>
        <returns><span data-ttu-id="f799e-780">해당 예외로 매핑되는 HRESULT입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-780">The HRESULT mapped to the supplied exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-781"><xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> 도 설정는 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) COM GetErrorInfoNEEDGUID 함수를 호출 하 여 얻을 수 있는 예외에 대 한 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-781"><xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> also sets up an [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface for the exception that can be obtained by calling the COM GetErrorInfoNEEDGUID function.</span></span> <span data-ttu-id="f799e-782">이 함수를 사용 하 여 적용 하는 COM 인터페이스의 관리 되는 클래스 구현에는 HRESULT 값을 반환 하는 <xref:System.Runtime.InteropServices.PreserveSigAttribute> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-782">You can use this function to return an HRESULT value on a managed class implementation of a COM interface where you apply the <xref:System.Runtime.InteropServices.PreserveSigAttribute> attribute.</span></span> <span data-ttu-id="f799e-783">특성 사용된 메서드가 모든 예외를 catch 하 고 사용 된 <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> 메서드를 해당 HRESULT 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-783">Have the attributed method catch all exceptions and use the <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> method to return the appropriate HRESULT value.</span></span> <span data-ttu-id="f799e-784">잘못 된 동작이 생성 메서드가 외부로 전파 되도록 한 예외를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-784">Allowing an exception to propagate outside the method produces incorrect behavior.</span></span> <span data-ttu-id="f799e-785">(사실, 공용 언어 런타임 하지 v 테이블을 통해 이러한 메서드를 호출 하는 COM 클라이언트에 예외를 전달 합니다.)</span><span class="sxs-lookup"><span data-stu-id="f799e-785">(In fact, the common language runtime fails to pass an exception to a COM client that calls such a method through a v-table.)</span></span>  
  
 <span data-ttu-id="f799e-786"><xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> 메서드 집합은 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) 현재 스레드의 인터페이스.</span><span class="sxs-lookup"><span data-stu-id="f799e-786">Note that the <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> method sets the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface of the current thread.</span></span> <span data-ttu-id="f799e-787">등의 메서드에서 예기치 않은 결과가 발생할 수 있습니다는 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 기본적으로을 사용 하는 메서드는 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) 설정 된 경우 현재 스레드의 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-787">This can cause unexpected results for methods like the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> methods that default to using the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) of the current thread if it is set.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-788">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-788">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-789">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-789">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetHRForLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetHRForLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForLastWin32Error();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f799e-790"><see cref="T:System.Runtime.InteropServices.Marshal" />을 사용하여 실행된 Win32 코드에서 발생한 마지막 오류에 해당하는 HRESULT를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-790">Returns the HRESULT corresponding to the last error incurred by Win32 code executed using <see cref="T:System.Runtime.InteropServices.Marshal" />.</span></span></summary>
        <returns><span data-ttu-id="f799e-791">마지막 Win32 오류 코드에 해당하는 HRESULT입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-791">The HRESULT corresponding to the last Win32 error code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-792">대상 함수에는 `setLastError` 메타 데이터 플래그를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-792">The target function must have had the `setLastError` metadata flag set.</span></span> <span data-ttu-id="f799e-793">예를 들어는 `SetLastError` 필드는 <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> 해야 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-793">For example, the `SetLastError` field of the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> must be `true`.</span></span> <span data-ttu-id="f799e-794">이 플래그를 설정 하기 위한 과정에 사용 되는 소스 언어: C# 및 c + +는 `false` 기본적으로 하지만 `Declare` Visual Basic의 문이 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-794">The process for setting this flag depends on the source language used: C# and C++ are `false` by default, but the `Declare` statement in Visual Basic is `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-795">다음 예제에서는 사용 하 여 Win32 오류 코드에 해당 하는 HRESULT를 검색 하는 방법의 <xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-795">The following example demonstrates how to retrieve an HRESULT corresponding to a Win32 error code using the <xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-796">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-796">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-797">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-797">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f799e-798"><see langword="IDispatch" /> 인터페이스가 요청되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-798">The object whose <see langword="IDispatch" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="f799e-799">관리되는 개체에서 [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) 인터페이스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-799">Returns an [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) interface from a managed object.</span></span></summary>
        <returns><span data-ttu-id="f799e-800"><paramref name="o" /> 매개 변수에 대한 <see langword="IDispatch" /> 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-800">The <see langword="IDispatch" /> pointer for the <paramref name="o" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-801">관리 코드에서 거의 직접 작업할 수는 `IDispatch` 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-801">In managed code, you seldom work directly with the `IDispatch` interface.</span></span> <span data-ttu-id="f799e-802">그러나 <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> 으로 COM 개체 매개 변수를 노출 하는 메서드를 호출할 때 유용 프로그램 <xref:System.IntPtr> 형식 또는 사용자 지정 마샬링을 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-802">However, <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="f799e-803">이 방법으로 개체를 호출 하면의 참조 횟수를 반환 되기 전에 포인터에 인터페이스 포인터 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-803">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="f799e-804">항상 사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 포인터 작업이 완료 되 면 참조 횟수를 감소 시키기 위해.</span><span class="sxs-lookup"><span data-stu-id="f799e-804">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span>  
  
 <span data-ttu-id="f799e-805">개체에 대 한 COM 호출 가능 래퍼에 대 한 인터페이스 포인터를 얻으려면 관리 되는 개체에이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-805">You can also use this method on a managed object to obtain an interface pointer to the COM callable wrapper for the object.</span></span> <span data-ttu-id="f799e-806">자세한 내용은 참조 하십시오. [COM 호출 가능 래퍼](~/docs/framework/interop/com-callable-wrapper.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-806">For additional information, see [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="f799e-807"><paramref name="o" />가 요청된 인터페이스를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-807"><paramref name="o" /> does not support the requested interface.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-808">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-808">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-809">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-809">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObjectInContext(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f799e-810"><see langword="IDispatch" /> 인터페이스가 요청되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-810">The object whose <see langword="IDispatch" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="f799e-811">호출자가 관리되는 개체와 같은 컨텍스트에 있는 경우 해당 개체에서 [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) 인터페이스 포인터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-811">Returns an [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) interface pointer from a managed object, if the caller is in the same context as that object.</span></span></summary>
        <returns><span data-ttu-id="f799e-812">지정된 개체의 <see langword="IDispatch" /> 인터페이스 포인터이거나 호출자가 지정된 개체와 같은 컨텍스트에 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-812">The <see langword="IDispatch" /> interface pointer for the specified object, or <see langword="null" /> if the caller is not in the same context as the specified object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-813">이 메서드는 동일 <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> 반환 한다는 점을 제외 하 고 `null` 개체와 같은 컨텍스트에 호출자에 게 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-813">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="f799e-814"><paramref name="o" />가 요청된 인터페이스를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-814"><paramref name="o" /> does not support the requested interface.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-815"><paramref name="o" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-815"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-816">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-816">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-817">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-817">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetITypeInfoForType">
      <MemberSignature Language="C#" Value="public static IntPtr GetITypeInfoForType (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetITypeInfoForType(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetITypeInfoForType (t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetITypeInfoForType(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="f799e-818"><see langword="ITypeInfo" /> 인터페이스가 요청 중인 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-818">The type whose <see langword="ITypeInfo" /> interface is being requested.</span></span></param>
        <summary><span data-ttu-id="f799e-819">관리되는 형식에서 <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> 인터페이스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-819">Returns a <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> interface from a managed type.</span></span></summary>
        <returns><span data-ttu-id="f799e-820"><paramref name="t" /> 매개 변수의 <see langword="ITypeInfo" /> 인터페이스에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-820">A pointer to the <see langword="ITypeInfo" /> interface for the <paramref name="t" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-821">이 메서드가 반환에 대 한 포인터는 `ITypeInfo` 원래 형식을 기반으로 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-821">This method returns a pointer to an `ITypeInfo` implementation that is based on the original type.</span></span> <span data-ttu-id="f799e-822">으로 개체를 호출 <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> 참조 횟수가 반환 되기 전에 포인터에 인터페이스 포인터 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-822">Calling an object with <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="f799e-823">항상 사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 포인터 작업이 완료 되 면 참조 횟수를 감소 시키기 위해.</span><span class="sxs-lookup"><span data-stu-id="f799e-823">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="f799e-824">적용할 수는 <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> 이 사용자 지정 마샬러를 사용한 표준 interop 마샬링 동작을 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-824">You can apply the <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> to replace standard interop marshaling behavior with this custom marshaler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-825">다음 예제에 대 한 포인터를 검색 하는 방법을 보여 줍니다는 `ITypeInfo` 사용 하 여 형식에 대 한 인터페이스는 <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-825">The following example demonstrates how to retrieve a pointer to the `ITypeInfo` interface for a type using the <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-826"><paramref name="t" />가 COM의 표시 형식이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-826"><paramref name="t" /> is not a visible type to COM.</span></span>  
  
 <span data-ttu-id="f799e-827">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-827">-or-</span></span>  
  
 <span data-ttu-id="f799e-828"><paramref name="t" />가 [!INCLUDE[wrt](~/includes/wrt-md.md)] 형식인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-828"><paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="f799e-829">형식 라이브러리가 해당 형식을 포함하는 어셈블리에 대해 등록되어 있지만 형식 정의를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-829">A type library is registered for the assembly that contains the type, but the type definition cannot be found.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-830">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-830">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-831">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-831">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f799e-832"><see langword="IUnknown" /> 인터페이스가 요청되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-832">The object whose <see langword="IUnknown" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="f799e-833">관리되는 개체에서 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 인터페이스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-833">Returns an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface from a managed object.</span></span></summary>
        <returns><span data-ttu-id="f799e-834"><paramref name="o" /> 매개 변수에 대한 <see langword="IUnknown" /> 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-834">The <see langword="IUnknown" /> pointer for the <paramref name="o" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-835">관리 코드에서 거의 직접 작업할 수는 `IUnknown` 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-835">In managed code, you seldom work directly with the `IUnknown` interface.</span></span> <span data-ttu-id="f799e-836">그러나 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> 으로 COM 개체 매개 변수를 노출 하는 메서드를 호출할 때 유용 프로그램 <xref:System.IntPtr> 형식 또는 사용자 지정 마샬링을 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-836">However, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="f799e-837">이 방법으로 개체를 호출 하면의 참조 횟수를 반환 되기 전에 포인터에 인터페이스 포인터 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-837">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="f799e-838">항상 사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 포인터 작업이 완료 되 면 참조 횟수를 감소 시키기 위해.</span><span class="sxs-lookup"><span data-stu-id="f799e-838">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="f799e-839">이 메서드는 제공 된 <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-839">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f799e-840">한 인터페이스 포인터를 얻으려면 관리 되는 개체에이 메서드를 사용할 수도 있습니다는 [COM 호출 가능 래퍼](~/docs/framework/interop/com-callable-wrapper.md) 개체에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-840">You can also use this method on a managed object to obtain an interface pointer to the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) for the object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-841">다음 예제에서는 검색 하는 방법을 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 사용 하 여 관리 되는 개체에 대 한 인터페이스는 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-841">The following example demonstrates how to retrieve an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-842">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-842">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-843">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-843">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObjectInContext(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f799e-844"><see langword="IUnknown" /> 인터페이스가 요청되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-844">The object whose <see langword="IUnknown" /> interface is requested.</span></span></param>
        <summary><span data-ttu-id="f799e-845">호출자가 관리되는 개체와 같은 컨텍스트에 있는 경우 해당 개체에서 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 인터페이스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-845">Returns an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface from a managed object, if the caller is in the same context as that object.</span></span></summary>
        <returns><span data-ttu-id="f799e-846">지정된 개체에 대한 <see langword="IUnknown" /> 포인터이거나 호출자가 지정된 개체와 같은 컨텍스트에 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-846">The <see langword="IUnknown" /> pointer for the specified object, or <see langword="null" /> if the caller is not in the same context as the specified object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-847">이 메서드는 동일 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> 반환 한다는 점을 제외 하 고 `null` 개체와 같은 컨텍스트에 호출자에 게 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-847">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-848">다음 예제에서는 검색 하는 방법을 `IUnknown` 사용 하 여 관리 되는 개체에 대 한 인터페이스는 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-848">The following example demonstrates how to retrieve an `IUnknown` interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-849">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-849">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-850">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-850">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetLastWin32Error();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f799e-851"><see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> 플래그가 설정된 플랫폼 호출을 사용하여 호출된 관리되지 않는 마지막 함수에서 반환하는 오류 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-851">Returns the error code returned by the last unmanaged function that was called using platform invoke that has the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> flag set.</span></span></summary>
        <returns><span data-ttu-id="f799e-852">Win32 [SetLastError](http://go.microsoft.com/fwlink/?LinkId=148656) 함수에 대한 호출로 설정된 마지막 오류 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-852">The last error code set by a call to the Win32 [SetLastError](http://go.microsoft.com/fwlink/?LinkId=148656) function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-853"><xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> Win32 노출 [GetLastError](http://go.microsoft.com/fwlink/?LinkId=148657) Kernel32.DLL에서 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-853"><xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> exposes the Win32 [GetLastError](http://go.microsoft.com/fwlink/?LinkId=148657) function from Kernel32.DLL.</span></span> <span data-ttu-id="f799e-854">이 메서드는 invoke 호출 직접 플랫폼 안전 없기 때문에 `GetLastError` 이 정보를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-854">This method exists because it is not safe to make a direct platform invoke call to `GetLastError` to obtain this information.</span></span> <span data-ttu-id="f799e-855">이 오류 코드에 액세스 하려는 경우 호출 해야 <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> 작성 하는 대신 사용자 고유의 플랫폼 호출 정의 `GetLastError` 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-855">If you want to access this error code, you must call <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> instead of writing your own platform invoke definition for `GetLastError` and calling it.</span></span> <span data-ttu-id="f799e-856">공용 언어 런타임 하 내부 호출을 수행할 수는 `GetLastError` 운영 체제에서 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-856">The common language runtime can make internal calls to APIs that overwrite the `GetLastError` maintained by the operating system.</span></span>  
  
 <span data-ttu-id="f799e-857">이 메서드를 사용 하 여 적용 하는 경우에 오류 코드를 가져올 수 있습니다는 <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> 을 설정 하 고는 메서드 시그니처는 <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> 필드를`true`합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-857">You can use this method to obtain error codes only if you apply the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> to the method signature and set the <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> field to`true`.</span></span> <span data-ttu-id="f799e-858">이 프로세스는 사용 된 소스 언어에 따라 달라 집니다: C# 및 c + +는 `false` 기본적으로 하지만 `Declare` Visual Basic에서는 문이 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-858">The process for this varies depending upon the source language used: C# and C++ are `false` by default, but the `Declare` statement in Visual Basic is `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-859">다음 예제에서는 <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> 메서드를 호출하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-859">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> method.</span></span> <span data-ttu-id="f799e-860">이 예제에서는 먼저 오류가 존재 하지 않은 메서드를 호출 하는 방법을 보여 줍니다 하 고 메서드를 호출 하면 현재 오류가 발생 하 여 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-860">The example first demonstrates calling the method with no error present and then demonstrates calling the method with an error present.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-861">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-861">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-862">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-862">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetManagedThunkForUnmanagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetManagedThunkForUnmanagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetManagedThunkForUnmanagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetManagedThunkForUnmanagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap"><span data-ttu-id="f799e-863">마샬링할 메서드에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-863">A pointer to the method to marshal.</span></span></param>
        <param name="pbSignature"><span data-ttu-id="f799e-864">메서드 시그니처에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-864">A pointer to the method signature.</span></span></param>
        <param name="cbSignature"><span data-ttu-id="f799e-865"><c>pbSignature</c>의 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-865">The number of bytes in <c>pbSignature</c>.</span></span></param>
        <summary><span data-ttu-id="f799e-866">관리 코드에서 비관리 코드로 호출을 마샬링하는 런타임 생성 함수에 대한 포인터를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-866">Gets a pointer to a runtime-generated function that marshals a call from managed to unmanaged code.</span></span></summary>
        <returns><span data-ttu-id="f799e-867"><paramref name="pfnMethodToWrap" /> 매개 변수에서의 호출을 비관리 코드로 마샬링할 함수에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-867">A pointer to the function that will marshal a call from the <paramref name="pfnMethodToWrap" /> parameter to unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-868"><xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A> 에 대 한 컴파일러 지원만 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-868"><xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A> is exposed for compiler support only.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-869">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-869">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-870">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-870">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodInfoForComSlot">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo GetMethodInfoForComSlot (Type t, int slot, ref System.Runtime.InteropServices.ComMemberType memberType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MemberInfo GetMethodInfoForComSlot(class System.Type t, int32 slot, valuetype System.Runtime.InteropServices.ComMemberType&amp; memberType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodInfoForComSlot (t As Type, slot As Integer, ByRef memberType As ComMemberType) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MemberInfo ^ GetMethodInfoForComSlot(Type ^ t, int slot, System::Runtime::InteropServices::ComMemberType % memberType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="slot" Type="System.Int32" />
        <Parameter Name="memberType" Type="System.Runtime.InteropServices.ComMemberType&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="f799e-871"><see cref="T:System.Reflection.MemberInfo" />가 검색될 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-871">The type for which the <see cref="T:System.Reflection.MemberInfo" /> is to be retrieved.</span></span></param>
        <param name="slot"><span data-ttu-id="f799e-872">VTBL 슬롯입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-872">The VTBL slot.</span></span></param>
        <param name="memberType"><span data-ttu-id="f799e-873">성공적으로 반환되는 경우 멤버의 형식을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-873">On successful return, one of the enumeration values that specifies the type of the member.</span></span></param>
        <summary><span data-ttu-id="f799e-874">지정된 가상 함수 테이블(v-table 또는 VTBL) 슬롯에서 <see cref="T:System.Reflection.MemberInfo" /> 개체를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-874">Retrieves a <see cref="T:System.Reflection.MemberInfo" /> object for the specified virtual function table (v-table or VTBL) slot.</span></span></summary>
        <returns><span data-ttu-id="f799e-875">지정된 VTBL 슬롯에서 멤버를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-875">The object that represents the member at the specified VTBL slot.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-876">반환 값 수는 <xref:System.Reflection.FieldInfo>, <xref:System.Reflection.MethodInfo>, 또는 <xref:System.Reflection.PropertyInfo> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-876">The return value may be a <xref:System.Reflection.FieldInfo>, <xref:System.Reflection.MethodInfo>, or <xref:System.Reflection.PropertyInfo> object.</span></span> <span data-ttu-id="f799e-877">반환 값은 지정 된 COM 슬롯에 있는 관리 되는 멤버의 형식에 따라 달라 집니다 (일반화 된 반환 형식이 따라서 <xref:System.Reflection.MemberInfo> 모든에서 3 개의 파생).</span><span class="sxs-lookup"><span data-stu-id="f799e-877">The return value depends on the type of managed member that exists in the given COM slot (hence the generalized return type <xref:System.Reflection.MemberInfo> from which all three derive).</span></span>  
  
 <span data-ttu-id="f799e-878">이 메서드에 의해 반환 되는 0부터 시작 슬롯 번호에 대 한 계정 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 수 있는 4 개의 및 [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) 메서드를 사용 가능한 첫 번째 슬롯의 값 중 하나가 3 또는 7입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-878">The zero-based slot number that is returned by this method accounts for three [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) and possibly four [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) methods, making the value of the first available slot either 3 or 7.</span></span> <span data-ttu-id="f799e-879"><xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> 반대 되는 기능을 제공 <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-879"><xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f799e-880">사용할 수 있습니다 <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> 및 <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> 함께에서 <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> 지정된 된 범위 내에서 슬롯을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-880">You can use <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> to pass slots within a specified range.</span></span>  
  
 <span data-ttu-id="f799e-881">`memberType` 매개 변수는 반환 시에만 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-881">The `memberType` parameter is important only on return.</span></span> <span data-ttu-id="f799e-882">반환 된에 해당 하는 COM 멤버 (일반 메서드 또는 속성 접근자)의 type <xref:System.Reflection.MemberInfo> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-882">It contains the type of the COM member (a regular method or a property accessor) that corresponds to the returned <xref:System.Reflection.MemberInfo> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-883"><paramref name="t" />가 COM에 표시되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-883"><paramref name="t" /> is not visible from COM.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-884">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-884">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-885">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-885">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComMemberType" />
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject (object obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject(object obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject (obj As Object, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetNativeVariantForObject(System::Object ^ obj, IntPtr pDstNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="f799e-886">COM VARIANT를 가져올 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-886">The object for which to get a COM VARIANT.</span></span></param>
        <param name="pDstNativeVariant"><span data-ttu-id="f799e-887"><c>obj</c> 매개 변수에 해당하는 VARIANT를 받을 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-887">A pointer to receive the VARIANT that corresponds to the <c>obj</c> parameter.</span></span></param>
        <summary><span data-ttu-id="f799e-888">개체를 COM VARIANT로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-888">Converts an object to a COM VARIANT.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-889">`pDstNativeVariant` 매개 변수는 결과 VARIANT를 저장할 충분 한 메모리를 가리켜야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-889">The `pDstNativeVariant` parameter must point to sufficient memory to store the resulting VARIANT.</span></span> <span data-ttu-id="f799e-890">이 메서드의 구현을 호출 또한는 [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) 원시 메모리에 대해 함수는는 `pDstNativeVariant` 매개 변수를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-890">Also, the implementation of this method calls the [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) function on the raw memory that the `pDstNativeVariant` parameter points to.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-891"><paramref name="obj" /> 매개 변수는 제네릭 형식의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-891">The <paramref name="obj" /> parameter is an instance of a generic type.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-892">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-892">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-893">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-893">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject&lt;T&gt; (T obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject&lt;T&gt;(!!T obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject(Of T) (obj As T, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="obj" Type="T" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-894">변환할 개체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-894">The type of the object to convert.</span></span></typeparam>
        <param name="obj"><span data-ttu-id="f799e-895">COM VARIANT를 가져올 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-895">The object for which to get a COM VARIANT.</span></span></param>
        <param name="pDstNativeVariant"><span data-ttu-id="f799e-896"><c>obj</c> 매개 변수에 해당하는 VARIANT를 받을 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-896">A pointer to receive the VARIANT that corresponds to the <c>obj</c> parameter.</span></span></param>
        <summary><span data-ttu-id="f799e-897">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-897">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-898">지정된 형식의 개체를 COM VARIANT로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-898">Converts an object of a specified type to a COM VARIANT.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-899">`pDstNativeVariant` 매개 변수는 결과 VARIANT를 저장할 충분 한 메모리를 가리켜야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-899">The `pDstNativeVariant` parameter must point to sufficient memory to store the resulting VARIANT.</span></span> <span data-ttu-id="f799e-900">이 메서드의 구현을 호출 또한 [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) 원시 메모리에 대해 함수는는 `pDstNativeVariant` 매개 변수를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-900">Also, the implementation of this method calls [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) function on the raw memory that the `pDstNativeVariant` parameter points to.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-901">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-901">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-902">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-902">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetObjectForIUnknown (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForIUnknown(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForIUnknown (pUnk As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForIUnknown(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="f799e-903"><see langword="IUnknown" /> 인터페이스에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-903">A pointer to the <see langword="IUnknown" /> interface.</span></span></param>
        <summary><span data-ttu-id="f799e-904">[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 인터페이스에 대한 포인터를 사용하여 COM 개체를 나타내는 형식의 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-904">Returns an instance of a type that represents a COM object by a pointer to its [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface.</span></span></summary>
        <returns><span data-ttu-id="f799e-905">지정된 관리되지 않는 COM 개체를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-905">An object that represents the specified unmanaged COM object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-906">이 메서드를 래핑합니다 `IUnknown` 관리 되는 개체에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-906">This method wraps `IUnknown` in a managed object.</span></span> <span data-ttu-id="f799e-907">COM 구성 요소 참조 횟수를 증가 시키는 것과 효과가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-907">This has the effect of incrementing the reference count of the COM component.</span></span> <span data-ttu-id="f799e-908">런타임에 COM 개체를 나타내는 관리 되는 개체에서 가비지 수집을 수행 하는 경우 참조 횟수를 감소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-908">The reference count will be decremented when the runtime performs garbage collection on the managed object that represents the COM object.</span></span>  
  
 <span data-ttu-id="f799e-909">`pUnk` 매개 변수를 나타냅니다는 `IUnknown` 인터페이스 포인터; 그러나 모든 COM 인터페이스에서 직접 또는 간접적으로 파생 되므로 `IUnknown`,이 메서드에 COM 인터페이스로 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-909">The `pUnk` parameter represents an `IUnknown` interface pointer; however, because all COM interfaces derive directly or indirectly from `IUnknown`, you can pass any COM interface to this method.</span></span> <span data-ttu-id="f799e-910">반환 되는 개체 <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A> 는 [런타임 호출 가능 래퍼](~/docs/framework/interop/runtime-callable-wrapper.md), 공용 언어 런타임 처럼 관리는 다른 관리 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-910">The object returned by <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A> is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), which the common language runtime manages as it does any other managed object.</span></span> <span data-ttu-id="f799e-911">이 래퍼 형식의 기본 방식은 `System.__ComObject` 종류 래퍼 형식이 모호 합니다. 때 사용 되는 숨겨진 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-911">The type of this wrapper is often a base `System.__ComObject` type, which is a hidden type used when the wrapper type is ambiguous.</span></span> <span data-ttu-id="f799e-912">사용할 수 있습니다 이러한 기본 형식에 대 한 런타임에 바인딩된 호출 COM 개체를 구현 하는 [IDispatch](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85)) 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-912">You can still make late-bound calls to such a base type as long as the COM object implements the [IDispatch](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85)) interface.</span></span> <span data-ttu-id="f799e-913">마찬가지로, 반환된 된 개체를 해당 하는 COM 인터페이스로 캐스팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-913">Likewise, you can cast the returned object to an appropriate COM interface.</span></span>  
  
 <span data-ttu-id="f799e-914">줄 바꿈 하는 개체에 대 한 관리 되는 특정 클래스 형식 (및 일반적인 래퍼 형식이 아닌)로 다음 요구 사항을 준수 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-914">For an object to be wrapped with a specific managed class type (and not a generic wrapper type), you must adhere to the following requirements:</span></span>  
  
-   <span data-ttu-id="f799e-915">구현 된 [IProvideClassInfo](http://go.microsoft.com/fwlink/?LinkID=148012) COM 개체에 대 한 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-915">Implement the [IProvideClassInfo](http://go.microsoft.com/fwlink/?LinkID=148012) interface for the COM object.</span></span>  
  
-   <span data-ttu-id="f799e-916">포함 하는 어셈블리를 등록 된 [Regasm.exe (어셈블리 등록 도구)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-916">Register the containing assembly with the [Regasm.exe (Assembly Registration Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).</span></span>  
  
 <span data-ttu-id="f799e-917">이러한 요구 사항을 충족 하 고 계속 사용 하 여 특정 관리 되는 클래스 형식과 래핑된 개체를 받을 수 또는 <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-917">Alternatively, you can avoid these requirements and still get an object that is wrapped with a specific managed class type by using the <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-918">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-918">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-919">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-919">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant">
      <MemberSignature Language="C#" Value="public static object GetObjectForNativeVariant (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForNativeVariant(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant (pSrcNativeVariant As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pSrcNativeVariant"><span data-ttu-id="f799e-920">COM VARIANT에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-920">A pointer to a COM VARIANT.</span></span></param>
        <summary><span data-ttu-id="f799e-921">COM VARIANT를 개체로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-921">Converts a COM VARIANT to an object.</span></span></summary>
        <returns><span data-ttu-id="f799e-922"><paramref name="pSrcNativeVariant" /> 매개 변수에 해당하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-922">An object that corresponds to the <paramref name="pSrcNativeVariant" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-923"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> 관리 되지 않는 VARIANT 형식에 대 한 원시 포인터를 해당 하는 관리 되는 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-923"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> returns a managed object that corresponds to a raw pointer to an unmanaged VARIANT type.</span></span> <span data-ttu-id="f799e-924">interopmarshaler VARIANT 형식을 관리 코드에 노출 하는 경우 동일한 변환을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-924">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span>  
  
 <span data-ttu-id="f799e-925"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> 반대 되는 기능을 제공 <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-925"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f799e-926">VARIANT 형식이 VT_ERROR, <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> 형식의 개체를 반환 `Int32` 대신 `UInt32`합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-926">When the VARIANT type is VT_ERROR, <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> returns an object of type `Int32` instead of `UInt32`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <span data-ttu-id="f799e-927"><paramref name="pSrcNativeVariant" />가 유효한 VARIANT 형식이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-927"><paramref name="pSrcNativeVariant" /> is not a valid VARIANT type.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f799e-928"><paramref name="pSrcNativeVariant" />가 지원되지 않는 형식인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-928"><paramref name="pSrcNativeVariant" /> has an unsupported type.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-929">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-929">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-930">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-930">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetObjectForNativeVariant&lt;T&gt; (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetObjectForNativeVariant&lt;T&gt;(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant(Of T) (pSrcNativeVariant As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-931">COM VARIANT를 변환할 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-931">The type to which to convert the COM VARIANT.</span></span></typeparam>
        <param name="pSrcNativeVariant"><span data-ttu-id="f799e-932">COM VARIANT에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-932">A pointer to a COM VARIANT.</span></span></param>
        <summary><span data-ttu-id="f799e-933">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-933">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-934">COM VARIANT를 지정된 형식의 개체로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-934">Converts a COM VARIANT to an object of a specified type.</span></span></summary>
        <returns><span data-ttu-id="f799e-935"><paramref name="pSrcNativeVariant" /> 매개 변수에 해당하는 지정된 형식의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-935">An object of the specified type that corresponds to the <paramref name="pSrcNativeVariant" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-936"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> 형식의 관리 되는 개체를 반환 `T` 관리 되지 않는 VARIANT 형식에 대 한 원시 포인터에 해당 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-936"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> returns a managed object of type `T` that corresponds to a raw pointer to an unmanaged VARIANT type.</span></span> <span data-ttu-id="f799e-937">interopmarshaler VARIANT 형식을 관리 코드에 노출 하는 경우 동일한 변환을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-937">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span>  
  
 <span data-ttu-id="f799e-938"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> 반대 되는 기능을 제공 <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-938"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <span data-ttu-id="f799e-939"><paramref name="pSrcNativeVariant" />가 유효한 VARIANT 형식이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-939"><paramref name="pSrcNativeVariant" /> is not a valid VARIANT type.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f799e-940"><paramref name="pSrcNativeVariant" />가 지원되지 않는 형식인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-940"><paramref name="pSrcNativeVariant" /> has an unsupported type.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-941">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-941">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-942">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-942">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants">
      <MemberSignature Language="C#" Value="public static object[] GetObjectsForNativeVariants (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object[] GetObjectsForNativeVariants(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants (aSrcNativeVariant As IntPtr, cVars As Integer) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Object ^&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="aSrcNativeVariant"><span data-ttu-id="f799e-943">COM VARIANT 배열의 첫 번째 요소에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-943">A pointer to the first element of an array of COM VARIANTs.</span></span></param>
        <param name="cVars"><span data-ttu-id="f799e-944"><c>aSrcNativeVariant</c>에서 COM VARIANT의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-944">The count of COM VARIANTs in <c>aSrcNativeVariant</c>.</span></span></param>
        <summary><span data-ttu-id="f799e-945">COM [VARIANT](http://go.microsoft.com/fwlink/?LinkId=148670)의 배열을 개체 배열로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-945">Converts an array of COM [VARIANTs](http://go.microsoft.com/fwlink/?LinkId=148670) to an array of objects.</span></span></summary>
        <returns><span data-ttu-id="f799e-946"><paramref name="aSrcNativeVariant" />에 해당하는 개체 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-946">An object array that corresponds to <paramref name="aSrcNativeVariant" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-947"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A> 관리 되지 않는 VARIANT 형식의 C 스타일 배열에 대 한 원시 포인터를 해당 하는 관리 되는 개체의 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-947"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A> returns an array of managed objects that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</span></span> <span data-ttu-id="f799e-948">interopmarshaler VARIANT 형식을 관리 코드에 노출 하는 경우 동일한 변환을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-948">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span> <span data-ttu-id="f799e-949">메서드가 반환 될 때 빈 배열에서 `cVars` 매개 변수는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-949">The method returns an empty array when the `cVars` parameter is 0.</span></span>  
  
 <span data-ttu-id="f799e-950">개체 배열 (반환 값)에 가비지를 수집을 정상적으로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-950">The object array (the return value) gets garbage collected as usual.</span></span> <span data-ttu-id="f799e-951">관리 되지 않는 입력된 배열 또는 입력 배열의 개별 변형 해제 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-951">The unmanaged input array or individual VARIANTs in the input array are not freed.</span></span> <span data-ttu-id="f799e-952">따라서 있기 적절 하 게 리소스를 해제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-952">Therefore it is your responsibility to free them as appropriate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f799e-953"><paramref name="cVars" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-953"><paramref name="cVars" /> is a negative number.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-954">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-954">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-955">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-955">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] GetObjectsForNativeVariants&lt;T&gt; (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] GetObjectsForNativeVariants&lt;T&gt;(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants(Of T) (aSrcNativeVariant As IntPtr, cVars As Integer) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-956">반환할 배열의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-956">The type of the array to return.</span></span></typeparam>
        <param name="aSrcNativeVariant"><span data-ttu-id="f799e-957">COM VARIANT 배열의 첫 번째 요소에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-957">A pointer to the first element of an array of COM VARIANTs.</span></span></param>
        <param name="cVars"><span data-ttu-id="f799e-958"><c>aSrcNativeVariant</c>에서 COM VARIANT의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-958">The count of COM VARIANTs in <c>aSrcNativeVariant</c>.</span></span></param>
        <summary><span data-ttu-id="f799e-959">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-959">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-960">COM VARIANT의 배열을 지정된 형식의 배열로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-960">Converts an array of COM VARIANTs to an array of a specified type.</span></span></summary>
        <returns><span data-ttu-id="f799e-961"><typeparamref name="T" />에 해당하는 <paramref name="aSrcNativeVariant" /> 개체 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-961">An array of <typeparamref name="T" /> objects that corresponds to <paramref name="aSrcNativeVariant" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-962"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29> 배열을 반환 `T` 관리 되지 않는 VARIANT 형식의 C 스타일 배열에 대 한 원시 포인터에 해당 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-962"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29> returns an array of `T` that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</span></span> <span data-ttu-id="f799e-963">interopmarshaler VARIANT 형식을 관리 코드에 노출 하는 경우 동일한 변환을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-963">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span> <span data-ttu-id="f799e-964">메서드가 반환 될 때 빈 배열에서 `cVars` 매개 변수는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-964">The method returns an empty array when the `cVars` parameter is 0.</span></span>  
  
 <span data-ttu-id="f799e-965">반환 된 배열은 가비지 수집 평소와 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-965">The returned array is garbage-collected as usual.</span></span> <span data-ttu-id="f799e-966">관리 되지 않는 입력된 배열 또는 입력 배열의 개별 변형 해제 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-966">The unmanaged input array or individual VARIANTs in the input array are not freed.</span></span> <span data-ttu-id="f799e-967">되므로 적절 하 게 리소스를 해제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-967">Therefore, it is your responsibility to free them as appropriate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f799e-968"><paramref name="cVars" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-968"><paramref name="cVars" /> is a negative number.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-969">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-969">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-970">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-970">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetStartComSlot">
      <MemberSignature Language="C#" Value="public static int GetStartComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetStartComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStartComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetStartComSlot(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="f799e-971">인터페이스를 나타내는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-971">A type that represents an interface.</span></span></param>
        <summary><span data-ttu-id="f799e-972">사용자 정의 메서드가 포함된 가상 함수 테이블(v-table 또는 VTBL)의 첫 번째 슬롯을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-972">Gets the first slot in the virtual function table (v-table or VTBL) that contains user-defined methods.</span></span></summary>
        <returns><span data-ttu-id="f799e-973">사용자 정의 메서드가 포함된 첫 번째 VTBL 슬롯입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-973">The first VTBL slot that contains user-defined methods.</span></span> <span data-ttu-id="f799e-974">[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)을 기준으로 하는 인터페이스의 경우 첫 번째 슬롯은 3이고, [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)를 기준으로 하는 인터페이스의 경우 7입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-974">The first slot is 3 if the interface is based on [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003), and 7 if the interface is based on [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-975">이 메서드는 인터페이스 또는 클래스에 대 한 0부터 시작 v 테이블 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-975">This method returns the zero-based v-table number for an interface or a class.</span></span> <span data-ttu-id="f799e-976">클래스를 사용 하면 반환 되는 슬롯 번호의 클래스 인터페이스는 클래스를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-976">When used on a class, the slot number that is returned refers to the class interface for the class.</span></span> <span data-ttu-id="f799e-977">자동 디스패치 클래스 인터페이스의 경우이 메서드는 항상 디스패치 전용 인터페이스 v-table 관리 되는 클라이언트에 노출 하지 않음을 나타내는-1을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-977">If the class interface is auto-dispatch, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</span></span> <span data-ttu-id="f799e-978">사용할 수 있습니다 <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A> 및 <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> 함께에서 <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> 지정된 된 범위 내에서 슬롯을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-978">You can use <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A> and <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> to pass slots within a specified range.</span></span> <span data-ttu-id="f799e-979">자세한 내용은 참조 하십시오. [클래스 인터페이스 소개](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-979">For additional information, see [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-980"><paramref name="t" />가 COM에 표시되지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-980"><paramref name="t" /> is not visible from COM.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-981">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-981">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-982">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-982">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetThreadFromFiberCookie">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread GetThreadFromFiberCookie (int cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Thread GetThreadFromFiberCookie(int32 cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetThreadFromFiberCookie (cookie As Integer) As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Thread ^ GetThreadFromFiberCookie(int cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cookie"><span data-ttu-id="f799e-983">파이버 쿠키를 나타내는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-983">An integer that represents a fiber cookie.</span></span></param>
        <summary><span data-ttu-id="f799e-984">파이버 쿠키를 해당 <see cref="T:System.Threading.Thread" /> 인스턴스로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-984">Converts a fiber cookie into the corresponding <see cref="T:System.Threading.Thread" /> instance.</span></span></summary>
        <returns><span data-ttu-id="f799e-985"><paramref name="cookie" /> 매개 변수에 해당하는 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-985">A thread that corresponds to the <paramref name="cookie" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-986">파이버 쿠키는 공용 언어 런타임에서 해당 파이버 일정 결정을 경고 하는 경우 호스트에서 사용 되는 불투명 한 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-986">Fiber cookies are opaque tokens that are used by the host when alerting the common language runtime to its fiber-scheduling decisions.</span></span> <span data-ttu-id="f799e-987">스택으로 구성 됩니다 하 고 컨텍스트를 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-987">They consist of a stack and register context.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-988"><paramref name="cookie" /> 매개 변수가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-988">The <paramref name="cookie" /> parameter is 0.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-989">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-989">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-990">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-990">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="GetTypedObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetTypedObjectForIUnknown (IntPtr pUnk, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetTypedObjectForIUnknown(native int pUnk, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypedObjectForIUnknown (pUnk As IntPtr, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetTypedObjectForIUnknown(IntPtr pUnk, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="f799e-991">관리되지 않는 개체의 <see langword="IUnknown" /> 인터페이스에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-991">A pointer to the <see langword="IUnknown" /> interface of the unmanaged object.</span></span></param>
        <param name="t"><span data-ttu-id="f799e-992">요청된 관리되는 클래스의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-992">The type of the requested managed class.</span></span></param>
        <summary><span data-ttu-id="f799e-993">COM 개체를 나타내는 지정된 형식의 관리되는 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-993">Returns a managed object of a specified type that represents a COM object.</span></span></summary>
        <returns><span data-ttu-id="f799e-994">요청된 관리되지 않는 COM 개체를 나타내는 <see cref="T:System.Type" /> 개체에 해당하는 클래스의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-994">An instance of the class corresponding to the <see cref="T:System.Type" /> object that represents the requested unmanaged COM object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-995">`t` 매개 변수는 가져온 COM 유형 또는 가져온 COM 형식의 하위 형식 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-995">The `t` parameter must be either a COM-imported type or a subtype of a COM-imported type.</span></span> <span data-ttu-id="f799e-996">또한 `t` 해당 메타 데이터에서 가져온 형식 이어야 합니다는 [Tlbimp.exe (형식 라이브러리 가져오기)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-996">In addition, `t` must be a type whose metadata was imported by the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span> <span data-ttu-id="f799e-997">이 형식은 클래스 및 하지 coclass 연결된 하는 인터페이스에 이름을 전달 하는 COM 클래스의 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-997">This type must be a class and not an associated coclass interface, which carries the name of the COM class.</span></span> <span data-ttu-id="f799e-998">예를 들어, Tlbimp.exe 가져오는 경우 `Myclass` 라는 클래스로 `MyclassClass` 호출을 coclass 인터페이스로 `Myclass`를 사용 해야 `MyclassClass` (하지 `Myclass`)이 방법을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-998">For example, if Tlbimp.exe imports `Myclass` as a class called `MyclassClass` and as a coclass interface called `Myclass`, you must use `MyclassClass` (not `Myclass`) with this method.</span></span> <span data-ttu-id="f799e-999">가져온된 클래스 및 인터페이스 coclass에 대 한 자세한 내용은 참조 하십시오. [가져온 형식 변환](http://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-999">For additional information about imported classes and coclass interfaces, see [Imported Type Conversion](http://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3).</span></span>  
  
 <span data-ttu-id="f799e-1000">개체에 대 한 이미 얻은 경우는 `pUnk` 매개 변수를 `t` 무시 되 고 기존 개체가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1000">If an object has already been obtained for the `pUnk` parameter, `t` is ignored and the existing object is returned.</span></span> <span data-ttu-id="f799e-1001">`pUnk` 나타냅니다는[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 인터페이스 포인터; 그러나 모든 COM 인터페이스에서 직접 또는 간접적으로 파생 되므로 `IUnknown`,이 메서드에 COM 인터페이스로 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1001">`pUnk` represents an[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer; however, because all COM interfaces derive directly or indirectly from `IUnknown`, you can pass any COM interface to this method.</span></span> <span data-ttu-id="f799e-1002">반환 되는 개체 <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A> 는 [런타임 호출 가능 래퍼](~/docs/framework/interop/runtime-callable-wrapper.md) RCW (), 공용 언어 런타임 처럼 관리는 다른 관리 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1002">The object returned by <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A> is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW), which the common language runtime manages as it does any other managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1003"><paramref name="t" /> 특성이 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1003"><paramref name="t" /> is not attributed with <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />.</span></span>  
  
 <span data-ttu-id="f799e-1004">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1004">-or-</span></span>  
  
 <span data-ttu-id="f799e-1005"><paramref name="t" />가 [!INCLUDE[wrt](~/includes/wrt-md.md)] 형식인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1005"><paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1006">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1006">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1007">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1007">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeForITypeInfo">
      <MemberSignature Language="C#" Value="public static Type GetTypeForITypeInfo (IntPtr piTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeForITypeInfo(native int piTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeForITypeInfo (piTypeInfo As IntPtr) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeForITypeInfo(IntPtr piTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="piTypeInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="piTypeInfo"><span data-ttu-id="f799e-1008">마샬링할 <see langword="ITypeInfo" /> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1008">The <see langword="ITypeInfo" /> interface to marshal.</span></span></param>
        <summary><span data-ttu-id="f799e-1009">관리되지 않는 [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) 개체를 관리되는 <see cref="T:System.Type" /> 개체로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1009">Converts an unmanaged [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object into a managed <see cref="T:System.Type" /> object.</span></span></summary>
        <returns><span data-ttu-id="f799e-1010">관리되지 않는 <see langword="ITypeInfo" /> 개체를 나타내는 관리되는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1010">A managed type that represents the unmanaged <see langword="ITypeInfo" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1011"><xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> 반환 된 <xref:System.Type?displayProperty=nameWithType> 원래 형식을 기반으로 하는 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="f799e-1011"><xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> returns a <xref:System.Type?displayProperty=nameWithType> instance that is based on the original type.</span></span> <span data-ttu-id="f799e-1012">적용할 수는 <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> 이 사용자 지정 마샬러를 사용한 표준 interop 마샬링 동작을 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1012">You can apply the <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> to replace standard interop marshaling behavior with this custom marshaler.</span></span> <span data-ttu-id="f799e-1013">[Tlbimp.exe (형식 라이브러리 가져오기)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) 도구 사용자 지정 마샬러를 사용 하 여 변환할 `ITypeInfo` 매개 변수를 <xref:System.Type?displayProperty=nameWithType> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1013">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool uses the custom marshaler to translate `ITypeInfo` parameters to <xref:System.Type?displayProperty=nameWithType> parameters.</span></span> <span data-ttu-id="f799e-1014">그러나 가져온 경우는 `ITypeInfo` 일부 인터페이스 Tlbimp.exe 아닌 다른 의미를 사용할 수 있습니다 <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> 을 동일한 번역을 수동으로 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1014">However, if you obtain an `ITypeInfo` interface by some means other than Tlbimp.exe, you can use <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> to manually perform the same translation.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1015">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1015">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1016">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1016">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="f799e-1017">반환할 형식의 CLSID입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1017">The CLSID of the type to return.</span></span></param>
        <summary><span data-ttu-id="f799e-1018">지정된 CLSID(클래스 식별자)와 연관된 형식을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1018">Returns the type associated with the specified class identifier (CLSID).</span></span></summary>
        <returns>
          <span data-ttu-id="f799e-1019">CLSID가 유효한지 여부에 관계 없이 <see langword="System.__ComObject" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1019"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeInfoName">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1020">[ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) 개체가 나타내는 형식의 이름을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1020">Retrieves the name of the type represented by an [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (typeInfo As ITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::ComTypes::ITypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Runtime.InteropServices.ComTypes.ITypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo"><span data-ttu-id="f799e-1021"><see langword="ITypeInfo" /> 포인터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1021">An object that represents an <see langword="ITypeInfo" /> pointer.</span></span></param>
        <summary><span data-ttu-id="f799e-1022">[ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) 개체가 나타내는 형식의 이름을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1022">Retrieves the name of the type represented by an [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object.</span></span></summary>
        <returns><span data-ttu-id="f799e-1023"><paramref name="typeInfo" /> 매개 변수가 가리키는 형식의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1023">The name of the type that the <paramref name="typeInfo" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1024">가 나타내는 형식의 이름을 검색할 수도 있습니다는 `ITypeInfo` 호출 하 여는 <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> 메서드와 해당 첫 번째 매개 변수에 대 한-1을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1024">You can also retrieve the name of the type represented by an `ITypeInfo` by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1025"><paramref name="typeInfo" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1025">The <paramref name="typeInfo" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1026">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1026">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1027">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1027">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.UCOMITypeInfo pTI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.UCOMITypeInfo pTI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (pTI As UCOMITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::UCOMITypeInfo ^ pTI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTI" Type="System.Runtime.InteropServices.UCOMITypeInfo" />
      </Parameters>
      <Docs>
        <param name="pTI"><span data-ttu-id="f799e-1028"><see langword="ITypeInfo" /> 포인터를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1028">An object that represents an <see langword="ITypeInfo" /> pointer.</span></span></param>
        <summary><span data-ttu-id="f799e-1029">[ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) 개체가 나타내는 형식의 이름을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1029">Retrieves the name of the type represented by an [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object.</span></span></summary>
        <returns><span data-ttu-id="f799e-1030"><paramref name="pTI" /> 매개 변수가 가리키는 형식의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1030">The name of the type that the <paramref name="pTI" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1031">가 나타내는 형식의 이름을 검색할 수도 있습니다는 `ITypeInfo` 호출 하 여 개체는 <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> 메서드와 해당 첫 번째 매개 변수에 대 한-1을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1031">You can also retrieve the name of the type represented by an `ITypeInfo` object by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1032">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1032">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1033">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1033">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibGuid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1034">형식 라이브러리의 LIBID(라이브러리 식별자)를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1034">Retrieves the library identifier (LIBID) of a type library.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (typelib As ITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib"><span data-ttu-id="f799e-1035">LIBID를 검색할 형식 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1035">The type library whose LIBID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="f799e-1036">형식 라이브러리의 LIBID(라이브러리 식별자)를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1036">Retrieves the library identifier (LIBID) of a type library.</span></span></summary>
        <returns><span data-ttu-id="f799e-1037">지정된 형식 라이브러리의 LIBID입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1037">The LIBID of the specified type library.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1038"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> 기존의 형식 라이브러리에서 직접 LIBID를 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1038"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extracts the LIBID directly from an existing type library.</span></span> <span data-ttu-id="f799e-1039">이 작업의 다른는 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> LIBID를 계산 하는 메서드는 현재 어셈블리를 기반 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1039">This action differs from that of the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> method, which calculates what the LIBID should be based on the current assembly.</span></span>  
  
 <span data-ttu-id="f799e-1040">라이브러리 식별자에 대 한 자세한 내용은 참조 [내보낸 어셈블리 변환](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1040">For more information about library identifiers, see [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1041">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1041">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1042">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1042">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (pTLB As UCOMITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB"><span data-ttu-id="f799e-1043">LIBID를 검색할 형식 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1043">The type library whose LIBID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="f799e-1044">형식 라이브러리의 LIBID(라이브러리 식별자)를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1044">Retrieves the library identifier (LIBID) of a type library.</span></span></summary>
        <returns><span data-ttu-id="f799e-1045"><paramref name="pTLB" /> 매개 변수가 가리키는 형식 라이브러리의 LIBID입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1045">The LIBID of the type library that the <paramref name="pTLB" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1046"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> 기존의 형식 라이브러리에서 직접 LIBID를 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1046"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extracts the LIBID directly from an existing type library.</span></span> <span data-ttu-id="f799e-1047">이 작업의 다른는 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> LIBID를 계산 하는 메서드는 현재 어셈블리를 기반 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1047">This action differs from that of the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> method, which calculates what the LIBID should be based on the current assembly.</span></span>  
  
 <span data-ttu-id="f799e-1048">라이브러리 식별자에 대 한 자세한 내용은 참조 [내보낸 어셈블리 변환](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1048">For more information about library identifiers, see [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1049">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1049">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1050">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1050">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuidForAssembly">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuidForAssembly (System.Reflection.Assembly asm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuidForAssembly(class System.Reflection.Assembly asm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuidForAssembly (asm As Assembly) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuidForAssembly(System::Reflection::Assembly ^ asm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asm" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="asm"><span data-ttu-id="f799e-1051">형식 라이브러리를 내보낸 소스 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1051">The assembly from which the type library was exported.</span></span></param>
        <summary><span data-ttu-id="f799e-1052">지정된 어셈블리에서 내보낼 때 형식 라이브러리에 할당되는 LIBID(라이브러리 식별자)를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1052">Retrieves the library identifier (LIBID) that is assigned to a type library when it was exported from the specified assembly.</span></span></summary>
        <returns><span data-ttu-id="f799e-1053">지정된 어셈블리에서 형식 라이브러리를 내보낼 때 형식 라이브러리에 할당되는 LIBID입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1053">The LIBID that is assigned to a type library when it is exported from the specified assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1054">어셈블리를 형식 라이브러리에 내보낼 때 형식 라이브러리의 LIBID 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1054">When assemblies are exported to type libraries, the type library is assigned a LIBID.</span></span> <span data-ttu-id="f799e-1055">LIBID를 적용 하 여 명시적으로 설정할 수 있습니다는 <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> 어셈블리에서 수준 자동 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1055">You can set the LIBID explicitly by applying the <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> at the assembly level, or it can be generated automatically.</span></span> <span data-ttu-id="f799e-1056">[Tlbimp.exe (형식 라이브러리 가져오기)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) 도구는 어셈블리의 id에 따라 LIBID 값을 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1056">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool calculates a LIBID value based on the identity of the assembly.</span></span> <span data-ttu-id="f799e-1057"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> 연관 된 LIBID 반환는 <xref:System.Runtime.InteropServices.GuidAttribute>, 특성이 적용 되는 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-1057"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> returns the LIBID that is associated with the <xref:System.Runtime.InteropServices.GuidAttribute>, if the attribute is applied.</span></span> <span data-ttu-id="f799e-1058">그렇지 않으면 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A> 계산된 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1058">Otherwise, <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A> returns the calculated value.</span></span> <span data-ttu-id="f799e-1059">사용할 수 있습니다는 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> 메서드는 기존의 형식 라이브러리에서 실제 LIBID를 추출 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1059">Alternatively, you can use the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> method to extract the actual LIBID from an existing type library.</span></span>  
  
 <span data-ttu-id="f799e-1060">참조는 [내보낸 어셈블리 변환](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86) 라이브러리 식별자에 대 한 자세한 내용은 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1060">See the [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86) topic for more information about library identifiers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-1061"><paramref name="asm" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1061"><paramref name="asm" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1062">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1062">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1063">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1063">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.GuidAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibLcid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1064">형식 라이브러리의 LCID를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1064">Retrieves the LCID of a type library.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (typelib As ITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib"><span data-ttu-id="f799e-1065">LCID를 검색할 형식 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1065">The type library whose LCID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="f799e-1066">형식 라이브러리의 LCID를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1066">Retrieves the LCID of a type library.</span></span></summary>
        <returns><span data-ttu-id="f799e-1067"><paramref name="typelib" /> 매개 변수가 가리키는 형식 라이브러리의 LCID입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1067">The LCID of the type library that the <paramref name="typelib" /> parameter points to.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1068">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1068">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1069">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1069">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (pTLB As UCOMITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB"><span data-ttu-id="f799e-1070">LCID를 검색할 형식 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1070">The type library whose LCID is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="f799e-1071">형식 라이브러리의 LCID를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1071">Retrieves the LCID of a type library.</span></span></summary>
        <returns><span data-ttu-id="f799e-1072"><paramref name="pTLB" /> 매개 변수가 가리키는 형식 라이브러리의 LCID입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1072">The LCID of the type library that the <paramref name="pTLB" /> parameter points to.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1073">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1073">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1074">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1074">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1075">형식 라이브러리의 이름을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1075">Retrieves the name of a type library.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (typelib As ITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib"><span data-ttu-id="f799e-1076">이름을 검색할 형식 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1076">The type library whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="f799e-1077">형식 라이브러리의 이름을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1077">Retrieves the name of a type library.</span></span></summary>
        <returns><span data-ttu-id="f799e-1078"><paramref name="typelib" /> 매개 변수가 가리키는 형식 라이브러리의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1078">The name of the type library that the <paramref name="typelib" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1079">이 메서드에 의해 반환 되는 Microsoft ADO 형식 라이브러리에 대 한 ADODB 같은 라이브러리 문으로 사용 되는 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1079">The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</span></span> <span data-ttu-id="f799e-1080">이름이 파일 이름이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1080">The name is not a file name.</span></span>  
  
 <span data-ttu-id="f799e-1081">호출 하 여 형식 라이브러리 이름을 검색할 수도 있습니다는 <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> 메서드와 해당 첫 번째 매개 변수에 대 한-1을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1081">You can also retrieve the type library name by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1082"><paramref name="typelib" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1082">The <paramref name="typelib" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1083">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1083">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1084">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1084">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (pTLB As UCOMITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB"><span data-ttu-id="f799e-1085">이름을 검색할 형식 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1085">The type library whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="f799e-1086">형식 라이브러리의 이름을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1086">Retrieves the name of a type library.</span></span></summary>
        <returns><span data-ttu-id="f799e-1087"><paramref name="pTLB" /> 매개 변수가 가리키는 형식 라이브러리의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1087">The name of the type library that the <paramref name="pTLB" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1088">이 메서드에 의해 반환 되는 Microsoft ADO 형식 라이브러리에 대 한 ADODB 같은 라이브러리 문으로 사용 되는 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1088">The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</span></span> <span data-ttu-id="f799e-1089">이름이 파일 이름이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1089">The name is not a file name.</span></span>  
  
 <span data-ttu-id="f799e-1090">호출 하 여 형식 라이브러리 이름을 검색할 수도 있습니다는 <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> 메서드와 해당 첫 번째 매개 변수에 대 한-1을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1090">You can also retrieve the type library name by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1091">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1091">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1092">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1092">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibVersionForAssembly">
      <MemberSignature Language="C#" Value="public static void GetTypeLibVersionForAssembly (System.Reflection.Assembly inputAssembly, out int majorVersion, out int minorVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetTypeLibVersionForAssembly(class System.Reflection.Assembly inputAssembly, [out] int32&amp; majorVersion, [out] int32&amp; minorVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetTypeLibVersionForAssembly (inputAssembly As Assembly, ByRef majorVersion As Integer, ByRef minorVersion As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetTypeLibVersionForAssembly(System::Reflection::Assembly ^ inputAssembly, [Runtime::InteropServices::Out] int % majorVersion, [Runtime::InteropServices::Out] int % minorVersion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="majorVersion" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="minorVersion" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="inputAssembly"><span data-ttu-id="f799e-1093">관리되는 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1093">A managed assembly.</span></span></param>
        <param name="majorVersion"><span data-ttu-id="f799e-1094">주 버전 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1094">The major version number.</span></span></param>
        <param name="minorVersion"><span data-ttu-id="f799e-1095">부 버전 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1095">The minor version number.</span></span></param>
        <summary><span data-ttu-id="f799e-1096">지정된 어셈블리에서 내보낼 형식 라이브러리의 버전 번호를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1096">Retrieves the version number of a type library that will be exported from the specified assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1097">사용 하 여 어셈블리를 내보내기 전에 <xref:System.Runtime.InteropServices.TypeLibExporterFlags> 와 `CallerResolvedReferences` 값, 어셈블리에서 형식 라이브러리 버전을 검색 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1097">Before exporting an assembly by using <xref:System.Runtime.InteropServices.TypeLibExporterFlags> with the `CallerResolvedReferences` value, you can use this method to retrieve the type library version from the assembly.</span></span>  
  
 <span data-ttu-id="f799e-1098">적용 되지 않은 경우는 <xref:System.Runtime.InteropServices.TypeLibVersionAttribute> 특성를 명시적으로 제어를 내보낸된 어셈블리에 생성된 된 형식 라이브러리의 버전 번호, 형식 라이브러리는 어셈블리와 동일한 버전 번호입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1098">If you do not apply the <xref:System.Runtime.InteropServices.TypeLibVersionAttribute> attribute to an exported assembly to explicitly control the version number of the generated type library, the type library will have the same version number as the assembly.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-1099"><paramref name="inputAssembly" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1099"><paramref name="inputAssembly" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1100">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1100">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1101">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1101">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.TypeLibExporterFlags" />
        <altmember cref="T:System.Runtime.InteropServices.TypeLibVersionAttribute" />
        <altmember cref="T:System.Runtime.InteropServices.ITypeLibConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetUniqueObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetUniqueObjectForIUnknown (IntPtr unknown);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUniqueObjectForIUnknown(native int unknown) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUniqueObjectForIUnknown (unknown As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUniqueObjectForIUnknown(IntPtr unknown);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unknown" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="unknown"><span data-ttu-id="f799e-1102"><see langword="IUnknown" /> 인터페이스에 대한 관리되는 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1102">A managed pointer to an <see langword="IUnknown" /> interface.</span></span></param>
        <summary><span data-ttu-id="f799e-1103">지정된 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 인터페이스에 대해 고유한 [RCW(런타임 호출 가능 래퍼)](~/docs/framework/interop/runtime-callable-wrapper.md) 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1103">Creates a unique [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) object for a given [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface.</span></span></summary>
        <returns><span data-ttu-id="f799e-1104">지정된 <see langword="IUnknown" /> 인터페이스에 대한 고유한 RCW입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1104">A unique RCW for the specified <see langword="IUnknown" /> interface.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1105"><xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A> 메서드를 사용 하면 고유한 RCW 나타나는 일치 하지 않으므로 `IUnknown` 기존 개체에 대 한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1105">The <xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A> method ensures that you receive a unique RCW, because it does not match an `IUnknown` pointer to an existing object.</span></span> <span data-ttu-id="f799e-1106">이 메서드를 호출 하는 다른 코드에 영향을 받지 않는 고유 RCW를 만들어야 할 때 사용 된 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1106">Use this method when you have to create a unique RCW that is not impacted by other code that calls the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1107">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1107">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1108">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1108">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetUnmanagedThunkForManagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetUnmanagedThunkForManagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetUnmanagedThunkForManagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnmanagedThunkForManagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap"><span data-ttu-id="f799e-1109">마샬링할 메서드에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1109">A pointer to the method to marshal.</span></span></param>
        <param name="pbSignature"><span data-ttu-id="f799e-1110">메서드 시그니처에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1110">A pointer to the method signature.</span></span></param>
        <param name="cbSignature"><span data-ttu-id="f799e-1111"><c>pbSignature</c>의 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1111">The number of bytes in <c>pbSignature</c>.</span></span></param>
        <summary><span data-ttu-id="f799e-1112">비관리 코드에서 관리 코드로 호출을 마샬링하는 런타임 생성 함수에 대한 포인터를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1112">Gets a pointer to a runtime-generated function that marshals a call from unmanaged to managed code.</span></span></summary>
        <returns><span data-ttu-id="f799e-1113"><paramref name="pfnMethodToWrap" />에서의 호출을 관리 코드로 마샬링할 함수에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1113">A pointer to a function that will marshal a call from <paramref name="pfnMethodToWrap" /> to managed code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1114"><xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A> 에 대 한 컴파일러 지원만 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1114"><xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A> is exposed for compiler support only.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1115">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1115">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1116">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1116">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsComObject">
      <MemberSignature Language="C#" Value="public static bool IsComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsComObject (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f799e-1117">검사할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1117">The object to check.</span></span></param>
        <summary><span data-ttu-id="f799e-1118">지정된 개체가 COM 개체를 나타낼지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1118">Indicates whether a specified object represents a COM object.</span></span></summary>
        <returns>
          <span data-ttu-id="f799e-1119"><paramref name="o" /> 매개 변수가 COM 형식이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1119"><see langword="true" /> if the <paramref name="o" /> parameter is a COM type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1120"><xref:System.Runtime.InteropServices.Marshal.IsComObject%2A> 반환 `true` 인스턴스의 클래스 형식을 특성으로 지정 하는 경우 <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> 특성을 사용 하는 클래스에서 직접 또는 간접적으로 파생 되는 경우 또는 <xref:System.Runtime.InteropServices.ComImportAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1120"><xref:System.Runtime.InteropServices.Marshal.IsComObject%2A> returns `true` if the class type of the instance is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> or if it derives directly or indirectly from a class attributed with <xref:System.Runtime.InteropServices.ComImportAttribute>.</span></span> <span data-ttu-id="f799e-1121">[Tlbimp.exe (형식 라이브러리 가져오기)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) 도구 형식 라이브러리를 가져올 때이 특성을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1121">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span>  
  
 <span data-ttu-id="f799e-1122">다른 두 메서드는 또한 지정 된 개체가 COM 개체를 반환 하는 요구 사항이 나타내는지 확인 `true` 이 메서드의 요구이 사항에서 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1122">Two other methods also determine whether a specified object represents a COM object, but the requirements for returning `true` differ from this method's requirements.</span></span> <span data-ttu-id="f799e-1123"><xref:System.Type.IsImport%2A?displayProperty=nameWithType> 반환 `true` 클래스 (또는 인터페이스)로 지정 하는 경우 <xref:System.Runtime.InteropServices.ComImportAttribute> 반환 하지 않는 직접; `true` 파생 형식에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1123"><xref:System.Type.IsImport%2A?displayProperty=nameWithType> returns `true` if the class (or interface) is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute> directly; it does not return `true` for derived types.</span></span> <span data-ttu-id="f799e-1124"><xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType> 반환 `true` 형식을 특성으로 지정 하는 경우 <xref:System.Runtime.InteropServices.ComImportAttribute> 또는 guid가 같은 형식에서 파생 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1124"><xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType> returns `true` if the type is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute> or derives from a type with the same GUID.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-1125"><paramref name="o" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1125"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="P:System.Type.IsImport" />
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsTypeVisibleFromCom">
      <MemberSignature Language="C#" Value="public static bool IsTypeVisibleFromCom (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTypeVisibleFromCom(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTypeVisibleFromCom (t As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTypeVisibleFromCom(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="f799e-1126">COM 표시 여부를 확인할 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1126">The type to check for COM visibility.</span></span></param>
        <summary><span data-ttu-id="f799e-1127">형식이 COM 클라이언트에 표시되는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1127">Indicates whether a type is visible to COM clients.</span></span></summary>
        <returns>
          <span data-ttu-id="f799e-1128">형식이 COM에 표시되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1128"><see langword="true" /> if the type is visible to COM; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1129"><xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A> 한 번에 COM 표시 여부를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1129"><xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A> enables you to check for COM visibility in one step.</span></span> <span data-ttu-id="f799e-1130">표시 되는 형식은 COM에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1130">Types that are not visible cannot be used from COM.</span></span> <span data-ttu-id="f799e-1131">이 경우 표시 되는 형식의 `public` 와 숨겨지지는 <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1131">A type is visible if it is `public` and not hidden with the <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />
      </Docs>
    </Member>
    <Member MemberName="NumParamBytes">
      <MemberSignature Language="C#" Value="public static int NumParamBytes (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NumParamBytes(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NumParamBytes (m As MethodInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NumParamBytes(System::Reflection::MethodInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="f799e-1132">검사할 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1132">The method to be checked.</span></span></param>
        <summary><span data-ttu-id="f799e-1133">지정된 메서드에 대한 매개 변수를 포함하는 데 필요한 관리되지 않는 메모리의 바이트 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1133">Calculates the number of bytes in unmanaged memory that are required to hold the parameters for the specified method.</span></span></summary>
        <returns><span data-ttu-id="f799e-1134">관리되지 않는 메모리에서 메서드 매개 변수를 나타내는 데 필요한 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1134">The number of bytes required to represent the method parameters in unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1135"><xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A> 의 스택 크기 (바이트) 관리 되지 않는 메모리에 메서드 시그니처의 매개 변수를 나타내는 데 필요한 메서드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1135">The <xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A> method returns the stack size (in bytes) needed to represent the parameters of a method signature in unmanaged memory.</span></span>  
  
 <span data-ttu-id="f799e-1136">이 메서드의 반환 값은 플랫폼별 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1136">Note that the return value of this method is platform-dependent.</span></span> <span data-ttu-id="f799e-1137">예를 들어 단일 정수 매개 변수를 사용 하는 서명을 32 비트 플랫폼과 64 비트 플랫폼에서 8의 값에서 값 4 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1137">For example, a signature with a single integer parameter returns a value of 4 on 32-bit platforms and a value of 8 on 64-bit platforms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1138"><paramref name="m" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1138">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-1139"><paramref name="m" /> 매개 변수가 <see cref="T:System.Reflection.MethodInfo" /> 개체가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1139">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MethodInfo" /> object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1140">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1140">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1141">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1141">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf (Type t, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf(class System.Type t, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf (t As Type, fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr OffsetOf(Type ^ t, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="f799e-1142">관리되는 클래스를 지정하는 값 형식이나 서식이 지정된 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1142">A value type or formatted reference type that specifies the managed class.</span></span> <span data-ttu-id="f799e-1143">클래스에 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />를 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1143">You must apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> to the class.</span></span></param>
        <param name="fieldName"><span data-ttu-id="f799e-1144"><c>t</c> 매개 변수에 있는 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1144">The field within the <c>t</c> parameter.</span></span></param>
        <summary><span data-ttu-id="f799e-1145">관리되는 클래스의 관리되지 않는 형식의 필드 오프셋을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1145">Returns the field offset of the unmanaged form of the managed class.</span></span></summary>
        <returns><span data-ttu-id="f799e-1146">플랫폼 호출로 선언된 지정된 클래스 내의 <paramref name="fieldName" /> 매개 변수에 대한 오프셋(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1146">The offset, in bytes, for the <paramref name="fieldName" /> parameter within the specified class that is declared by platform invoke.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1147"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> 관리 되는 구조체 레이아웃의 오프셋에 대응 되지 않는 관리 되지 않는 구조체 레이아웃 측면에서 오프셋을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1147"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</span></span> <span data-ttu-id="f799e-1148">구조 마샬링 레이아웃을 변환 하 고 오프셋을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1148">Marshaling the structure can transform the layout and alter the offset.</span></span> <span data-ttu-id="f799e-1149">`t` (순차적 또는 명시적 레이아웃)으로 형식이 지정 된 참조 형식 이거나 값 형식 매개 변수 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1149">The `t` parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</span></span> <span data-ttu-id="f799e-1150">사용 하 여 전체 레이아웃의 크기를 가져올 수는 <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1150">You can obtain the size of the entire layout by using the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f799e-1151">자세한 내용은 참조 하십시오. [값 형식에 대 한 마샬링을 기본](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1151">For additional information, see [Default Marshaling for Value Types](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f799e-1152">.NET Framework 버전 2.0 부터는 <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> 전용 필드를 노출 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1152">Beginning with the .NET Framework version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> may expose private fields.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-1153">클래스를 구조체로 내보낼 수 없거나 필드가 공용이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1153">The class cannot be exported as a structure or the field is nonpublic.</span></span> <span data-ttu-id="f799e-1154">.NET Framework 버전 2.0 이상에서는 이 필드가 private 필드일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1154">Beginning with the .NET Framework version 2.0, the field may be private.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1155"><paramref name="t" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1155">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OffsetOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf&lt;T&gt; (string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf&lt;T&gt;(string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf(Of T) (fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr OffsetOf(System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-1156">관리되는 값 또는 formatted 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1156">A managed value type or formatted reference type.</span></span> <span data-ttu-id="f799e-1157">클래스에 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 특성을 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1157">You must apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> attribute to the class.</span></span></typeparam>
        <param name="fieldName"><span data-ttu-id="f799e-1158"><c>T</c> 형식의 필드 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1158">The name of the field in the <c>T</c> type.</span></span></param>
        <summary><span data-ttu-id="f799e-1159">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-1159">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-1160">지정된 관리되는 클래스의 관리되지 않는 형식의 필드 오프셋을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1160">Returns the field offset of the unmanaged form of a specified managed class.</span></span></summary>
        <returns><span data-ttu-id="f799e-1161">플랫폼 호출로 선언된 지정된 클래스 내의 <paramref name="fieldName" /> 매개 변수에 대한 오프셋(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1161">The offset, in bytes, for the <paramref name="fieldName" /> parameter within the specified class that is declared by platform invoke.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1162"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29> 관리 되는 구조체 레이아웃의 오프셋에 대응 되지 않는 관리 되지 않는 구조체 레이아웃 측면에서 오프셋을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1162"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</span></span> <span data-ttu-id="f799e-1163">구조 마샬링 레이아웃을 변환 하 고 오프셋을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1163">Marshaling the structure can transform the layout and alter the offset.</span></span> <span data-ttu-id="f799e-1164">`T` 제네릭 형식 매개 변수 값 형식 또는 서식이 지정 된 참조 형식 (순차적 또는 명시적 레이아웃)을 사용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1164">The `T` generic type parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</span></span> <span data-ttu-id="f799e-1165">사용 하 여 전체 레이아웃의 크기를 가져올 수는 <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1165">You can obtain the size of the entire layout by using the <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> method.</span></span> <span data-ttu-id="f799e-1166">자세한 내용은 참조 하십시오. [값 형식에 대 한 마샬링을 기본](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1166">For additional information, see [Default Marshaling for Value Types](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f799e-1167">.NET Framework 버전 2.0 부터는 <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> 전용 필드를 노출 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1167">Beginning with the .NET Framework version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> may expose private fields.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="Prelink">
      <MemberSignature Language="C#" Value="public static void Prelink (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Prelink(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Prelink (m As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Prelink(System::Reflection::MethodInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m"><span data-ttu-id="f799e-1168">검사할 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1168">The method to be checked.</span></span></param>
        <summary><span data-ttu-id="f799e-1169">메서드를 호출하지 않고 메서드 설정 작업을 한 번에 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1169">Executes one-time method setup tasks without calling the method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1170">설정 작업 빠른 초기화를 제공 하 고 대상 메서드가 호출 될 때 자동으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1170">Setup tasks provide early initialization and are performed automatically when the target method is invoked.</span></span> <span data-ttu-id="f799e-1171">첫 번째 작업은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1171">First-time tasks include the following:</span></span>  
  
-   <span data-ttu-id="f799e-1172">확인 하는 플랫폼 호출 메타 데이터 형식이 잘못 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1172">Verifying that the platform invoke metadata is correctly formatted.</span></span>  
  
-   <span data-ttu-id="f799e-1173">함수를 호출 하는지 확인 하는 모든 관리 되는 형식을 플랫폼의 올바른 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1173">Verifying that all the managed types are valid parameters of platform invoke functions.</span></span>  
  
-   <span data-ttu-id="f799e-1174">찾기 및 프로세스에 관리 되지 않는 DLL을 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1174">Locating and loading the unmanaged DLL into the process.</span></span>  
  
-   <span data-ttu-id="f799e-1175">프로세스의 진입점을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1175">Locating the entry point in the process.</span></span>  
  
 <span data-ttu-id="f799e-1176">호출 <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> 호출 플랫폼 외부의 메서드에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1176">Calling <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> on a method outside of platform invoke has no effect.</span></span> <span data-ttu-id="f799e-1177">모든 플랫폼에서 작업 설치 프로그램을 실행 하는 형식 사용의에서 메서드를 호출 <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1177">To execute setup tasks on all platform invoke methods in a type, use <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1178"><paramref name="m" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1178">The <paramref name="m" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-1179"><paramref name="m" /> 매개 변수가 <see cref="T:System.Reflection.MethodInfo" /> 개체가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1179">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MethodInfo" /> object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1180">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1180">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1181">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1181">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="PrelinkAll">
      <MemberSignature Language="C#" Value="public static void PrelinkAll (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrelinkAll(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrelinkAll (c As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrelinkAll(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="f799e-1182">메서드를 검사할 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1182">The class whose methods are to be checked.</span></span></param>
        <summary><span data-ttu-id="f799e-1183">클래스의 모든 메서드에 대해 링크 전 검사를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1183">Performs a pre-link check for all methods on a class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1184"><xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> 메서드 호출 <xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType> 모든 메서드에서 지정된 된 형식에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1184">The <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> method invokes <xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType> on every method for a given type.</span></span> <span data-ttu-id="f799e-1185"><xref:System.Runtime.InteropServices.Marshal.Prelink%2A> 각 메서드를 호출 하지 않고 메서드를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1185"><xref:System.Runtime.InteropServices.Marshal.Prelink%2A> executes one-time method setup tasks without calling each method.</span></span> <span data-ttu-id="f799e-1186">사용할 수 있습니다 <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> 플랫폼에 대 한 호출을 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1186">You can use <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> only for platform invoke calls.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1187"><paramref name="c" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1187">The <paramref name="c" /> parameter is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1188">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1188">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1189">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAnsi">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1190">관리되는 <see cref="T:System.String" />을 할당하고 관리되지 않는 ANSI 문자열의 전체 또는 일부를 해당 개체로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1190">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged ANSI string into it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1191">관리되지 않는 문자열의 첫 문자 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1191">The address of the first character of the unmanaged string.</span></span></param>
        <summary><span data-ttu-id="f799e-1192">관리되지 않는 ANSI 문자열에서 첫 번째 null 문자가 나올 때까지의 모든 문자를 관리되는 <see cref="T:System.String" />으로 복사하고 각 ANSI 문자를 유니코드로 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1192">Copies all characters up to the first null character from an unmanaged ANSI string to a managed <see cref="T:System.String" />, and widens each ANSI character to Unicode.</span></span></summary>
        <returns><span data-ttu-id="f799e-1193">관리되지 않는 ANSI 문자열의 복사본을 보유하는 관리되는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1193">A managed string that holds a copy of the unmanaged ANSI string.</span></span> <span data-ttu-id="f799e-1194"><paramref name="ptr" />이 <see langword="null" />이면 메서드가 null 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1194">If <paramref name="ptr" /> is <see langword="null" />, the method returns a null string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1195"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> 사용자 지정 마샬링에 또는 관리 코드와 비관리 코드를 혼합 하는 경우 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1195"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1196">이 메서드는 관리 되지 않는 문자열의 내용의 복사본을 만들기 때문에 적절 하 게 원래 문자열을 해제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1196">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="f799e-1197">이 메서드는 제공 된 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> 및 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1197">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1198">다음 예제에서는 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> 에서 관리 되지 않는 관리 되는 문자열을 만드는 메서드를 `char` 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1198">The following example uses the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> method to create a managed string from an unmanaged `char` array.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1199">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1199">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1200">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1200">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1201">관리되지 않는 문자열의 첫 문자 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1201">The address of the first character of the unmanaged string.</span></span></param>
        <param name="len"><span data-ttu-id="f799e-1202">복사할 입력 문자열의 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1202">The byte count of the input string to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-1203">관리되는 <see cref="T:System.String" />을 할당하고, 관리되지 않는 ANSI 문자열에서 지정된 수의 문자를 해당 개체로 복사한 다음 각 ANSI 문자를 유니코드로 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1203">Allocates a managed <see cref="T:System.String" />, copies a specified number of characters from an unmanaged ANSI string into it, and widens each ANSI character to Unicode.</span></span></summary>
        <returns><span data-ttu-id="f799e-1204"><paramref name="ptr" /> 매개 변수의 값이 <see langword="null" />이 아니면 네이티브 ANSI 문자열의 복사본을 보유하는 관리되는 문자열이고, 그렇지 않으면 이 메서드에서 <see langword="null" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1204">A managed string that holds a copy of the native ANSI string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1205"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> 사용자 지정 마샬링에 또는 관리 코드와 비관리 코드를 혼합 하는 경우 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1205"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1206">이 메서드는 관리 되지 않는 문자열의 내용의 복사본을 만들기 때문에 적절 하 게 원래 문자열을 해제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1206">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="f799e-1207">이 메서드는 제공 된 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> 및 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1207">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1208">다음 예제에서는 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> 에서 관리 되지 않는 관리 되는 문자열을 만드는 메서드를`char` 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1208">The following example uses the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> method to create a managed string from an unmanaged`char` array.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1209"><paramref name="len" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1209"><paramref name="len" /> is less than zero.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1210">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1210">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1211">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1211">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAuto">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1212">관리되는 <see cref="T:System.String" />을 할당하고 관리되지 않는 문자열의 전체 또는 일부를 그 안에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1212">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged string into it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1213">유니코드 플랫폼의 경우 첫째 유니코드 문자의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1213">For Unicode platforms, the address of the first Unicode character.</span></span>  
  
 <span data-ttu-id="f799e-1214">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1214">-or-</span></span>  
  
 <span data-ttu-id="f799e-1215">ANSI 플랫폼의 경우 첫째 ANSI 문자의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1215">For ANSI plaforms, the address of the first ANSI character.</span></span></param>
        <summary><span data-ttu-id="f799e-1216">관리되는 <see cref="T:System.String" />을 할당하고 관리되지 않는 메모리에 저장된 문자열에서 첫 번째 null이 나올 때까지의 모든 문자를 해당 개체로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1216">Allocates a managed <see cref="T:System.String" /> and copies all characters up to the first null character from a string stored in unmanaged memory into it.</span></span></summary>
        <returns><span data-ttu-id="f799e-1217"><paramref name="ptr" /> 매개 변수의 값이 <see langword="null" />이 아니면 관리되지 않는 문자열의 복사본이 들어 있는 관리되는 문자열이고, 그렇지 않으면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1217">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1218">현재 플랫폼은 유니코드 각 ANSI 문자를 유니코드 문자로 확장 되 고이 메서드를 호출 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1218">If the current platform is Unicode, each ANSI character is widened to a Unicode character and this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>.</span></span> <span data-ttu-id="f799e-1219">그렇지 않으면이 메서드를 호출 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1219">Otherwise, this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span></span>  
  
 <span data-ttu-id="f799e-1220"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> 사용자 지정 마샬링에 또는 관리 코드와 비관리 코드를 혼합 하는 경우 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1220"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1221">이 메서드는 관리 되지 않는 문자열의 내용의 복사본을 만들기 때문에 적절 하 게 원래 문자열을 해제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1221">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="f799e-1222"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> 반대 되는 기능을 제공 된 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> 및 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1222"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1223">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1223">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1224">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1224">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1225">유니코드 플랫폼의 경우 첫째 유니코드 문자의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1225">For Unicode platforms, the address of the first Unicode character.</span></span>  
  
 <span data-ttu-id="f799e-1226">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1226">-or-</span></span>  
  
 <span data-ttu-id="f799e-1227">ANSI 플랫폼의 경우 첫째 ANSI 문자의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1227">For ANSI plaforms, the address of the first ANSI character.</span></span></param>
        <param name="len"><span data-ttu-id="f799e-1228">복사할 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1228">The number of characters to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-1229">관리되는 <see cref="T:System.String" />을 할당하고 관리되지 않는 메모리에 저장된 문자열에서 지정된 수의 문자를 그 안에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1229">Allocates a managed <see cref="T:System.String" /> and copies the specified number of characters from a string stored in unmanaged memory into it.</span></span></summary>
        <returns><span data-ttu-id="f799e-1230"><paramref name="ptr" /> 매개 변수의 값이 <see langword="null" />이 아니면 네이티브 문자열의 복사본이 들어 있는 관리되는 문자열이고, 그렇지 않으면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1230">A managed string that holds a copy of the native string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1231">이 메서드를 호출 유니코드 플랫폼 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>; ANSI 플랫폼 호출 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1231">On Unicode platforms, this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>; on ANSI platforms, it calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span></span> <span data-ttu-id="f799e-1232">이러한 메서드를 호출 하기 전에 변환이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1232">No transformations are done before these methods are called.</span></span>  
  
 <span data-ttu-id="f799e-1233"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> 사용자 지정 마샬링에 또는 관리 코드와 비관리 코드를 혼합 하는 경우 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1233"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1234">이 메서드는 관리 되지 않는 문자열의 내용의 복사본을 만들기 때문에 적절 하 게 원래 문자열을 해제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1234">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="f799e-1235"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> 반대 되는 기능을 제공 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> 및 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1235"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1236"><paramref name="len" />가 0보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1236"><paramref name="len" /> is less than zero.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1237">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1237">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1238">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1238">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringBSTR">
      <MemberSignature Language="C#" Value="public static string PtrToStringBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringBSTR (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringBSTR(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1239">관리되지 않는 문자열의 첫 문자 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1239">The address of the first character of the unmanaged string.</span></span></param>
        <summary><span data-ttu-id="f799e-1240">관리되는 <see cref="T:System.String" />을 할당하고 관리되지 않는 메모리에 저장된 [BSTR(이진 문자열)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)을 그 안에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1240">Allocates a managed <see cref="T:System.String" /> and copies a [binary string (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) stored in unmanaged memory into it.</span></span></summary>
        <returns><span data-ttu-id="f799e-1241">관리되지 않는 문자열의 복사본을 보유하는 관리되는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1241">A managed string that holds a copy of the unmanaged string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1242">할당 된 문자열에 대해서만이 메서드를 호출 합니다. 관리 되지 않는 [SysAllocString](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx) 및 [SysAllocStringLen](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx) 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1242">Call this method only on strings that were allocated with the unmanaged [SysAllocString](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx) and [SysAllocStringLen](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx) functions.</span></span>  
  
 <span data-ttu-id="f799e-1243"><xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A> 사용자 지정 마샬링에 또는 관리 코드와 비관리 코드를 혼합 하는 경우 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1243"><xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1244">이 메서드는 관리 되지 않는 문자열의 내용의 복사본을 만들기 때문에 적절 하 게 원래 문자열을 해제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1244">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="f799e-1245">이 메서드는 제공 된 <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1245">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-1246"><paramref name="ptr" />가 <see cref="F:System.IntPtr.Zero" />와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1246"><paramref name="ptr" /> equals <see cref="F:System.IntPtr.Zero" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1247">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1247">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1248">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1248">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringUni">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1249">관리되는 <see cref="T:System.String" />을 할당하고 관리되지 않는 유니코드 문자열의 전체 또는 일부를 그 안에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1249">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged Unicode string into it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1250">관리되지 않는 문자열의 첫 문자 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1250">The address of the first character of the unmanaged string.</span></span></param>
        <summary><span data-ttu-id="f799e-1251">관리되는 <see cref="T:System.String" />을 할당하고 관리되지 않는 유니코드 문자열에서 첫 번째 null이 나올 때까지의 모든 문자를 해당 개체로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1251">Allocates a managed <see cref="T:System.String" /> and copies all characters up to the first null character from an unmanaged Unicode string into it.</span></span></summary>
        <returns><span data-ttu-id="f799e-1252"><paramref name="ptr" /> 매개 변수의 값이 <see langword="null" />이 아니면 관리되지 않는 문자열의 복사본이 들어 있는 관리되는 문자열이고, 그렇지 않으면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1252">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1253"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> 관리 및 비관리 코드를 혼합 하는 경우 사용자 지정 마샬링 하거나 사용 하기 위해 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1253"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1254">이 메서드는 관리 되지 않는 문자열의 내용의 복사본을 만들기 때문에 적절 하 게 원래 문자열을 해제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1254">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="f799e-1255">이 메서드는 제공 된 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> 및 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1255">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1256">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1256">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1257">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1257">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1258">관리되지 않는 문자열의 첫 문자 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1258">The address of the first character of the unmanaged string.</span></span></param>
        <param name="len"><span data-ttu-id="f799e-1259">복사할 유니코드 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1259">The number of Unicode characters to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-1260">관리되는 <see cref="T:System.String" />을 할당하고 관리되지 않는 유니코드 문자열의 지정된 문자 수를 그 안에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1260">Allocates a managed <see cref="T:System.String" /> and copies a specified number of characters from an unmanaged Unicode string into it.</span></span></summary>
        <returns><span data-ttu-id="f799e-1261"><paramref name="ptr" /> 매개 변수의 값이 <see langword="null" />이 아니면 관리되지 않는 문자열의 복사본이 들어 있는 관리되는 문자열이고, 그렇지 않으면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1261">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1262"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> 사용자 지정 마샬링에 또는 관리 코드와 비관리 코드를 혼합 하는 경우 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1262"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1263">이 메서드는 관리 되지 않는 문자열의 내용의 복사본을 만들기 때문에 적절 하 게 원래 문자열을 해제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1263">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="f799e-1264">이 메서드는 제공 된 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> 및 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1264">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1265">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1265">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1266">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1266">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr, int byteLen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr, int32 byteLen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr, byteLen As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr, int byteLen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="byteLen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="byteLen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStructure">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1267">관리되지 않는 메모리 블록의 데이터를 관리되는 개체로 마샬링합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1267">Marshals data from an unmanaged block of memory to a managed object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static void PtrToStructure (IntPtr ptr, object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure(native int ptr, object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure (ptr As IntPtr, structure As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PtrToStructure(IntPtr ptr, System::Object ^ structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1268">관리되지 않는 메모리 블록에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1268">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structure"><span data-ttu-id="f799e-1269">데이터가 복사될 대상 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1269">The object to which the data is to be copied.</span></span> <span data-ttu-id="f799e-1270">이 개체는 형식이 지정된 클래스의 인스턴스여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1270">This must be an instance of a formatted class.</span></span></param>
        <summary><span data-ttu-id="f799e-1271">관리되지 않는 메모리 블록의 데이터를 관리되는 개체로 마샬링합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1271">Marshals data from an unmanaged block of memory to a managed object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1272"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> 하는 경우가 com에서 interop 및 플랫폼 호출 구조체 매개 변수는로 표현 되는 <xref:System.IntPtr?displayProperty=nameWithType> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1272"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> is often necessary in COM interop and platform invoke when structure parameters are represented as an <xref:System.IntPtr?displayProperty=nameWithType> value.</span></span> <span data-ttu-id="f799e-1273">값이 있는이 오버 로드 메서드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1273">You cannot use this overload method with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-1274">구조체 레이아웃이 Sequential 또는 Explicit이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1274">Structure layout is not sequential or explicit.</span></span>  
  
 <span data-ttu-id="f799e-1275">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1275">-or-</span></span>  
  
 <span data-ttu-id="f799e-1276">구조체가 boxed 값 형식인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1276">Structure is a boxed value type.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1277">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1277">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1278">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1278">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static object PtrToStructure (IntPtr ptr, Type structureType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object PtrToStructure(native int ptr, class System.Type structureType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure (ptr As IntPtr, structureType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ PtrToStructure(IntPtr ptr, Type ^ structureType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structureType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1279">관리되지 않는 메모리 블록에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1279">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structureType"><span data-ttu-id="f799e-1280">만들 개체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1280">The type of object to be created.</span></span> <span data-ttu-id="f799e-1281">이 개체는 서식이 지정된 클래스나 구조체를 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1281">This object must represent a formatted class or a structure.</span></span></param>
        <summary><span data-ttu-id="f799e-1282">관리되지 않는 메모리 블록의 데이터를 지정된 형식의 새로 할당된 관리되는 개체로 마샬링합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1282">Marshals data from an unmanaged block of memory to a newly allocated managed object of the specified type.</span></span></summary>
        <returns><span data-ttu-id="f799e-1283"><paramref name="ptr" /> 매개 변수가 가리키는 데이터가 있는 관리되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1283">A managed object containing the data pointed to by the <paramref name="ptr" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1284"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> 하는 경우가 com에서 interop 및 플랫폼 호출 구조체 매개 변수는로 표현 되는 <xref:System.IntPtr?displayProperty=nameWithType> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1284"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> is often necessary in COM interop and platform invoke when structure parameters are represented as an <xref:System.IntPtr?displayProperty=nameWithType> value.</span></span> <span data-ttu-id="f799e-1285">이 오버 로드 메서드의 값 형식을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1285">You can pass a value type to this overload method.</span></span> <span data-ttu-id="f799e-1286">이 경우 반환된 된 개체는 boxed 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1286">In this case, the returned object is a boxed instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1287">다음 예제에서는 관리 되는 구조를 만들고, 관리 되지 않는 메모리를 한 후 사용 하 여 관리 되는 메모리에 다시 전송 된 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1287">The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 <span data-ttu-id="f799e-1288">다음 예제에는 관리 되지 않는 메모리 블록을 사용 하 여 관리 되는 구조를 마샬링하는 방법을 보여 줍니다는 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1288">The following example demonstrates how to marshal an unmanaged block of memory to a managed structure using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f799e-1289">이 코드는 32 비트 컴파일을 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1289">This code assumes 32-bit compilation.</span></span> <span data-ttu-id="f799e-1290">64 비트 컴파일러를 사용 하기 전에 교체 <xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType> 와 <xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1290">Before using a 64-bit compiler, replace <xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType> with <xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[PtrToStructure#1](~/samples/snippets/cpp/VS_Snippets_CLR/PtrToStructure/CPP/pts.cpp#1)]
 [!code-csharp[PtrToStructure#1](~/samples/snippets/csharp/VS_Snippets_CLR/PtrToStructure/CS/pts.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-1291"><paramref name="structureType" /> 매개 변수 레이아웃이 Sequential 또는 Explicit이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1291">The <paramref name="structureType" /> parameter layout is not sequential or explicit.</span></span>  
  
 <span data-ttu-id="f799e-1292">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1292">-or-</span></span>  
  
 <span data-ttu-id="f799e-1293"><paramref name="structureType" /> 매개 변수는 제네릭 형식 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1293">The <paramref name="structureType" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-1294"><paramref name="structureType" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1294"><paramref name="structureType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="f799e-1295"><paramref name="structureType" />에서 지정한 클래스에는 액세스할 수 있는 기본 생성자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1295">The class specified by <paramref name="structureType" /> does not have an accessible default constructor.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1296">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1296">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1297">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1297">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetTypeAttr(System.IntPtr@)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T PtrToStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T PtrToStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure(Of T) (ptr As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T PtrToStructure(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-1298">데이터가 복사될 개체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1298">The type of the object to which the data is to be copied.</span></span> <span data-ttu-id="f799e-1299">이 개체는 서식이 지정된 클래스나 구조체여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1299">This must be a formatted class or a structure.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="f799e-1300">관리되지 않는 메모리 블록에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1300">A pointer to an unmanaged block of memory.</span></span></param>
        <summary><span data-ttu-id="f799e-1301">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-1301">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-1302">관리되지 않는 메모리 블록의 데이터를 제네릭 형식 매개 변수에 의해 지정된 형식의 새로 할당된 관리되는 개체로 마샬링합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1302">Marshals data from an unmanaged block of memory to a newly allocated managed object of the type specified by a generic type parameter.</span></span></summary>
        <returns><span data-ttu-id="f799e-1303"><paramref name="ptr" /> 매개 변수가 가리키는 데이터가 있는 관리되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1303">A managed object that contains the data that the <paramref name="ptr" /> parameter points to.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1304"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29> 하는 경우가 com에서 interop 및 플랫폼 호출 구조체 매개 변수는 라도 <xref:System.IntPtr?displayProperty=nameWithType> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1304"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29> is often necessary in COM interop and platform invoke when structure parameters are represented as <xref:System.IntPtr?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="f799e-1305">이 메서드 오버 로드에 값 형식을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1305">You can pass a value type to this method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-1306"><typeparamref name="T" /> 레이아웃이 Sequential 또는 Explicit이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1306">The layout of <typeparamref name="T" /> is not sequential or explicit.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="f799e-1307"><typeparamref name="T" />에서 지정한 클래스에는 액세스할 수 있는 기본 생성자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1307">The class specified by <typeparamref name="T" /> does not have an accessible default constructor.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1308">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1308">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1309">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1309">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void PtrToStructure&lt;T&gt; (IntPtr ptr, T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure&lt;T&gt;(native int ptr, !!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure(Of T) (ptr As IntPtr, structure As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void PtrToStructure(IntPtr ptr, T structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-1310">유형의 <c>구조</c>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1310">The type of <c>structure</c>.</span></span> <span data-ttu-id="f799e-1311">형식이 지정된 클래스여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1311">This must be a formatted class.</span></span></typeparam>
        <param name="ptr"><span data-ttu-id="f799e-1312">관리되지 않는 메모리 블록에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1312">A pointer to an unmanaged block of memory.</span></span></param>
        <param name="structure"><span data-ttu-id="f799e-1313">데이터가 복사될 대상 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1313">The object to which the data is to be copied.</span></span></param>
        <summary><span data-ttu-id="f799e-1314">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-1314">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-1315">관리되지 않는 메모리 블록의 데이터를 지정된 형식의 관리되는 개체로 마샬링합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1315">Marshals data from an unmanaged block of memory to a managed object of the specified type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1316"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29> 하는 경우가 com에서 interop 및 플랫폼 호출 구조체 매개 변수는 라도 <xref:System.IntPtr> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1316"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29> is often necessary in COM interop and platform invoke when structure parameters are represented as <xref:System.IntPtr> values.</span></span> <span data-ttu-id="f799e-1317">값이 있는이 메서드 오버 로드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1317">You cannot use this method overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-1318">구조체 레이아웃이 Sequential 또는 Explicit이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1318">Structure layout is not sequential or explicit.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1319">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1319">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1320">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1320">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="QueryInterface">
      <MemberSignature Language="C#" Value="public static int QueryInterface (IntPtr pUnk, ref Guid iid, out IntPtr ppv);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 QueryInterface(native int pUnk, valuetype System.Guid&amp; iid, [out] native int&amp; ppv) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueryInterface (pUnk As IntPtr, ByRef iid As Guid, ByRef ppv As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int QueryInterface(IntPtr pUnk, Guid % iid, [Runtime::InteropServices::Out] IntPtr % ppv);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="iid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="ppv" Type="System.IntPtr&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="f799e-1321">쿼리될 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1321">The interface to be queried.</span></span></param>
        <param name="iid"><span data-ttu-id="f799e-1322">요청된 인터페이스의 IID(인터페이스 식별자)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1322">The interface identifier (IID) of the requested interface.</span></span></param>
        <param name="ppv"><span data-ttu-id="f799e-1323">이 메서드는 반환될 때 반환된 인터페이스에 대한 참조를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1323">When this method returns, contains a reference to the returned interface.</span></span></param>
        <summary><span data-ttu-id="f799e-1324">COM 개체에서 지정된 인터페이스에 대한 포인터를 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1324">Requests a pointer to a specified interface from a COM object.</span></span></summary>
        <returns><span data-ttu-id="f799e-1325">호출의 성공이나 실패를 나타내는 HRESULT입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1325">An HRESULT that indicates the success or failure of the call.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1326"><xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A> 메서드 노출 된 [iunknown:: Queryinterface](http://go.microsoft.com/fwlink/?LinkID=144867) 특정 인터페이스 포인터를 얻으려고 시도 하는 COM 개체의 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1326">The <xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A> method exposes the [IUnknown::QueryInterface](http://go.microsoft.com/fwlink/?LinkID=144867) method of a COM object, which attempts to obtain a specific interface pointer.</span></span> <span data-ttu-id="f799e-1327">사용 하 여 `QueryInterface` COM 개체는 관리 코드에서 캐스트 작업 수행과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1327">Using `QueryInterface` on a COM object is the same as performing a cast operation in managed code.</span></span> <span data-ttu-id="f799e-1328">이 방법으로 개체를 호출 하면의 참조 횟수를 반환 되기 전에 포인터에 인터페이스 포인터 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1328">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="f799e-1329">항상 사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> 포인터 작업이 완료 되 면 참조 횟수를 감소 시키기 위해.</span><span class="sxs-lookup"><span data-stu-id="f799e-1329">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="f799e-1330">가져올 수는 <xref:System.IntPtr> 를 나타내는 값을 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 인터페이스 포인터를 호출할 수 있습니다 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, 또는 <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1330">To obtain an <xref:System.IntPtr> value that represents a [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer, you can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1331">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1331">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1332">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1332">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1333">관리되지 않는 메모리에서 싱글바이트를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1333">Reads a single byte from unmanaged memory.</span></span> <span data-ttu-id="f799e-1334">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1334">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1335">읽을 관리되지 않는 메모리의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1335">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="f799e-1336">관리되지 않는 메모리에서 싱글바이트를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1336">Reads a single byte from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1337">관리되지 않는 메모리에서 읽은 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1337">The byte read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1338"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 묵시적된 오프셋이 0에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1338"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> has an implied offset of 0.</span></span> <span data-ttu-id="f799e-1339">이 메서드를 통해 관리 되지 않는 배열 전체를 복사 하지 않아도 관리 되지 않는 C-스타일 바이트 배열와 직접 상호 작용 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1339">This method enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1340">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1340">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1341">관리 되지 않는 메모리 블록을 만듭니다. 하는 관리 되지 않는 메모리를 바이트를 쓰고 해당 바이트를 읽은 관리 되지 않는 메모리에서 다시 고 관리 되지 않는 메모리를 삭제 하는 다음 예제에서는 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1341">The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 <span data-ttu-id="f799e-1342">다음 예제에서는 사용 하는 방법을 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 메서드는 관리 되지 않는 문자 값을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1342">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> method to read the value of an unmanaged character.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="f799e-1343"><paramref name="ptr" />의 형식을 인식할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1343"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="f799e-1344">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1344">-or-</span></span>  
  
 <span data-ttu-id="f799e-1345"><paramref name="ptr" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1345"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-1346">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1346">-or-</span></span>  
  
 <span data-ttu-id="f799e-1347"><paramref name="ptr" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1347"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1348">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1348">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1349">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1349">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1350">읽을 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1350">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1351">읽기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1351">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="f799e-1352">관리되지 않는 메모리의 지정된 오프셋(또는 인덱스) 위치에서 싱글바이트를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1352">Reads a single byte at a given offset (or index) from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1353">관리되지 않는 메모리의 지정된 오프셋 위치에서 읽은 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1353">The byte read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1354"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 직접 관리 되지 않는 배열 전체를 복사 하지 않아도 관리 되지 않는 C-스타일 바이트 배열와의 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1354"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1355">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1355">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1356">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1356">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 <span data-ttu-id="f799e-1357">다음 예제에서는 사용 하는 방법을 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 메서드는 관리 되지 않는 문자 값을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1357">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> method to read the value of an unmanaged character.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1358">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1358">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1359">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1359">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1360">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1360">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As Object, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1361">소스 개체에 대한 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1361">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1362">읽기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1362">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="f799e-1363">관리되지 않는 메모리의 지정된 오프셋(또는 인덱스) 위치에서 싱글바이트를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1363">Reads a single byte at a given offset (or index) from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1364">관리되지 않는 메모리의 지정된 오프셋 위치에서 읽은 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1364">The byte read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1365"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 직접 관리 되지 않는 배열 전체를 복사 하지 않아도 관리 되지 않는 C-스타일 바이트 배열와의 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1365"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1366">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1366">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1367">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1367">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1368"><paramref name="ptr" />이 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 개체인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-1368"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="f799e-1369">이 메서드에는 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1369">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1370">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1370">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1371">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1371">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1372">관리되지 않는 메모리에서 16비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1372">Reads a 16-bit signed integer from unmanaged memory.</span></span> <span data-ttu-id="f799e-1373">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1373">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1374">읽을 관리되지 않는 메모리의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1374">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="f799e-1375">관리되지 않는 메모리에서 16비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1375">Reads a 16-bit signed integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1376">관리되지 않는 메모리에서 읽은 16비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1376">The 16-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1377"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 묵시적된 오프셋이 0에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1377"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> has an implied offset of 0.</span></span> <span data-ttu-id="f799e-1378">이 메서드를 통해 관리 되지 않는 C 스타일의 직접적인 상호 `Int16` 관리 되지 않는 배열 전체를 복사 하지 않아도 배열 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1378">This method enables direct interaction with an unmanaged C-style `Int16` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1379">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1379">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1380">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1380">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 <span data-ttu-id="f799e-1381">다음 예제에서는 사용 하는 방법을 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 관리 되지 않는 값을 읽을 메서드 `short` 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1381">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> method to read the value of an unmanaged `short` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="f799e-1382"><paramref name="ptr" />의 형식을 인식할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1382"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="f799e-1383">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1383">-or-</span></span>  
  
 <span data-ttu-id="f799e-1384"><paramref name="ptr" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1384"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-1385">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1385">-or-</span></span>  
  
 <span data-ttu-id="f799e-1386"><paramref name="ptr" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1386"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1387">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1387">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1388">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1388">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1389">읽을 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1389">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1390">읽기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1390">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="f799e-1391">관리되지 않는 메모리의 지정된 오프셋 위치에서 16비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1391">Reads a 16-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1392">관리되지 않는 메모리의 지정된 오프셋 위치에서 읽은 16비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1392">The 16-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1393"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 직접 관리 되지 않는 16 비트 부호 있는 배열, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1393"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1394">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1394">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1395">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1395">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 <span data-ttu-id="f799e-1396">다음 예제에서는 사용 하는 방법을 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 관리 되지 않는 값을 읽을 메서드 `short` 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1396">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> method to read the value of an unmanaged `short` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1397">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1397">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1398">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1398">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1399">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1399">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As Object, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1400">소스 개체에 대한 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1400">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1401">읽기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1401">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="f799e-1402">관리되지 않는 메모리의 지정된 오프셋 위치에서 16비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1402">Reads a 16-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1403">관리되지 않는 메모리의 지정된 오프셋 위치에서 읽은 16비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1403">The 16-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1404"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 직접 관리 되지 않는 16 비트 부호 있는 배열, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1404"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1405">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1405">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1406">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1406">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1407"><paramref name="ptr" />이 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 개체인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-1407"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="f799e-1408">이 메서드에는 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1408">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1409">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1409">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1410">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1410">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1411">관리되지 않는 메모리에서 32비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1411">Reads a 32-bit signed integer from unmanaged memory.</span></span> <span data-ttu-id="f799e-1412">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1412">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1413">읽을 관리되지 않는 메모리의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1413">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="f799e-1414">관리되지 않는 메모리에서 32비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1414">Reads a 32-bit signed integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1415">관리되지 않는 메모리에서 읽은 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1415">The 32-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1416"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 묵시적된 오프셋이 0에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1416"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> has an implied offset of 0.</span></span> <span data-ttu-id="f799e-1417">이 메서드를 통해 관리 되지 않는 C 스타일의 직접적인 상호 `Int32` 관리 되지 않는 배열 전체를 복사 하지 않아도 배열 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1417">This method enables direct interaction with an unmanaged C-style `Int32` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1418">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1418">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1419">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1419">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 <span data-ttu-id="f799e-1420">다음 예제에서는 사용 하는 방법을 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 관리 되지 않는 값을 읽을 메서드 `int` 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1420">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> method to read the value of an unmanaged `int` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="f799e-1421"><paramref name="ptr" />의 형식을 인식할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1421"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="f799e-1422">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1422">-or-</span></span>  
  
 <span data-ttu-id="f799e-1423"><paramref name="ptr" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1423"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-1424">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1424">-or-</span></span>  
  
 <span data-ttu-id="f799e-1425"><paramref name="ptr" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1425"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1426">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1426">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1427">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1427">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1428">읽을 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1428">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1429">읽기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1429">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="f799e-1430">관리되지 않는 메모리의 지정된 오프셋 위치에서 32비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1430">Reads a 32-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1431">관리되지 않는 메모리에서 읽은 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1431">The 32-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1432"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 직접 관리 되지 않는 32 비트 부호 있는 배열, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1432"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1433">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1433">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1434">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1434">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 <span data-ttu-id="f799e-1435">다음 예제에서는 사용 하는 방법을 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 관리 되지 않는 값을 읽을 메서드 `int` 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1435">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> method to read the value of an unmanaged `int` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1436">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1436">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1437">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1437">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1438">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1438">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As Object, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1439">소스 개체에 대한 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1439">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1440">읽기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1440">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="f799e-1441">관리되지 않는 메모리의 지정된 오프셋 위치에서 32비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1441">Reads a 32-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1442">관리되지 않는 메모리의 지정된 오프셋 위치에서 읽은 32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1442">The 32-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1443"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 직접 관리 되지 않는 32 비트 부호 있는 배열, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1443"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1444">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1444">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1445">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1445">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1446"><paramref name="ptr" />이 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 개체인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-1446"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="f799e-1447">이 메서드에는 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1447">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1448">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1448">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1449">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1449">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1450">관리되지 않는 메모리에서 64비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1450">Reads a 64-bit signed integer from unmanaged memory.</span></span> <span data-ttu-id="f799e-1451">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1451">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1452">읽을 관리되지 않는 메모리의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1452">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="f799e-1453">관리되지 않는 메모리에서 64비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1453">Reads a 64-bit signed integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1454">관리되지 않는 메모리에서 읽은 64비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1454">The 64-bit signed integer read from unmanaged memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1455"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 묵시적된 오프셋이 0에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1455"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> has an implied offset of 0.</span></span> <span data-ttu-id="f799e-1456">이 메서드를 통해 관리 되지 않는 C 스타일의 직접적인 상호 `Int64` 관리 되지 않는 배열 전체를 복사 하지 않아도 배열 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1456">This method enables direct interaction with an unmanaged C-style `Int64` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1457">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1457">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1458">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1458">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 <span data-ttu-id="f799e-1459">다음 예제에서는 사용 하는 방법을 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 관리 되지 않는 값을 읽을 메서드 `__int64` 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1459">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> method to read the value of an unmanaged `__int64` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="f799e-1460"><paramref name="ptr" />의 형식을 인식할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1460"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="f799e-1461">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1461">-or-</span></span>  
  
 <span data-ttu-id="f799e-1462"><paramref name="ptr" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1462"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-1463">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1463">-or-</span></span>  
  
 <span data-ttu-id="f799e-1464"><paramref name="ptr" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1464"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1465">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1465">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1466">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1466">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1467">읽을 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1467">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1468">읽기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1468">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="f799e-1469">관리되지 않는 메모리의 지정된 오프셋 위치에서 64비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1469">Reads a 64-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1470">관리되지 않는 메모리의 지정된 오프셋 위치에서 읽은 64비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1470">The 64-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1471"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 직접 관리 되지 않는 64 비트 부호 있는 배열, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1471"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1472">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1472">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1473">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1473">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 <span data-ttu-id="f799e-1474">다음 예제에서는 사용 하는 방법을 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 관리 되지 않는 값을 읽을 메서드 `__int64` 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1474">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> method to read the value of an unmanaged `__int64` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1475">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1475">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1476">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1476">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1477">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1477">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As Object, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1478">소스 개체에 대한 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1478">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1479">읽기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1479">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="f799e-1480">관리되지 않는 메모리의 지정된 오프셋 위치에서 64비트 부호 있는 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1480">Reads a 64-bit signed integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1481">관리되지 않는 메모리의 지정된 오프셋 위치에서 읽은 64비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1481">The 64-bit signed integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1482"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 직접 관리 되지 않는 64 비트 부호 있는 배열, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1482"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1483">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1483">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1484">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1484">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1485"><paramref name="ptr" />이 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 개체인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-1485"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="f799e-1486">이 메서드에는 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1486">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1487">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1487">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1488">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1488">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1489">관리되지 않는 메모리에서 프로세서의 기본 크기로 지정된 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1489">Reads a processor native sized integer from unmanaged memory.</span></span> <span data-ttu-id="f799e-1490">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1490">Reading from unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1491">읽을 관리되지 않는 메모리의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1491">The address in unmanaged memory from which to read.</span></span></param>
        <summary><span data-ttu-id="f799e-1492">관리되지 않는 메모리에서 프로세서의 기본 크기로 지정된 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1492">Reads a processor native-sized integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1493">관리되지 않는 메모리에서 읽은 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1493">The integer read from unmanaged memory.</span></span> <span data-ttu-id="f799e-1494">32비트 컴퓨터에서는 32비트 정수가 반환되고 64비트 컴퓨터에서는 64비트 정수가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1494">A 32 bit integer is returned on 32 bit machines and a 64 bit integer is returned on 64 bit machines.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1495"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 묵시적된 오프셋이 0에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1495"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> has an implied offset of 0.</span></span> <span data-ttu-id="f799e-1496">이 메서드를 통해 관리 되지 않는 C 스타일의 직접적인 상호 `IntPtr` 관리 되지 않는 배열 전체를 복사 하지 않아도 배열 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1496">This method enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1497">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1497">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1498">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1498">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="f799e-1499"><paramref name="ptr" />의 형식을 인식할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1499"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="f799e-1500">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1500">-or-</span></span>  
  
 <span data-ttu-id="f799e-1501"><paramref name="ptr" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1501"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-1502">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1502">-or-</span></span>  
  
 <span data-ttu-id="f799e-1503"><paramref name="ptr" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1503"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1504">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1504">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1505">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1505">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1506">읽을 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1506">The base address in unmanaged memory from which to read.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1507">읽기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1507">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="f799e-1508">관리되지 않는 메모리의 지정된 오프셋 위치에서 프로세서의 기본 크기로 지정된 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1508">Reads a processor native sized integer at a given offset from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1509">관리되지 않는 메모리의 지정된 오프셋 위치에서 읽은 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1509">The integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1510"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 직접 관리 되지 않는 C 스타일의 상호 작용을 수 있으므로 `IntPtr` 관리 되지 않는 배열 전체를 복사 하지 않아도 배열 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1510"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1511">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1511">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1512">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1512">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1513">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1513">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1514">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1514">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1515">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1515">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As Object, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1516">소스 개체에 대한 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1516">The base address in unmanaged memory of the source object.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1517">읽기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1517">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span></span></param>
        <summary><span data-ttu-id="f799e-1518">관리되지 않는 메모리에서 프로세서의 기본 크기로 지정된 정수를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1518">Reads a processor native sized integer from unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1519">관리되지 않는 메모리의 지정된 오프셋 위치에서 읽은 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1519">The integer read from unmanaged memory at the given offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1520"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 직접 관리 되지 않는 C 스타일의 상호 작용을 수 있으므로 `IntPtr` 관리 되지 않는 배열 전체를 복사 하지 않아도 배열 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 읽기 전에 별도 관리 되는 배열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1520"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="f799e-1521">정렬되지 않은 메모리 위치에서 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1521">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1522">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1522">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1523"><paramref name="ptr" />이 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 개체인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-1523"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="f799e-1524">이 메서드에는 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1524">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1525">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1525">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1526">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1526">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocCoTaskMem (IntPtr pv, int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocCoTaskMem(native int pv, int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocCoTaskMem (pv As IntPtr, cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pv"><span data-ttu-id="f799e-1527"><see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />을 사용하여 할당된 메모리에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1527">A pointer to memory allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span></span></param>
        <param name="cb"><span data-ttu-id="f799e-1528">할당된 블록의 새 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1528">The new size of the allocated block.</span></span></param>
        <summary><span data-ttu-id="f799e-1529"><see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />을 사용하여 이전에 할당된 메모리 블록 크기를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1529">Resizes a block of memory previously allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span></span></summary>
        <returns><span data-ttu-id="f799e-1530">다시 할당된 메모리 블록 주소를 나타내는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1530">An integer representing the address of the reallocated block of memory.</span></span> <span data-ttu-id="f799e-1531">이 메모리는 <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />을 사용하여 해제되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1531">This memory must be released with <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1532"><xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A> 두 개의 메모리 재할당 메서드 중 하나는 <xref:System.Runtime.InteropServices.Marshal> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1532"><xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A> is one of two memory reallocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="f799e-1533">(<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> 다른 됩니다.) 다시 할당 된 메모리 내용이의 시작 부분에서 원본 콘텐츠와;와 같습니다. 그러나 전체 메모리 블록은 다른 위치에 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1533">(<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> is the other.) The beginning of the reallocated memory content is the same as the original content; however, the entire memory block can be in a different location.</span></span> <span data-ttu-id="f799e-1534">이 메서드는 COM 노출 [CoTaskMemRealloc](http://go.microsoft.com/fwlink/?LinkId=148778) COM 작업 메모리 할당자 라고 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1534">This method exposes the COM [CoTaskMemRealloc](http://go.microsoft.com/fwlink/?LinkId=148778) function, which is referred to as the COM task memory allocator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1535">메모리가 부족하여 요청을 만족시킬 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1535">There is insufficient memory to satisfy the request.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1536">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1536">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1537">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1537">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocHGlobal (IntPtr pv, IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocHGlobal(native int pv, native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocHGlobal (pv As IntPtr, cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pv"><span data-ttu-id="f799e-1538"><see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />을 사용하여 할당된 메모리에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1538">A pointer to memory allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span></span></param>
        <param name="cb"><span data-ttu-id="f799e-1539">할당된 블록의 새 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1539">The new size of the allocated block.</span></span> <span data-ttu-id="f799e-1540">이것은 포인터가 아니라 요청하는 바이트 수로, 형식 <see cref="T:System.IntPtr" />로 캐스팅합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1540">This is not a pointer; it is the byte count you are requesting, cast to type <see cref="T:System.IntPtr" />.</span></span> <span data-ttu-id="f799e-1541">포인터를 전달하면 크기로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1541">If you pass a pointer, it is treated as a size.</span></span></param>
        <summary><span data-ttu-id="f799e-1542"><see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />을 사용하여 이전에 할당된 메모리 블록 크기를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1542">Resizes a block of memory previously allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span></span></summary>
        <returns><span data-ttu-id="f799e-1543">다시 할당된 메모리에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1543">A pointer to the reallocated memory.</span></span> <span data-ttu-id="f799e-1544">이 메모리는 <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />을 사용하여 해제되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1544">This memory must be released using <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1545"><xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> API 메서드는 두 개의 메모리 재할당 중 하나는 <xref:System.Runtime.InteropServices.Marshal> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1545"><xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> is one of two memory reallocation API methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="f799e-1546">(<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType> 다른 됩니다.)</span><span class="sxs-lookup"><span data-stu-id="f799e-1546">(<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType> is the other.)</span></span>  
  
 <span data-ttu-id="f799e-1547">이 메서드는 Win32 노출 [GlobalReAlloc](http://go.microsoft.com/fwlink/?LinkId=148780) Kernel32.dll에서 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1547">This method exposes the Win32 [GlobalReAlloc](http://go.microsoft.com/fwlink/?LinkId=148780) function from Kernel32.dll.</span></span> <span data-ttu-id="f799e-1548">반환된 된 포인터 원본과에서 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1548">The returned pointer can differ from the original.</span></span> <span data-ttu-id="f799e-1549">다른 경우 새 블록에 할당 하면 원래 메모리 블록이의 내용을 복사 된 및 할당 하면 원래 메모리 블록이 해제 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1549">If it is different, the contents of the original memory block have been copied to the new block, and the original memory block has been freed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1550">메모리가 부족하여 요청을 만족시킬 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1550">There is insufficient memory to satisfy the request.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1551">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1551">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1552">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1552">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public static int Release (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Release(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Release (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Release(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk"><span data-ttu-id="f799e-1553">해제할 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1553">The interface to release.</span></span></param>
        <summary><span data-ttu-id="f799e-1554">지정된 인터페이스의 참조 횟수를 감소시킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1554">Decrements the reference count on the specified interface.</span></span></summary>
        <returns><span data-ttu-id="f799e-1555"><paramref name="pUnk" /> 매개 변수에서 지정하는 인터페이스에 대한 참조 횟수의 새 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1555">The new value of the reference count on the interface specified by the <paramref name="pUnk" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1556">공용 언어 런타임에서이 메서드를 직접 사용 하는 불필요 한 하므로 사용자에 대 한 COM 개체의 참조 횟수를 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1556">The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</span></span> <span data-ttu-id="f799e-1557">이 값을 사용 하 여 테스트용 으로만 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1557">Use this value only for testing purposes.</span></span> <span data-ttu-id="f799e-1558">드문 경우 이지만 사용자 지정 마샬러 테스트와 같이 필요할 수 있습니다 것 개체의 수명을 직접 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1558">In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</span></span> <span data-ttu-id="f799e-1559">호출 하는 프로그램만 <xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType> 호출 해야 <xref:System.Runtime.InteropServices.Marshal.Release%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1559">Only programs that call <xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType> should call <xref:System.Runtime.InteropServices.Marshal.Release%2A>.</span></span> <span data-ttu-id="f799e-1560">호출 <xref:System.Runtime.InteropServices.Marshal.Release%2A> 참조 횟수에 도달 하면 0이 정의 되지 않은 동작을 유발 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1560">Calling <xref:System.Runtime.InteropServices.Marshal.Release%2A> after the reference count has reached zero causes undefined behavior.</span></span>  
  
 <span data-ttu-id="f799e-1561">호출할 수 있습니다 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, 또는 <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> 얻으려고는 <xref:System.IntPtr> 를 나타내는 값은 [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) 인터페이스 포인터를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1561">You can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to obtain an <xref:System.IntPtr> value that represents a [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer to release.</span></span> <span data-ttu-id="f799e-1562">이러한 메서드를 사용할 수도 및 <xref:System.Runtime.InteropServices.Marshal.Release%2A> 관리 되는 개체가 나타내는 COM 인터페이스를 해제 하기 위해 관리 되는 개체에서 메서드 [COM 호출 가능 래퍼](~/docs/framework/interop/com-callable-wrapper.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1562">You can also use these methods and the <xref:System.Runtime.InteropServices.Marshal.Release%2A> method on managed objects to release the COM interfaces represented by the managed object's [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1563">다음 예제에서는 검색 하는 방법을 `IUnknown` 사용 하 여 관리 되는 개체에 대 한 인터페이스는 <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1563">The following example demonstrates how to retrieve an `IUnknown` interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> method.</span></span> <span data-ttu-id="f799e-1564">다음 예제에서는 호출 하 여 인터페이스 포인터를 해제는 <xref:System.Runtime.InteropServices.Marshal.Release%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1564">The example then releases the interface pointer by calling the <xref:System.Runtime.InteropServices.Marshal.Release%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1565">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1565">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1566">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1566">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseComObject">
      <MemberSignature Language="C#" Value="public static int ReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReleaseComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f799e-1567">해제할 COM 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1567">The COM object to release.</span></span></param>
        <summary><span data-ttu-id="f799e-1568">지정된 COM 개체와 연결된 지정된 [RCW(런타임 호출 가능 래퍼)](~/docs/framework/interop/runtime-callable-wrapper.md)의 참조 횟수를 감소시킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1568">Decrements the reference count of the [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) associated with the specified COM object.</span></span></summary>
        <returns><span data-ttu-id="f799e-1569"><paramref name="o" />와 연결된 RCW 참조 횟수의 새 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1569">The new value of the reference count of the RCW associated with <paramref name="o" />.</span></span> <span data-ttu-id="f799e-1570">RCW는 참조를 호출하는 관리되는 클라이언트의 수에 관계없이 래핑된 COM 개체에 대한 참조를 하나만 유지하므로 일반적으로 이 값은 0이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1570">This value is typically zero since the RCW keeps just one reference to the wrapped COM object regardless of the number of managed clients calling it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1571">이 메서드는 명시적으로 제어 하는 관리 코드에서 사용 되는 COM 개체의 수명을 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1571">This method is used to explicitly control the lifetime of a COM object used from managed code.</span></span> <span data-ttu-id="f799e-1572">적절 하 게에서 하거나 특정 순서에 따라 개체를 해제 해야 하는 경우 리소스에 대 한 참조를 보유 하는 기본 COM 개체를 해제 합니다.이 메서드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1572">You should use this method to free the underlying COM object that holds references to resources in a timely manner or when objects must be freed in a specific order.</span></span>  
  
 <span data-ttu-id="f799e-1573">COM 인터페이스 포인터가 공용 언어 런타임 (CLR)를 입력할 때마다 RCW에 래핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1573">Every time a COM interface pointer enters the common language runtime (CLR), it is wrapped in an RCW.</span></span>  
  
 <span data-ttu-id="f799e-1574">RCW에 COM 인터페이스 포인터 매핑될 때마다 증가 하는 참조 횟수가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1574">The RCW has a reference count that is incremented every time a COM interface pointer is mapped to it.</span></span> <span data-ttu-id="f799e-1575"><xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 메서드 RCW의 참조 횟수를 감소 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1575">The <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method decrements the reference count of an RCW.</span></span> <span data-ttu-id="f799e-1576">참조 횟수가 0에 도달 하면 런타임에서 관리 되지 않는 COM 개체에서 모든 참조를 해제 하 고 throw 한 <xref:System.NullReferenceException?displayProperty=nameWithType> 개체를 더 이상 사용 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1576">When the reference count reaches zero, the runtime releases all its references on the unmanaged COM object, and throws a <xref:System.NullReferenceException?displayProperty=nameWithType> if you attempt to use the object further.</span></span> <span data-ttu-id="f799e-1577">될 때마다 증가 하 고 호출 래퍼에 대 한 참조 개수는 같은 COM 인터페이스를 전달 하면 한 번 이상 비관리에서 관리 코드에 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 는 남은 참조 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1577">If the same COM interface is passed more than one time from unmanaged to managed code, the reference count on the wrapper is incremented every time, and calling <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> returns the number of remaining references.</span></span>  
  
 <span data-ttu-id="f799e-1578">이 메서드를 사용 하면 정확 하 게 하려는 경우에 수행 되도록 RCW 참조 개수 릴리스를 강제로 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1578">This method enables you to force an RCW reference count release so that it occurs precisely when you want it to.</span></span> <span data-ttu-id="f799e-1579">그러나 잘못 사용 하면 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 하면 응용 프로그램이 실패 또는 액세스 위반이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1579">However, improper use of <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> may cause your application to fail, or may cause an access violation.</span></span>  
  
 <span data-ttu-id="f799e-1580">COM 구성 요소를 나타내는 RCW에 응용 프로그램 도메인에서 관리 되는 코드는 유지 하는 시나리오를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1580">Consider a scenario in which managed code in an application domain is holding onto an RCW that represents a COM component.</span></span> <span data-ttu-id="f799e-1581">호출 하는 경우는 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> RCW에서 관리 코드의 RCW에 액세스할 수 없습니다 메서드와 발생 한 <xref:System.Runtime.InteropServices.InvalidComObjectException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1581">If you call the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method on the RCW, the managed code will be unable to access the RCW and will raise an <xref:System.Runtime.InteropServices.InvalidComObjectException> exception.</span></span>  
  
 <span data-ttu-id="f799e-1582">더 심각한 오류 RCW를 놓을 때 RCW에 대 한 호출 실행 하는 경우에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1582">A more serious error may occur if a call to the RCW is executing when the RCW is released.</span></span> <span data-ttu-id="f799e-1583">이 경우 전화 통화를 걸기 스레드의 액세스 위반이 발생 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1583">In this case, there is a good chance that the thread making the call will cause an access violation.</span></span> <span data-ttu-id="f799e-1584">그러나 프로세스 메모리 손상 될 수 및 디버그 하기 매우 어려운 이유로 실패할 때까지 실행 하는 프로세스를 계속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1584">However, process memory may become corrupted, and the process may continue to run until it fails for reasons that are very difficult to debug.</span></span>  
  
 <span data-ttu-id="f799e-1585">사용 되는 COM 구성 요소를 단일 다음과 같은 이유로 때 이러한 위험 더 복잡해 집니다: COM을 호출 하 여 COM 구성 요소를 활성화 하는 CLR [CoCreateInstance](http://go.microsoft.com/fwlink/?LinkID=142894) 동일한 인터페이스 포인터를 반환 하는 함수를 모든 시간 singleton COM 구성 요소에 대해 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1585">This risk is compounded when the COM component that is being used is a singleton, for the following reason: The CLR activates COM components by calling the COM [CoCreateInstance](http://go.microsoft.com/fwlink/?LinkID=142894) function, which returns the same interface pointer every time it is called for singleton COM components.</span></span> <span data-ttu-id="f799e-1586">따라서 응용 프로그램 도메인에서 관리 되는 코드의 개별적이 고 독립적인 부분 수 수를 사용 하 여 동일한 RCW는 단일 COM 구성 요소에 대 한 경우 어느 한 호출은 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> COM 구성 요소에서 메서드를 다른 손상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1586">Thus, separate and independent pieces of managed code in an application domain can be using the same RCW for a singleton COM component, and if either one calls the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method on the COM component, the other will be broken.</span></span>  
  
 <span data-ttu-id="f799e-1587">따라서 사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 반드시 필요한 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1587">Therefore, use the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> only if it is absolutely required.</span></span> <span data-ttu-id="f799e-1588">COM 구성 요소 결정된 된 시간에 해제 되도록 하려면이 메서드를 호출 하려는 경우를 사용해는 <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1588">If you want to call this method to ensure that a COM component is released at a determined time, consider using the <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method instead.</span></span> <span data-ttu-id="f799e-1589"><xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> CLR 다시 전환 하는 횟수에 관계 없이 기본 COM 구성 요소를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1589"><xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> will release the underlying COM component regardless of how many times it has re-entered the CLR.</span></span> <span data-ttu-id="f799e-1590">RCW의 내부 참조 횟수는 COM 구성 요소는 CLR에 재진입 될 때마다 1 씩 증가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1590">The internal reference count of the RCW is incremented by one every time the COM component re-enters the CLR.</span></span> <span data-ttu-id="f799e-1591">따라서 호출할 수 있습니다는 <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> 값이 반환 될 때까지 루프에는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1591">Therefore, you could call the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method in a loop until the value returned is zero.</span></span> <span data-ttu-id="f799e-1592">이 경우에 동일한 결과를 <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1592">This achieves the same result as the <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1593"><paramref name="o" />가 올바른 개체 범위가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1593"><paramref name="o" /> is not a valid COM object.</span></span></exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="f799e-1594"><paramref name="o" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1594"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1595">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1595">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1596">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1596">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseThreadCache">
      <MemberSignature Language="C#" Value="public static void ReleaseThreadCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReleaseThreadCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReleaseThreadCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReleaseThreadCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f799e-1597">스레드 캐시를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1597">Releases the thread cache.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1598">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1598">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1599">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1599">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToBSTR (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToBSTR(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToBSTR (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToBSTR(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1600">복사할 관리되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1600">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-1601">관리되지 않는 [이진 문자열(BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)을 할당하고 관리되는 <see cref="T:System.Security.SecureString" /> 개체의 내용을 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1601">Allocates an unmanaged [binary string (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) and copies the contents of a managed <see cref="T:System.Security.SecureString" /> object into it.</span></span></summary>
        <returns><span data-ttu-id="f799e-1602">관리되지 않는 메모리에서 <paramref name="s" /> 매개 변수가 복사된 주소 또는 null 개체가 제공된 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1602">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1603"><xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> 경우 혼합 코드와 비관리 코드 또는 메서드는 사용자 지정 마샬링 하는 데 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1603">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1604">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 해제는 `BSTR` 호출 하 여 완료 되 면는 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1604">Because this method allocates the unmanaged memory required for a string, always free the `BSTR` when finished by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1605"><paramref name="s" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1605">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f799e-1606">현재 컴퓨터에서 Windows 2000 서비스 팩 3 이상을 실행하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1606">The current computer is not running Windows 2000 Service Pack 3 or later.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1607">사용 가능한 메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1607">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1608">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1608">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1609">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1609">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <block subset="none" type="usage">
          <para><span data-ttu-id="f799e-1610">이 방법은 이상을 Windows 2000 서비스 팩 3을 실행 하는 컴퓨터에 대해서만 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1610">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemAnsi(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1611">복사할 관리되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1611">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-1612">관리되는 <see cref="T:System.Security.SecureString" /> 개체의 내용을 관리되지 않는 COM 작업 할당자에서 할당된 메모리 블록으로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1612">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="f799e-1613">관리되지 않는 메모리에서 <paramref name="s" /> 매개 변수가 복사된 주소 또는 null 개체가 제공된 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1613">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1614"><xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> 경우 혼합 코드와 비관리 코드 또는 메서드는 사용자 지정 마샬링 하는 데 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1614">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1615">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 메모리 해제를 호출 하 여 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1615">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>.</span></span> <span data-ttu-id="f799e-1616">문자열의 문자는 ANSI 문자로 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1616">The characters of the string are copied as ANSI characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1617">다음 예제에서는 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> 마샬링할의 내용을 해독 하는 메서드는 <xref:System.Security.SecureString> 관리 되지 않는 메모리 블록에는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1617">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="f799e-1618">다음 사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> 메서드를 비우고 관리 되지 않는 블록을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1618">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1619"><paramref name="s" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1619">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f799e-1620">현재 컴퓨터에서 Windows 2000 서비스 팩 3 이상을 실행하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1620">The current computer is not running Windows 2000 Service Pack 3 or later.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1621">사용 가능한 메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1621">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1622">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1622">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1623">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1623">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <block subset="none" type="usage">
          <para><span data-ttu-id="f799e-1624">이 방법은 이상을 Windows 2000 서비스 팩 3을 실행 하는 컴퓨터에 대해서만 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1624">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemUnicode(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1625">복사할 관리되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1625">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-1626">관리되는 <see cref="T:System.Security.SecureString" /> 개체의 내용을 관리되지 않는 COM 작업 할당자에서 할당된 메모리 블록으로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1626">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="f799e-1627">관리되지 않는 메모리에서 <paramref name="s" /> 매개 변수가 복사된 주소 또는 null 개체가 제공된 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1627">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1628"><xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> 경우 혼합 코드와 비관리 코드 또는 메서드는 사용자 지정 마샬링 하는 데 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1628">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1629">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 메모리 해제를 호출 하 여는 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1629">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method.</span></span> <span data-ttu-id="f799e-1630">문자열의 문자는 유니코드 문자로 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1630">The characters of the string are copied as Unicode characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1631">다음 예제에서는 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> 마샬링할의 내용을 해독 하는 메서드는 <xref:System.Security.SecureString> 관리 되지 않는 메모리 블록에는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1631">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="f799e-1632">다음 사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> 메서드를 비우고 관리 되지 않는 블록을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1632">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1633"><paramref name="s" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1633">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f799e-1634">현재 컴퓨터에서 Windows 2000 서비스 팩 3 이상을 실행하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1634">The current computer is not running Windows 2000 Service Pack 3 or later.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1635">사용 가능한 메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1635">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1636">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1636">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1637">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1637">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <block subset="none" type="usage">
          <para><span data-ttu-id="f799e-1638">이 방법은 이상을 Windows 2000 서비스 팩 3을 실행 하는 컴퓨터에 대해서만 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1638">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocAnsi(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1639">복사할 관리되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1639">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-1640">복사할 때 ANSI 형식으로 변환하여 관리되는 <see cref="T:System.Security.SecureString" />의 내용을 관리되지 않는 메모리로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1640">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> into unmanaged memory, converting into ANSI format as it copies.</span></span></summary>
        <returns><span data-ttu-id="f799e-1641">관리되지 않는 메모리에서 <paramref name="s" /> 매개 변수가 복사된 주소이거나 null 개체가 제공된 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1641">The address, in unmanaged memory, to where the <paramref name="s" /> parameter was copied, or 0 if a null object was supplied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1642"><xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> 경우 혼합 코드와 비관리 코드 또는 메서드는 사용자 지정 마샬링 하는 데 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1642">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1643">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 메모리 해제를 호출 하 여는 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1643">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1644">다음 예제에서는 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> 마샬링할의 내용을 해독 하는 메서드는 <xref:System.Security.SecureString> 관리 되지 않는 메모리 블록에는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1644">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="f799e-1645">다음 사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> 메서드를 비우고 관리 되지 않는 블록을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1645">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1646"><paramref name="s" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1646">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f799e-1647">현재 컴퓨터에서 Windows 2000 서비스 팩 3 이상을 실행하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1647">The current computer is not running Windows 2000 Service Pack 3 or later.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1648">사용 가능한 메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1648">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1649">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1649">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1650">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1650">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <block subset="none" type="usage">
          <para><span data-ttu-id="f799e-1651">이 방법은 이상을 Windows 2000 서비스 팩 3을 실행 하는 컴퓨터에 대해서만 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1651">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocUnicode(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1652">복사할 관리되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1652">The managed object to copy.</span></span></param>
        <summary><span data-ttu-id="f799e-1653">관리되는 <see cref="T:System.Security.SecureString" /> 개체의 콘텐츠를 관리되지 않는 메모리로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1653">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object into unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1654">관리되지 않는 메모리에서 <paramref name="s" />가 복사된 주소이거나 <paramref name="s" />가 길이가 0인 <see cref="T:System.Security.SecureString" /> 개체인 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1654">The address, in unmanaged memory, where <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is a <see cref="T:System.Security.SecureString" /> object whose length is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1655"><xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> 메서드는 코드와 비관리 코드 함께 때 사용자 지정 마샬링 하거나 사용 하기 위해 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1655">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1656">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 메모리 해제를 호출 하 여는 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1656">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1657">다음 예제에서는 사용 하는 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> 관리 되지 않는 메서드 `LogonUser` 가장을 수행 하는 함수는 <xref:System.Security.SecureString> 클래스.</span><span class="sxs-lookup"><span data-stu-id="f799e-1657">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method with the unmanaged `LogonUser` function to perform impersonation with the <xref:System.Security.SecureString> class.</span></span> <span data-ttu-id="f799e-1658">이 예제에서는 다음 사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> 메서드를 비우고 관리 되지 않는 문자열 파일에 대 한 참조를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1658">The example then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method to zero out and free the unmanaged string reference.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1659"><paramref name="s" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1659">The <paramref name="s" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f799e-1660">현재 컴퓨터에서 Windows 2000 서비스 팩 3 이상을 실행하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1660">The current computer is not running Windows 2000 Service Pack 3 or later.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1661">사용 가능한 메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1661">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1662">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1662">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1663">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1663">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <block subset="none" type="usage">
          <para><span data-ttu-id="f799e-1664">이 방법은 이상을 Windows 2000 서비스 팩 3을 실행 하는 컴퓨터에 대해서만 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1664">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetComObjectData">
      <MemberSignature Language="C#" Value="public static bool SetComObjectData (object obj, object key, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetComObjectData(object obj, object key, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetComObjectData (obj As Object, key As Object, data As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetComObjectData(System::Object ^ obj, System::Object ^ key, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="f799e-1665">데이터를 저장할 COM 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1665">The COM object in which to store the data.</span></span></param>
        <param name="key"><span data-ttu-id="f799e-1666">데이터를 저장할 COM 개체의 내부 해시 테이블에 있는 키입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1666">The key in the internal hash table of the COM object in which to store the data.</span></span></param>
        <param name="data"><span data-ttu-id="f799e-1667">설정할 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1667">The data to set.</span></span></param>
        <summary><span data-ttu-id="f799e-1668">지정된 COM 개체에서 지정된 키가 참조하는 데이터를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1668">Sets data referenced by the specified key in the specified COM object.</span></span></summary>
        <returns>
          <span data-ttu-id="f799e-1669">데이터가 성공적으로 설정되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1669"><see langword="true" /> if the data was set successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1670">모든 COM 개체에 래핑된는 [런타임 호출 가능 래퍼](~/docs/framework/interop/runtime-callable-wrapper.md) RCW ()는 연결 된 해시 테이블에 있는 <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A> 데이터를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1670">All COM objects wrapped in a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) have an associated hash table, to which <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A> adds data.</span></span> <span data-ttu-id="f799e-1671"><xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType> 해시 테이블에서 데이터를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1671"><xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType> retrieves data from the hash table.</span></span> <span data-ttu-id="f799e-1672">코드에서 두 방법 중 하나를 호출을 수행할 필요는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1672">You should never have to call either method from your code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f799e-1673"><paramref name="obj" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1673"><paramref name="obj" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-1674">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1674">-or-</span></span>  
  
 <span data-ttu-id="f799e-1675"><paramref name="key" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1675"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1676"><paramref name="obj" />가 COM 개체가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1676"><paramref name="obj" /> is not a COM object.</span></span>  
  
 <span data-ttu-id="f799e-1677">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1677">-or-</span></span>  
  
 <span data-ttu-id="f799e-1678"><paramref name="obj" />가 [!INCLUDE[wrt](~/includes/wrt-md.md)] 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1678"><paramref name="obj" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1679">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1679">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1680">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1680">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SizeOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1681">클래스의 관리되지 않는 크기(바이트)를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1681">Returns the unmanaged size, in bytes, of a class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (structure As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(System::Object ^ structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="structure"><span data-ttu-id="f799e-1682">크기가 반환되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1682">The object whose size is to be returned.</span></span></param>
        <summary><span data-ttu-id="f799e-1683">개체의 관리되지 않는 크기(바이트)를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1683">Returns the unmanaged size of an object in bytes.</span></span></summary>
        <returns><span data-ttu-id="f799e-1684">비관리 코드에서 지정된 개체의 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1684">The size of the specified object in unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1685">이 메서드는 boxed 값 형식 또는 참조 형식이 될 수 있는 구조체의 인스턴스를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1685">This method accepts an instance of a structure, which can be a reference type or a boxed value type.</span></span> <span data-ttu-id="f799e-1686">레이아웃은 순차적 또는 명시적 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1686">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="f799e-1687">반환 되는 크기에는 관리 되지 않는 개체의 크기가입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1687">The size returned is the size of the unmanaged object.</span></span> <span data-ttu-id="f799e-1688">개체의 관리 되지 않는 및 관리 되는 크기 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1688">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="f799e-1689">문자 형식의 크기는 영향을 받는 <xref:System.Runtime.InteropServices.CharSet> 해당 클래스에 적용 되는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1689">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 <span data-ttu-id="f799e-1690">사용할 수는 <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> 메서드를 사용 하 여 할당 관리 되지 않는 메모리 양을 결정 하는 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 및 <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1690">You can use the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method to determine how much unmanaged memory to allocate using the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> and <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1691">다음 예제에서는 관리 되는 구조를 만들고, 관리 되지 않는 메모리에 전송 되 고 관리 되는 메모리에 다시 전송 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1691">The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory.</span></span> <span data-ttu-id="f799e-1692">사용 하 여이 예제는 <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> 메서드를 할당할 관리 되지 않는 메모리 양을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1692">This example uses the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method to determine how much unmanaged memory to allocate.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1693"><paramref name="structure" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1693">The <paramref name="structure" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><span data-ttu-id="f799e-1694">크기가 반환되는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1694">The type whose size is to be returned.</span></span></param>
        <summary><span data-ttu-id="f799e-1695">관리되지 않는 형식의 크기(바이트)를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1695">Returns the size of an unmanaged type in bytes.</span></span></summary>
        <returns><span data-ttu-id="f799e-1696">비관리 코드에서 지정된 형식의 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1696">The size of the specified type in unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1697">구조체가 없는 경우이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1697">You can use this method when you do not have a structure.</span></span> <span data-ttu-id="f799e-1698">레이아웃은 순차적 또는 명시적 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1698">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="f799e-1699">반환 되는 크기에는 관리 되지 않는 형식의 크기가입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1699">The size returned is the size of the unmanaged type.</span></span> <span data-ttu-id="f799e-1700">개체의 관리 되지 않는 및 관리 되는 크기 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1700">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="f799e-1701">문자 형식의 크기는 영향을 받는 <xref:System.Runtime.InteropServices.CharSet> 해당 클래스에 적용 되는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1701">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1702">다음 예제에서는 <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> 메서드를 호출하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1702">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method.</span></span> <span data-ttu-id="f799e-1703">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Runtime.InteropServices.Marshal> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1703">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#3](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#3)]
 [!code-csharp[Marshal#3](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#3)]
 [!code-vb[Marshal#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f799e-1704"><paramref name="t" /> 매개 변수는 제네릭 형식 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1704">The <paramref name="t" /> parameter is a generic type definition.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1705"><paramref name="t" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1705">The <paramref name="t" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-1706">크기가 반환되는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1706">The type whose size is to be returned.</span></span></typeparam>
        <summary><span data-ttu-id="f799e-1707">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-1707">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-1708">관리되지 않는 형식의 크기(바이트)를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1708">Returns the size of an unmanaged type in bytes.</span></span></summary>
        <returns><span data-ttu-id="f799e-1709"><typeparamref name="T" /> 제네릭 형식 매개 변수로 지정된 형식의 크기(바이트 단위)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1709">The size, in bytes, of the type that is specified by the <typeparamref name="T" /> generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1710">구조체가 없는 경우이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1710">You can use this method when you do not have a structure.</span></span> <span data-ttu-id="f799e-1711">레이아웃은 순차적 또는 명시적 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1711">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="f799e-1712">반환 되는 크기에는 관리 되지 않는 형식의 크기가입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1712">The size returned is the size of the unmanaged type.</span></span> <span data-ttu-id="f799e-1713">개체의 관리 되지 않는 및 관리 되는 크기 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1713">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="f799e-1714">문자 형식의 크기는 영향을 받는 <xref:System.Runtime.InteropServices.CharSet> 해당 클래스에 적용 되는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1714">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; (T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;(!!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) (structure As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf(T structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-1715">종류는 <c>구조</c> 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1715">The type of the <c>structure</c> parameter.</span></span></typeparam>
        <param name="structure"><span data-ttu-id="f799e-1716">크기가 반환되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1716">The object whose size is to be returned.</span></span></param>
        <summary><span data-ttu-id="f799e-1717">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-1717">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-1718">지정된 형식의 개체의 관리되지 않은 크기를 반환합니다(바이트 단위).</span><span class="sxs-lookup"><span data-stu-id="f799e-1718">Returns the unmanaged size of an object of a specified type in bytes.</span></span></summary>
        <returns><span data-ttu-id="f799e-1719">비관리 코드에서 지정된 개체의 크기(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1719">The size, in bytes, of the specified object in unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1720">이 메서드는 boxed 값 형식 또는 참조 형식이 될 수 있는 구조체의 인스턴스를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1720">This method accepts an instance of a structure, which can be a reference type or a boxed value type.</span></span> <span data-ttu-id="f799e-1721">레이아웃은 순차적 또는 명시적 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1721">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="f799e-1722">반환 되는 크기에는 관리 되지 않는 개체의 크기가입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1722">The size returned is the size of the unmanaged object.</span></span> <span data-ttu-id="f799e-1723">개체의 관리 되지 않는 및 관리 되는 크기 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1723">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="f799e-1724">문자 형식의 크기는 영향을 받는 <xref:System.Runtime.InteropServices.CharSet> 해당 클래스에 적용 되는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1724">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 <span data-ttu-id="f799e-1725">사용할 수는 <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> 메서드를 사용 하 여 할당 관리 되지 않는 메모리 양을 결정 하는 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> 및 <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1725">You can use the <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> method to determine how much unmanaged memory to allocate by using the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> and <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f799e-1726"><paramref name="structure" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1726">The <paramref name="structure" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr StringToBSTR (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToBSTR(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToBSTR (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToBSTR(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1727">복사할 관리되는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1727">The managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="f799e-1728">[BSTR](https://msdn.microsoft.com/library/ms221069.aspx)을 할당하고 관리되는 <see cref="T:System.String" />의 내용을 그 안에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1728">Allocates a [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) and copies the contents of a managed <see cref="T:System.String" /> into it.</span></span></summary>
        <returns><span data-ttu-id="f799e-1729"><see langword="BSTR" />에 대한 관리되지 않는 포인터이거나 <paramref name="s" />가 null인 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1729">An unmanaged pointer to the <see langword="BSTR" />, or 0 if <paramref name="s" /> is null.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1730"><xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A> 사용자 지정 마샬링에 또는 관리 코드와 비관리 코드를 혼합 하는 경우 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1730"><xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1731">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 해제는 `BSTR` 호출 하 여 완료 되 면 <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1731">Because this method allocates the unmanaged memory required for a string, always free the `BSTR` when finished by calling <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f799e-1732">이 메서드는 제공 <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1732">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1733">사용 가능한 메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1733">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f799e-1734"><paramref name="s" />의 길이가 범위를 벗어난 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1734">The length for <paramref name="s" /> is out of range.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1735">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1735">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1736">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1736">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAnsi(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1737">복사할 관리되는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1737">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="f799e-1738">관리되는 <see cref="T:System.String" />의 내용을 관리되지 않는 COM 작업 할당자에서 할당된 메모리 블록으로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1738">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="f799e-1739">문자열에 할당된 메모리 블록에 대한 포인터를 나타내는 정수이거나 <paramref name="s" />가 <see langword="null" />인 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1739">An integer representing a pointer to the block of memory allocated for the string, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1740"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A> 사용자 지정 마샬링에 또는 관리 코드와 비관리 코드를 혼합 하는 경우 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1740"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1741">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 메모리 해제를 호출 하 여 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1741">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span> <span data-ttu-id="f799e-1742">이 메서드는 제공 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1742">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f799e-1743">문자열의 문자는 ANSI 문자로 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1743">The characters of the string are copied as ANSI characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1744">사용 가능한 메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1744">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f799e-1745"><paramref name="s" /> 매개 변수가 운영 체제에서 허용되는 최대 길이를 초과하는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1745">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1746">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1746">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1747">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1747">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAuto(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1748">복사할 관리되는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1748">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="f799e-1749">관리되는 <see cref="T:System.String" />의 내용을 관리되지 않는 COM 작업 할당자에서 할당된 메모리 블록으로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1749">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="f799e-1750">할당된 메모리 블록이거나 <paramref name="s" />가 <see langword="null" />인 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1750">The allocated memory block, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1751"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A> 관리 및 비관리 코드를 혼합 하는 경우 사용자 지정 마샬링 하거나 사용 하기 위해 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1751"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1752">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 메모리 해제를 호출 하 여 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1752">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span> <span data-ttu-id="f799e-1753">이 메서드는 제공 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1753">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f799e-1754">문자열의 문자 코드가 실행 중인 운영 체제에 따라 ANSI 또는 유니코드 문자로 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1754">The characters of the string are copied as either ANSI or Unicode characters, depending on the operating system where the code is executing.</span></span> <span data-ttu-id="f799e-1755">Windows 98에서는 ANSI 문자로 문자가 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1755">On Windows 98, the characters are copied as ANSI characters.</span></span> <span data-ttu-id="f799e-1756">Windows NT 4.0, Windows 2000, Windows XP 및 Windows Server 2003 제품군에는 문자는 유니코드 문자로 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1756">On Windows NT 4.0, Windows 2000, Windows XP, and the Windows Server 2003 family, the characters are copied as Unicode characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1757">사용 가능한 메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1757">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f799e-1758"><paramref name="s" />의 길이가 범위를 벗어난 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1758">The length for <paramref name="s" /> is out of range.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1759">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1759">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1760">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1760">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUni(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1761">복사할 관리되는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1761">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="f799e-1762">관리되는 <see cref="T:System.String" />의 내용을 관리되지 않는 COM 작업 할당자에서 할당된 메모리 블록으로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1762">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span></span></summary>
        <returns><span data-ttu-id="f799e-1763">문자열에 할당된 메모리 블록에 대한 포인터를 나타내는 정수이거나 s가 <see langword="null" />인 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1763">An integer representing a pointer to the block of memory allocated for the string, or 0 if s is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1764"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A> 관리 및 비관리 코드를 혼합 하는 경우 사용자 지정 마샬링 하거나 사용 하기 위해 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1764"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1765">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 메모리 해제를 호출 하 여 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1765">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f799e-1766">이 메서드는 제공 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1766">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f799e-1767">문자열의 문자는 유니코드 문자로 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1767">The characters of the string are copied as Unicode characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f799e-1768"><paramref name="s" /> 매개 변수가 운영 체제에서 허용되는 최대 길이를 초과하는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1768">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1769">사용 가능한 메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1769">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1770">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1770">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1771">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1771">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUTF8 (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUTF8(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUTF8 (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUTF8(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAnsi(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1772">복사할 관리되는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1772">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="f799e-1773">복사할 때 ANSI 형식으로 변환하여 관리되는 <see cref="T:System.String" />의 내용을 관리되지 않는 메모리로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1773">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory, converting into ANSI format as it copies.</span></span></summary>
        <returns><span data-ttu-id="f799e-1774">관리되지 않는 메모리에서 <paramref name="s" />가 복사된 주소이거나 <paramref name="s" />가 <see langword="null" />인 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1774">The address, in unmanaged memory, to where <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1775"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> 사용자 지정 마샬링에 또는 관리 코드와 비관리 코드를 혼합 하는 경우 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1775"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1776">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 메모리 해제를 호출 하 여 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1776">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="f799e-1777"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> 반대 되는 기능을 제공 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1777"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f799e-1778">이 메서드는 포함 된 null 문자를 복사 하 고 null 종결 문자 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1778">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1779">다음 예제에서는 관리 되는 콘텐츠를 변환 하는 방법을 <xref:System.String> 관리 되지 않는 메모리에 클래스를 한 다음 완료 한 후에 관리 되지 않는 메모리의 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1779">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1780">사용 가능한 메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1780">There is insufficient memory available.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f799e-1781"><paramref name="s" /> 매개 변수가 운영 체제에서 허용되는 최대 길이를 초과하는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1781">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1782">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1782">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1783">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1783">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAuto(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1784">복사할 관리되는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1784">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="f799e-1785">필요할 때 ANSI 형식으로 변환하여 관리되는 <see cref="T:System.String" />의 내용을 관리되지 않는 메모리로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1785">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory, converting into ANSI format if required.</span></span></summary>
        <returns><span data-ttu-id="f799e-1786">관리되지 않는 메모리에서 문자열이 복사된 주소이거나 <paramref name="s" />가 <see langword="null" />인 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1786">The address, in unmanaged memory, to where the string was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1787"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A> 관리 및 비관리 코드를 혼합 하는 경우 사용자 지정 마샬링 하거나 사용 하기 위해 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1787"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1788">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 메모리 해제를 호출 하 여 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1788">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="f799e-1789">이 메서드는 제공 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1789">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f799e-1790">이 메서드는 포함 된 null 문자를 복사 하 고 null 종결 문자 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1790">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1791">다음 예제에서는 관리 되는 콘텐츠를 변환 하는 방법을 <xref:System.String> 관리 되지 않는 메모리에 클래스를 한 다음 완료 한 후에 관리 되지 않는 메모리의 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1791">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAuto#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAuto/CPP/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1792">사용 가능한 메모리가 부족한 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1792">There is insufficient memory available.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1793">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1793">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1794">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1794">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalUni(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-1795">복사할 관리되는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1795">A managed string to be copied.</span></span></param>
        <summary><span data-ttu-id="f799e-1796">관리되는 <see cref="T:System.String" />의 내용을 관리되지 않는 메모리로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1796">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory.</span></span></summary>
        <returns><span data-ttu-id="f799e-1797">관리되지 않는 메모리에서 <paramref name="s" />가 복사된 주소이거나 <paramref name="s" />가 <see langword="null" />인 경우 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1797">The address, in unmanaged memory, to where the <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1798"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A> 관리 및 비관리 코드를 혼합 하는 경우 사용자 지정 마샬링 하거나 사용 하기 위해 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1798"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="f799e-1799">이 메서드는 문자열에 필요한 관리 되지 않는 메모리를 할당 하기 때문에 항상 메모리 해제를 호출 하 여 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1799">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="f799e-1800">이 메서드는 제공 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1800">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f799e-1801">이 메서드는 포함 된 null 문자를 복사 하 고 null 종결 문자 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1801">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f799e-1802">메서드가 충분한 네이티브 힙 메모리를 할당할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1802">The method could not allocate enough native heap memory.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f799e-1803"><paramref name="s" /> 매개 변수가 운영 체제에서 허용되는 최대 길이를 초과하는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1803">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1804">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1804">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1805">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1805">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr">
      <MemberSignature Language="C#" Value="public static void StructureToPtr (object structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr(object structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr (structure As Object, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void StructureToPtr(System::Object ^ structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="structure"><span data-ttu-id="f799e-1806">마샬링될 데이터가 있는 관리되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1806">A managed object that holds the data to be marshaled.</span></span> <span data-ttu-id="f799e-1807">이 개체는 구조체이거나 형식이 지정된 클래스의 인스턴스여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1807">This object must be a structure or an instance of a formatted class.</span></span></param>
        <param name="ptr"><span data-ttu-id="f799e-1808">관리되지 않는 메모리 블록에 대한 포인터로서 이 메서드가 호출되기 전에 할당되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1808">A pointer to an unmanaged block of memory, which must be allocated before this method is called.</span></span></param>
        <param name="fDeleteOld">
          <span data-ttu-id="f799e-1809">이 메서드가 데이터를 복사하기 전에 <c>ptr</c> 매개 변수에 대해 <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> 메서드를 호출하려면 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1809"><see langword="true" /> to call the <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> method on the <c>ptr</c> parameter before this method copies the data.</span></span> <span data-ttu-id="f799e-1810">블록에는 유효한 데이터가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1810">The block must contain valid data.</span></span> <span data-ttu-id="f799e-1811">메모리 블록에 이미 데이터가 포함되어 있을 때 <see langword="false" />를 전달하면 메모리 누수가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1811">Note that passing <see langword="false" /> when the memory block already contains data can lead to a memory leak.</span></span></param>
        <summary><span data-ttu-id="f799e-1812">관리되는 개체의 데이터를 관리되지 않는 메모리 블록으로 마샬링합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1812">Marshals data from a managed object to an unmanaged block of memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1813">경우 `structure` 값 형식이 boxed 하거나 unboxed 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1813">If `structure` is a value type, it can be boxed or unboxed.</span></span> <span data-ttu-id="f799e-1814">Boxed 인 경우 하지 boxed 복사 하기 전에입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1814">If it is boxed, it is unboxed before copying.</span></span>  
  
 <span data-ttu-id="f799e-1815">형식이 지정 된 클래스는 참조 형식으로 레이아웃 지정는 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 하나로 특성 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 또는 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1815">A formatted class is a reference type whose layout is specified by the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute, as either <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f799e-1816"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 내용을 복사 `structure` 미리 할당 된 메모리 블록에 있는 `ptr` 매개 변수를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1816"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> copies the contents of `structure` to the pre-allocated block of memory that the `ptr` parameter points to.</span></span> <span data-ttu-id="f799e-1817">경우 `structure` COM 인터페이스 포인터를 마샬링하는 참조 형식을 포함 (인터페이스, 레이아웃을 이용 하지 않는 클래스 및 <xref:System.Object?displayProperty=nameWithType>), 관리 되는 개체 참조 횟수를 활성 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1817">If `structure` contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <xref:System.Object?displayProperty=nameWithType>), the managed objects are kept alive with reference counts.</span></span> <span data-ttu-id="f799e-1818">다른 모든 참조 형식 (예: 문자열 및 배열) 복사본을 마샬링됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1818">All other reference types (for example, strings and arrays) are marshaled to copies.</span></span> <span data-ttu-id="f799e-1819">이러한 관리 되거나 관리 되지 않는 개체를 해제 하기 위해 호출 해야 합니다는 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType> 메서드 전에 메모리 블록을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1819">To release these managed or unmanaged objects, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType> method before you free the memory block.</span></span>  
  
 <span data-ttu-id="f799e-1820">사용 하는 경우는 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 메모리 블록에는 나중에 다른 인스턴스를 복사 하려면 지정 `true` 에 대 한 `fDeleteOld` 이전 인스턴스에 대 한 참조 형식에 대 한 참조를 제거 하려면를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1820">If you use the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method to copy a different instance to the memory block at a later time, specify `true` for `fDeleteOld` to remove reference counts for reference types in the previous instance.</span></span> <span data-ttu-id="f799e-1821">그렇지 않은 경우 관리 되는 참조 관리 되지 않는 typesand 복사본 유출 효과적으로 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1821">Otherwise, the managed reference typesand unmanaged copies are effectively leaked.</span></span>  
  
 <span data-ttu-id="f799e-1822">사용 하기 위한 전반적인 패턴 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1822">The overall pattern for using <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> is as follows:</span></span>  
  
1.  <span data-ttu-id="f799e-1823">첫 번째 호출에서는 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 메서드 메모리 블록 할당 된 후에, `fDeleteOld` 이어야 합니다 `false`지우려면 내용이 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1823">On the first call to the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method after a memory block has been allocated, `fDeleteOld` must be `false`, because there are no contents to clear.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="f799e-1824">지정 `true` 에 대 한 `fDeleteOld` 블록 유효한 데이터를 포함 하는 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1824">Specify `true` for `fDeleteOld` only if the block contains valid data.</span></span>  
  
2.  <span data-ttu-id="f799e-1825">메모리 블록에 다른 인스턴스를 복사 하 고 참조 형식을 포함 하는 경우 `fDeleteOld` 해야 `true` 무료 이전 내용을 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1825">If you copy a different instance to the memory block, and the object contains reference types, `fDeleteOld` must be `true` to free reference types in the old contents.</span></span>  
  
3.  <span data-ttu-id="f799e-1826">참조 형식을 포함 하는 개체를 호출 해야 합니다는 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> 메서드 전에 메모리 블록을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1826">If the object contains reference types, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> method before you free the memory block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f799e-1827">복사 하는 대신 기존 구조를 고정 하려면 사용 하 여는 <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> 구조에 대 한 고정된 된 핸들을 만들 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1827">To pin an existing structure instead of copying it, use the <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> type to create a pinned handle for the structure.</span></span> <span data-ttu-id="f799e-1828">참조에 고정 하는 방법에 대 한 내용은 [복사 및 고정](~/docs/framework/interop/copying-and-pinning.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1828">For details on how to pin, see [Copying and Pinning](~/docs/framework/interop/copying-and-pinning.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1829">다음 예제에서는 관리 되는 구조를 만들고, 관리 되지 않는 메모리를 사용 하 여 전송 된 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 메서드를 사용 하 여 관리 되는 메모리에 다시 다음 전송은 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1829">The following example creates a managed structure, transfers it to unmanaged memory using the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method, and then transfers it back to managed memory using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1830"><paramref name="structure" />가 형식이 지정된 클래스가 아닌 참조 형식인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1830"><paramref name="structure" /> is a reference type that is not a formatted class.</span></span>  
  
 <span data-ttu-id="f799e-1831">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1831">-or-</span></span>  
  
 <span data-ttu-id="f799e-1832"><paramref name="structure" />은 제네릭 형식(.NET Framework 4.5 및 이전 버전에만 해당)의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1832"><paramref name="structure" /> is an instance of a generic type (in the .NET Framework 4.5 and earlier versions only).</span></span> </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1833">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1833">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1834">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1834">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void StructureToPtr&lt;T&gt; (T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr&lt;T&gt;(!!T structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr(Of T) (structure As T, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-1835">관리되는 개체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1835">The type of the managed object.</span></span></typeparam>
        <param name="structure"><span data-ttu-id="f799e-1836">마샬링될 데이터가 있는 관리되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1836">A managed object that holds the data to be marshaled.</span></span> <span data-ttu-id="f799e-1837">이 개체는 구조체이거나 형식이 지정된 클래스의 인스턴스여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1837">The object must be a structure or an instance of a formatted class.</span></span></param>
        <param name="ptr"><span data-ttu-id="f799e-1838">관리되지 않는 메모리 블록에 대한 포인터로서 이 메서드가 호출되기 전에 할당되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1838">A pointer to an unmanaged block of memory, which must be allocated before this method is called.</span></span></param>
        <param name="fDeleteOld">
          <span data-ttu-id="f799e-1839">이 메서드가 데이터를 복사하기 전에 <c>ptr</c> 매개 변수에 대해 <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /> 메서드를 호출하려면 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1839"><see langword="true" /> to call the <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /> method on the <c>ptr</c> parameter before this method copies the data.</span></span> <span data-ttu-id="f799e-1840">블록에는 유효한 데이터가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1840">The block must contain valid data.</span></span> <span data-ttu-id="f799e-1841">메모리 블록에 이미 데이터가 포함되어 있을 때 <see langword="false" />를 전달하면 메모리 누수가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1841">Note that passing <see langword="false" /> when the memory block already contains data can lead to a memory leak.</span></span></param>
        <summary><span data-ttu-id="f799e-1842">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-1842">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-1843">지정된 형식의 관리되는 개체의 데이터를 관리되지 않는 메모리 블록으로 마샬링합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1843">Marshals data from a managed object of a specified type to an unmanaged block of memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1844">형식이 지정 된 클래스는 참조 형식으로 레이아웃 지정는 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 하나로 특성 <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 또는 <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1844">A formatted class is a reference type whose layout is specified by the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute, as either <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f799e-1845"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> 내용을 복사 `structure` 미리 할당 된 메모리 블록에 있는 `ptr` 매개 변수를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1845"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> copies the contents of `structure` to the pre-allocated block of memory that the `ptr` parameter points to.</span></span> <span data-ttu-id="f799e-1846">경우 `structure` COM 인터페이스 포인터를 마샬링하는 참조 형식을 포함 (인터페이스, 레이아웃을 이용 하지 않는 클래스 및 <xref:System.Object?displayProperty=nameWithType>), 관리 되는 개체 참조 횟수를 활성 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1846">If `structure` contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <xref:System.Object?displayProperty=nameWithType>), the managed objects are kept alive with reference counts.</span></span> <span data-ttu-id="f799e-1847">다른 모든 참조 형식 (예: 문자열 및 배열) 복사본을 마샬링됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1847">All other reference types (for example, strings and arrays) are marshaled to copies.</span></span> <span data-ttu-id="f799e-1848">이러한 관리 되거나 관리 되지 않는 개체를 해제 하기 위해 호출 해야 합니다는 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29> 메서드 전에 메모리 블록을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1848">To release these managed or unmanaged objects, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29> method before you free the memory block.</span></span>  
  
 <span data-ttu-id="f799e-1849">사용 하는 경우는 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> 메모리 블록에는 나중에 다른 인스턴스를 복사 하려면 지정 `true` 에 대 한 `fDeleteOld` 이전 인스턴스에 대 한 참조 형식에 대 한 참조를 제거 하려면를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1849">If you use the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> method to copy a different instance to the memory block at a later time, specify `true` for `fDeleteOld` to remove reference counts for reference types in the previous instance.</span></span> <span data-ttu-id="f799e-1850">그렇지 않은 경우 관리 되는 참조 형식 및 관리 되지 않는 복사본 유출 효과적으로 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1850">Otherwise, the managed reference types and unmanaged copies are effectively leaked.</span></span>  
  
 <span data-ttu-id="f799e-1851">사용 하기 위한 전반적인 패턴 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> 는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1851">The overall pattern for using <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> is as follows:</span></span>  
  
1.  <span data-ttu-id="f799e-1852">첫 번째 호출에서는 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> 메서드 메모리 블록 할당 된 후에, `fDeleteOld` 이어야 합니다 `false`지우려면 내용이 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1852">On the first call to the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method after a memory block has been allocated, `fDeleteOld` must be `false`, because there are no contents to clear.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="f799e-1853">지정 `true` 에 대 한 `fDeleteOld` 블록 유효한 데이터를 포함 하는 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1853">Specify `true` for `fDeleteOld` only if the block contains valid data.</span></span>  
  
2.  <span data-ttu-id="f799e-1854">메모리 블록에 다른 인스턴스를 복사 하 고 참조 형식을 포함 하는 경우 `fDeleteOld` 해야 `true` 무료 이전 내용을 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1854">If you copy a different instance to the memory block, and the object contains reference types, `fDeleteOld` must be `true` to free reference types in the old contents.</span></span>  
  
3.  <span data-ttu-id="f799e-1855">참조 형식을 포함 하는 개체를 호출 해야 합니다는 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> 메서드 전에 메모리 블록을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1855">If the object contains reference types, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> method before you free the memory block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f799e-1856">복사 하는 대신 기존 구조를 고정 하려면 사용 하 여는 <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> 구조에 대 한 고정된 된 핸들을 만들 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1856">To pin an existing structure instead of copying it, use the <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> type to create a pinned handle for the structure.</span></span> <span data-ttu-id="f799e-1857">참조에 고정 하는 방법에 대 한 내용은 [복사 및 고정](~/docs/framework/interop/copying-and-pinning.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1857">For details on how to pin, see [Copying and Pinning](~/docs/framework/interop/copying-and-pinning.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1858"><paramref name="structure" />가 형식이 지정된 클래스가 아닌 참조 형식인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1858"><paramref name="structure" /> is a reference type that is not a formatted class.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1859">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1859">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1860">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1860">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="SystemDefaultCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemDefaultCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemDefaultCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemDefaultCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemDefaultCharSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f799e-1861">시스템의 기본 문자 크기를 나타냅니다. 유니코드 시스템의 경우 기본값이 2이고, ANSI 시스템의 경우 1입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1861">Represents the default character size on the system; the default is 2 for Unicode systems and 1 for ANSI systems.</span></span> <span data-ttu-id="f799e-1862">이 필드는 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1862">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f799e-1863">다음 예제는 <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1863">The following example demonstrates the <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> field.</span></span> <span data-ttu-id="f799e-1864">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Runtime.InteropServices.Marshal> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1864">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SystemMaxDBCSCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemMaxDBCSCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemMaxDBCSCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemMaxDBCSCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemMaxDBCSCharSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f799e-1865">현재 운영 체제에서 DBCS(더블바이트 문자 집합)의 최대 크기(바이트)를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1865">Represents the maximum size of a double byte character set (DBCS) size, in bytes, for the current operating system.</span></span> <span data-ttu-id="f799e-1866">이 필드는 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1866">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f799e-1867">다음 예제는 <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1867">The following example demonstrates the <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> field.</span></span> <span data-ttu-id="f799e-1868">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Runtime.InteropServices.Marshal> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1868">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ThrowExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1869">오류가 있는 특정 HRESULT 값을 사용하여 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1869">Throws an exception with a specific failure HRESULT value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="f799e-1870">해당 예외에 해당하는 HRESULT입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1870">The HRESULT corresponding to the desired exception.</span></span></param>
        <summary><span data-ttu-id="f799e-1871">오류가 있는 특정 HRESULT 값을 사용하여 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1871">Throws an exception with a specific failure HRESULT value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1872">이 메서드는 오류가 있는 특정된 HRESULT에 대 한 예외 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1872">This method creates an exception object for the specified failure HRESULT.</span></span> <span data-ttu-id="f799e-1873">HRESULT 0 또는 양수 (성공 코드) 이면 메서드를 만들거나 예외를 throw 하지 않고 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1873">If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</span></span>  
  
 <span data-ttu-id="f799e-1874"><xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29> 기반으로 예외를 반환 하는 메서드는 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) 설정 된 경우 현재 스레드의 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1874">Note that the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29> method returns an exception based on the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface of the current thread if one is set.</span></span> <span data-ttu-id="f799e-1875">이런 경우는 `errorCode` 매개 변수가 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1875">When this happens, the `errorCode` parameter is ignored.</span></span>  
  
 <span data-ttu-id="f799e-1876">하지만 그렇지 않은 경우도 일부 실패 Hresult 정의 된 예외에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1876">Some failure HRESULTs map to defined exceptions, whereas others do not.</span></span> <span data-ttu-id="f799e-1877">정의 된 예외를 HRESULT 매핑될 경우 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 예외의 인스턴스를 만들고 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1877">If the HRESULT maps to a defined exception, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> creates an instance of the exception and throws it.</span></span> <span data-ttu-id="f799e-1878">인스턴스를 만들고 이렇게 하지 않으면 <xref:System.Runtime.InteropServices.COMException>, HRESULT 사용 하 여 오류 코드 필드를 초기화 하 고 해당 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1878">Otherwise, it creates an instance of <xref:System.Runtime.InteropServices.COMException>, initializes the error code field with the HRESULT, and throws that exception.</span></span> <span data-ttu-id="f799e-1879">때 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 는 관리 되지 않는 사용 하 여 오류와 관련 된 추가 정보를 검색 하려고 호출 [GetErrorInfo](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx) 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1879">When <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> is invoked, it attempts to retrieve extra information regarding the error by using the unmanaged [GetErrorInfo](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx) function.</span></span>  
  
 <span data-ttu-id="f799e-1880">.NET Framework에서 해당 예외 클래스를 각 hresult에서는 매핑에 대 한 참조 [하는 방법: 지도 Hresult 및 예외](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1880">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 <span data-ttu-id="f799e-1881">경우에 따라서는 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> COM에 대 한 이전 호출에서 예외를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1881">Occasionally, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> might return an exception from a previous COM call.</span></span> <span data-ttu-id="f799e-1882">다음 해결 방법을 사용 하 여 전달 하는 경우에 `IntPtr(-1)` 두 번째 매개 변수로 (`errorInfo`):</span><span class="sxs-lookup"><span data-stu-id="f799e-1882">In this case, you can use the following workaround and pass `IntPtr(-1)` as the second parameter (`errorInfo`):</span></span>  
  
```  
[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]  
public static void ThrowExceptionForHR(interrorCode,IntPtrerrorInfo)  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1883">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1883">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1884">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1884">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer, errorInfo As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode"><span data-ttu-id="f799e-1885">해당 예외에 해당하는 HRESULT입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1885">The HRESULT corresponding to the desired exception.</span></span></param>
        <param name="errorInfo"><span data-ttu-id="f799e-1886">오류에 대한 추가 정보를 제공하는 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) 인터페이스에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1886">A pointer to the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface that provides more information about the error.</span></span> <span data-ttu-id="f799e-1887">현재 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) 인터페이스를 사용하려면 <c>IntPtr(0)</c>을 지정하고, 현재 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) 인터페이스를 무시하고 오류 코드에서만 예외를 생성하려면 <c>IntPtr(-1)</c>을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1887">You can specify <c>IntPtr(0)</c> to use the current [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface, or <c>IntPtr(-1)</c> to ignore the current [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface and construct the exception just from the error code.</span></span></param>
        <summary><span data-ttu-id="f799e-1888">지정된 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) 인터페이스에 따라 특정 오류 HRESULT가 포함된 예외를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1888">Throws an exception with a specific failure HRESULT, based on the specified [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1889">이 메서드는 오류가 있는 특정된 HRESULT에 대 한 예외 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1889">This method creates an exception object for the specified failure HRESULT.</span></span> <span data-ttu-id="f799e-1890">HRESULT 0 또는 양수 (성공 코드) 이면 메서드를 만들거나 예외를 throw 하지 않고 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1890">If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</span></span>  
  
 <span data-ttu-id="f799e-1891"><xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 메서드 릴리스는 `errorInfo` COM 감소 하는 매개 변수 참조의 개수는 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1891">The <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method releases the `errorInfo` parameter, decreasing the COM reference count of the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface.</span></span>  
  
 <span data-ttu-id="f799e-1892"><xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 기반으로 예외를 반환 하는 메서드는 [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) 설정 된 경우 현재 스레드의 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1892">Note that the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method returns an exception based on the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface of the current thread if one is set.</span></span> <span data-ttu-id="f799e-1893">이런 경우는 `errorCode` 매개 변수가 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1893">When this happens, the `errorCode` parameter is ignored.</span></span>  
  
 <span data-ttu-id="f799e-1894">하지만 그렇지 않은 경우도 일부 실패 Hresult 정의 된 예외에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1894">Some failure HRESULTs map to defined exceptions, whereas others do not.</span></span> <span data-ttu-id="f799e-1895">정의 된 예외를 HRESULT 매핑될 경우 <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> 예외의 인스턴스를 만들고 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1895">If the HRESULT maps to a defined exception, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> creates an instance of the exception and throws it.</span></span> <span data-ttu-id="f799e-1896">인스턴스를 만들고 이렇게 하지 않으면 <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>, HRESULT 사용 하 여 오류 코드 필드를 초기화 하 고 해당 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1896">Otherwise, it creates an instance of <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>, initializes the error code field with the HRESULT, and throws that exception.</span></span> <span data-ttu-id="f799e-1897">`errorInfo` 매개 변수를 사용 하는 오류에 대 한 추가 정보를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1897">The `errorInfo` parameter is used to retrieve extra information regarding the error.</span></span>  
  
 <span data-ttu-id="f799e-1898">.NET Framework에서 해당 예외 클래스를 각 hresult에서는 매핑에 대 한 참조 [하는 방법: 지도 Hresult 및 예외](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1898">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1899">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1899">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1900">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1900">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement (arr As Array, index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(Array ^ arr, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr"><span data-ttu-id="f799e-1901">필요한 요소가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1901">The array that contains the desired element.</span></span></param>
        <param name="index"><span data-ttu-id="f799e-1902">원하는 요소의 <c>arr</c> 매개 변수에 있는 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1902">The index in the <c>arr</c> parameter of the desired element.</span></span></param>
        <summary><span data-ttu-id="f799e-1903">지정된 배열의 지정된 인덱스에 있는 요소의 주소를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1903">Gets the address of the element at the specified index inside the specified array.</span></span></summary>
        <returns><span data-ttu-id="f799e-1904"><paramref name="index" />에 있는 <paramref name="arr" /> 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1904">The address of <paramref name="index" /> inside <paramref name="arr" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1905">사용 하 여 배열 고정 해야는 <xref:System.Runtime.InteropServices.GCHandle> 이 메서드에 전달 하기 전에.</span><span class="sxs-lookup"><span data-stu-id="f799e-1905">The array must be pinned using a <xref:System.Runtime.InteropServices.GCHandle> before it is passed to this method.</span></span> <span data-ttu-id="f799e-1906">최상의 성능을 위해이 방법을 적용 합니다. 전달 된 배열을 확인 하지 않습니다. 이 인해 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1906">For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1907">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1907">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1908">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1908">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement&lt;T&gt; (T[] arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement&lt;T&gt;(!!T[] arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement(Of T) (arr As T(), index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(cli::array &lt;T&gt; ^ arr, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arr" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="f799e-1909">배열의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1909">The type of the array.</span></span></typeparam>
        <param name="arr"><span data-ttu-id="f799e-1910">필요한 요소가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1910">The array that contains the desired element.</span></span></param>
        <param name="index"><span data-ttu-id="f799e-1911"><c>arr</c> 배열에서 원하는 요소의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1911">The index of the desired element in the <c>arr</c> array.</span></span></param>
        <summary><span data-ttu-id="f799e-1912">[.NET Framework 4.5.1 이상 버전에서 지원됨]</span><span class="sxs-lookup"><span data-stu-id="f799e-1912">[Supported in the .NET Framework 4.5.1 and later versions]</span></span>  
  
 <span data-ttu-id="f799e-1913">지정된 형식의 배열에 지정된 인덱스에 있는 요소의 주소를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1913">Gets the address of the element at the specified index in an array of a specified type.</span></span></summary>
        <returns><span data-ttu-id="f799e-1914"><paramref name="index" />에 있는 <paramref name="arr" /> 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1914">The address of <paramref name="index" /> in <paramref name="arr" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1915">배열을 사용 하 여 고정 해야는 <xref:System.Runtime.InteropServices.GCHandle> 이 메서드에 전달 하기 전에.</span><span class="sxs-lookup"><span data-stu-id="f799e-1915">The array must be pinned by using a <xref:System.Runtime.InteropServices.GCHandle> before it is passed to this method.</span></span> <span data-ttu-id="f799e-1916">최상의 성능을 위해이 방법을 적용 합니다. 전달 된 배열을 확인 하지 않습니다. 이 인해 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1916">For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1917">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1917">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1918">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1918">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1919">관리되지 않는 메모리에 싱글바이트 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1919">Writes a single byte value to unmanaged memory.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1920">관리되지 않는 메모리에서 값을 쓸 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1920">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-1921">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1921">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-1922">관리되지 않는 메모리에 싱글바이트 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1922">Writes a single byte value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1923"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> 직접 관리 되지 않는 배열 전체를 복사 하지 않아도 관리 되지 않는 C-스타일 바이트 배열와의 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1923"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1924">관리 되지 않는 메모리 블록을 만듭니다. 하는 관리 되지 않는 메모리를 바이트를 쓰고 해당 바이트를 읽은 관리 되지 않는 메모리에서 다시 고 관리 되지 않는 메모리를 삭제 하는 다음 예제에서는 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1924">The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="f799e-1925"><paramref name="ptr" />의 형식을 인식할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1925"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="f799e-1926">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1926">-or-</span></span>  
  
 <span data-ttu-id="f799e-1927"><paramref name="ptr" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1927"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-1928">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1928">-or-</span></span>  
  
 <span data-ttu-id="f799e-1929"><paramref name="ptr" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1929"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1930">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1930">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1931">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1931">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, int ofs, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1932">관리되지 않는 메모리에서 값을 쓸 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1932">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1933">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1933">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-1934">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1934">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-1935">관리되지 않는 메모리의 지정된 오프셋 위치에 싱글바이트 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1935">Writes a single byte value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1936"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> 직접 관리 되지 않는 배열 전체를 복사 하지 않아도 관리 되지 않는 C-스타일 바이트 배열와의 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1936"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1937">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1937">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1938">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1938">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1939">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1939">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1940">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1940">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (object ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte([out] object ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As Object, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(System::Object ^ ptr, int ofs, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1941">대상 개체에 대한 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1941">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1942">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1942">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-1943">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1943">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-1944">관리되지 않는 메모리의 지정된 오프셋 위치에 싱글바이트 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1944">Writes a single byte value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1945"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> 직접 관리 되지 않는 배열 전체를 복사 하지 않아도 관리 되지 않는 C-스타일 바이트 배열와의 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1945"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1946">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1946">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-1947"><paramref name="ptr" />이 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 개체인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-1947"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="f799e-1948">이 메서드에는 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1948">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1949">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1949">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1950">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1950">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-1951">관리되지 않는 메모리에 부호 있는 16비트 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1951">Writes a 16-bit signed integer value to unmanaged memory.</span></span> <span data-ttu-id="f799e-1952">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1952">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1953">관리되지 않는 메모리에서 값을 쓸 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1953">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-1954">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1954">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-1955">관리되지 않는 메모리에 16비트 정수 값으로 문자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1955">Writes a character as a 16-bit integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1956"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 직접 배열 사용 하 여 관리 되지 않는 16 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1956"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-1957">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1957">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1958">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1958">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="f799e-1959"><paramref name="ptr" />의 형식을 인식할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1959"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="f799e-1960">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1960">-or-</span></span>  
  
 <span data-ttu-id="f799e-1961"><paramref name="ptr" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1961"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-1962">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1962">-or-</span></span>  
  
 <span data-ttu-id="f799e-1963"><paramref name="ptr" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1963"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1964">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1964">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1965">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1965">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1966">관리되지 않는 메모리에서 값을 쓸 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1966">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-1967">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1967">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-1968">관리되지 않는 메모리에 16비트 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1968">Writes a 16-bit integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1969"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 직접 배열 사용 하 여 관리 되지 않는 16 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1969"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-1970">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1970">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1971">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1971">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="f799e-1972"><paramref name="ptr" />의 형식을 인식할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1972"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="f799e-1973">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1973">-or-</span></span>  
  
 <span data-ttu-id="f799e-1974"><paramref name="ptr" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1974"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-1975">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-1975">-or-</span></span>  
  
 <span data-ttu-id="f799e-1976"><paramref name="ptr" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1976"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1977">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1977">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1978">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1978">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1979">네이티브 힙에서 값을 쓸 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1979">The base address in the native heap to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1980">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1980">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-1981">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1981">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-1982">관리되지 않는 메모리의 지정된 오프셋 위치에 16비트 부호 있는 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1982">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1983"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 직접 배열 사용 하 여 관리 되지 않는 16 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1983"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-1984">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1984">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1985">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1985">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1986">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1986">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1987">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1987">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1988">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1988">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1989">관리되지 않는 메모리에서 값을 쓸 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1989">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-1990">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1990">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-1991">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1991">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-1992">관리되지 않는 메모리의 지정된 오프셋 위치에 16비트 부호 있는 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1992">Writes a 16-bit signed integer value into unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-1993"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 직접 배열 사용 하 여 관리 되지 않는 16 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1993"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-1994">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1994">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-1995">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-1995">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-1996">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-1996">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-1997">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1997">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-1998">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1998">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-1999">대상 개체에 대한 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-1999">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-2000">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2000">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-2001">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2001">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-2002">관리되지 않는 메모리의 지정된 오프셋 위치에 16비트 부호 있는 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2002">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2003"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 직접 배열 사용 하 여 관리 되지 않는 16 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2003"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-2004">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2004">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-2005">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2005">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-2006"><paramref name="ptr" />이 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 개체인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-2006"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="f799e-2007">이 메서드에는 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2007">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2008">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2008">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2009">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2009">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-2010">대상 개체에 대한 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2010">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-2011">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2011">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-2012">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2012">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-2013">관리되지 않는 메모리의 지정된 오프셋 위치에 16비트 부호 있는 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2013">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2014"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> 직접 배열 사용 하 여 관리 되지 않는 16 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2014"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-2015">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2015">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-2016">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2016">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-2017"><paramref name="ptr" />이 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 개체인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-2017"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="f799e-2018">이 메서드에는 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2018">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2019">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2019">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2020">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2020">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-2021">관리되지 않는 메모리에 부호 있는 32비트 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2021">Writes a 32-bit signed integer value to unmanaged memory.</span></span> <span data-ttu-id="f799e-2022">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2022">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-2023">관리되지 않는 메모리에서 값을 쓸 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2023">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-2024">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2024">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-2025">관리되지 않는 메모리에 부호 있는 32비트 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2025">Writes a 32-bit signed integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2026"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 직접 배열 사용 하 여 관리 되지 않는 32 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2026"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-2027">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2027">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-2028">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-2028">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="f799e-2029"><paramref name="ptr" />의 형식을 인식할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2029"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="f799e-2030">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-2030">-or-</span></span>  
  
 <span data-ttu-id="f799e-2031"><paramref name="ptr" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2031"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-2032">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-2032">-or-</span></span>  
  
 <span data-ttu-id="f799e-2033"><paramref name="ptr" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2033"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2034">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2034">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2035">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2035">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int ofs, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-2036">관리되지 않는 메모리에서 값을 쓸 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2036">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-2037">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2037">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-2038">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2038">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-2039">관리되지 않는 메모리의 지정된 오프셋 위치에 32비트 부호 있는 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2039">Writes a 32-bit signed integer value into unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2040"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 직접 배열 사용 하 여 관리 되지 않는 32 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2040"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-2041">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2041">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-2042">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-2042">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-2043">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2043">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2044">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2044">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2045">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2045">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (object ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32([out] object ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As Object, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(System::Object ^ ptr, int ofs, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-2046">대상 개체에 대한 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2046">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-2047">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2047">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-2048">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2048">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-2049">관리되지 않는 메모리의 지정된 오프셋 위치에 32비트 부호 있는 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2049">Writes a 32-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2050"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> 직접 배열 사용 하 여 관리 되지 않는 32 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2050"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-2051">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2051">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-2052">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2052">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-2053"><paramref name="ptr" />이 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 개체인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-2053"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="f799e-2054">이 메서드에는 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2054">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2055">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2055">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2056">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2056">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-2057">관리되지 않는 메모리에 부호 있는 64비트 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2057">Writes a 64-bit signed integer value to unmanaged memory.</span></span> <span data-ttu-id="f799e-2058">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2058">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-2059">관리되지 않는 메모리에서 값을 쓸 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2059">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-2060">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2060">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-2061">관리되지 않는 메모리에 부호 있는 64비트 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2061">Writes a 64-bit signed integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2062"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 직접 배열 사용 하 여 관리 되지 않는 64 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2062"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-2063">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2063">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-2064">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-2064">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="f799e-2065"><paramref name="ptr" />의 형식을 인식할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2065"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="f799e-2066">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-2066">-or-</span></span>  
  
 <span data-ttu-id="f799e-2067"><paramref name="ptr" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2067"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-2068">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-2068">-or-</span></span>  
  
 <span data-ttu-id="f799e-2069"><paramref name="ptr" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2069"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2070">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2070">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2071">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2071">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, int ofs, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-2072">데이터를 쓸 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2072">The base address in unmanaged memory to write.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-2073">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2073">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-2074">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2074">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-2075">관리되지 않는 메모리의 지정된 오프셋 위치에 64비트 부호 있는 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2075">Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2076"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 직접 배열 사용 하 여 관리 되지 않는 64 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2076"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-2077">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2077">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-2078">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-2078">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-2079">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2079">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2080">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2080">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2081">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2081">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (object ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64([out] object ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As Object, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(System::Object ^ ptr, int ofs, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-2082">대상 개체에 대한 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2082">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-2083">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2083">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-2084">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2084">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-2085">관리되지 않는 메모리의 지정된 오프셋 위치에 64비트 부호 있는 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2085">Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2086"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> 직접 배열 사용 하 여 관리 되지 않는 64 비트 부호 있는, 관리 되지 않는 배열 전체를 복사 하지 않아도 상호 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2086"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-2087">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2087">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-2088">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2088">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-2089"><paramref name="ptr" />이 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 개체인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-2089"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="f799e-2090">이 메서드에는 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2090">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2091">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2091">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2092">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2092">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f799e-2093">관리되지 않는 메모리에 프로세서의 기본 크기로 지정된 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2093">Writes a processor native-sized integer value to unmanaged memory.</span></span> <span data-ttu-id="f799e-2094">32비트 시스템에는 32비트 정수를 쓰고 64비트 시스템에는 64비트 정수를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2094">32-bit integers are written on 32-bit systems, and 64-bit integers are written on 64-bit systems.</span></span> <span data-ttu-id="f799e-2095">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2095">Writing to unaligned memory locations is supported.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-2096">관리되지 않는 메모리에서 값을 쓸 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2096">The address in unmanaged memory to write to.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-2097">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2097">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-2098">관리되지 않는 메모리에 프로세서의 기본 크기로 지정된 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2098">Writes a processor native sized integer value into unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2099"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 직접 관리 되지 않는 C 스타일의 상호 작용을 수 있으므로 `IntPtr` 관리 되지 않는 배열 전체를 복사 하지 않아도 배열 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)를 별도 관리 되는 배열 요소의 값을 설정 하기 전에.</span><span class="sxs-lookup"><span data-stu-id="f799e-2099"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-2100">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2100">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-2101">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-2101">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="f799e-2102"><paramref name="ptr" />의 형식을 인식할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2102"><paramref name="ptr" /> is not a recognized format.</span></span>  
  
 <span data-ttu-id="f799e-2103">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-2103">-or-</span></span>  
  
 <span data-ttu-id="f799e-2104"><paramref name="ptr" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2104"><paramref name="ptr" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="f799e-2105">또는</span><span class="sxs-lookup"><span data-stu-id="f799e-2105">-or-</span></span>  
  
 <span data-ttu-id="f799e-2106"><paramref name="ptr" />이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2106"><paramref name="ptr" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2107">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2107">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2108">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2108">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-2109">관리되지 않는 메모리에서 값을 쓸 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2109">The base address in unmanaged memory to write to.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-2110">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2110">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-2111">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2111">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-2112">관리되지 않는 메모리의 지정된 오프셋 위치에 프로세서의 기본 크기로 지정된 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2112">Writes a processor native-sized integer value to unmanaged memory at a specified offset.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2113">이 메서드는 32 비트 시스템과 64 비트 시스템에서 64 비트 정수에는 32 비트 정수를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2113">This method writes a 32 bit integer on 32 bit systems, and a 64 bit integer on 64 bit systems.</span></span>  
  
 <span data-ttu-id="f799e-2114"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 직접 관리 되지 않는 C 스타일의 상호 작용을 수 있으므로 `IntPtr` 관리 되지 않는 배열 전체를 복사 하지 않아도 배열 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>)를 별도 관리 되는 배열 요소의 값을 설정 하기 전에.</span><span class="sxs-lookup"><span data-stu-id="f799e-2114"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-2115">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2115">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-2116">다음 예제에서는 읽기 / 쓰기를 사용 하 여 관리 되지 않는 배열 하는 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> 및 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-2116">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-2117">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2117">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2118">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2118">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2119">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2119">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (object ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr([out] object ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As Object, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(System::Object ^ ptr, int ofs, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr"><span data-ttu-id="f799e-2120">대상 개체에 대한 관리되지 않는 메모리의 기본 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2120">The base address in unmanaged memory of the target object.</span></span></param>
        <param name="ofs"><span data-ttu-id="f799e-2121">쓰기 전에 <c>ptr</c> 매개 변수에 추가되는 추가 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2121">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span></span></param>
        <param name="val"><span data-ttu-id="f799e-2122">작성할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2122">The value to write.</span></span></param>
        <summary><span data-ttu-id="f799e-2123">관리되지 않는 메모리에 프로세서의 기본 크기로 지정된 정수 값을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2123">Writes a processor native sized integer value to unmanaged memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2124"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> 직접 관리 되지 않는 배열 전체를 복사 하지 않아도 관리 되지 않는 C-스타일 바이트 배열와의 상호 작용을 수 있으므로 (사용 하 여 <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) 해당 요소 값을 설정 하기 전에 별도 관리 되는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2124"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="f799e-2125">정렬되지 않은 메모리 위치에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2125">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="f799e-2126">기준 주소(<paramref name="ptr" />)에 오프셋 바이트(<paramref name="ofs" />)를 더하면 null 또는 잘못된 주소가 생성되는 경우</span><span class="sxs-lookup"><span data-stu-id="f799e-2126">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f799e-2127"><paramref name="ptr" />이 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 개체인 경우.</span><span class="sxs-lookup"><span data-stu-id="f799e-2127"><paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span></span> <span data-ttu-id="f799e-2128">이 메서드에는 <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> 매개 변수를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2128">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2129">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2129">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2130">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2130">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeBSTR">
      <MemberSignature Language="C#" Value="public static void ZeroFreeBSTR (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeBSTR(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeBSTR (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeBSTR(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-2131">해제할 <see langword="BSTR" />의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2131">The address of the <see langword="BSTR" /> to free.</span></span></param>
        <summary><span data-ttu-id="f799e-2132"><see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /> 메서드를 사용하여 할당된 [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) 포인터를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2132">Frees a [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2133"><xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> 메서드를 0으로 BSTR의 콘텐츠를 먼저 설정 하 고 BSTR를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2133">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> method first sets the contents of the BSTR to zero, and then frees the BSTR.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2134">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2134">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2135">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2135">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemAnsi(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-2136">해제할 관리되지 않는 문자열의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2136">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="f799e-2137"><see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /> 메서드를 사용하여 할당한 관리되지 않는 문자열 포인터를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2137">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2138"><xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> 메서드 먼저 비운 및 사용 하 여 할당 된 관리 되지 않는 메모리를 해제 합니다는 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-2138">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-2139">다음 예제에서는 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> 마샬링할의 내용을 해독 하는 메서드는 <xref:System.Security.SecureString> 관리 되지 않는 메모리 블록에는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2139">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="f799e-2140">다음 사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> 메서드를 비우고 관리 되지 않는 블록을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2140">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2141">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2141">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2142">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2142">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUnicode(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-2143">해제할 관리되지 않는 문자열의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2143">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="f799e-2144"><see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /> 메서드를 사용하여 할당한 관리되지 않는 문자열 포인터를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2144">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2145"><xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> 메서드 먼저 비운 및 사용 하 여 할당 된 관리 되지 않는 메모리를 해제 합니다는 <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-2145">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2146">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2146">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2147">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUTF8 (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUTF8(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUTF8 (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUTF8(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocAnsi(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-2148">해제할 관리되지 않는 문자열의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2148">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="f799e-2149"><see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /> 메서드를 사용하여 할당한 관리되지 않는 문자열 포인터를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2149">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2150"><xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> 메서드 먼저 비운 및 사용 하 여 할당 된 관리 되지 않는 메모리를 해제 합니다는 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-2150">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-2151">다음 예제에서는 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> 마샬링할의 내용을 해독 하는 메서드는 <xref:System.Security.SecureString> 관리 되지 않는 메모리 블록에는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2151">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="f799e-2152">다음 사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> 메서드를 비우고 관리 되지 않는 블록을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2152">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2153">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2153">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2154">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2154">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocUnicode(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="f799e-2155">해제할 관리되지 않는 문자열의 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2155">The address of the unmanaged string to free.</span></span></param>
        <summary><span data-ttu-id="f799e-2156"><see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /> 메서드를 사용하여 할당한 관리되지 않는 문자열 포인터를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2156">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f799e-2157"><xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> 메서드 먼저 비운 및 사용 하 여 할당 된 관리 되지 않는 메모리를 해제 합니다는 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f799e-2157">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f799e-2158">다음 예제에서는 사용 하는 <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> 관리 되지 않는 메서드 `LogonUser` 가장을 수행 하는 함수는 <xref:System.Security.SecureString> 클래스.</span><span class="sxs-lookup"><span data-stu-id="f799e-2158">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method with the unmanaged `LogonUser` function to perform impersonation with the <xref:System.Security.SecureString> class.</span></span> <span data-ttu-id="f799e-2159">이 예제에서는 다음 사용 하 여는 <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> 메서드를 비우고 관리 되지 않는 문자열 파일에 대 한 참조를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2159">The example then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method to zero out and free the unmanaged string reference.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f799e-2160">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2160">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f799e-2161">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f799e-2161">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>