<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="853f59d82c93a1b22f4873b07aed3315c6946bea" />
    <Meta Name="ms.sourcegitcommit" Value="01f28caab7b3f23878dd07b402a8dd48b9478c8c" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/19/2018" />
    <Meta Name="ms.locfileid" Value="39142411" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="bc823-101">Berkeley 소켓 인터페이스를 구현합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="bc823-101">Implements the Berkeley sockets interface.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-102"><xref:System.Net.Sockets.Socket> 클래스는 네트워크 통신을 위한 다양 한 메서드 및 속성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-102">The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications.</span></span> <span data-ttu-id="bc823-103"><xref:System.Net.Sockets.Socket> 클래스 수행할 수 있도록 둘 다 동기 및 통신 프로토콜 중 하나를 사용 하 여 비동기 데이터 전송에 나열 된 <xref:System.Net.Sockets.ProtocolType> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-103">The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.</span></span>  
  
 <span data-ttu-id="bc823-104"><xref:System.Net.Sockets.Socket> 클래스는 비동기 메서드에 대 한.NET Framework 명명 패턴을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-104">The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods.</span></span> <span data-ttu-id="bc823-105">예를 들어 동기 <xref:System.Net.Sockets.Socket.Receive%2A> 는 비동기 메서드는 해당 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 고 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-105">For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.</span></span>  
  
 <span data-ttu-id="bc823-106">응용 프로그램 실행 중 하나의 스레드만, 필요한 경우에 동기 작업 모드를 위해 설계 된 다음 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-106">If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</span></span>  
  
-   <span data-ttu-id="bc823-107">서버 수를 사용 하 여 연결을 수신 TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Listen%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-107">If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="bc823-108"><xref:System.Net.Sockets.Socket.Accept%2A> 들어오는 모든 연결 요청 및 반환 방법 프로세스는 <xref:System.Net.Sockets.Socket> 원격 호스트를 사용 하 여 데이터를 통신에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-108">The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host.</span></span> <span data-ttu-id="bc823-109">반환이 사용 하 여 <xref:System.Net.Sockets.Socket> 를 호출 하 여 <xref:System.Net.Sockets.Socket.Send%2A> 또는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-109">Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span> <span data-ttu-id="bc823-110">호출 된 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드 호출 하기 전에 <xref:System.Net.Sockets.Socket.Listen%2A> 메서드 로컬 IP 주소 및 포트 번호를 지정 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="bc823-110">Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number.</span></span> <span data-ttu-id="bc823-111">사용 가능한 포트를 할당 하려면 기본 서비스 공급자를 하려는 경우 0의 포트 번호를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-111">Use a port number of zero if you want the underlying service provider to assign a free port for you.</span></span> <span data-ttu-id="bc823-112">수신 호스트에 연결 하려는 경우 호출 된 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-112">If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="bc823-113">데이터에 전달 하기 위해 호출 된 <xref:System.Net.Sockets.Socket.Send%2A> 또는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-113">To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
-   <span data-ttu-id="bc823-114">UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 연결을 전혀 수신 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-114">If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</span></span> <span data-ttu-id="bc823-115">호출 된 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 들어오는 데이터 그램을 수락 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-115">Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams.</span></span> <span data-ttu-id="bc823-116">사용 된 <xref:System.Net.Sockets.Socket.SendTo%2A> 데이터 그램을 원격 호스트에 보내는 방법.</span><span class="sxs-lookup"><span data-stu-id="bc823-116">Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.</span></span>  
  
 <span data-ttu-id="bc823-117">실행 하는 동안 별도 스레드를 사용 하 여 통신을 처리 하려면 비동기 작업 모드를 위해 설계 된 다음 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-117">To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</span></span>  
  
-   <span data-ttu-id="bc823-118">TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 및 <xref:System.Net.Sockets.Socket.EndConnect%2A> 수신 호스트와 연결 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-118">If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host.</span></span> <span data-ttu-id="bc823-119">사용 하 여는 <xref:System.Net.Sockets.Socket.BeginSend%2A> 하 고 <xref:System.Net.Sockets.Socket.EndSend%2A> 또는 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 및 <xref:System.Net.Sockets.Socket.EndReceive%2A> 데이터를 비동기적으로 통신 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-119">Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously.</span></span> <span data-ttu-id="bc823-120">사용 하 여 들어오는 연결 요청을 처리할 수 있습니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 고 <xref:System.Net.Sockets.Socket.EndAccept%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-120">Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span></span>  
  
-   <span data-ttu-id="bc823-121">UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 하 고 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 데이터 그램, 및 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 및 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 데이터 그램을 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-121">If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> and <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.</span></span>  
  
 <span data-ttu-id="bc823-122">소켓에서 여러 비동기 작업을 수행 하는 경우 완료 되지 않은 반드시 시작 되는 순서에서입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-122">If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</span></span>  
  
 <span data-ttu-id="bc823-123">사용 하 여 데이터를 받는 경우는 <xref:System.Net.Sockets.Socket.Shutdown%2A> 사용 하지 않도록 설정 하는 방법의 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-123">When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-124">호출한 후 <xref:System.Net.Sockets.Socket.Shutdown%2A>, 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 관련 된 모든 리소스를 해제 하는 메서드에 <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="bc823-124">After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="bc823-125">합니다 <xref:System.Net.Sockets.Socket> 클래스를 사용 하면 구성할 수 있습니다 하 <xref:System.Net.Sockets.Socket> 사용 하 여를 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-125">The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span> <span data-ttu-id="bc823-126">이러한 설정을 사용 하 여 검색 된 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-126">Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-127">상대적으로 간단한 응용 프로그램을 작성 하는 최대 성능이 필요 하지 않은 경우 사용을 고려 <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, 및 <xref:System.Net.Sockets.UdpClient>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-127">If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>.</span></span> <span data-ttu-id="bc823-128">이러한 클래스를 간단 하 고 보다 편리한 사용자 인터페이스를 제공 합니다. <xref:System.Net.Sockets.Socket> 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-128">These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-129">다음 코드 예제에서는 방법을 <xref:System.Net.Sockets.Socket> HTTP 서버에 데이터를 보내고 응답을 수신 하는 클래스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-129">The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response.</span></span> <span data-ttu-id="bc823-130">이 예제에서는 전체 페이지를 받을 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-130">This example blocks until the entire page is received.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">
      <span data-ttu-id="bc823-131">나가는 연결을 설정 하거나 들어오는 요청을 수락 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="bc823-131">To establish an outgoing connection or accept an incoming request.</span>
      </span>
    </permission>
    <threadsafe>
      <span data-ttu-id="bc823-132">이 클래스의 인스턴스는 스레드로부터 안전 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="bc823-132">Instances of this class are thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-133">
            <see cref="T:System.Net.Sockets.Socket" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-133">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">
          <span data-ttu-id="bc823-134">
            <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />에서 반환된 소켓 정보입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-134">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-135">
            <see cref="T:System.Net.Sockets.Socket" />에서 반환된 특정 값을 사용하여 <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-135">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-136">호출 하는 경우는 <xref:System.Net.Sockets.Socket.%23ctor%2A> 여러 번 사용 하 여 각 호출에 대 한 인수로 동일한 바이트 배열 생성자를 만들려는 관리 되는 여러 <xref:System.Net.Sockets.Socket>s 동일한 기본 소켓을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-136">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket.</span></span> <span data-ttu-id="bc823-137">이 방법은 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-137">This practice is strongly discouraged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <span data-ttu-id="bc823-138">
            <see cref="T:System.Net.Sockets.SocketType" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-138">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </param>
        <param name="protocolType">
          <span data-ttu-id="bc823-139">
            <see cref="T:System.Net.Sockets.ProtocolType" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-139">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-140">지정된 소켓 종류 및 프로토콜을 사용하여 <see cref="T:System.Net.Sockets.Socket" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-140">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-141">합니다 `socketType` 매개 변수 유형을 지정 합니다 <xref:System.Net.Sockets.Socket> 클래스 및 `protocolType` 매개 변수에서 사용 하는 프로토콜을 지정 합니다. <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-141">The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-142">두 매개 변수가 독립적인있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-142">The two parameters are not independent.</span></span> <span data-ttu-id="bc823-143">종종는 <xref:System.Net.Sockets.Socket> 형식 프로토콜에서 암시적입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-143">Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="bc823-144">경우 조합을 <xref:System.Net.Sockets.Socket> 형식 및 프로토콜에서 잘못 된 결과 형식 <xref:System.Net.Sockets.Socket>,이 생성자는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-144">If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-145">이 생성자는 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-145">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-146">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-146">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-147">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-147">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-148">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-148">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-149">
            <paramref name="socketType" />과 <paramref name="protocolType" />을 조합했을 때 소켓이 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-149">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">
          <span data-ttu-id="bc823-150">
            <see cref="T:System.Net.Sockets.AddressFamily" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-150">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span>
          </span>
        </param>
        <param name="socketType">
          <span data-ttu-id="bc823-151">
            <see cref="T:System.Net.Sockets.SocketType" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-151">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </param>
        <param name="protocolType">
          <span data-ttu-id="bc823-152">
            <see cref="T:System.Net.Sockets.ProtocolType" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-152">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-153">지정된 주소 패밀리, 소켓 종류 및 프로토콜을 사용하여 <see cref="T:System.Net.Sockets.Socket" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-153">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-154">`addressFamily` 매개 변수를 지정 하는 주소 지정 체계를 <xref:System.Net.Sockets.Socket> 클래스 사용을 `socketType` 매개 변수 유형을 지정 합니다 <xref:System.Net.Sockets.Socket> 클래스 및 `protocolType` 매개 변수에서 사용 하는 프로토콜을 지정 합니다. <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="bc823-154">The `addressFamily` parameter specifies the addressing scheme that the <xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-155">세 개의 매개 변수가 독립적인있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-155">The three parameters are not independent.</span></span> <span data-ttu-id="bc823-156">일부 주소 패밀리 제한으로, 그리고 자주 프로토콜을 사용할 수는 <xref:System.Net.Sockets.Socket> 형식 프로토콜에서 암시적입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-156">Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="bc823-157">경우 주소 패밀리, 조합 <xref:System.Net.Sockets.Socket> 형식 및 프로토콜에서 잘못 된 형식 <xref:System.Net.Sockets.Socket>,이 생성자는 <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="bc823-157">If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-158">이 생성자는 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-158">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-159">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-159">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-160">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-160">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-161">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-161">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-162">다음 코드 예제에는 인스턴스를 만드는 방법을 보여 줍니다는 <xref:System.Net.Sockets.Socket> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-162">The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-163">
            <paramref name="addressFamily" />, <paramref name="socketType" /> 및 <paramref name="protocolType" />을 조합했을 때 소켓이 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-163">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bc823-164">새로 만든 연결에 대한 새 <see cref="T:System.Net.Sockets.Socket" />을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-164">Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-165">새로 만든 연결에 대한 <see cref="T:System.Net.Sockets.Socket" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-165">A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-166"><xref:System.Net.Sockets.Socket.Accept%2A> 동기적으로 수신 소켓의 연결 요청 큐에서 첫 번째 보류 중인 연결 요청을 추출 하 고 다음 만들고 반환 새 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-166"><xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-167">반환이 사용할 수 없습니다 <xref:System.Net.Sockets.Socket> 연결 큐에서 모든 추가 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-167">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="bc823-168">호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 메서드의 반환된 된 <xref:System.Net.Sockets.Socket> 원격 호스트의 네트워크 주소 및 포트 번호를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-168">However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
 <span data-ttu-id="bc823-169">블로킹 모드에서 <xref:System.Net.Sockets.Socket.Accept%2A> 들어오는 연결 시도 큐에 대기 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-169">In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued.</span></span> <span data-ttu-id="bc823-170">연결을 수락 되 면 원래 <xref:System.Net.Sockets.Socket> 큐 들어오는 연결 요청 될 때까지 닫기 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-170">Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.</span></span>  
  
 <span data-ttu-id="bc823-171">비블로킹을 사용 하 여이 메서드를 호출 하는 경우 <xref:System.Net.Sockets.Socket>, 고 요청 큐에 대기 하는 연결 되지 않았습니다 <xref:System.Net.Sockets.Socket.Accept%2A> throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-171">If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-172">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-172">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-173">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-173">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-174">호출 하기 전에 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드를 먼저 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Listen%2A> 수신 대기 하 고 들어오는 연결 요청을 큐에 대 한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-174">Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-175">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-175">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-176">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-176">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-177">다음 코드 예제에서는 간단한 허용 <xref:System.Net.Sockets.Socket> 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-177">The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.</span></span>  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-178">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-178">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-179">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-179">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-180">받아들이는 소켓이 연결을 수신하지 않는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-180">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="bc823-181">
            <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />를 호출하기 전에 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 및 <see cref="M:System.Net.Sockets.Socket.Accept" />을 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-181">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="bc823-182">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-182">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-183">들어오는 연결 시도를 받아들이는 비동기 작업을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-183">Begins an asynchronous operation to accept an incoming connection attempt.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-184">I/O 작업이 보류 중인 경우 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-184">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="bc823-185">작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-185">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="bc823-186">I/O 작업이 동기적으로 완료된 경우 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-186">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="bc823-187">이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-187">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-188">연결 지향 프로토콜에서 사용할 수는 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 메서드 들어오는 연결을 비동기적으로 처리를 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-188">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="bc823-189">비동기적으로 연결을 허용 하면 별도 실행 스레드 내에서 데이터를 주고받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-189">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="bc823-190">호출 하기 전에 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.Listen%2A> 수신 대기 하 고 들어오는 연결 요청을 큐에 대 한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-190">Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="bc823-191">콜백 메서드를 이벤트 처리기를 구현 하는 완료 알림을 수를 만들어야\<SocketAsyncEventArgs > 대리자를 연결 하는 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-191">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="bc823-192">다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 개체는 필요:</span><span class="sxs-lookup"><span data-stu-id="bc823-192">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="bc823-193">호출자에 게 기존를 선택적으로 지정할 수 <xref:System.Net.Sockets.Socket> 지정 하 여 들어오는 연결을 사용 하는 <xref:System.Net.Sockets.Socket> 사용 하는 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-193">The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="bc823-194">경우는 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 속성이 null이 새 <xref:System.Net.Sockets.Socket> 같은 생성 된 <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, 및 <xref:System.Net.Sockets.Socket.ProtocolType%2A> 현재 <xref:System.Net.Sockets.Socket> 으로 설정 하 고는 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-194">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="bc823-195">호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-195">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="bc823-196">콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-196">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="bc823-197">필요에 따라 초기 데이터 블록의 후 소켓을 수신 하는 버퍼를 제공할 수 있습니다는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드가 성공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-197">Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="bc823-198">이 경우에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 받을 데이터를 포함 하는 버퍼를 설정 해야 하는 속성 및 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 속성 버퍼에서 수신 하도록 데이터의 바이트의 최대 수로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-198">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the maximum number of bytes of data to receive in the buffer.</span></span> <span data-ttu-id="bc823-199">사용 하 여 이러한 속성을 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-199">These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bc823-200">전달 된 버퍼의 파트에서 사용 하는 내부적으로 사용에 대 한 기본 Winsock AcceptEx 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-200">Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</span></span> <span data-ttu-id="bc823-201">즉, 반환 되는 데이터 양을 값 보다 작을 수 항상은 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 속성에는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 제공 되는 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="bc823-201">This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance provided.</span></span> <span data-ttu-id="bc823-202">내부적으로 사용 되는 버퍼의 크기는 소켓의 주소 패밀리에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-202">The amount of the buffer used internally varies based on the address family of the socket.</span></span> <span data-ttu-id="bc823-203">필요한 최소 버퍼 크기는 288 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-203">The minimum buffer size required is 288 bytes.</span></span> <span data-ttu-id="bc823-204">큰 버퍼 크기를 지정 하는 경우 해당 <xref:System.Net.Sockets.Socket> Winsock AcceptEx 호출에서 받은 주소 데이터가 아닌 일부 추가 데이터는 것을 예상 하 고이 추가 데이터를 수신할 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-204">If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</span></span> <span data-ttu-id="bc823-205">시간 초과가 발생 하는 경우 연결이 다시 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-205">If a timeout occurs, the connection is reset.</span></span> <span data-ttu-id="bc823-206">따라서 추가 데이터는 특정 크기, 예상 되는 경우 버퍼 크기는 최소 버퍼 크기와이 크기를 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-206">So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</span></span>  
  
 <span data-ttu-id="bc823-207">완료 콜백 메서드를 검사 해야 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 여부를 확인 하는 속성을 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 작업이 성공적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-207">The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.</span></span>  
  
 <span data-ttu-id="bc823-208">합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트 발생 및 연결 없음에 동의 하는 경우 일부 경우에 발생할 수는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 속성을 설정할 <xref:System.Net.Sockets.SocketError.ConnectionReset>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-208">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span></span> <span data-ttu-id="bc823-209">반 열린 SYN 형식 검사를 사용 하 여 포트 검색의 결과로 발생할 수 있습니다 (SYN SYN-ACK-> RST 시퀀스->).</span><span class="sxs-lookup"><span data-stu-id="bc823-209">This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence).</span></span> <span data-ttu-id="bc823-210">사용 하 여 응용 프로그램을 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 메서드는이 조건을 처리할 준비가 되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-210">Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-211">인수가 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-211">An argument is not valid.</span>
          </span>
          <span data-ttu-id="bc823-212">제공된 버퍼의 크기가 너무 작으면 이 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-212">This exception occurs if the buffer provided is not large enough.</span>
          </span>
          <span data-ttu-id="bc823-213">버퍼의 크기는 최소한 2 \* (sizeof(SOCKADDR_STORAGE + 16)바이트 이상이어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-213">The buffer must be at least 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span>
          </span>
          <span data-ttu-id="bc823-214">버퍼를 여러 개 지정하고 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 속성이 null이 아닌 경우에도 이 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-214">This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-215">인수가 범위를 벗어난 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-215">An argument is out of range.</span>
          </span>
          <span data-ttu-id="bc823-216">
            <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />가 0보다 작으면 이 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-216">The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-217">잘못된 작업이 요청된 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-217">An invalid operation was requested.</span>
          </span>
          <span data-ttu-id="bc823-218">받아들이는 <see cref="T:System.Net.Sockets.Socket" />이 연결을 수신 대기하지 않거나 받아들인 소켓이 바인딩되어 있으면 이 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-218">This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.</span>
          </span>
          <span data-ttu-id="bc823-219">
            <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 메서드를 호출하기 전에 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 및 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 메서드를 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-219">You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span>
          </span>
          <span data-ttu-id="bc823-220">소켓이 이미 연결되어 있거나 지정된 <paramref name="e" /> 매개 변수를 사용하여 소켓 작업이 이미 진행 중인 경우에도 이 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-220">This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-221">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-221">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-222">이 메서드에 Windows XP 이상이 필요한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-222">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-223">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-223">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-224">
            <see cref="T:System.Net.Sockets.Socket" />의 주소 패밀리를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-224">Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-225">
            <see cref="T:System.Net.Sockets.AddressFamily" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-225">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-226"><xref:System.Net.Sockets.AddressFamily> 주소 지정 체계를 지정 인스턴스의 <xref:System.Net.Sockets.Socket> 클래스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-226">The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use.</span></span> <span data-ttu-id="bc823-227">이 속성은 읽기 전용 및 경우 설정 됩니다는 <xref:System.Net.Sockets.Socket> 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-227">This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-228">다음 코드 예제는 <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, 및 <xref:System.Net.Sockets.ProtocolType> 콘솔.</span><span class="sxs-lookup"><span data-stu-id="bc823-228">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-229">네트워크에서 받아서 읽을 수 있는 데이터의 양을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-229">Gets the amount of data that has been received from the network and is available to be read.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-230">네트워크에서 받아서 읽을 수 있는 데이터의 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-230">The number of bytes of data received from the network and available to be read.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-231">비블로킹을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> 가 호출 하기 전에 읽기에 대 한 데이터가 대기 될 수 있는지 여부를 결정 하는 좋은 방법은 <xref:System.Net.Sockets.Socket.Receive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-231">If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="bc823-232">사용 가능한 데이터 읽기에 대 한 네트워크 버퍼에 대기 하는 데이터의 총 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-232">The available data is the total amount of data queued in the network buffer for reading.</span></span> <span data-ttu-id="bc823-233">네트워크 버퍼에서 대기 중인 데이터가 없을 경우 <xref:System.Net.Sockets.Socket.Available%2A> 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-233">If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.</span></span>  
  
 <span data-ttu-id="bc823-234">원격 호스트 종료 되거나 연결이 닫히면 <xref:System.Net.Sockets.Socket.Available%2A> throw 할 수는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-234">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-235">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-235">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-236">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-236">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-237">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-237">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-238">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-238">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-239">다음 코드 예제에서는 호출 IOControl FIONREAD 및 사용 가능한 속성을 사용 하 여 결과 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-239">The following code example compares the results of calling IOControl with FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-240">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-240">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-241">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-241">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-242">들어오는 연결 시도를 받아들이는 비동기 작업을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-242">Begins an asynchronous operation to accept an incoming connection attempt.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="bc823-243">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-243">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-244">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-244">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-245">들어오는 연결 시도를 받아들이는 비동기 작업을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-245">Begins an asynchronous operation to accept an incoming connection attempt.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-246">비동기 <see cref="T:System.IAsyncResult" /> 생성을 참조하는 <see cref="T:System.Net.Sockets.Socket" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-246">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-247">연결 지향 프로토콜에서 사용할 수는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 들어오는 연결을 비동기적으로 처리를 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-247">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="bc823-248">비동기적으로 연결을 허용 하면 별도 실행 스레드 내에서 데이터를 주고받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-248">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="bc823-249">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.Listen%2A> 수신 대기 하 고 들어오는 연결 요청을 큐에 대 한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-249">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="bc823-250">구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-250">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="bc823-251">수신 대기 전달 해야이를 위해서는, 최소한 <xref:System.Net.Sockets.Socket> 개체를 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-251">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="bc823-252">콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-252">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="bc823-253">이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-253">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-254">콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-254">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="bc823-255">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginAccept%2A>, 시스템에서 일반적으로 지정 된 콜백 메서드를 실행 하는 별도 스레드를 사용 하 고에서 차단 <xref:System.Net.Sockets.Socket.EndAccept%2A> 보류 중인 연결 검색 될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-255">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span> <span data-ttu-id="bc823-256"><xref:System.Net.Sockets.Socket.EndAccept%2A> 새 돌아갑니다 <xref:System.Net.Sockets.Socket> 원격 호스트를 사용 하 여 데이터를 받고 보내는 데 사용할 수 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-256"><xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="bc823-257">반환이 사용할 수 없습니다 <xref:System.Net.Sockets.Socket> 연결 큐에서 모든 추가 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-257">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="bc823-258">원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 사용 하 여 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-258">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-259">Set 메서드를 호출을 <xref:System.Threading.ManualResetEvent> 콜백 메서드에서 원래 스레드가 계속 실행 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="bc823-259">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="bc823-260">시스템 콜백 메서드를 호출 하는 호출 스레드를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-260">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="bc823-261">이 경우에 <xref:System.IAsyncResult.CompletedSynchronously%2A> 속성에서 반환 된 <xref:System.IAsyncResult> 나타내는로 설정 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 동기적으로 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-261">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="bc823-262">콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-262">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="bc823-263">보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-263">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-264">경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-264">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="bc823-265">이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-265">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-266">사용할 수는 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 반환 된 속성 <xref:System.Net.Sockets.Socket> 원격 호스트의 네트워크 주소 및 포트 번호를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-266">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-267">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-267">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-268">이 코드를 가져온 후의 Windows 소켓 버전 2 API 오류 코드 설명서에서 MSDN에 대 한 자세한 설명은 오류를 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="bc823-268">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-269">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-269">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-270">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-270">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-271">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-271">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-272">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-272">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-273">다음 코드 예제에서는 비동기적으로 들어오는 연결을 수신 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-273">The following code example attempts to receive an incoming connection asynchronously.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-274">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-274">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-275">이 메서드에는 Windows NT가 필요합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-275">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-276">받아들이는 소켓이 연결을 수신하지 않는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-276">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="bc823-277">
            <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />를 호출하기 전에 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 및 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />을 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-277">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
          <span data-ttu-id="bc823-278">-또는-  받아들여진 소켓이 바인딩됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-278">-or-  The accepted socket is bound.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-279">
            <paramref name="receiveSize" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-279">
              <paramref name="receiveSize" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-280">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-280">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">
          <span data-ttu-id="bc823-281">송신자로부터 받아들일 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-281">The number of bytes to accept from the sender.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-282">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-282">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-283">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-283">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-284">들어오는 연결 시도를 받아들이는 비동기 작업을 시작하고 클라이언트 응용 프로그램에서 보낸 데이터의 첫 번째 블록을 받습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-284">Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-285">비동기 <see cref="T:System.IAsyncResult" /> 생성을 참조하는 <see cref="T:System.Net.Sockets.Socket" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-285">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-286">연결 지향 프로토콜에서 사용할 수는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 들어오는 연결을 비동기적으로 처리를 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-286">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="bc823-287">연결을 비동기적으로 수락 별도 실행 스레드 내에서 데이터를 주고받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-287">Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="bc823-288">이 오버 로드를 사용 하면 초기 전송에 동의 하는 바이트 수를 지정할 수 있습니다는 `receiveSize` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-288">This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="bc823-289">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.Listen%2A> 수신 대기 하 고 들어오는 연결 요청을 큐에 대 한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-289">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="bc823-290">구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-290">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="bc823-291">수신 대기 전달 해야이를 위해서는, 최소한 <xref:System.Net.Sockets.Socket> 개체를 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-291">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="bc823-292">콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-292">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="bc823-293">이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-293">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-294">콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-294">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="bc823-295">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginAccept%2A>, 시스템에서 일반적으로 지정 된 콜백 메서드를 실행 하는 별도 스레드를 사용 하 고에서 차단 <xref:System.Net.Sockets.Socket.EndAccept%2A> 보류 중인 연결 검색 될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-295">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="bc823-296"><xref:System.Net.Sockets.Socket.EndAccept%2A> 반환 된 새 <xref:System.Net.Sockets.Socket> 원격 호스트를 사용 하 여 데이터를 받고 보내는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-296"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="bc823-297">반환이 사용할 수 없습니다 <xref:System.Net.Sockets.Socket> 연결 큐에서 모든 추가 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-297">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="bc823-298">원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 사용 하 여 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-298">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-299">Set 메서드를 호출을 <xref:System.Threading.ManualResetEvent> 콜백 메서드에서 원래 스레드가 계속 실행 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="bc823-299">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="bc823-300">시스템 콜백 메서드를 호출 하는 호출 스레드를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-300">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="bc823-301">이 경우에 <xref:System.IAsyncResult.CompletedSynchronously%2A> 속성에서 반환 된 <xref:System.IAsyncResult> 나타내는로 설정 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 동기적으로 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-301">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="bc823-302">콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-302">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="bc823-303">보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-303">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span>  <span data-ttu-id="bc823-304">경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-304">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="bc823-305">이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-305">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-306">사용 하 여 호출할 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 반환 된 속성 <xref:System.Net.Sockets.Socket> 원격 호스트의 네트워크 주소 및 포트 번호를 식별 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-306">You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-307">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-307">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-308">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-308">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-309">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-309">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-310">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-310">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-311">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-311">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-312">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-312">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-313">다음 코드 예제에서는 소켓을 열어 및 비동기 연결을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-313">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="bc823-314">이 예제에서는 소켓 초기 10 바이트의 데이터를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-314">In this example, the socket accepts the initial 10 bytes of data.</span></span> <span data-ttu-id="bc823-315">받은 바이트 수와 데이터는 콜백 대리자에 의해 콘솔에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-315">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="bc823-316">참조 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 에 대 한 설명은 나머지 데이터는 어떻게 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-316">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-317">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-317">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-318">이 메서드에는 Windows NT가 필요합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-318">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-319">받아들이는 소켓이 연결을 수신하지 않는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-319">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="bc823-320">
            <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />를 호출하기 전에 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 및 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />을 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-320">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
          <span data-ttu-id="bc823-321">-또는-  받아들여진 소켓이 바인딩됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-321">-or-  The accepted socket is bound.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-322">
            <paramref name="receiveSize" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-322">
              <paramref name="receiveSize" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-323">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-323">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">
          <span data-ttu-id="bc823-324">허용되는 <see cref="T:System.Net.Sockets.Socket" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-324">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
          <span data-ttu-id="bc823-325">이 값은 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-325">This value may be <see langword="null" />.</span>
          </span>
        </param>
        <param name="receiveSize">
          <span data-ttu-id="bc823-326">받을 최대 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-326">The maximum number of bytes to receive.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-327">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-327">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-328">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-328">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-329">지정된 소켓에서 들어오는 연결 시도를 받아들이는 비동기 작업을 시작하고 클라이언트 응용 프로그램에서 보낸 데이터의 첫 번째 블록을 받습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-329">Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-330">비동기 <see cref="T:System.IAsyncResult" /> 개체 생성을 참조하는 <see cref="T:System.Net.Sockets.Socket" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-330">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-331">연결 지향 프로토콜에서 사용할 수는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 들어오는 연결을 비동기적으로 처리를 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-331">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="bc823-332">비동기적으로 연결을 허용 하면 별도 실행 스레드 내에서 데이터를 주고받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-332">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="bc823-333">이 오버 로드를 사용 하면에 수락한 소켓을 지정할 수 있습니다는 `acceptSocket` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-333">This overload allows you to specify the accepted socket in the `acceptSocket` parameter.</span></span> <span data-ttu-id="bc823-334">이 매개 변수가 `null`, 받아들여진된 소켓이 만들어집니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-334">If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="bc823-335">초기 전송에 동의 하는 바이트 수를 지정할 수는 `receiveSize` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-335">You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="bc823-336">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.Listen%2A> 수신 대기 하 고 들어오는 연결 요청을 큐에 대 한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-336">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="bc823-337">구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-337">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="bc823-338">수신 대기 전달 해야이를 위해서는, 최소한 <xref:System.Net.Sockets.Socket> 개체를 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-338">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="bc823-339">콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-339">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="bc823-340">이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-340">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-341">콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-341">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="bc823-342">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginAccept%2A>, 시스템에서 일반적으로 지정 된 콜백 메서드를 실행 하는 별도 스레드를 사용 하 고에서 차단 <xref:System.Net.Sockets.Socket.EndAccept%2A> 보류 중인 연결 검색 될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-342">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="bc823-343"><xref:System.Net.Sockets.Socket.EndAccept%2A> 반환 된 새 <xref:System.Net.Sockets.Socket> 원격 호스트를 사용 하 여 데이터를 받고 보내는 데 사용할 수 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-343"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="bc823-344">반환이 사용할 수 없습니다 <xref:System.Net.Sockets.Socket> 연결 큐에서 모든 추가 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-344">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="bc823-345">원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 사용 하 여 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-345">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-346">Set 메서드를 호출을 <xref:System.Threading.ManualResetEvent> 콜백 메서드에서 원래 스레드가 계속 실행 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="bc823-346">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="bc823-347">시스템 콜백 메서드를 호출 하는 호출 스레드를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-347">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="bc823-348">이 경우에 <xref:System.IAsyncResult.CompletedSynchronously%2A> 속성에서 반환 된 <xref:System.IAsyncResult> 나타내는로 설정 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 동기적으로 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-348">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="bc823-349">콜백 메서드를 작성에 대 한 자세한 내용은 참조 하세요. [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-349">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="bc823-350">보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-350">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-351">경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-351">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="bc823-352">이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-352">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-353">사용할 수는 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 반환 된 속성 <xref:System.Net.Sockets.Socket> 원격 호스트의 네트워크 주소 및 포트 번호를 식별 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-353">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-354">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-354">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-355">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-355">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-356">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-356">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-357">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-357">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-358">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-358">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-359">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-359">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-360">다음 코드 예제에서는 소켓을 열어 및 비동기 연결을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-360">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="bc823-361">이 예제에서는 소켓 수락 초기 10 바이트의 데이터 및 `acceptSocket` 매개 변수는 `null`는 강제로 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 받아들여진된 소켓이 만드는 방법.</span><span class="sxs-lookup"><span data-stu-id="bc823-361">In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket.</span></span> <span data-ttu-id="bc823-362">받은 바이트 수와 데이터는 콜백 대리자에 의해 콘솔에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-362">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="bc823-363">참조 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 에 대 한 설명은 나머지 데이터는 어떻게 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-363">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-364">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-364">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-365">이 메서드에는 Windows NT가 필요합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-365">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-366">받아들이는 소켓이 연결을 수신하지 않는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-366">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="bc823-367">
            <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />를 호출하기 전에 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 및 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />을 호출해야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-367">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
          <span data-ttu-id="bc823-368">-또는-  받아들여진 소켓이 바인딩됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-368">-or-  The accepted socket is bound.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-369">
            <paramref name="receiveSize" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-369">
              <paramref name="receiveSize" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-370">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-370">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-371">원격 호스트 연결에 대한 비동기 요청을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-371">Begins an asynchronous request for a remote host connection.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <span data-ttu-id="bc823-372">원격 호스트를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-372">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span>
          </span>
        </param>
        <param name="end_point">
          <span data-ttu-id="bc823-373">원격 호스트를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-373">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-374">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-374">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-375">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-375">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-376">원격 호스트 연결에 대한 비동기 요청을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-376">Begins an asynchronous request for a remote host connection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-377">비동기 연결을 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-377">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-378">연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 에 대 한 연결에 대 한 비동기 요청을 시작 하는 메서드는 `remoteEP` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-378">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter.</span></span> <span data-ttu-id="bc823-379">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-379">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host.</span></span> <span data-ttu-id="bc823-380">기본 원격 호스트를 비동기적으로 설정 하거나 연결을 별도 실행 스레드 내에서 데이터 전송 및 수신 하는 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-380">Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="bc823-381">구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-381">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span> <span data-ttu-id="bc823-382">최소한를 전달 해야 합니다는 <xref:System.Net.Sockets.Socket> 하 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 통해를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-382">At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter.</span></span> <span data-ttu-id="bc823-383">콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket>, 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-383">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="bc823-384">이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-384">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-385">콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-385">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="bc823-386">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginConnect%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndConnect%2A> 때까지 <xref:System.Net.Sockets.Socket> 성공적으로 연결 하거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-386">When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception.</span></span> <span data-ttu-id="bc823-387">원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 사용 하 여 <xref:System.Threading.WaitHandle.WaitOne%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-387">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="bc823-388">Set 메서드를 호출을 <xref:System.Threading.ManualResetEvent> 콜백 메서드에서 원래 스레드가 계속 실행 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="bc823-388">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="bc823-389">콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-389">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="bc823-390">UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 데이터 보내기 및 받기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-390">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data.</span></span> <span data-ttu-id="bc823-391">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 고 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 원격 호스트와 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-391">You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host.</span></span> <span data-ttu-id="bc823-392">호출 하는 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-392">If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="bc823-393">먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 브로드캐스트 설정 하 고 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-393">If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="bc823-394">그렇게 할 수 없으면 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-394">If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-395">연결 지향 프로토콜을 사용 하 고 호출 하지 마세요 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-395">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="bc823-396">호출 하기 전에 서비스 공급자가 로컬 네트워크 주소 및 포트 번호를 연결 없는 프로토콜을 사용 하는 경우 할당 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 또는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-396">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-397">기본 원격 호스트를 변경 하려는 경우 호출 된 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 원하는 끝점을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-397">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="bc823-398">보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-398">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-399">경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-399">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="bc823-400">이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-400">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-401">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-401">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-402">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-402">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-403">이 소켓의 이전 연결이 끊어지면 다음 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 작업이 완료 될 때까지 종료 되지 않는 스레드에서 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-403">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="bc823-404">기본 공급자의 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-404">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-405">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-405">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-406">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-406">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-407">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-407">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-408">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-408">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-409">다음 코드 예제에서는 비동기 연결 시도 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-409">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-410">
            <paramref name="remoteEP" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-410">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-411">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-411">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-412">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-412">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-413">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-413">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-414">
            <see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었거나 비동기 작업이 이미 진행 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-414">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="bc823-415">콜백 메서드로 대리자 마샬링</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-415">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="bc823-416">비동기 클라이언트 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-416">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="bc823-417">비동기 서버 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-417">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="bc823-418">원격 호스트의 <see cref="T:System.Net.IPAddress" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-418">The <see cref="T:System.Net.IPAddress" /> of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="bc823-419">원격 호스트의 포트 번호입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-419">The port number of the remote host.</span>
          </span>
        </param>
        <param name="requestCallback">
          <span data-ttu-id="bc823-420">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-420">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-421">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-421">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-422">연결 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-422">A user-defined object that contains information about the connect operation.</span>
          </span>
          <span data-ttu-id="bc823-423">이 개체는 작업이 완료되면 <c>requestCallback</c> 대리자에게 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-423">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-424">원격 호스트 연결에 대한 비동기 요청을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-424">Begins an asynchronous request for a remote host connection.</span>
          </span>
          <span data-ttu-id="bc823-425">호스트는 <see cref="T:System.Net.IPAddress" />와 포트 번호로 지정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-425">The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-426">비동기 연결을 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-426">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-427">비동기 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-427">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="bc823-428">메서드는 일반적으로 `requestCallback` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-428">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="bc823-429">이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-429">This method does not block until the operation is complete.</span></span> <span data-ttu-id="bc823-430">작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 오버 로드 또는 <xref:System.Net.Sockets.Socket.EndConnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-430">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span></span>  
  
 <span data-ttu-id="bc823-431">보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-431">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-432">경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-432">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="bc823-433">이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-433">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="bc823-434">비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="bc823-434">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-435">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-435">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-436">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-436">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-437">이 소켓의 이전 연결이 끊어지면 다음 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 작업이 완료 될 때까지 종료 되지 않는 스레드에서 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-437">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="bc823-438">기본 공급자의 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-438">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="bc823-439">또한는 <xref:System.Net.EndPoint> 즉 사용 되는 달라 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-439">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-440">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-440">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-441">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-441">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-442">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-442">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-443">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-443">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-444">다음 코드 예제에서는 비동기 연결 시도 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-444">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-445">
            <paramref name="address" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-445">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-446">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-446">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-447">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-447">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-448">
            <see cref="T:System.Net.Sockets.Socket" />이 소켓 패밀리에 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-448">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-449">포트 번호가 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-449">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-450">
            <paramref name="address" />의 길이가 0인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-450">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-451">
            <see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었거나 비동기 작업이 이미 진행 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-451">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="bc823-452">콜백 메서드로 대리자 마샬링</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-452">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="bc823-453">비동기 클라이언트 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-453">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="bc823-454">비동기 서버 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-454">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses">
          <span data-ttu-id="bc823-455">원격 호스트를 지정하는 하나 이상의 <see cref="T:System.Net.IPAddress" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-455">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="bc823-456">원격 호스트의 포트 번호입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-456">The port number of the remote host.</span>
          </span>
        </param>
        <param name="requestCallback">
          <span data-ttu-id="bc823-457">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-457">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-458">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-458">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-459">연결 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-459">A user-defined object that contains information about the connect operation.</span>
          </span>
          <span data-ttu-id="bc823-460">이 개체는 작업이 완료되면 <c>requestCallback</c> 대리자에게 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-460">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-461">원격 호스트 연결에 대한 비동기 요청을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-461">Begins an asynchronous request for a remote host connection.</span>
          </span>
          <span data-ttu-id="bc823-462">호스트는 <see cref="T:System.Net.IPAddress" /> 배열과 포트 번호로 지정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-462">The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-463">비동기 연결을 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-463">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-464">비동기 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-464">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="bc823-465">메서드는 일반적으로 `requestCallback` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-465">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="bc823-466">이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-466">This method does not block until the operation is complete.</span></span> <span data-ttu-id="bc823-467">작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-467">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="bc823-468">보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-468">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-469">경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-469">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="bc823-470">이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-470">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="bc823-471">비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-471">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-472">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-472">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-473">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-473">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-474">이 소켓의 이전 연결이 끊어지면 다음 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 작업이 완료 될 때까지 종료 되지 않는 스레드에서 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-474">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="bc823-475">기본 공급자의 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-475">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="bc823-476">또한는 <xref:System.Net.EndPoint> 즉 사용 되는 달라 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-476">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-477">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-477">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-478">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-478">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-479">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-479">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-480">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-480">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-481">다음 코드 예제에서는 비동기 연결 시도 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-481">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-482">
            <paramref name="addresses" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-482">
              <paramref name="addresses" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-483">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-483">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-484">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-484">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-485">이 메서드는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />를 사용하는 소켓에 유효합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-485">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-486">포트 번호가 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-486">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-487">
            <paramref name="address" />의 길이가 0인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-487">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-488">
            <see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었거나 비동기 작업이 이미 진행 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-488">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="bc823-489">콜백 메서드로 대리자 마샬링</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-489">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="bc823-490">비동기 클라이언트 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-490">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="bc823-491">비동기 서버 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-491">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="bc823-492">원격 호스트의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-492">The name of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="bc823-493">원격 호스트의 포트 번호입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-493">The port number of the remote host.</span>
          </span>
        </param>
        <param name="requestCallback">
          <span data-ttu-id="bc823-494">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-494">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-495">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-495">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-496">연결 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-496">A user-defined object that contains information about the connect operation.</span>
          </span>
          <span data-ttu-id="bc823-497">이 개체는 작업이 완료되면 <c>requestCallback</c> 대리자에게 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-497">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-498">원격 호스트 연결에 대한 비동기 요청을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-498">Begins an asynchronous request for a remote host connection.</span>
          </span>
          <span data-ttu-id="bc823-499">호스트는 호스트 이름과 포트 번호로 지정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-499">The host is specified by a host name and a port number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-500">비동기 연결을 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-500">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-501">비동기 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-501">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="bc823-502">메서드는 일반적으로 `requestCallback` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-502">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="bc823-503">이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-503">This method does not block until the operation is complete.</span></span> <span data-ttu-id="bc823-504">작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-504">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="bc823-505">보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-505">To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-506">경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-506">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="bc823-507">이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-507">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="bc823-508">비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="bc823-508">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-509">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-509">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-510">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-510">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-511">이 소켓의 이전 연결이 끊어지면 다음 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 작업이 완료 될 때까지 종료 되지 않는 스레드에서 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-511">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="bc823-512">기본 공급자의 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-512">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="bc823-513">또한는 <xref:System.Net.EndPoint> 즉 사용 되는 달라 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-513">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-514">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-514">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-515">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-515">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-516">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-516">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-517">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-517">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-518">다음 코드 예제에서는 비동기 연결 시도 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-518">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-519">
            <paramref name="host" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-519">
              <paramref name="host" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-520">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-520">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-521">이 메서드는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 제품군의 소켓에 유효합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-521">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-522">포트 번호가 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-522">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-523">
            <see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었거나 비동기 작업이 이미 진행 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-523">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="bc823-524">콜백 메서드로 대리자 마샬링</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-524">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="bc823-525">비동기 클라이언트 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-525">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="bc823-526">비동기 서버 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-526">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="bc823-527">연결을 닫은 다음 이 소켓을 다시 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-527">
              <see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-528">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-528">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-529">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-529">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-530">원격 끝점과의 연결을 끊는 비동기 요청을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-530">Begins an asynchronous request to disconnect from a remote endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-531">비동기 작업을 참조하는 <see cref="T:System.IAsyncResult" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-531">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-532">연결 지향 프로토콜을 사용 하는 경우 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 원격 끝점 으로부터의 연결을 끊도록을 요청 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-532">If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint.</span></span> <span data-ttu-id="bc823-533">하는 경우 `reuseSocket` 는 `true`, 소켓을 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-533">If `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="bc823-534"><xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 메서드 별도 스레드를 사용 하 여 지정된 된 콜백 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-534">The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method.</span></span> <span data-ttu-id="bc823-535"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> 완료 보류 중 연결 해제 될 때까지 메서드가 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-535">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete.</span></span> <span data-ttu-id="bc823-536">콜백 메서드를 작성에 대 한 자세한 내용은 참조 하세요. [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-536">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-537">표시 되 면을 <xref:System.Net.Sockets.SocketException> 예외를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-537">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-538">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-538">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-539">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-539">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-540">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-540">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-541">다음 코드 예제에서는 비동기 통신을 위한 소켓을 만들고 원격 호스트에 일부 데이터를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-541">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="bc823-542">데이터를 보낼 때 <xref:System.Net.Sockets.Socket.Shutdown%2A> 송신을 중지 하 고 작업을 수신 하기 위해 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-542">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="bc823-543">그런 다음 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 연결 끊기 요청을 시작 하기 위해 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-543">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="bc823-544">요청이 완료 되 면는 <xref:System.Net.Sockets.Socket.Connected%2A> 속성 소켓 연결이 있는지 여부를 테스트 하기 위해 쿼리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-544">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-545">이 메서드에는 Windows XP가 필요한데 운영 체제가 Windows 2000 또는 그 이전 버전인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-545">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-546">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-546">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-547">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-547">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-548">연결된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 비동기적으로 받기 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-548">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="bc823-549">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-549">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-550">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-550">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-551">작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-551">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-552">수신 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-552">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="bc823-553">이 개체는 작업이 완료되면 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 대리자에게 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-553">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-554">연결된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 비동기적으로 받기 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-554">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-555">비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-555">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-556">비동기 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-556">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="bc823-557">메서드는 일반적으로 `callback` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-557">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="bc823-558">이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-558">This method does not block until the operation is complete.</span></span> <span data-ttu-id="bc823-559">작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-559">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="bc823-560">취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-560">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-561">비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-561">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-562">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-562">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-563">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-563">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-564">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-564">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-565">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-565">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-566">`state` 사용자 정의 클래스의 인스턴스화가입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-566">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-567">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-567">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-568">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-568">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-569">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-569">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-570">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-570">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-571">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-571">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-572">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-572">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-573">
            <see cref="T:System.Net.Sockets.Socket" />이 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-573">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="bc823-574">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-574">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-575">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-575">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="bc823-576">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-576">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-577">작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-577">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-578">수신 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-578">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="bc823-579">이 개체는 작업이 완료되면 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 대리자에게 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-579">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-580">연결된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 비동기적으로 받기 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-580">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-581">비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-581">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-582">비동기 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-582">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="bc823-583">메서드는 일반적으로 `callback` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-583">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="bc823-584">이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-584">This method does not block until the operation is complete.</span></span> <span data-ttu-id="bc823-585">작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-585">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="bc823-586">취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-586">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-587">비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-587">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-588">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-588">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-589">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-589">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-590">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-590">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-591">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-591">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-592">`state` 사용자 정의 클래스의 인스턴스화가입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-592">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-593">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-593">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-594">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-594">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-595">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-595">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-596">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-596">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-597">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-597">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-598">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-598">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-599">
            <see cref="T:System.Net.Sockets.Socket" />이 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-599">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-600">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-600">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-601">받은 데이터를 저장하기 위한 <c>buffer</c> 매개 변수의 위치(0부터 시작)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-601">The zero-based position in the <c>buffer</c> parameter at which to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-602">수신 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-602">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-603">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-603">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="socket_flags">
          <span data-ttu-id="bc823-604">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-604">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-605">작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-605">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-606">수신 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-606">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="bc823-607">이 개체는 작업이 완료되면 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 대리자에게 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-607">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-608">연결된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 비동기적으로 받기 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-608">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-609">비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-609">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-610">비동기 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-610">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="bc823-611">메서드는 일반적으로 `callback` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-611">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="bc823-612">이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-612">This method does not block until the operation is complete.</span></span> <span data-ttu-id="bc823-613">작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-613">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="bc823-614">취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-614">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-615">비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-615">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-616">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-616">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-617">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-617">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-618">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-618">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-619">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-619">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-620">`state` 사용자 정의 클래스의 인스턴스화가입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-620">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-621">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-621">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-622">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-622">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-623">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-623">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-624">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-624">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-625">다음 코드 예제에서는 연결 된 데이터를 비동기적으로 받으려면 시작 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-625">The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-626">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-626">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-627">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-627">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-628">
            <see cref="T:System.Net.Sockets.Socket" />이 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-628">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-629">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-629">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-630">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-630">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-631">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-631">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-632">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-632">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="bc823-633">콜백 메서드로 대리자 마샬링</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-633">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="bc823-634">비동기 클라이언트 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-634">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="bc823-635">비동기 서버 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-635">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-636">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-636">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-637">받은 데이터를 저장할 <c>버퍼</c> 내의 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-637">The location in <c>buffer</c> to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-638">수신 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-638">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-639">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-639">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="bc823-640">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-640">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="bc823-641">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-641">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="error">
          <span data-ttu-id="bc823-642">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-642">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-643">작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-643">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-644">수신 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-644">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="bc823-645">이 개체는 작업이 완료되면 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 대리자에게 전달됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-645">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-646">연결된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 비동기적으로 받기 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-646">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-647">비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-647">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-648">비동기 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-648">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="bc823-649">메서드는 일반적으로 `callback` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-649">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="bc823-650">이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-650">This method does not block until the operation is complete.</span></span> <span data-ttu-id="bc823-651">작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-651">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="bc823-652">취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-652">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-653">비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-653">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-654">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-654">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-655">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-655">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-656">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-656">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-657">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-657">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-658">`state` 사용자 정의 클래스의 인스턴스화가입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-658">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-659">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-659">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-660">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-660">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-661">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-661">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-662">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-662">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-663">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-663">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-664">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-664">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-665">
            <see cref="T:System.Net.Sockets.Socket" />이 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-665">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-666">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-666">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-667">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-667">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-668">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-668">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-669">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-669">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="bc823-670">콜백 메서드로 대리자 마샬링</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-670">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="bc823-671">비동기 클라이언트 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-671">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="bc823-672">비동기 서버 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-672">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-673">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-673">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-674">데이터를 저장하기 위한 <c>buffer</c> 매개 변수의 위치(0부터 시작)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-674">The zero-based position in the <c>buffer</c> parameter at which to store the data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-675">수신 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-675">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-676">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-676">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="socket_flags">
          <span data-ttu-id="bc823-677">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-677">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-678">데이터의 소스를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-678">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span>
          </span>
        </param>
        <param name="remote_end">
          <span data-ttu-id="bc823-679">데이터의 소스를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-679">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-680">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-680">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-681">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-681">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-682">지정된 네트워크 장치에서 비동기적으로 데이터를 받기 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-682">Begins to asynchronously receive data from a specified network device.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-683">비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-683">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-684"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드 비동기적으로 원격 호스트에서 연결 없는 데이터 그램을 읽기 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-684">The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host.</span></span> <span data-ttu-id="bc823-685">호출 된 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-685">Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="bc823-686">구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-686">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-687">최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-687">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="bc823-688">콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-688">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="bc823-689">이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-689">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-690">콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-690">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-691">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>시스템 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는, 및에서 차단 됩니다 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 때까지 <xref:System.Net.Sockets.Socket> 데이터를 읽거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-691">When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception.</span></span> <span data-ttu-id="bc823-692">원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드를 사용 하 여 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-692">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-693">원래 스레드를 계속 실행 하려는 경우 콜백 메서드에서 받으며에서 Set 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-693">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="bc823-694">콜백 메서드를 작성에 대 한 자세한 내용은 참조 하세요. [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-694">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-695">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, 명시적으로 바인딩해야 합니다 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 또는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="bc823-695">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-696">이 메서드는 데이터를 읽습니다는 `buffer` 매개 변수를 캡처를 원격 데이터를 전송 하는 끝점을 호스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-696">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent.</span></span> <span data-ttu-id="bc823-697">이 끝점을 검색 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-697">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="bc823-698">이 메서드는 비동기적으로 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 가장 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-698">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span> <span data-ttu-id="bc823-699">이러한 경우 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 는 로컬 네트워크 버퍼에 받은 첫 번째 큐에 넣은 데이터 그램을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-699">In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="bc823-700">받게 데이터 그램의 크기 보다 큰 경우 `buffer`, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드를 채울 `buffer` 으로 가능한 한 throw 되는 메시지의 대부분을 <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="bc823-700">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-701">신뢰할 수 없는 프로토콜을 사용 하는 경우 과도 한 데이터 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-701">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="bc823-702">신뢰할 수 있는 프로토콜을 사용 하는, 과도 한 데이터는 서비스 공급자가 유지 되 고 호출 하 여 검색할 수 있습니다는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 충분히 큰 버퍼를 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-702">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="bc823-703">항상 반환 되는 원격 호스트 끝점에는 응용 프로그램을 명시적으로 바인딩해야 하는 데는 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드 및 호출 합니다 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드를 `optionLevel` 매개변수설정<xref:System.Net.Sockets.SocketOptionLevel.IP>또는 <xref:System.Net.Sockets.SocketOptionLevel.IPv6> 적절 하 게 합니다 `optionName` 매개 변수 설정 <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, 및 `optionValue` 호출 하기 전에이 옵션을 사용 하도록 설정 하려면 매개 변수는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-703">To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-704">그렇지 않을 경우 반환 되지 않을 때 보낸 데이터 그램의 수를 수신기가 호출 되기 전에 원격 호스트 끝점에 대 한 가능한는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-704">Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-705">하지만 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 것 연결 없는 프로토콜에 대 한 연결 지향 프로토콜도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-705">Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="bc823-706">작업을 수행 하려는 경우 먼저 하거나 설정 해야 원격 호스트 연결을 호출 하 여는 <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 호출 하 여 들어오는 연결 요청을 수락 하거나 합니다 <xref:System.Net.Sockets.Socket.Accept%2A> 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-706">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="bc823-707">호출 하는 경우는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 을 설정 하거나 연결을 허용 하기 전에 메서드를 받을 수는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-707">If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-708">호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-708">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-709">이러한 경우 중를 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드는 무시를 `remoteEP` 매개 변수 및 데이터로 연결된 된 또는 기본 원격 호스트에만 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-709">In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="bc823-710">연결 지향 소켓 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 을 사용 하 여 지정 된 바이트 수 만큼 데이터를 읽습니다는 `size` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-710">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span>  
  
 <span data-ttu-id="bc823-711">취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-711">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-712">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-712">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-713">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-713">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-714">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-714">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-715">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-715">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-716">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-716">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-717">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-717">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-718">다음 코드 예제는 원격 호스트에서 연결 없는 데이터 그램을 비동기적으로 받습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-718">The following code example asynchronously receives connectionless datagrams from a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-719">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-719">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-720">-또는-  <paramref name="remoteEP" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-720">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-721">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-721">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-722">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-722">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-723">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-723">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-724">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-724">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-725">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-725">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-726">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-726">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-727">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-727">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="bc823-728">콜백 메서드로 대리자 마샬링</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-728">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-729">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-729">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-730">데이터를 저장하기 위한 <c>buffer</c> 매개 변수의 위치(0부터 시작)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-730">The zero-based position in the <c>buffer</c> parameter at which to store the data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-731">수신 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-731">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-732">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-732">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-733">데이터의 소스를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-733">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-734">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-734">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-735">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-735">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-736">비동기적으로 지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 데이터 버퍼의 특정 위치로 원하는 바이트 수의 데이터를 받고 끝점 및 패킷 정보를 저장하는 작업을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-736">Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information..</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-737">비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-737">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-738">비동기 수신 작업을 호출 하 여 완료 해야 합니다는 <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-738">The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method.</span></span> <span data-ttu-id="bc823-739">메서드는 일반적으로 `asyncCallback` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-739">Typically, the method is invoked by the `asyncCallback` delegate.</span></span>  
  
 <span data-ttu-id="bc823-740">이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-740">This method does not block until the operation completes.</span></span> <span data-ttu-id="bc823-741">작업이 완료 될 때까지 차단 합니다 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-741">To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-742">취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-742">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-743">비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="bc823-743">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
 <span data-ttu-id="bc823-744">이 메서드는 데이터를 읽습니다는 `buffer` 받은 패킷에 대 한 정보 뿐만 아니라 매개 변수를 캡처를 원격 호스트, 데이터 전송 되는 끝점입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-744">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</span></span> <span data-ttu-id="bc823-745">이 끝점을 검색 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-745">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="bc823-746">이 메서드는 비동기적으로 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 가장 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-746">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-747">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-747">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-748">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-748">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-749">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-749">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-750">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-750">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-751">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-751">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-752">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-752">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-753">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-753">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-754">-또는-  <paramref name="remoteEP" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-754">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-755">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-755">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-756">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-756">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-757">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-757">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-758">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-758">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-759">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-759">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-760">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-760">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-761">이 메서드에는 Windows XP가 필요한데 운영 체제가 Windows 2000 또는 그 이전 버전인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-761">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-762">연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 비동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-762">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="bc823-763">보낼 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-763">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-764">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-764">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-765">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-765">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-766">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-766">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-767">연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 비동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-767">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-768">비동기 보내기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-768">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-769">합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-769">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="bc823-770"><xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 하지 않으면 예외가 throw 됩니다 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>하십시오 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-770"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="bc823-771">호출 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-771">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="bc823-772">구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-772">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="bc823-773">최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-773">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="bc823-774">작은 클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-774">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="bc823-775">이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-775">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-776">콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-776">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="bc823-777">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSend%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 때까지 <xref:System.Net.Sockets.Socket> 요청 된 바이트의 번호를 전송 하거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-777">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="bc823-778">원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드를 사용 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-778">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bc823-779">원래 스레드를 계속 실행 하려는 경우 콜백 메서드에서 받으며에서 Set 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-779">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="bc823-780">콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-780">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="bc823-781">연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-781">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="bc823-782">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-782">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="bc823-783">사용 해도 되는지 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-783">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-784">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-784">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="bc823-785">연결 없는 프로토콜 사용도 해야 버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-785">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-786">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.BeginSend%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-786">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-787">지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-787">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-788">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-788">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-789">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-789">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-790">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-790">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-791">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-791">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-792">`state` 사용자 정의 클래스의 인스턴스화가입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-792">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-793">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-793">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-794">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-794">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-795">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-795">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-796">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-796">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-797">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-797">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-798">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-798">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-799">
            <paramref name="buffers" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-799">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-800">
            <paramref name="buffers" />가 비어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-800">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-801">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-801">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-802">아래의 설명 부분을 참조하십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-802">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-803">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-803">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="bc823-804">보낼 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-804">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-805">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-805">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="bc823-806">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-806">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-807">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-807">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-808">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-808">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-809">연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 비동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-809">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-810">비동기 보내기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-810">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-811">합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-811">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="bc823-812"><xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 하지 않으면 예외가 throw 됩니다 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>하십시오 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-812"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="bc823-813">호출 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-813">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="bc823-814">구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-814">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="bc823-815">최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-815">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="bc823-816">작은 클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-816">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="bc823-817">이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-817">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-818">콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-818">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="bc823-819">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSend%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 때까지 <xref:System.Net.Sockets.Socket> 요청 된 바이트의 번호를 전송 하거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-819">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="bc823-820">원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드를 사용 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-820">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bc823-821">Set 메서드를 호출을 <xref:System.Threading.ManualResetEvent> 콜백 메서드에서 원래 스레드가 계속 실행 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="bc823-821">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="bc823-822">콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-822">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="bc823-823">연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-823">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="bc823-824">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-824">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="bc823-825">사용 해도 되는지 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-825">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-826">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-826">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="bc823-827">연결 없는 프로토콜 사용도 해야 버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-827">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-828">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.BeginSend%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-828">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-829">지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-829">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-830">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-830">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-831">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-831">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-832">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-832">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-833">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-833">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-834">`state` 사용자 정의 클래스의 인스턴스화가입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-834">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-835">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-835">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-836">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-836">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-837">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-837">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-838">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-838">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-839">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-839">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-840">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-840">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-841">
            <paramref name="buffers" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-841">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-842">
            <paramref name="buffers" />가 비어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-842">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-843">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-843">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-844">아래의 설명 부분을 참조하십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-844">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-845">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-845">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-846">보낼 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-846">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-847">데이터 보내기를 시작하기 위한 <c>buffer</c> 매개 변수의 위치(0부터 시작)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-847">The zero-based position in the <c>buffer</c> parameter at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-848">보낼 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-848">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-849">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-849">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="bc823-850">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-850">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-851">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-851">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-852">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-852">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-853">연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 비동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-853">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-854">비동기 보내기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-854">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-855">합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-855">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="bc823-856"><xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 하지 않으면 예외가 throw 됩니다 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>하십시오 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-856"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="bc823-857">호출 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-857">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="bc823-858">구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-858">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="bc823-859">최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-859">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="bc823-860">작은 클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-860">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="bc823-861">이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-861">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-862">콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-862">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="bc823-863">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSend%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 때까지 <xref:System.Net.Sockets.Socket> 요청 된 바이트의 번호를 전송 하거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-863">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="bc823-864">원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드를 사용 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-864">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bc823-865">원래 스레드를 계속 실행 하려는 경우 콜백 메서드에서 받으며에서 Set 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-865">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="bc823-866">콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-866">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="bc823-867">연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-867">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="bc823-868">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-868">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="bc823-869">사용 해도 되는지 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-869">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-870">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-870">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="bc823-871">연결 없는 프로토콜 사용도 해야 버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-871">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-872">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.BeginSend%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-872">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-873">지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-873">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-874">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-874">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-875">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-875">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-876">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-876">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-877">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-877">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-878">`state` 사용자 정의 클래스의 인스턴스화가입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-878">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-879">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-879">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-880">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-880">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-881">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-881">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-882">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-882">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-883">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-883">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-884">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-884">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-885">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-885">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-886">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-886">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-887">아래의 설명 부분을 참조하십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-887">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-888">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-888">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-889">-또는-  <paramref name="offset" />이 <paramref name="buffer" />의 길이보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-889">-or-  <paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-890">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-890">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-891">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-891">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-892">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-892">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-893">보낼 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-893">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-894">데이터 보내기를 시작하기 위한 <c>buffer</c> 매개 변수의 위치(0부터 시작)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-894">The zero-based position in the <c>buffer</c> parameter at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-895">보낼 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-895">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-896">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-896">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="socket_flags">
          <span data-ttu-id="bc823-897">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-897">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-898">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-898">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-899">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-899">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-900">연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 비동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-900">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-901">비동기 보내기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-901">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-902">합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-902">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="bc823-903"><xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 하지 않으면 예외가 throw 됩니다 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>하십시오 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-903"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="bc823-904">호출 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-904">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="bc823-905">구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-905">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="bc823-906">최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-906">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="bc823-907">작은 클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-907">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="bc823-908">이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-908">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-909">콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-909">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="bc823-910">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSend%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 때까지 <xref:System.Net.Sockets.Socket> 요청 된 바이트의 번호를 전송 하거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-910">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="bc823-911">원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드를 사용 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-911">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bc823-912">원래 스레드를 계속 실행 하려는 경우 콜백 메서드에서 받으며에서 Set 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-912">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="bc823-913">콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-913">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="bc823-914">연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-914">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="bc823-915">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-915">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="bc823-916">사용 해도 되는지 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-916">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-917">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-917">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="bc823-918">연결 없는 프로토콜 사용도 해야 버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-918">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-919">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.BeginSend%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-919">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-920">지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-920">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-921">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-921">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-922">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-922">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-923">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-923">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-924">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-924">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-925">`state` 사용자 정의 클래스의 인스턴스화가입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-925">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-926">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-926">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-927">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-927">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-928">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-928">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-929">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-929">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-930">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-930">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-931">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-931">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-932">다음 코드 예제는 비동기적으로 원격 호스트에 데이터를 보내기 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-932">The following code example begins asynchronously sending data to a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-933">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-933">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-934">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-934">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-935">아래의 설명 부분을 참조하십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-935">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-936">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-936">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-937">-또는-  <paramref name="offset" />이 <paramref name="buffer" />의 길이보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-937">-or-  <paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-938">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-938">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-939">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-939">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-940">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-940">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="bc823-941">콜백 메서드로 대리자 마샬링</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-941">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="bc823-942">비동기 클라이언트 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-942">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="bc823-943">비동기 서버 소켓 예제</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-943">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-944">파일을 연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에 비동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-944">Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="bc823-945">보낼 파일의 경로 및 이름이 들어 있는 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-945">A string that contains the path and name of the file to send.</span>
          </span>
          <span data-ttu-id="bc823-946">이 매개 변수는 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-946">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-947">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-947">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-948">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-948">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-949">
            <see cref="T:System.Net.Sockets.Socket" /> 플래그를 사용하여 <paramref name="fileName" /> 파일을 연결된 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 개체에 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-949">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-950">비동기 보내기를 나타내는 <see cref="T:System.IAsyncResult" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-950">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-951">이 오버 로드 된 파일을 보냅니다 `fileName` 연결 된 소켓입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-951">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="bc823-952">경우 `fileName` 는 로컬 디렉터리에서 식별 된 파일의 이름만 사용 하 여, 그렇지 않으면 전체 경로 및 파일의 이름을 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-952">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="bc823-953">와일드 카드 ("... \\\myfile.txt ") 및 UNC 공유 이름 ("\\\\\\\shared 디렉터리\\\myfile.txt ")는 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-953">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="bc823-954">파일이 없는 경우, 예외 <xref:System.IO.FileNotFoundException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-954">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="bc823-955">이 메서드는 사용 된 `TransmitFile` Windows Sockets 2 api에서 함수를 찾을.</span><span class="sxs-lookup"><span data-stu-id="bc823-955">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="bc823-956">에 대 한 자세한 내용은 `TransmitFile` 함수와 해당 플래그를 MSDN Library의 Windows 소켓 설명서를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="bc823-956">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="bc823-957">합니다 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-957">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="bc823-958"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> 먼저 호출 하지 않으면 예외를 throw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>를 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-958"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="bc823-959">호출 된 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 메서드를 사용 하면 별도 실행 스레드 내에서 파일을 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-959">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="bc823-960">작업을 완료 하 여 호출 되는 콜백 메서드를 만들 수 있습니다는 <xref:System.AsyncCallback> 대리자 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-960">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="bc823-961">최소한,이 작업을 수행 하는 `state` 매개 변수를 포함 해야 합니다는 <xref:System.Net.Sockets.Socket> 통신에 사용 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-961">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="bc823-962">클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-962">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="bc823-963">이 사용자 지정 개체의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-963">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-964">콜백 메서드를 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-964">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="bc823-965">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, 시스템을 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하 고에서 차단 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 때까지 <xref:System.Net.Sockets.Socket> 전체 파일을 전송 하거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-965">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="bc823-966">콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-966">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="bc823-967">연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-967">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="bc823-968">연결 없는 프로토콜을 사용 하 여 파일의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-968">With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-969">이 경우 데이터 그램 전송 되지 않습니다 하 고 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throw를 <xref:System.Net.Sockets.SocketException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-969">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-970">표시 되 면을 <xref:System.Net.Sockets.SocketException> 예외를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-970">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-971">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-971">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-972">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-972">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-973">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-973">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-974">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-974">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-975">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-975">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-976">다음 코드 예제를 만들고 비동기 통신을 위한 소켓을 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-976">The following code example creates and connects a socket for asynchronous communication.</span></span> <span data-ttu-id="bc823-977">먼저 "text.txt" 파일은 원격 호스트에 비동기적으로 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-977">First, the file "text.txt" is sent asynchronously to the remote host.</span></span> <span data-ttu-id="bc823-978">콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 전송을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-978">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-979">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-979">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-980">소켓이 원격 호스트에 연결되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-980">The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="bc823-981">
            <paramref name="fileName" /> 파일을 찾을 수 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-981">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-982">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-982">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-983">아래의 설명 부분을 참조하십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-983">See remarks section below.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="bc823-984">보낼 파일의 경로 및 이름이 들어 있는 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-984">A string that contains the path and name of the file to be sent.</span>
          </span>
          <span data-ttu-id="bc823-985">이 매개 변수는 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-985">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="preBuffer">
          <span data-ttu-id="bc823-986">파일이 전송되기 전에 전송할 데이터를 포함하는 <see cref="T:System.Byte" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-986">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span>
          </span>
          <span data-ttu-id="bc823-987">이 매개 변수는 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-987">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="postBuffer">
          <span data-ttu-id="bc823-988">파일이 전송된 후에 전송할 데이터를 포함하는 <see cref="T:System.Byte" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-988">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span>
          </span>
          <span data-ttu-id="bc823-989">이 매개 변수는 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-989">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="bc823-990">
            <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-990">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-991">이 작업이 완료되면 호출될 <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-991">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes.</span>
          </span>
          <span data-ttu-id="bc823-992">이 매개 변수는 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-992">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-993">이 요청에 대한 상태 정보가 들어 있는 사용자 정의 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-993">A user-defined object that contains state information for this request.</span>
          </span>
          <span data-ttu-id="bc823-994">이 매개 변수는 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-994">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-995">파일 및 데이터 버퍼를 연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에 비동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-995">Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-996">비동기 작업을 나타내는 <see cref="T:System.IAsyncResult" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-996">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-997">이 오버 로드의 비트 조합 보낼 파일의 이름이 필요한 <xref:System.Net.Sockets.TransmitFileOptions> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-997">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="bc823-998">`preBuffer` 매개 변수를 파일 앞에 데이터를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-998">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="bc823-999">`postBuffer` 파일을 따라 하려는 데이터가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-999">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="bc823-1000">경우 `fileName` 는 로컬 디렉터리에서 식별 된 파일의 이름만 사용 하 여, 그렇지 않으면 전체 경로 및 파일의 이름을 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1000">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="bc823-1001">와일드 카드 ("... \\\myfile.txt ") 및 UNC 공유 이름 ("\\\\\\\shared 디렉터리\\\myfile.txt ")는 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1001">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="bc823-1002">파일이 없는 경우, 예외 <xref:System.IO.FileNotFoundException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1002">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="bc823-1003">`flags` 매개 변수는 파일 전송에 대 한 추가 정보를 사용 하 여 창 소켓 서비스 공급자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1003">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="bc823-1004">이 매개 변수를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Net.Sockets.TransmitFileOptions>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1004">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="bc823-1005">이 메서드는 사용 된 `TransmitFile` Windows Sockets 2 api에서 함수를 찾을.</span><span class="sxs-lookup"><span data-stu-id="bc823-1005">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="bc823-1006">에 대 한 자세한 내용은 `TransmitFile` 함수와 해당 플래그를 MSDN Library의 Windows 소켓 설명서를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="bc823-1006">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="bc823-1007">합니다 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1007">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="bc823-1008"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> 먼저 호출 하지 않으면 예외를 throw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>를 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1008"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="bc823-1009">호출 된 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 방법을 사용 하면 별도 실행 스레드 내에서 파일을 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1009">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="bc823-1010">작업을 완료 하 여 호출 되는 콜백 메서드를 만들 수 있습니다는 <xref:System.AsyncCallback> 대리자 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1010">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="bc823-1011">최소한,이 작업을 수행 하는 `state` 매개 변수를 포함 해야 합니다는 <xref:System.Net.Sockets.Socket> 통신에 사용 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1011">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="bc823-1012">클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1012">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="bc823-1013">이 사용자 지정 개체의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1013">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-1014">콜백 메서드를 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1014">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="bc823-1015">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, 시스템을 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하 고에서 차단 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 때까지 <xref:System.Net.Sockets.Socket> 전체 파일을 전송 하거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1015">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="bc823-1016">콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1016">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="bc823-1017">연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1017">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="bc823-1018">연결 없는 프로토콜 사용도 해야 파일의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1018">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-1019">이 경우 데이터 그램 전송 되지 않습니다 하 고 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throw를 <xref:System.Net.Sockets.SocketException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1019">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1020">표시 되 면을 <xref:System.Net.Sockets.SocketException> 예외를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1020">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1021">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1021">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1022">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1022">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1023">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1023">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1024">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1024">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-1025">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1025">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1026">다음 코드 예제에서는 비동기 통신에 대 한 소켓 연결 및 보내기 시작 파일 "text.txt" 비동기적으로 원격 호스트에 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1026">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="bc823-1027">이 예는 `preBuffer` 및 `postBuffer` 데이터 파일 및 기본값을 사용 하 여 보낼 생성 <xref:System.Net.Sockets.TransmitFileOptions> 값이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1027">In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used.</span></span> <span data-ttu-id="bc823-1028">콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 전송을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1028">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1029">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1029">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1030">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1030">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-1031">아래의 설명 부분을 참조하십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1031">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1032">운영 체제가 Windows NT 이상이 아닌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1032">The operating system is not Windows NT or later.</span>
          </span>
          <span data-ttu-id="bc823-1033">\- 또는 -  소켓이 원격 호스트에 연결되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1033">\- or -  The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="bc823-1034">
            <paramref name="fileName" /> 파일을 찾을 수 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1034">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-1035">보낼 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1035">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-1036">데이터 보내기를 시작할 <c>버퍼</c>의 위치(0부터 시작)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1036">The zero-based position in <c>buffer</c> at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-1037">보낼 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1037">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-1038">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1038">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="socket_flags">
          <span data-ttu-id="bc823-1039">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1039">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-1040">원격 장치를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1040">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span>
          </span>
        </param>
        <param name="remote_end">
          <span data-ttu-id="bc823-1041">원격 장치를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1041">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="bc823-1042">
            <see cref="T:System.AsyncCallback" /> 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1042">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="bc823-1043">이 요청에 대한 상태 정보를 포함하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1043">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1044">특정 원격 호스트에 데이터를 비동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1044">Sends data asynchronously to a specific remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1045">비동기 보내기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1045">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1046">합니다 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 에 지정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드는 `remoteEP` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1046">The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter.</span></span> <span data-ttu-id="bc823-1047">호출 된 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1047">Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="bc823-1048">연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 프로토콜과 연결 지향 프로토콜 모두 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1048">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="bc823-1049">구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1049">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method.</span></span> <span data-ttu-id="bc823-1050">최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1050">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="bc823-1051">콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket>, 및 기타 필요한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1051">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="bc823-1052">이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 를 통해 메서드를 `state` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1052">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="bc823-1053">콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1053">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method.</span></span> <span data-ttu-id="bc823-1054">응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 때까지 <xref:System.Net.Sockets.Socket> 요청 된 바이트의 번호를 전송 하거나 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1054">When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="bc823-1055">원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 메서드를 사용 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1055">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bc823-1056">원래 스레드를 계속 실행 하려는 경우 콜백 메서드에서 받으며에서 Set 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1056">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="bc823-1057">콜백 메서드를 작성 하는 방법에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1057">For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="bc823-1058">먼저 호출 해야 합니다는 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 또는 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1058">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-1059"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> 무시 합니다는 `remoteEP` 매개 변수 및 송신 데이터를를 <xref:System.Net.EndPoint> 에 설정 된 합니다 <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1059"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1060">연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 나 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1060">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="bc823-1061">호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1061">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="bc823-1062">호출 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>는 `remoteEP` 작업만 송신 하는 매개 변수에서 지정 된 기본 원격 호스트를 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1062">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="bc823-1063">또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1063">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="bc823-1064">이 경우 기본 서비스 공급자는 가장 적절 한 로컬 네트워크 주소 및 포트 번호를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1064">In this case, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="bc823-1065">기본 서비스 공급자가 사용 가능한 포트를 선택 하려는 경우 0의 포트 번호를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1065">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="bc823-1066">할당 된 로컬 네트워크 주소 및 포트 번호를 확인 해야 하는 경우 사용할 수 있습니다는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 메서드가 성공적으로 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1066">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="bc823-1067">먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1067">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-1068">-버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1068">-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-1069">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1069">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-1070">지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1070">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1071">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1071">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1072">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1072">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1073">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1073">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1074">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1074">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1075">비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1075">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="bc823-1076">특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1076">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1077">다음 코드 예제에서는 지정된 된 원격 호스트에 데이터를 비동기적으로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1077">The following code example asynchronously sends data to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1078">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1078">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-1079">-또는-  <paramref name="remoteEP" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1079">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1080">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1080">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-1081">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1081">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-1082">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1082">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-1083">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1083">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-1084">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1084">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1085">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1085">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-1086">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1086">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="bc823-1087">콜백 메서드로 대리자 마샬링</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1087">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <span data-ttu-id="bc823-1088">
            <see cref="T:System.Net.EndPoint" />과 연결된 로컬 <see cref="T:System.Net.Sockets.Socket" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1088">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1089">
            <see cref="T:System.Net.Sockets.Socket" />을 로컬 끝점과 연결합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1089">Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1090">사용 된 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드 특정 로컬 끝점을 사용 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="bc823-1090">Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint.</span></span> <span data-ttu-id="bc823-1091">호출 해야 합니다 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Listen%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1091">You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="bc823-1092">호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.Bind%2A> 사용 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 특정 로컬 끝점을 사용 하는 제외 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1092">You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint.</span></span> <span data-ttu-id="bc823-1093">사용할 수는 <xref:System.Net.Sockets.Socket.Bind%2A> 프로토콜과 연결 지향 프로토콜 모두에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1093">You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="bc823-1094">호출 하기 전에 <xref:System.Net.Sockets.Socket.Bind%2A>, 로컬을 먼저 만들어야 <xref:System.Net.IPEndPoint> 에서 데이터를 전달 하려는입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1094">Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data.</span></span> <span data-ttu-id="bc823-1095">할당 되는 로컬 주소는 중요 하지 않은 경우 만들 수 있습니다는 <xref:System.Net.IPEndPoint> 를 사용 하 여 <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> 주소 매개 변수 및 기본 서비스 공급자 가장 적합 한 네트워크 주소를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1095">If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> as the address parameter, and the underlying service provider will assign the most appropriate network address.</span></span> <span data-ttu-id="bc823-1096">이렇게 하면 여러 네트워크 인터페이스가 있는 경우 응용 프로그램을 간소화 하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1096">This might help simplify your application if you have multiple network interfaces.</span></span> <span data-ttu-id="bc823-1097">사용 되는 로컬 포트는 중요 하지 않은 경우 만들 수 있습니다는 <xref:System.Net.IPEndPoint> 포트 번호 0을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1097">If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number.</span></span> <span data-ttu-id="bc823-1098">이 경우 서비스 공급자에는 1024-5000 사이의 사용 가능한 포트 번호를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1098">In this case, the service provider will assign an available port number between 1024 and 5000.</span></span>  
  
 <span data-ttu-id="bc823-1099">호출 하 여 할당 된 로컬 네트워크 주소 및 포트 번호를 검색할 수 있습니다, 위의 접근 방식을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1099">If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span></span> <span data-ttu-id="bc823-1100">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 에 대 한 호출을 수행한 후 될 때까지 할당 된 로컬 네트워크 주소를 반환 하지 것입니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1100">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="bc823-1101">연결 없는 프로토콜을 사용 하는 경우 완료 송신 또는 수신 될 때까지이 정보에 액세스할을 수 없습니다 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1101">If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</span></span>  
  
 <span data-ttu-id="bc823-1102">UDP 소켓을 받은 패킷에 대 한 인터페이스 정보를 수신 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 로 설정 하는 소켓 옵션을 사용 하 여 메서드를 명시적으로 호출 해야 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 호출한 후 즉시는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1102">If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1103">호출 해야 멀티 캐스트 데이터 그램을 수신 하려는 경우는 <xref:System.Net.Sockets.Socket.Bind%2A> 멀티 캐스트 포트 번호를 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1103">If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1104">호출 해야 합니다 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 사용 하 여 연결 없는 데이터 그램을 수신 하려는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1104">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1105">수신 되 면를 <xref:System.Net.Sockets.SocketException> 호출할 때 합니다 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1105">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1106">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1106">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1107">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1107">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1108">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1108">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1109">다음 코드 예에서는 바인드를 <xref:System.Net.Sockets.Socket> 지정된 된 로컬 끝점을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1109">The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.</span></span>  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1110">
            <paramref name="localEP" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1110">
              <paramref name="localEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1111">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1111">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1112">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1112">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-1113">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1113">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-1114">정의한 호스트에서 연결을 수락 하기 위해 <paramref name="localEP" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1114">for accepting connections from the host defined by <paramref name="localEP" />.</span>
          </span>
          <span data-ttu-id="bc823-1115">연결 된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1115">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1116">
            <see cref="T:System.Net.Sockets.Socket" />이 블로킹 모드인지 여부를 나타내는 값을 설정하거나 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1116">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1117">
            <see cref="T:System.Net.Sockets.Socket" />이 차단되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1117">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> will block; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="bc823-1118">기본값은 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1118">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1119"><xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 나타냅니다 여부를 <xref:System.Net.Sockets.Socket> 블로킹 모드 인지 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1119">The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.</span></span>  
  
 <span data-ttu-id="bc823-1120">블로킹 모드에 있으며 메서드를 호출 하는 즉시 완료 되지 않은 경우에 응용 프로그램 요청 된 작업이 완료 될 때까지 실행에 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1120">If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</span></span> <span data-ttu-id="bc823-1121">요청 된 작업이 완료 하는 경우에 계속 변경, 실행 하려는 경우는 <xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1121">If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`.</span></span> <span data-ttu-id="bc823-1122"><xref:System.Net.Sockets.Socket.Blocking%2A> 속성이 비동기 메서드에 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1122">The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods.</span></span> <span data-ttu-id="bc823-1123">전송 및 데이터를 비동기적으로 받는 실행을 차단 하려면를 사용 하 여는 <xref:System.Threading.ManualResetEvent> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1123">If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1124">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1124">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1125">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1125">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1126">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1126">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1127">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1127">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1128">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1128">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1129">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1129">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="bc823-1130">
            <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 메서드 중 하나를 호출하여 원격 호스트에 대한 연결을 요청하는 데 사용되는 <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1130">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1131">원격 호스트 연결에 대한 비동기 요청을 취소합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1131">Cancels an asynchronous request for a remote host connection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1132"><xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> 메서드는 원격 호스트 연결에 대 한 비동기 요청을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1132">The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1133">
            <paramref name="e" /> 매개 변수가 null일 수 없으며, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />도 null일 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1133">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1134">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1134">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1135">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1135">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-1136">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1136">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1137">
            <see cref="T:System.Net.Sockets.Socket" /> 연결을 닫고 연결된 리소스를 모두 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1137">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1138">
            <see cref="T:System.Net.Sockets.Socket" /> 연결을 닫고 연결된 리소스를 모두 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1138">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1139">합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드는 원격 호스트 연결을 닫고 관리 되는 모든 릴리스와 연관 된 리소스를 관리 되지 않는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1139">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-1140">를 닫으면 합니다 <xref:System.Net.Sockets.Socket.Connected%2A> 속성이 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1140">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="bc823-1141">연결 지향 프로토콜에 대 한 것이 좋습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Shutdown%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1141">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span> <span data-ttu-id="bc823-1142">이렇게 하면 모든 데이터가 전송 및 연결이 닫히기 전에 연결된 된 소켓에서 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1142">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="bc823-1143">호출 해야 하는 경우 <xref:System.Net.Sockets.Socket.Close%2A> 첫 번째 호출 하지 않고 <xref:System.Net.Sockets.Socket.Shutdown%2A>, 대기 중인 데이터를 설정 하 여 전송 나가는 전송 되도록 할 수 있습니다 합니다 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> 옵션을 `false` 고 0이 아닌 제한 시간 간격을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1143">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="bc823-1144"><xref:System.Net.Sockets.Socket.Close%2A> 그런 다음,는이 데이터를 보낼 때까지 또는 지정된 된 제한 시간이 만료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1144"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="bc823-1145">설정 하는 경우 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 하 `false` 0 시간 제한 간격을 지정 하 고 <xref:System.Net.Sockets.Socket.Close%2A> 연결을 해제 하 고 나가는 큐에 대기 중인된 데이터를 자동으로 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1145">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1146">설정 하는 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 소켓 옵션을 `false`, 만들기를 <xref:System.Net.Sockets.LingerOption>, 설정 된 속성을 설정 `true`, 설정 및는 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 속성을 원하는 시간 초과 기간.</span><span class="sxs-lookup"><span data-stu-id="bc823-1146">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period.</span></span> <span data-ttu-id="bc823-1147">이 사용 하 여 <xref:System.Net.Sockets.LingerOption> 와 함께 합니다 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 소켓 옵션을 호출 합니다 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1147">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1148">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1148">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1149">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1149">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1150">다음 코드 예제에서는 닫습니다는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1150">The following code example closes a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="bc823-1151">나머지 데이터가 전송될 때까지 <c>timeout</c>초까지 기다린 후 소켓을 닫습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1151">Wait up to <c>timeout</c> seconds to send any remaining data, then close the socket.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1152">
            <see cref="T:System.Net.Sockets.Socket" /> 연결을 닫고 지정된 시간 제한의 모든 관련 리소스를 해제하여 대기 중인 데이터가 전송될 수 있도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1152">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1153">합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드는 원격 호스트 연결을 닫고 관리 되는 모든 릴리스와 연관 된 리소스를 관리 되지 않는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1153">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-1154">를 닫으면 합니다 <xref:System.Net.Sockets.Socket.Connected%2A> 속성이 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1154">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="bc823-1155">연결 지향 프로토콜에 대 한 것이 좋습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Shutdown%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Close%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1155">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>.</span></span> <span data-ttu-id="bc823-1156">이렇게 하면 모든 데이터가 전송 및 연결이 닫히기 전에 연결된 된 소켓에서 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1156">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="bc823-1157">호출 해야 하는 경우 <xref:System.Net.Sockets.Socket.Close%2A> 첫 번째 호출 하지 않고 <xref:System.Net.Sockets.Socket.Shutdown%2A>, 대기 중인 데이터를 설정 하 여 전송 나가는 전송 되도록 할 수 있습니다 합니다 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 옵션을 `false` 고 0이 아닌 제한 시간 간격을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1157">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="bc823-1158"><xref:System.Net.Sockets.Socket.Close%2A> 그런 다음,는이 데이터를 보낼 때까지 또는 지정된 된 제한 시간이 만료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1158"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="bc823-1159">설정 하는 경우 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 하 `false` 0 시간 제한 간격을 지정 하 고 <xref:System.Net.Sockets.Socket.Close%2A> 연결을 해제 하 고 나가는 큐에 대기 중인된 데이터를 자동으로 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1159">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1160">설정 하는 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 소켓 옵션을 `false`, 만들기를 <xref:System.Net.Sockets.LingerOption>, 설정 된 속성을 설정 `true`, 설정 및는 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 속성을 원하는 시간 제한 기간.</span><span class="sxs-lookup"><span data-stu-id="bc823-1160">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period.</span></span> <span data-ttu-id="bc823-1161">이 사용 하 여 <xref:System.Net.Sockets.LingerOption> 와 함께 합니다 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 소켓 옵션을 호출 합니다 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1161">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1162">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1162">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1163">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1163">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1164">다음 코드 예제에서는 종결 하는 방법을 보여 줍니다는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1164">The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1165">원격 호스트에 대한 연결을 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1165">Establishes a connection to a remote host.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <span data-ttu-id="bc823-1166">원격 장치를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1166">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1167">원격 호스트에 대한 연결을 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1167">Establishes a connection to a remote host.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1168">TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드는 동기적으로 간에 네트워크 연결을 설정 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 및 지정된 된 원격 끝점입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1168">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="bc823-1169">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 기본 원격 호스트를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1169">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="bc823-1170">호출한 후 <xref:System.Net.Sockets.Socket.Connect%2A>를 사용 하 여 원격 장치에 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드를 사용 하 여 원격 장치에서 데이터를 수신 하거나는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1170">After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1171">UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.Connect%2A> 데이터 보내기 및 받기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1171">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="bc823-1172">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 원격 호스트를 사용 하 여 동기적으로 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1172">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="bc823-1173">호출 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A>, 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1173">If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="bc823-1174">먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, 또는 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1174">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-1175">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1175">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1176">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1176">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="bc823-1177">합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 설정 하지 않으면 메서드가 차단 되는 <xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 `false` 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1177">The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-1178">TCP 비활성화 차단 같은 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException> 연결을 만드는 데 시간이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1178">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="bc823-1179">연결 없는 프로토콜 기본 원격 호스트를 설정 하기만 하므로 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1179">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="bc823-1180">사용할 수 있습니다 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1180">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1181">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1181">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="bc823-1182">연결 지향 하 여 원격 호스트 연결이 시작 오류 WSAEWOULDBLOCK 반환 되 면 <xref:System.Net.Sockets.Socket>, 있지만 아직 완료 되지 않은 성공적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1182">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="bc823-1183">사용 하 여를 <xref:System.Net.Sockets.Socket.Poll%2A> 시기를 결정 하는 방법의 <xref:System.Net.Sockets.Socket> 가 완료 된 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1183">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1184">연결 지향 프로토콜을 사용 하 고 호출 하지 않았습니다 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>, 기본 서비스 공급자가 로컬 네트워크 주소 및 포트 번호를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1184">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="bc823-1185">연결 없는 프로토콜을 사용 하는 경우 완료를 송신 하거나 수신 작업 때까지 서비스 공급자 로컬 네트워크 주소 및 포트 번호를 할당 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1185">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="bc823-1186">기본 원격 호스트를 변경 하려는 경우 호출 <xref:System.Net.Sockets.Socket.Connect%2A> 원하는 끝점을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1186">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1187">소켓 이전에 연결 하는 경우 연결을 복원 하려면이 방법을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1187">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="bc823-1188">비동기 작업 중 하나를 사용 하 여 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 다시 연결 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1188">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="bc823-1189">기본 공급자의 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1189">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1190">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1190">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1191">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1191">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1192">다음 코드 예제는 원격 끝점에 연결 하 고 연결을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1192">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1193">
            <paramref name="remoteEP" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1193">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1194">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1194">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1195">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1195">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-1196">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1196">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1197">
            <see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1197">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-1198">원격 호스트에 연결 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1198">for connecting to the remote host.</span>
          </span>
          <span data-ttu-id="bc823-1199">연결 된 열거형: <see cref="F:System.Net.NetworkAccess.Connect" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1199">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="bc823-1200">원격 호스트의 IP 주소입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1200">The IP address of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="bc823-1201">원격 호스트의 포트 번호입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1201">The port number of the remote host.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1202">원격 호스트에 대한 연결을 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1202">Establishes a connection to a remote host.</span>
          </span>
          <span data-ttu-id="bc823-1203">호스트는 IP 주소와 포트 번호로 지정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1203">The host is specified by an IP address and a port number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1204">TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드는 동기적으로 간에 네트워크 연결을 설정 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 및 지정된 된 원격 끝점입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1204">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="bc823-1205">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 기본 원격 호스트를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1205">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="bc823-1206">호출한 후 <xref:System.Net.Sockets.Socket.Connect%2A> 사용 하 여 원격 장치에 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드를 사용 하 여 원격 장치에서 데이터를 수신 하거나는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1206">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1207">UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.Connect%2A> 데이터 보내기 및 받기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1207">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="bc823-1208">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 원격 호스트를 사용 하 여 동기적으로 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1208">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="bc823-1209">호출 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1209">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="bc823-1210">먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, 또는 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1210">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-1211">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1211">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1212">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1212">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="bc823-1213"><xref:System.Net.Sockets.Socket.Connect%2A> 설정 하지 않으면 메서드가 차단 되는 <xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 `false` 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1213"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-1214">TCP 비활성화 차단 같은 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException> 연결을 만드는 데 시간이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1214">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="bc823-1215">연결 없는 프로토콜 기본 원격 호스트를 설정 하기만 하므로 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1215">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="bc823-1216">사용할 수 있습니다 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1216">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1217">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1217">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="bc823-1218">연결 지향 하 여 원격 호스트 연결이 시작 오류 WSAEWOULDBLOCK 반환 되 면 <xref:System.Net.Sockets.Socket>, 있지만 아직 완료 되지 않은 성공적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1218">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="bc823-1219">사용 하 여를 <xref:System.Net.Sockets.Socket.Poll%2A> 시기를 결정 하는 방법의 <xref:System.Net.Sockets.Socket> 가 완료 된 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1219">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1220">연결 지향 프로토콜을 사용 하 고 호출 하지 않았습니다 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>, 기본 서비스 공급자가 로컬 네트워크 주소 및 포트 번호를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1220">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="bc823-1221">연결 없는 프로토콜을 사용 하는 경우 완료를 송신 하거나 수신 작업 때까지 서비스 공급자 로컬 네트워크 주소 및 포트 번호를 할당 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1221">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="bc823-1222">기본 원격 호스트를 변경 하려는 경우 호출 <xref:System.Net.Sockets.Socket.Connect%2A> 원하는 끝점을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1222">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1223">소켓 이전에 연결 하는 경우 연결을 복원 하려면이 방법을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1223">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="bc823-1224">비동기 작업 중 하나를 사용 하 여 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 다시 연결 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1224">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="bc823-1225">기본 공급자의 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1225">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1226">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1226">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1227">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1227">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1228">다음 코드 예제는 원격 끝점에 연결 하 고 연결을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1228">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1229">
            <paramref name="address" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1229">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-1230">포트 번호가 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1230">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1231">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1231">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1232">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1232">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1233">이 메서드는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 제품군의 소켓에 유효합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1233">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1234">
            <paramref name="address" />의 길이가 0인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1234">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1235">
            <see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1235">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">
          <span data-ttu-id="bc823-1236">원격 호스트의 IP 주소입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1236">The IP addresses of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="bc823-1237">원격 호스트의 포트 번호입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1237">The port number of the remote host.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1238">원격 호스트에 대한 연결을 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1238">Establishes a connection to a remote host.</span>
          </span>
          <span data-ttu-id="bc823-1239">호스트는 IP 주소의 배열과 포트 번호로 지정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1239">The host is specified by an array of IP addresses and a port number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1240">이 메서드를 호출한 후 즉시 일반적으로 <xref:System.Net.Dns.GetHostAddresses%2A>, 단일 호스트에 대 한 여러 IP 주소를 반환할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1240">This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host.</span></span> <span data-ttu-id="bc823-1241">TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드는 동기적으로 간에 네트워크 연결을 설정 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 및 지정된 된 원격 끝점입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1241">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="bc823-1242">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 기본 원격 호스트를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1242">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="bc823-1243">호출한 후 <xref:System.Net.Sockets.Socket.Connect%2A> 사용 하 여 원격 장치에 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드를 사용 하 여 원격 장치에서 데이터를 수신 하거나는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1243">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1244">UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.Connect%2A> 데이터 보내기 및 받기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1244">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="bc823-1245">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 원격 호스트를 사용 하 여 동기적으로 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1245">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="bc823-1246">호출 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1246">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="bc823-1247">먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, 또는 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1247">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-1248">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1248">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1249">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1249">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="bc823-1250"><xref:System.Net.Sockets.Socket.Connect%2A> 설정 하지 않으면 메서드가 차단 되는 <xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 `false` 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1250"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-1251">TCP 비활성화 차단 같은 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException> 연결을 만드는 데 시간이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1251">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="bc823-1252">연결 없는 프로토콜 기본 원격 호스트를 설정 하기만 하므로 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1252">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="bc823-1253">사용할 수 있습니다 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1253">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1254">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1254">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="bc823-1255">연결 지향 하 여 원격 호스트 연결이 시작 오류 WSAEWOULDBLOCK 반환 되 면 <xref:System.Net.Sockets.Socket>, 있지만 아직 완료 되지 않은 성공적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1255">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="bc823-1256">사용 하 여를 <xref:System.Net.Sockets.Socket.Poll%2A> 시기를 결정 하는 방법의 <xref:System.Net.Sockets.Socket> 가 완료 된 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1256">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1257">연결 지향 프로토콜을 사용 하 고 호출 하지 않았습니다 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>, 기본 서비스 공급자가 로컬 네트워크 주소 및 포트 번호를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1257">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="bc823-1258">연결 없는 프로토콜을 사용 하는 경우 완료를 송신 하거나 수신 작업 때까지 서비스 공급자 로컬 네트워크 주소 및 포트 번호를 할당 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1258">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="bc823-1259">기본 원격 호스트를 변경 하려는 경우 호출 <xref:System.Net.Sockets.Socket.Connect%2A> 원하는 끝점을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1259">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1260">소켓 이전에 연결 하는 경우 연결을 복원 하려면이 방법을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1260">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="bc823-1261">비동기 작업 중 하나를 사용 하 여 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 다시 연결 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1261">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="bc823-1262">기본 공급자의 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1262">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1263">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1263">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1264">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1264">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1265">다음 코드 예제는 원격 끝점에 연결 하 고 연결을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1265">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1266">
            <paramref name="addresses" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1266">
              <paramref name="addresses" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-1267">포트 번호가 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1267">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1268">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1268">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1269">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1269">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1270">이 메서드는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 제품군의 소켓에 유효합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1270">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1271">
            <paramref name="address" />의 길이가 0인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1271">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1272">
            <see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1272">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="bc823-1273">원격 호스트의 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1273">The name of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="bc823-1274">원격 호스트의 포트 번호입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1274">The port number of the remote host.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1275">원격 호스트에 대한 연결을 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1275">Establishes a connection to a remote host.</span>
          </span>
          <span data-ttu-id="bc823-1276">호스트는 호스트 이름과 포트 번호로 지정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1276">The host is specified by a host name and a port number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1277">TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드는 동기적으로 간에 네트워크 연결을 설정 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 및 지정된 된 원격 호스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1277">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host.</span></span> <span data-ttu-id="bc823-1278">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 기본 원격 호스트를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1278">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="bc823-1279">호출한 후 <xref:System.Net.Sockets.Socket.Connect%2A> 사용 하 여 원격 장치에 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드를 사용 하 여 원격 장치에서 데이터를 수신 하거나는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1279">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1280">UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.Connect%2A> 데이터 보내기 및 받기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1280">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="bc823-1281">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 원격 호스트를 사용 하 여 동기적으로 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1281">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="bc823-1282">호출 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1282">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="bc823-1283">먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, 또는 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1283">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-1284">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1284">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1285">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1285">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="bc823-1286"><xref:System.Net.Sockets.Socket.Connect%2A> 설정 하지 않으면 메서드가 차단 되는 <xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 `false` 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1286"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-1287">TCP 비활성화 차단 같은 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException> 연결을 만드는 데 시간이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1287">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="bc823-1288">연결 없는 프로토콜 기본 원격 호스트를 설정 하기만 하므로 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1288">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="bc823-1289">사용할 수 있습니다 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1289">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1290">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1290">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="bc823-1291">연결 지향 하 여 원격 호스트 연결이 시작 오류 WSAEWOULDBLOCK 반환 되 면 <xref:System.Net.Sockets.Socket>, 있지만 아직 완료 되지 않은 성공적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1291">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="bc823-1292">사용 하 여를 <xref:System.Net.Sockets.Socket.Poll%2A> 시기를 결정 하는 방법의 <xref:System.Net.Sockets.Socket> 가 완료 된 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1292">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
 <span data-ttu-id="bc823-1293">IPv6을 사용 하는 경우 및 <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> 메서드는 모두 IPv6로 확인 되는 호스트에 연결할 및 IPv4 주소, IPv6 주소에 대 한 연결 IPv4 주소 앞의 첫 번째 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1293">If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</span></span> <span data-ttu-id="bc823-1294">호스트의 IPv6 주소에서 수신 하지 않는 경우 연결을 설정 하는 시간을 지연이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1294">This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1295">연결 지향 프로토콜을 사용 하 고 호출 하지 않았습니다 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>, 기본 서비스 공급자가 로컬 네트워크 주소 및 포트 번호를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1295">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="bc823-1296">연결 없는 프로토콜을 사용 하는 경우 완료를 송신 하거나 수신 작업 때까지 서비스 공급자 로컬 네트워크 주소 및 포트 번호를 할당 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1296">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="bc823-1297">기본 원격 호스트를 변경 하려는 경우 호출 <xref:System.Net.Sockets.Socket.Connect%2A> 원하는 끝점을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1297">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1298">소켓 이전에 연결 하는 경우 연결을 복원 하려면이 방법을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1298">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="bc823-1299">비동기 작업 중 하나를 사용 하 여 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 다시 연결 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1299">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="bc823-1300">기본 공급자의 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1300">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1301">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1301">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1302">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1302">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1303">다음 코드 예제는 원격 끝점에 연결 하 고 연결을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1303">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1304">
            <paramref name="host" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1304">
              <paramref name="host" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-1305">포트 번호가 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1305">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1306">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1306">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1307">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1307">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1308">이 메서드는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 제품군의 소켓에 유효합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1308">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1309">
            <see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1309">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1310">원격 호스트 연결에 대한 비동기 요청을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1310">Begins an asynchronous request for a connection to a remote host.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="bc823-1311">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1311">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1312">원격 호스트 연결에 대한 비동기 요청을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1312">Begins an asynchronous request for a connection to a remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1313">I/O 작업이 보류 중인 경우 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1313">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="bc823-1314">작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1314">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="bc823-1315">I/O 작업이 동기적으로 완료된 경우 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1315">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="bc823-1316">이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1316">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1317">연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드 원격 호스트에 대 한 연결에 대 한 비동기 요청을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1317">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="bc823-1318">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 기본 원격 호스트를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1318">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.</span></span>  
  
 <span data-ttu-id="bc823-1319">콜백 메서드를 이벤트 처리기를 구현 하는 완료 알림을 수를 만들어야\<SocketAsyncEventArgs > 대리자를 연결 하는 콜백에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1319">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="bc823-1320">호출자에 게 설정 해야 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 속성을는 <xref:System.Net.IPEndPoint> 연결할 원격 호스트의 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1320">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="bc823-1321">호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1321">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="bc823-1322">콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1322">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="bc823-1323">UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 데이터 보내기 및 받기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1323">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="bc823-1324">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 원격 호스트와 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1324">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="bc823-1325">호출 하는 경우 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1325">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="bc823-1326">기본 원격 호스트를 변경 하려는 경우 호출 된 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 원하는 끝점을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1326">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="bc823-1327">먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 브로드캐스트 설정 하 고 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1327">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="bc823-1328">이렇게 하지 않으면 경우는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드는 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1328">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-1329">다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 개체는 필요:</span><span class="sxs-lookup"><span data-stu-id="bc823-1329">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="bc823-1330">필요에 따라 버퍼 제공 될 수 있습니다는 원자 단위로 전송 후 소켓을 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드가 성공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1330">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="bc823-1331">이 경우에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 보낼 데이터를 포함 하는 버퍼를 설정 해야 하는 속성 및 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 속성 버퍼에서 보내는 데이터의 바이트 수로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1331">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="bc823-1332">연결이 설정 되 면이 버퍼의 데이터 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1332">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="bc823-1333">연결 지향 프로토콜을 사용 하 고 호출 하지 마세요 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1333">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="bc823-1334">호출 하기 전에 서비스 공급자가 로컬 네트워크 IP 주소 및 포트 번호를 연결 없는 프로토콜을 사용 하는 경우 할당 된 <xref:System.Net.Sockets.Socket.SendAsync%2A> 또는 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1334">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="bc823-1335"><xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드가 throw <xref:System.NotSupportedException> 경우의 주소 패밀리를 <xref:System.Net.Sockets.Socket> 및 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 같은 주소 패밀리를 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1335">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1336">표시 되 면를 <xref:System.Net.Sockets.SocketException> 사용 하 여이 메서드를 호출 하는 경우는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1336">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1337">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1337">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1338">인수가 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1338">An argument is not valid.</span>
          </span>
          <span data-ttu-id="bc823-1339">버퍼를 여러 개 지정하고 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 속성이 null이 아니면 이 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1339">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1340">
            <paramref name="e" /> 매개 변수가 null일 수 없으며, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />도 null일 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1340">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1341">
            <see cref="T:System.Net.Sockets.Socket" />이 수신 대기 중이거나 <paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1341">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1342">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1342">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1343">이 메서드에 Windows XP 이상이 필요한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1343">Windows XP or later is required for this method.</span>
          </span>
          <span data-ttu-id="bc823-1344">로컬 끝점과 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />가 같은 주소 패밀리에 포함되지 않은 경우에도 이 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1344">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1345">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1345">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-1346">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1346">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <span data-ttu-id="bc823-1347">
            <see cref="T:System.Net.Sockets.SocketType" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1347">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </param>
        <param name="protocolType">
          <span data-ttu-id="bc823-1348">
            <see cref="T:System.Net.Sockets.ProtocolType" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1348">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </param>
        <param name="e">
          <span data-ttu-id="bc823-1349">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1349">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1350">원격 호스트 연결에 대한 비동기 요청을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1350">Begins an asynchronous request for a connection to a remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1351">I/O 작업이 보류 중인 경우 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1351">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="bc823-1352">작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1352">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="bc823-1353">I/O 작업이 동기적으로 완료된 경우 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1353">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="bc823-1354">이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1354">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1355">M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) 메서드에 대 한 비동기 요청을 시작 하는 연결 지향 프로토콜을 사용 하는 경우는 원격 호스트에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1355">If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="bc823-1356">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 으로 지정 된 기본 원격 호스트를 설정 합니다 `socketType` 및 `protocolType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1356">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.</span></span>  
  
 <span data-ttu-id="bc823-1357">콜백 메서드를 이벤트 처리기를 구현 하는 완료 알림을 수를 만들어야\<SocketAsyncEventArgs > 대리자를 연결 하는 콜백에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1357">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="bc823-1358">호출자에 게 설정 해야 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 속성을는 <xref:System.Net.IPEndPoint> 연결할 원격 호스트의 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1358">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="bc823-1359">호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1359">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="bc823-1360">콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1360">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="bc823-1361">UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 데이터 보내기 및 받기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1361">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="bc823-1362">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 원격 호스트와 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1362">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="bc823-1363">호출 하는 경우 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1363">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="bc823-1364">기본 원격 호스트를 변경 하려는 경우 호출 된 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 원하는 끝점을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1364">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="bc823-1365">먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 브로드캐스트 설정 하 고 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1365">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="bc823-1366">이렇게 하지 않으면 경우는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드는 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1366">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-1367">다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 개체는 필요:</span><span class="sxs-lookup"><span data-stu-id="bc823-1367">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="bc823-1368">필요에 따라 버퍼 제공 될 수 있습니다는 원자 단위로 전송 후 소켓을 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드가 성공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1368">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="bc823-1369">이 경우에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 보낼 데이터를 포함 하는 버퍼를 설정 해야 하는 속성 및 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 속성 버퍼에서 보내는 데이터의 바이트 수로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1369">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="bc823-1370">연결이 설정 되 면이 버퍼의 데이터 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1370">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="bc823-1371">연결 지향 프로토콜을 사용 하 고 호출 하지 마세요 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1371">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="bc823-1372">호출 하기 전에 서비스 공급자가 로컬 네트워크 IP 주소 및 포트 번호를 연결 없는 프로토콜을 사용 하는 경우 할당 된 <xref:System.Net.Sockets.Socket.SendAsync%2A> 또는 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1372">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="bc823-1373"><xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드가 throw <xref:System.NotSupportedException> 경우의 주소 패밀리를 <xref:System.Net.Sockets.Socket> 및 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 같은 주소 패밀리를 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1373">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1374">표시 되 면를 <xref:System.Net.Sockets.SocketException> 사용 하 여이 메서드를 호출 하는 경우는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1374">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1375">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1375">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1376">인수가 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1376">An argument is not valid.</span>
          </span>
          <span data-ttu-id="bc823-1377">버퍼를 여러 개 지정하고 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 속성이 null이 아니면 이 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1377">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1378">
            <paramref name="e" /> 매개 변수가 null일 수 없으며, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />도 null일 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1378">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1379">
            <see cref="T:System.Net.Sockets.Socket" />이 수신 대기 중이거나 <paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1379">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1380">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1380">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1381">이 메서드에 Windows XP 이상이 필요한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1381">Windows XP or later is required for this method.</span>
          </span>
          <span data-ttu-id="bc823-1382">로컬 끝점과 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />가 같은 주소 패밀리에 포함되지 않은 경우에도 이 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1382">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1383">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1383">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-1384">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1384">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1385">
            <see cref="T:System.Net.Sockets.Socket" />이 마지막으로 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 또는 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 작업을 수행할 때 원격 호스트에 연결되었는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1385">Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1386">가장 최근 작업에서 <see cref="T:System.Net.Sockets.Socket" />이 원격 리소스에 연결되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1386">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1387">합니다 `Connected` 속성의 연결 상태를 가져옵니다는 <xref:System.Net.Sockets.Socket> 마지막 I/O 작업을 기준으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1387">The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation.</span></span> <span data-ttu-id="bc823-1388">반환 될 때 `false`, <xref:System.Net.Sockets.Socket> 가 연결 된 적 또는 연결 되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1388">When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.</span></span>  
  
 <span data-ttu-id="bc823-1389">값을 <xref:System.Net.Sockets.Socket.Connected%2A> 속성은 가장 최근 작업 연결의 상태를 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1389">The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation.</span></span> <span data-ttu-id="bc823-1390">연결의 현재 상태를 확인 해야 할 경우 비차단, 0 바이트 송신 호출을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1390">If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</span></span> <span data-ttu-id="bc823-1391">호출이 성공적으로 반환 또는 WAEWOULDBLOCK 오류 코드 (10035)를 throw 하는 경우 소켓 아직 연결 되어 있습니다. 그렇지 않으면 소켓 연결 되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1391">If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</span></span>  
  
 <span data-ttu-id="bc823-1392">호출 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 는 사용자 데이터 그램 프로토콜 (UDP) socket 클래스에는 <xref:System.Net.Sockets.Socket.Connected%2A> 속성은 항상 반환 `true`하지만이 동작은 UDP의 고유한 연결 없는 특성을 변경 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1392">If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1393">원격 끝점을 확인 하려면 다음 코드 예제에서는 연결 된 <xref:System.Net.Sockets.Socket.Connected%2A> 속성인 연결의 현재 상태를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1393">The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="bc823-1394">현재 연결을 닫은 다음 이 소켓을 다시 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1394">
              <see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1395">소켓 연결을 닫고 소켓을 다시 사용할 수 있도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1395">Closes the socket connection and allows reuse of the socket.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1396">연결 지향 프로토콜을 사용 하는 경우에 소켓을 닫으려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1396">If you are using a connection-oriented protocol, you can use this method to close the socket.</span></span> <span data-ttu-id="bc823-1397">이 메서드 종료 집합과 연결 된 <xref:System.Net.Sockets.Socket.Connected%2A> 속성을 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1397">This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`.</span></span> <span data-ttu-id="bc823-1398">그러나 경우 `reuseSocket` 는 `true`, 소켓을 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1398">However, if `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="bc823-1399">호출 해야 모든 데이터가 전송 및 소켓 닫히기 전에 수신 되도록 <xref:System.Net.Sockets.Socket.Shutdown%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Disconnect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1399">To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1400">호출 해야 하는 경우 <xref:System.Net.Sockets.Socket.Disconnect%2A> 첫 번째 호출 하지 않고 <xref:System.Net.Sockets.Socket.Shutdown%2A>를 설정할 수 있습니다 합니다 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> 옵션을 `false` 보내도록 위해 대기 중인 데이터를 확인 하는 0이 아닌 제한 시간 간격을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1400">If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</span></span> <span data-ttu-id="bc823-1401"><xref:System.Net.Sockets.Socket.Disconnect%2A> 그런 다음 데이터를 보낼 때까지 또는 지정된 된 제한 시간이 만료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1401"><xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="bc823-1402">설정 하는 경우 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 하 `false` 0 시간 제한 간격을 지정 하 고 <xref:System.Net.Sockets.Socket.Close%2A> 연결을 해제 하 고 나가는 큐에 대기 중인된 데이터를 자동으로 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1402">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1403">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1403">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1404">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1404">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1405">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1405">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1406">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1406">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1407">다음 코드 예제에서는 동기 통신을 위한 소켓을 만들고 원격 호스트에 일부 데이터를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1407">The following code example creates a socket for synchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="bc823-1408">그런 다음 호출 <xref:System.Net.Sockets.Socket.Shutdown%2A>송신을 중지 하 고 작업을 수신 하려면, 및 <xref:System.Net.Sockets.Socket.Disconnect%2A>, 소켓 연결을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1408">It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="bc823-1409">이 메서드는 Windows 2000 이전 버전에서 사용해야 합니다. 그렇지 않으면 예외가 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1409">This method requires Windows 2000 or earlier, or the exception will be thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1410">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1410">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1411">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1411">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="bc823-1412">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1412">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1413">원격 끝점과의 연결을 끊는 비동기 요청을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1413">Begins an asynchronous request to disconnect from a remote endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1414">I/O 작업이 보류 중인 경우 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1414">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="bc823-1415">작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1415">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="bc823-1416">I/O 작업이 동기적으로 완료된 경우 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1416">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="bc823-1417">이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1417">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1418">연결 지향 프로토콜을 사용 하는 경우 호출 된 <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> 메서드 원격 끝점 으로부터의 연결을 끊도록을 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1418">When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint.</span></span> <span data-ttu-id="bc823-1419">설정 하는 경우 <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> 하 `true` 에 `e` 매개 변수를 소켓을 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1419">If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> to `true` in the `e` parameter, the socket can be reused.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1420">
            <paramref name="e" /> 매개 변수가 null인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1420">The <paramref name="e" /> parameter cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1421">
            <paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1421">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1422">이 메서드에 Windows XP 이상이 필요한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1422">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1423">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1423">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1424">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1424">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1425">
            <see cref="T:System.Net.Sockets.Socket" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1425">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1426">
            <see cref="T:System.Net.Sockets.Socket" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1426">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1427">`Dispose` 사용을 마치면 <xref:System.Net.Sockets.Socket>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1427">Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-1428">`Dispose` 메서드를 사용하면 <xref:System.Net.Sockets.Socket>를 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1428">The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="bc823-1429">호출한 후 `Dispose`에 대 한 모든 참조를 해제 해야 합니다 <xref:System.Net.Sockets.Socket> 가비지 수집기에서 메모리를 회수할 수 있도록 하는 <xref:System.Net.Sockets.Socket> 차지한 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1429">After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span>  
  
 <span data-ttu-id="bc823-1430">자세한 내용은 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md) 하 고 [Dispose 메서드 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1430">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1431">`Dispose`에 대한 마지막 참조를 해제하기 전에 반드시 <xref:System.Net.Sockets.Socket>를 호출하십시오.</span><span class="sxs-lookup"><span data-stu-id="bc823-1431">Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-1432">이렇게 하지 않으면 가비지 수집기가 <xref:System.Net.Sockets.Socket> 개체의 `Finalize` 메서드를 호출할 때까지 사용 중인 리소스가 해제되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1432">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="bc823-1433">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />, 관리되지 않는 리소스만 해제하려면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1433">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1434">
            <see cref="T:System.Net.Sockets.Socket" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 삭제할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1434">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1435">이 메서드는 공용 `Dispose()` 메서드 및 <xref:System.Object.Finalize%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1435">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="bc823-1436">`Dispose()` 보호 된 호출 `Dispose(Boolean)` 메서드를 `disposing` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1436">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="bc823-1437"><xref:System.Object.Finalize%2A> 호출 `Dispose` 사용 하 여 `disposing` 로 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1437"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="bc823-1438">`disposing` 매개 변수가 `true`인 경우 이 메서드는 이 <xref:System.Net.Sockets.Socket>에서 참조하는 관리 개체가 보유하고 있는 리소스를 모두 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1438">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references.</span></span> <span data-ttu-id="bc823-1439">이 메서드는 참조되는 각 개체의 `Dispose()` 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1439">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1440">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1440">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1441">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1441">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="bc823-1442">
            <para>
              <see langword="Dispose" /> 다른 개체에서 여러 번 호출할 수 있습니다. <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />를 재정의할 때 이전 <see langword="Dispose" /> 호출에서 삭제된 개체를 참조하지 않도록 주의하십시오. 구현 하는 방법에 대 한 자세한 내용은 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />를 참조 하세요 [Dispose 메서드 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.  에 대 한 자세한 내용은 <see langword="Dispose" /> 및 <see cref="M:System.Object.Finalize" />를 참조 하십시오 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md) 및 [Finalize 메서드 재정의](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1442">
              <para>
                <see langword="Dispose" /> can be called multiple times by other objects. When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />. For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1443">
            <see cref="T:System.Boolean" />에서 IP(인터넷 프로토콜) 데이터그램의 조각화를 허용하는지 여부를 나타내는 <see cref="T:System.Net.Sockets.Socket" /> 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1443">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1444">
            <see cref="T:System.Net.Sockets.Socket" />에서 데이터그램 조각화를 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1444">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows datagram fragmentation; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="bc823-1445">기본값은 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1445">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1446">데이터 그램 크기는 최대 전송 단위 (MTU) 전송 매체의 초과 하는 경우 조각화가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1446">Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</span></span> <span data-ttu-id="bc823-1447">송신 호스트 (모든 인터넷 프로토콜 버전) 또는 중간 라우터 (인터넷 프로토콜 버전 4만) 하 여 데이터 그램을 조각화 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1447">Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</span></span> <span data-ttu-id="bc823-1448">데이터 그램을 조각화 수 해야 하는 경우 및 <xref:System.Net.Sockets.Socket.DontFragment%2A> 옵션 설정, 데이터 그램 무시 되 고 데이터 그램의 보낸 사람에 게 제어 메시지 ICMP (Internet Protocol) 오류 메시지가 보내집니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1448">If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</span></span>  
  
 <span data-ttu-id="bc823-1449">프로토콜 TCP (Transmission Control) 소켓에서이 속성을 설정 하는 아무런 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1449">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1450">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.DontFragment%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1450">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1451">
            <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 패밀리의 소켓이 아닌 소켓에 대해 이 속성을 설정한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1451">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1452">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1452">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1453">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1453">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1454">
            <see cref="T:System.Net.Sockets.Socket" />이 IPv4 및 IPv6 둘 다에 사용되는 이중 모드 소켓인지 여부를 지정하는 <see cref="T:System.Boolean" /> 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1454">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1455">
            <see cref="T:System.Net.Sockets.Socket" />이 이중 모드 소켓이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1455">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is a  dual-mode socket; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="bc823-1456">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1456">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">
          <span data-ttu-id="bc823-1457">소켓 참조의 복제본을 만드는 대상 프로세스의 ID입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1457">The ID of the target process where a duplicate of the socket reference is created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1458">대상 프로세스에 대한 소켓 참조를 복제하고 이 프로세스의 소켓을 닫습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1458">Duplicates the socket reference for the target process, and closes the socket for this process.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1459">대상 프로세스에 전달될 소켓 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1459">The socket reference to be passed to the target process.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1460">대상 프로세스를 사용할지 <xref:System.Net.Sockets.Socket.%23ctor%2A> 중복 소켓 인스턴스를 만들려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1460">The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.</span></span>  
  
 <span data-ttu-id="bc823-1461">호출 하는 경우는 <xref:System.Net.Sockets.Socket.%23ctor%2A> 여러 번 사용 하 여 각 호출에 대 한 인수로 동일한 바이트 배열 생성자를 만들려는 관리 되는 여러 <xref:System.Net.Sockets.Socket> 인스턴스가 동일한 기본 소켓을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1461">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket.</span></span> <span data-ttu-id="bc823-1462">이 방법은 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1462">This practice is strongly discouraged.</span></span>  
  
 <span data-ttu-id="bc823-1463">소켓을 생성 하는 프로세스는 비동기 메서드를 사용 하는 경우 (<xref:System.Net.Sockets.Socket.BeginReceive%2A> 또는 <xref:System.Net.Sockets.Socket.BeginSend%2A>), 먼저 설정 해야 하는 프로세스는 <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> 속성을 소켓을 않을만들기프로세스의완료포트에바인딩된고,그렇지않으면true<xref:System.ArgumentNullException> 대상 프로세스에 대해 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1463">If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1464">
            <paramref name="targetProcessID" />가 잘못된 프로세스 ID입니다.  -또는-  소켓 참조를 복제하지 못했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1464">
              <paramref name="targetProcessID" /> is not a valid process id.  -or-  Duplication of the socket reference failed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1465">
            <see cref="T:System.Boolean" />이 브로드캐스트 패킷을 보내거나 받을 수 있는지 여부를 나타내는 <see cref="T:System.Net.Sockets.Socket" /> 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1465">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1466">
            <see cref="T:System.Net.Sockets.Socket" />이 브로드캐스트 패킷을 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1466">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows broadcast packets; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="bc823-1467">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1467">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1468">브로드캐스트 특정 서브넷으로 제한 되며 사용자 데이터 그램 프로토콜 (UDP.)를 사용 해야 합니다. 인터넷 프로토콜 버전 4 브로드캐스트할 수 있습니다 로컬 서브넷에 패킷을 255.255.255.255;로 전송 하 여 또는 네트워크의 호스트 부분에 설정 된 모든 비트를 사용 하 여 IP (인터넷 프로토콜) 주소 부분은 지정 된 브로드캐스트 주소로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1468">Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</span></span> <span data-ttu-id="bc823-1469">예를 들어 IP 주소는 192.168.1.40 클래스 C 주소를 네트워크 마스크 255.255.255.0-을 사용 하 여 네트워크 부분은 처음 세 옥텟과 호스트 부분은 마지막 8 진수에 리디렉션된 브로드캐스트 주소 192.168.1.255 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1469">For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</span></span>  
  
 <span data-ttu-id="bc823-1470">프로토콜 TCP (Transmission Control) 소켓에서이 속성을 설정 하는 아무런 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1470">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1471">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1471">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1472">데이터그램 소켓이 아닌 소켓에 이 옵션을 설정한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1472">This option is valid for a datagram socket only.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1473">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1473">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1474">들어오는 연결 시도를 비동기적으로 받아들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1474">Asynchronously accepts an incoming connection attempt.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-1475">전송된 바이트가 들어 있는 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1475">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span>
          </span>
        </param>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1476">이 비동기 작업에 대한 상태 정보와 모든 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1476">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1477">들어오는 연결 시도를 비동기적으로 받아들이고 원격 호스트 통신을 처리할 새 <see cref="T:System.Net.Sockets.Socket" /> 개체를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1477">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span>
          </span>
          <span data-ttu-id="bc823-1478">이 메서드는 전송된 초기 데이터가 들어 있는 버퍼를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1478">This method returns a buffer that contains the initial data transferred.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1479">원격 호스트와의 통신을 처리할 <see cref="T:System.Net.Sockets.Socket" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1479">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1480"><xref:System.Net.Sockets.Socket.EndAccept%2A> 호출을 완료 <xref:System.Net.Sockets.Socket.BeginAccept%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1480"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="bc823-1481">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A>에서 호출 되는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1481">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="bc823-1482">이 콜백 메서드를 별도 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1482">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span>  
  
 <span data-ttu-id="bc823-1483">콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 `asyncResult` 가져오려면 매개 변수를 <xref:System.Net.Sockets.Socket> 에서 연결 시도가 수행 되는.</span><span class="sxs-lookup"><span data-stu-id="bc823-1483">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="bc823-1484">구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 성공적으로 연결 시도 완료 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1484">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="bc823-1485">`buffer` 호출에서 받은 데이터가이 오버 로드의 매개 변수 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 및 `bytesTransferred` 매개 변수는 호출에서 전송 된 바이트 수를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1485">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="bc823-1486"><xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드 연결이 보류 중이면 때까지 차단 들어오는 연결 큐에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1486">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="bc823-1487">합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드는 들어오는 연결을 허용 하 고 반환 된 새 <xref:System.Net.Sockets.Socket> 원격 호스트에서 데이터를 받고 데이터를 보내는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1487">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1488">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1488">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1489">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1489">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1490">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1490">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1491">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1491">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1492">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 연결 소켓을 만들고 초기 10 바이트의 데이터를 수락 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1492">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="bc823-1493">콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndAccept%2A> 비동기 요청을 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1493">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="bc823-1494">데이터 및 전송 된 바이트 수가 반환 됩니다 합니다 `buffer` 및 `bytesTransferred` 이 메서드의 매개 변수를 콘솔에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1494">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1495">이 메서드에는 Windows NT가 필요합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1495">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1496">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1496">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1497">
            <paramref name="asyncResult" />가 비어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1497">
              <paramref name="asyncResult" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1498">
            <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />를 호출했지만 <paramref name="asyncResult" />가 만들어지지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1498">
              <paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1499">
            <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 메서드가 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1499">
              <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1500">
            <see cref="T:System.Net.Sockets.Socket" />에 액세스하려고 시도하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1500">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1501">모든 사용자 정의 데이터뿐만 아니라 이 비동기 작업에 대한 상태 정보도 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1501">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="bc823-1502">모든 사용자 정의 데이터뿐만 아니라 이 비동기 작업에 대한 상태 정보도 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1502">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1503">들어오는 연결 시도를 비동기적으로 받아들이고 원격 호스트 통신을 처리할 새로운 <see cref="T:System.Net.Sockets.Socket" />을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1503">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1504">원격 호스트와의 통신을 처리할 <see cref="T:System.Net.Sockets.Socket" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1504">A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1505"><xref:System.Net.Sockets.Socket.EndAccept%2A> 호출을 완료 <xref:System.Net.Sockets.Socket.BeginAccept%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1505"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="bc823-1506">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1506">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="bc823-1507">이 콜백 메서드를 별도 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1507">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="bc823-1508">사용할 수 있어야 합니다 `asyncResult` 매개 변수에서 반환 된는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1508">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1509">콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 `asyncResult` 가져오려면 매개 변수를 <xref:System.Net.Sockets.Socket> 에서 연결 시도가 수행 되는.</span><span class="sxs-lookup"><span data-stu-id="bc823-1509">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="bc823-1510">구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 성공적으로 연결 시도 완료 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1510">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span>  
  
 <span data-ttu-id="bc823-1511"><xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드 연결이 보류 중이면 때까지 차단 들어오는 연결 큐에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1511">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="bc823-1512">합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드는 들어오는 연결을 허용 하 고 반환 된 새 <xref:System.Net.Sockets.Socket> 원격 호스트에서 데이터를 받고 데이터를 보내는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1512">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1513">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1513">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1514">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1514">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1515">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1515">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1516">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1516">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1517">다음 코드 예제에서는 비동기 요청을 종료 하 고 새 <xref:System.Net.Sockets.Socket> 들어오는 연결 요청을 수락 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1517">The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request.</span></span> <span data-ttu-id="bc823-1518">소켓을 사용 하 여 비동기 통신을 보여 주는 전체 예제를 참조 하세요 [소켓 코드 예제에서는](~/docs/framework/network-programming/socket-code-examples.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1518">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1519">
            <paramref name="asyncResult" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1519">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1520">
            <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />를 호출했지만 <paramref name="asyncResult" />가 만들어지지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1520">
              <paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1521">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1521">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-1522">자세한 내용은 설명 부분을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1522">See the Remarks section for more information.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1523">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1523">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1524">
            <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 메서드가 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1524">
              <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1525">이 메서드에는 Windows NT가 필요합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1525">Windows NT is required for this method.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-1526">전송된 바이트가 들어 있는 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1526">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span>
          </span>
        </param>
        <param name="bytesTransferred">
          <span data-ttu-id="bc823-1527">전송된 바이트 수 입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1527">The number of bytes transferred.</span>
          </span>
        </param>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1528">이 비동기 작업에 대한 상태 정보와 모든 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1528">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1529">들어오는 연결 시도를 비동기적으로 받아들이고 원격 호스트 통신을 처리할 새 <see cref="T:System.Net.Sockets.Socket" /> 개체를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1529">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span>
          </span>
          <span data-ttu-id="bc823-1530">이 메서드는 전송된 초기 데이터와 바이트 수가 들어 있는 버퍼를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1530">This method returns a buffer that contains the initial data and the number of bytes transferred.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1531">원격 호스트와의 통신을 처리할 <see cref="T:System.Net.Sockets.Socket" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1531">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1532"><xref:System.Net.Sockets.Socket.EndAccept%2A> 호출을 완료 <xref:System.Net.Sockets.Socket.BeginAccept%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1532"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="bc823-1533">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A>에서 호출 되는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1533">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="bc823-1534">이 콜백 메서드를 별도 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1534">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="bc823-1535">사용할 수 있어야 합니다 `asyncResult` 매개 변수에서 반환 된는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1535">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1536">콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 `asyncResult` 가져오려면 매개 변수를 <xref:System.Net.Sockets.Socket> 에서 연결 시도가 수행 되는.</span><span class="sxs-lookup"><span data-stu-id="bc823-1536">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="bc823-1537">구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 성공적으로 연결 시도 완료 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1537">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="bc823-1538">`buffer` 호출에서 받은 데이터가이 오버 로드의 매개 변수 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 및 `bytesTransferred` 매개 변수는 호출에서 전송 된 바이트 수를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1538">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="bc823-1539"><xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드 연결이 보류 중이면 때까지 차단 들어오는 연결 큐에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1539">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="bc823-1540">합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드는 들어오는 연결을 허용 하 고 반환 된 새 <xref:System.Net.Sockets.Socket> 원격 호스트에서 데이터를 받고 데이터를 보내는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1540">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1541">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1541">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1542">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1542">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1543">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1543">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1544">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1544">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1545">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 연결 소켓을 만들고 초기 10 바이트의 데이터를 수락 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1545">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="bc823-1546">콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndAccept%2A> 비동기 요청을 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1546">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="bc823-1547">데이터 및 전송 된 바이트 수가 반환 됩니다 합니다 `buffer` 및 `bytesTransferred` 이 메서드의 매개 변수를 콘솔에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1547">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1548">이 메서드에는 Windows NT가 필요합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1548">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1549">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1549">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1550">
            <paramref name="asyncResult" />가 비어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1550">
              <paramref name="asyncResult" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1551">
            <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />를 호출했지만 <paramref name="asyncResult" />가 만들어지지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1551">
              <paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1552">
            <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 메서드가 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1552">
              <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1553">
            <see cref="T:System.Net.Sockets.Socket" />에 액세스하려고 시도하는 동안 오류가 발생한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1553">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1554">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1554">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="bc823-1555">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1555">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1556">보류 중인 비동기 연결 요청을 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1556">Ends a pending asynchronous connection request.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1557"><xref:System.Net.Sockets.Socket.EndConnect%2A> 시작 하는 비동기 원격 호스트 연결 요청을 완료 하는 차단 메서드를 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1557"><xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1558">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginConnect%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1558">Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="bc823-1559">이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1559">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns.</span></span> <span data-ttu-id="bc823-1560">콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드에 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1560">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="bc823-1561">콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 <xref:System.IAsyncResult> 가져오려면 매개 변수를 <xref:System.Net.Sockets.Socket> 에서 연결 시도가 수행 되는.</span><span class="sxs-lookup"><span data-stu-id="bc823-1561">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="bc823-1562">구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 성공적으로 연결 시도 완료 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1562">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1563">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1563">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1564">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1564">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1565">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1565">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1566">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1566">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1567">다음 코드 예제에서는 비동기 연결 시도 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1567">The following code example ends the asynchronous connection attempt.</span></span> <span data-ttu-id="bc823-1568">소켓을 사용 하 여 비동기 통신을 보여 주는 전체 예제를 참조 하세요 [소켓 코드 예제에서는](~/docs/framework/network-programming/socket-code-examples.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1568">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1569">
            <paramref name="asyncResult" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1569">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1570">
            <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1570">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1571">
            <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />가 비동기 연결을 위해 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1571">
              <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1572">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1572">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1573">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1573">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1574">이 비동기 작업에 대한 상태 정보와 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1574">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1575">보류 중인 비동기 연결 끊기 요청을 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1575">Ends a pending asynchronous disconnect request.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1576"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> 호출을 완료 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1576"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span></span> <span data-ttu-id="bc823-1577"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> 메서드는 연결 끊기 완료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1577">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes.</span></span> <span data-ttu-id="bc823-1578">비동기 작업에 대 한 자세한 내용은 MSDN 라이브러리의 비동기 프로그래밍 개요 항목을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="bc823-1578">For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1579">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1579">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1580">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1580">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1581">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1581">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1582">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1582">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1583">다음 코드 예제에서는 비동기 통신을 위한 소켓을 만들고 원격 호스트에 일부 데이터를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1583">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="bc823-1584">데이터를 보낼 때 <xref:System.Net.Sockets.Socket.Shutdown%2A> 송신을 중지 하 고 작업을 수신 하기 위해 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1584">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="bc823-1585">그런 다음 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 연결 끊기 요청을 시작 하기 위해 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1585">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="bc823-1586">콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 비동기 요청을 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1586">The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request.</span></span> <span data-ttu-id="bc823-1587">요청이 완료 되 면는 <xref:System.Net.Sockets.Socket.Connected%2A> 속성 소켓 연결이 있는지 여부를 테스트 하기 위해 쿼리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1587">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1588">이 메서드에는 Windows XP가 필요한데 운영 체제가 Windows 2000 또는 그 이전 버전인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1588">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1589">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1589">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1590">
            <paramref name="asyncResult" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1590">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1591">
            <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1591">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1592">
            <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />가 비동기 연결을 위해 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1592">
              <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1593">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1593">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.WebException">
          <span data-ttu-id="bc823-1594">연결 끊기 요청 시간이 초과된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1594">The disconnect request has timed out.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1595">보류 중인 비동기 읽기를 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1595">Ends a pending asynchronous read.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1596">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1596">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="bc823-1597">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1597">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1598">보류 중인 비동기 읽기를 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1598">Ends a pending asynchronous read.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1599">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1599">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1600">합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 에서 시작한 비동기 읽기 작업을 완료 하는 메서드를 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1600">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1601">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1601">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="bc823-1602">이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1602">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="bc823-1603">콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드에 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1603">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="bc823-1604">콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 에 전달 된 상태 개체를 가져오는 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1604">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="bc823-1605">수신 추출 <xref:System.Net.Sockets.Socket> 에서이 상태 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1605">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="bc823-1606">구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 읽기 작업을 완료 하 고 읽은 바이트 수를 반환 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1606">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="bc823-1607"><xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드는 데이터가 있을 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1607">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="bc823-1608">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndReceive%2A> 는 들어오는 네트워크 버퍼에 사용 가능한 첫 번째 큐에 넣은 데이터 그램을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1608">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="bc823-1609">연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드는에 지정 된 바이트 수를 최대 수 만큼의 데이터를 읽을 합니다 `size` 의 매개 변수는 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1609">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="bc823-1610">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1610">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="bc823-1611">받은 데이터를 가져오려면 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 <xref:System.IAsyncResult>, 결과 상태 개체에 포함 된 버퍼를 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1611">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
 <span data-ttu-id="bc823-1612">취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1612">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1613">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1613">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1614">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1614">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1615">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1615">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-1616">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1616">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1617">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1617">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1618">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1618">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1619">다음 코드 예제에서는 보류 중인 비동기 읽기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1619">The following code example ends a pending asynchronous read.</span></span> <span data-ttu-id="bc823-1620">소켓을 사용 하 여 비동기 통신을 보여 주는 전체 예제를 참조 하세요 [소켓 코드 예제에서는](~/docs/framework/network-programming/socket-code-examples.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1620">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1621">
            <paramref name="asyncResult" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1621">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1622">
            <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1622">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1623">
            <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />가 비동기 읽기를 위해 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1623">
              <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1624">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1624">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1625">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1625">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1626">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1626">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="bc823-1627">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1627">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1628">보류 중인 비동기 읽기를 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1628">Ends a pending asynchronous read.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1629">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1629">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1630">합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 에서 시작한 비동기 읽기 작업을 완료 하는 메서드를 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1630">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1631">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1631">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="bc823-1632">이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1632">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="bc823-1633">콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드에 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1633">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="bc823-1634">콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 에 전달 된 상태 개체를 가져오는 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1634">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="bc823-1635">수신 추출 <xref:System.Net.Sockets.Socket> 에서이 상태 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1635">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="bc823-1636">구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 읽기 작업을 완료 하 고 읽은 바이트 수를 반환 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1636">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="bc823-1637"><xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드는 데이터가 있을 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1637">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="bc823-1638">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndReceive%2A> 는 들어오는 네트워크 버퍼에 사용 가능한 첫 번째 큐에 넣은 데이터 그램을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1638">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="bc823-1639">연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드는에 지정 된 바이트 수를 최대 수 만큼의 데이터를 읽을 합니다 `size` 의 매개 변수는 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1639">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="bc823-1640">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1640">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="bc823-1641">받은 데이터를 가져오려면 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 <xref:System.IAsyncResult>, 결과 상태 개체에 포함 된 버퍼를 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1641">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1642">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1642">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1643">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1643">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1644">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1644">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-1645">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1645">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1646">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1646">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1647">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1647">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1648">
            <paramref name="asyncResult" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1648">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1649">
            <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1649">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1650">
            <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />가 비동기 읽기를 위해 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1650">
              <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1651">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1651">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1652">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1652">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1653">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1653">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="bc823-1654">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1654">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="endPoint">
          <span data-ttu-id="bc823-1655">소스 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1655">The source <see cref="T:System.Net.EndPoint" />.</span>
          </span>
        </param>
        <param name="end_point">
          <span data-ttu-id="bc823-1656">소스 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1656">The source <see cref="T:System.Net.EndPoint" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1657">특정 끝점에서 보류 중인 비동기 읽기를 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1657">Ends a pending asynchronous read from a specific endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1658">성공할 경우 받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1658">If successful, the number of bytes received.</span>
          </span>
          <span data-ttu-id="bc823-1659">실패하면 0을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1659">If unsuccessful, returns 0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1660">합니다 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 에서 시작한 비동기 읽기 작업을 완료 하는 메서드를 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1660">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1661">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1661">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="bc823-1662">이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1662">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns.</span></span> <span data-ttu-id="bc823-1663">콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드에 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1663">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="bc823-1664">콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 에 전달 된 상태 개체를 가져오는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1664">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-1665">수신 추출 <xref:System.Net.Sockets.Socket> 에서이 상태 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1665">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="bc823-1666">구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 읽기 작업을 완료 하 고 읽은 바이트 수를 반환 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1666">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="bc823-1667"><xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 메서드는 데이터가 있을 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1667">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="bc823-1668">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 는 들어오는 네트워크 버퍼에 사용 가능한 첫 번째 큐에 넣은 데이터 그램을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1668">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="bc823-1669">연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 메서드는에 지정 된 바이트 수를 최대 수 만큼의 데이터를 읽을 합니다 `size` 의 매개 변수는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1669">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-1670">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1670">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span> <span data-ttu-id="bc823-1671">받은 데이터를 가져오려면 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 <xref:System.IAsyncResult> 개체를 결과 상태 개체에 포함 된 버퍼를 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1671">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object.</span></span> <span data-ttu-id="bc823-1672">원래 호스트를 식별 하려면 추출 합니다 <xref:System.Net.EndPoint> 로 캐스팅 하 고는 <xref:System.Net.IPEndPoint>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1672">To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>.</span></span> <span data-ttu-id="bc823-1673">사용 된 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> IP 주소를 획득 하는 방법 및 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 포트 번호를 가져올 방법.</span><span class="sxs-lookup"><span data-stu-id="bc823-1673">Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to obtain the port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1674">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1674">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1675">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1675">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1676">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1676">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1677">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1677">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1678">다음 코드 예제에서는 특정에서 보류 중인 비동기 읽기를 끝냅니다 <xref:System.Net.EndPoint>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1678">The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1679">
            <paramref name="asyncResult" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1679">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1680">
            <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1680">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1681">
            <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />가 비동기 읽기를 위해 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1681">
              <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1682">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1682">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1683">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1683">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1684">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1684">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-1685">받은 패킷에 대한 <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1685">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</span>
          </span>
        </param>
        <param name="endPoint">
          <span data-ttu-id="bc823-1686">소스 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1686">The source <see cref="T:System.Net.EndPoint" />.</span>
          </span>
        </param>
        <param name="ipPacketInformation">
          <span data-ttu-id="bc823-1687">받은 패킷의 <see cref="T:System.Net.IPAddress" /> 및 인터페이스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1687">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1688">특정 끝점에서 보류 중인 비동기 읽기를 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1688">Ends a pending asynchronous read from a specific endpoint.</span>
          </span>
          <span data-ttu-id="bc823-1689">또한 이 메서드는 패킷에 대해 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />이 제공하는 것보다 많은 정보를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1689">This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1690">성공할 경우 받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1690">If successful, the number of bytes received.</span>
          </span>
          <span data-ttu-id="bc823-1691">실패하면 0을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1691">If unsuccessful, returns 0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1692">작업이 완료 되지 않은 경우이 메서드는 완료 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1692">If the operation has not completed, this method blocks until it does.</span></span>  
  
 <span data-ttu-id="bc823-1693">이 작업을 동기적으로 수행 하려면 사용 된 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1693">To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-1694">검사 `ipPacketInformation` 경우 알아야 할 유니캐스트, 멀티 캐스트 또는 브로드캐스트 주소를 사용 하 여 데이터 그램을 보냈습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1694">Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1695">
            <paramref name="asyncResult" />가 <see langword="null" />입니다. 또는 <paramref name="endPoint" />가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1695">
              <paramref name="asyncResult" /> is <see langword="null" />  -or-  <paramref name="endPoint" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1696">
            <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1696">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1697">
            <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />가 비동기 읽기를 위해 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1697">
              <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1698">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1698">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1699">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1699">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1700">보류 중인 비동기 보내기를 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1700">Ends a pending asynchronous send.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1701">이 비동기 작업에 대한 상태 정보를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1701">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="bc823-1702">이 비동기 작업에 대한 상태 정보를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1702">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1703">보류 중인 비동기 보내기를 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1703">Ends a pending asynchronous send.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1704">성공적이면 <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수이고, 그렇지 않으면 잘못된 <see cref="T:System.Net.Sockets.Socket" /> 오류입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1704">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1705"><xref:System.Net.Sockets.Socket.EndSend%2A> 시작 하는 비동기 송신 작업을 완료 <xref:System.Net.Sockets.Socket.BeginSend%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1705"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="bc823-1706">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginSend%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1706">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="bc823-1707">이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1707">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="bc823-1708">콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드에 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1708">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="bc823-1709">콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 보내는 가져오려면 매개 변수 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1709">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-1710">구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndSend%2A> 성공적으로 송신 작업을 완료 하 고 전송 된 바이트 수를 반환 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1710">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="bc823-1711">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSend%2A> 데이터 그램 전송 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1711">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="bc823-1712">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSend%2A> 보낸 버퍼의 일부 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1712">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="bc823-1713">반환 된 값 <xref:System.Net.Sockets.Socket.EndSend%2A> 버퍼 없음을 나타냅니다 호출 완전히 전송 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드가 다시 보내지 않은 데이터를 저장할 버퍼를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1713">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="bc823-1714">보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1714">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-1715">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1715">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-1716">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1716">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1717">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1717">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1718">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1718">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1719">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1719">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-1720">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1720">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1721">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1721">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-1722">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1722">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1723">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1723">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1724">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1724">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1725">다음 코드 예제에는 보류 중인 비동기 보내기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1725">The following code example ends a pending asynchronous send.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1726">
            <paramref name="asyncResult" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1726">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1727">
            <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1727">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1728">
            <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />가 비동기 보내기를 위해 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1728">
              <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1729">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1729">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1730">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1730">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1731">이 비동기 작업에 대한 상태 정보를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1731">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="bc823-1732">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1732">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1733">보류 중인 비동기 보내기를 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1733">Ends a pending asynchronous send.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1734">성공적이면 <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수이고, 그렇지 않으면 잘못된 <see cref="T:System.Net.Sockets.Socket" /> 오류입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1734">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1735"><xref:System.Net.Sockets.Socket.EndSend%2A> 시작 하는 비동기 송신 작업을 완료 <xref:System.Net.Sockets.Socket.BeginSend%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1735"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="bc823-1736">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginSend%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1736">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="bc823-1737">이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1737">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="bc823-1738">콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드에 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1738">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="bc823-1739">콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 보내는 가져오려면 매개 변수 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1739">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-1740">구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndSend%2A> 성공적으로 송신 작업을 완료 하 고 전송 된 바이트 수를 반환 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1740">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="bc823-1741">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSend%2A> 데이터 그램 전송 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1741">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="bc823-1742">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSend%2A> 보낸 버퍼의 일부 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1742">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="bc823-1743">반환 된 값 <xref:System.Net.Sockets.Socket.EndSend%2A> 버퍼 없음을 나타냅니다 호출 완전히 전송 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드가 다시 보내지 않은 데이터를 저장할 버퍼를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1743">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="bc823-1744">보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1744">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-1745">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1745">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-1746">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1746">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1747">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1747">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1748">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1748">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1749">지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1749">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="bc823-1750">스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1750">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1751">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1751">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-1752">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1752">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1753">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1753">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1754">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1754">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1755">
            <paramref name="asyncResult" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1755">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1756">
            <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1756">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1757">
            <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />가 비동기 보내기를 위해 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1757">
              <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1758">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1758">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1759">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1759">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1760">이 비동기 작업에 대한 상태 정보를 저장하는 <see cref="T:System.IAsyncResult" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1760">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1761">보류 중인 비동기 파일 보내기를 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1761">Ends a pending asynchronous send of a file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1762"><xref:System.Net.Sockets.Socket.EndSendFile%2A> 시작 하는 비동기 송신 작업을 완료 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1762"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span></span>  
  
 <span data-ttu-id="bc823-1763">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1763">Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="bc823-1764">이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1764">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns.</span></span> <span data-ttu-id="bc823-1765">콜백 메서드를 <xref:System.IAsyncResult> 에서 반환 된 개체는 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 메서드에 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1765">The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="bc823-1766">콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 보내는 가져오려면 매개 변수 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1766">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-1767">구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 보내기 작업을 완료 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1767">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.</span></span>  
  
 <span data-ttu-id="bc823-1768">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 데이터 그램 전송 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1768">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent.</span></span> <span data-ttu-id="bc823-1769">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 전체 파일이 전송 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1769">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="bc823-1770">보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1770">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-1771">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1771">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-1772">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1772">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1773">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1773">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1774">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1774">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1775">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1775">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1776">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1776">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1777">다음 코드 예제에서는 비동기 통신에 대 한 소켓 연결 및 보내기 시작 파일 "text.txt" 비동기적으로 원격 호스트에 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1777">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="bc823-1778">콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 전송을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1778">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-1779">이 메서드에는 Windows NT가 필요합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1779">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1780">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1780">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1781">
            <paramref name="asyncResult" />가 비어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1781">
              <paramref name="asyncResult" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1782">
            <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1782">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1783">
            <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />이 비동기 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />을 위해 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1783">
              <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1784">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1784">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-1785">아래의 설명 부분을 참조하십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1785">See remarks section below.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="bc823-1786">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1786">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="bc823-1787">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1787">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1788">특정 위치로의 보류 중인 비동기 보내기를 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1788">Ends a pending asynchronous send to a specific location.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1789">성공적이면 보낸 바이트 수이고, 그렇지 않으면 잘못된 <see cref="T:System.Net.Sockets.Socket" /> 오류입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1789">If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1790"><xref:System.Net.Sockets.Socket.EndSendTo%2A> 시작 하는 비동기 송신 작업을 완료 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1790"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span>  
  
 <span data-ttu-id="bc823-1791">호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1791">Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="bc823-1792">이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1792">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="bc823-1793">콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 메서드에 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1793">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="bc823-1794">콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 보내는 가져오려면 매개 변수 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1794">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-1795">구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 성공적으로 송신 작업을 완료 하 고 전송 된 바이트 수를 반환 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1795">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="bc823-1796">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 데이터 그램 전송 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1796">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="bc823-1797">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 바이트 수가 요청 된 전송 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1797">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="bc823-1798">보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1798">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-1799">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1799">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-1800">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1800">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1801">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1801">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1802">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1802">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1803">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1803">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1804">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1804">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1805">다음 코드 예제에는 특정 위치에는 비동기 보내기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1805">The following code example ends an asynchronous send to a specific location.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-1806">
            <paramref name="asyncResult" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1806">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-1807">
            <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1807">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1808">
            <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />가 비동기 보내기를 위해 이미 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1808">
              <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1809">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1809">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1810">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1810">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1811">
            <see cref="T:System.Boolean" />이 하나의 포트에 하나의 프로세스만 바인딩하는 것을 허용하는지 여부를 지정하는 <see cref="T:System.Net.Sockets.Socket" /> 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1811">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1812">
            <see cref="T:System.Net.Sockets.Socket" />이 특정 포트에 하나의 소켓만 바인딩하는 것을 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1812">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows only one socket to bind to a specific port; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="bc823-1813">기본값은 <see langword="true" /> Windows Server 2003 및 Windows XP 서비스 팩 2 및 <see langword="false" /> 다른 모든 버전.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1813">The default is <see langword="true" /> for Windows Server 2003 and Windows XP Service Pack 2, and <see langword="false" /> for all other versions.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1814">경우 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> 됩니다 `false`, 여러 소켓을 사용할 수는 <xref:System.Net.Sockets.Socket.Bind%2A> 특정 포트에 바인딩할 메서드; 있지만 하나의 소켓의 포트에 전송 되는 네트워크 트래픽에서 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1814">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</span></span> <span data-ttu-id="bc823-1815">둘 이상의 소켓을 사용 하려고 하는 경우는 <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> 구체적인 IP 주소를 사용 하 여 하나를 해당 포트로 전송 되는 네트워크 트래픽을 처리한 다음 특정 포트에 바인딩할 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1815">If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</span></span>  
  
 <span data-ttu-id="bc823-1816">경우 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> 됩니다 `true`를 처음 사용 합니다 <xref:System.Net.Sockets.Socket.Bind%2A> IP (인터넷 프로토콜) 주소에 관계 없이 특정 포트에 바인딩하지 하려고 하는 메서드가 성공;의 모든 후속 사용를 <xref:System.Net.Sockets.Socket.Bind%2A> 해당 포트에 바인딩하지 하려고 하는 방법에는 원래 바인딩된 소켓 소멸 될 때까지 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1816">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.</span></span>  
  
 <span data-ttu-id="bc823-1817">이 속성 전에 설정 해야 <xref:System.Net.Sockets.Socket.Bind%2A> 이 고 그렇지 않으면 호출을 <xref:System.InvalidOperationException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1817">This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1818">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1818">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1819">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1819">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1820">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1820">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1821">
            <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />가 이 <see cref="T:System.Net.Sockets.Socket" />에 대해 호출된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1821">
              <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1822">
            <see cref="T:System.Net.Sockets.Socket" /> 클래스에서 사용한 리소스를 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1822">Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1823"><xref:System.Net.Sockets.Socket> 종료 자가 호출 클래스를 <xref:System.Net.Sockets.Socket.Close%2A> 닫는 메서드를를 <xref:System.Net.Sockets.Socket> 와 연결 된 리소스를 해제 하 고는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1823">The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1824">
            <see cref="T:System.Net.Sockets.Socket" /> 옵션의 값을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1824">Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="bc823-1825">
            <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1825">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="bc823-1826">
            <see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1826">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1827">개체로 나타내는 지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션 값을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1827">Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1828">옵션 값을 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1828">An object that represents the value of the option.</span>
          </span>
          <span data-ttu-id="bc823-1829">
            <paramref name="optionName" /> 매개 변수가 <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />로 설정되면 반환 값은 <see cref="T:System.Net.Sockets.LingerOption" /> 클래스의 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1829">When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class.</span>
          </span>
          <span data-ttu-id="bc823-1830">
            <paramref name="optionName" />이 <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" />이나 <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />으로 설정되면 반환 값은 <see cref="T:System.Net.Sockets.MulticastOption" /> 클래스의 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1830">When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class.</span>
          </span>
          <span data-ttu-id="bc823-1831">
            <paramref name="optionName" />이 다른 값이면 반환 값은 정수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1831">When <paramref name="optionName" /> is any other value, the return value is an integer.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1832"><xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1832"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-1833">이 오버 로드를 사용 하 여 합니다 <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, 및 <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1833">Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="bc823-1834">에 대 한 합니다 <xref:System.Net.Sockets.SocketOptionName.Linger> 옵션을 사용 하 여 <xref:System.Net.Sockets.Socket> 에 대 한는 `optionLevel` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1834">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="bc823-1835">에 대 한 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 하 고 <xref:System.Net.Sockets.SocketOptionName.DropMembership>를 사용 하 여 <xref:System.Net.Sockets.SocketOptionLevel.IP>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1835">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="bc823-1836">위에 나열 된 옵션의 값을 설정, 사용 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1836">If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1837">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1837">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1838">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1838">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1839">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1839">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1840">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1840">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1841">다음 코드 예제에서는 검색 된 <xref:System.Net.Sockets.LingerOption> 및 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값을 콘솔에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1841">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1842">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1842">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-1843">-또는-  <paramref name="optionName" />이 지원되지 않는 값인 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />로 설정되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1843">-or-  <paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1844">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1844">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="bc823-1845">
            <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1845">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="bc823-1846">
            <see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1846">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="bc823-1847">해당 옵션 설정을 받을 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1847">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1848">바이트 배열로 나타내는 지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션 설정을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1848">Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1849"><xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1849"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-1850">이 메서드가 성공적으로 완료 되는 배열에서 지정 된 `optionValue` 매개 변수는 지정 된 값이 포함 <xref:System.Net.Sockets.Socket> 옵션.</span><span class="sxs-lookup"><span data-stu-id="bc823-1850">Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.</span></span>  
  
 <span data-ttu-id="bc823-1851">때의 길이 `optionValue` 배열이 지정된 된 값을 저장 하는 데 필요한 바이트의 수보다 작은 <xref:System.Net.Sockets.Socket> 옵션을 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1851">When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-1852">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1852">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1853">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1853">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="bc823-1854">정수 또는 부울 값으로 표현 되는 모든 소켓에 대 한이 오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1854">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1855">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1855">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1856">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1856">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1857">다음 코드 예제에서는 검색 된 <xref:System.Net.Sockets.LingerOption> 및 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값을 콘솔에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1857">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1858">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1858">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-1859">\- 또는 -  .NET Compact Framework 응용 프로그램에서 Windows CE 기본 버퍼 공간을 32768바이트로 설정되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1859">\- or -  In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span>
          </span>
          <span data-ttu-id="bc823-1860">
            <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />을 호출하여 소켓당 버퍼 공간을 변경할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1860">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1861">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1861">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="bc823-1862">
            <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1862">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="bc823-1863">
            <see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1863">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionLength">
          <span data-ttu-id="bc823-1864">예상되는 반환 값의 길이(바이트)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1864">The length, in bytes, of the expected return value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1865">배열의 지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션 값을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1865">Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1866">소켓 옵션의 값을 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1866">An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1867">`optionLength` 매개 변수는 반환 된 바이트 배열의 최대 크기를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1867">The `optionLength` parameter sets the maximum size of the returned byte array.</span></span> <span data-ttu-id="bc823-1868">옵션 값을 바이트에 필요한 경우 배열이 포함 됩니다 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1868">If the option value requires fewer bytes, the array will contain only that many bytes.</span></span> <span data-ttu-id="bc823-1869">옵션 값을 더 많은 바이트를 요구 하는 경우 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1869">If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-1870">정수 또는 부울 값으로 표현 되는 모든 소켓에 대 한이 오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1870">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1871">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1871">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1872">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1872">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1873">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1873">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1874">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1874">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1875">다음 코드 예제에서는 검색 된 <xref:System.Net.Sockets.LingerOption> 및 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값을 콘솔에 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1875">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1876">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1876">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-1877">\- 또는 -  .NET Compact Framework 응용 프로그램에서 Windows CE 기본 버퍼 공간을 32768바이트로 설정되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1877">\- or -  In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span>
          </span>
          <span data-ttu-id="bc823-1878">
            <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />을 호출하여 소켓당 버퍼 공간을 변경할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1878">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1879">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1879">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1880">
            <see cref="T:System.Net.Sockets.Socket" />에 대한 운영 체제 핸들을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1880">Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1881">
            <see cref="T:System.IntPtr" />에 대한 운영 체제 핸들을 나타내는 <see cref="T:System.Net.Sockets.Socket" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1881">An <see cref="T:System.IntPtr" /> that represents the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1882">
            <see cref="T:System.Net.Sockets.Socket" />의 하위 수준 운영 모드를 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1882">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">
          <span data-ttu-id="bc823-1883">수행할 작업의 컨트롤 코드를 지정하는 <see cref="T:System.Int32" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1883">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</span>
          </span>
        </param>
        <param name="optionInValue">
          <span data-ttu-id="bc823-1884">작업에 필요한 입력 데이터가 들어 있는 <see cref="T:System.Byte" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1884">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</span>
          </span>
        </param>
        <param name="optionOutValue">
          <span data-ttu-id="bc823-1885">작업에서 반환된 출력 데이터가 들어 있는 <see cref="T:System.Byte" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1885">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1886">숫자 컨트롤 코드를 사용하여 <see cref="T:System.Net.Sockets.Socket" />의 하위 수준 운영 모드를 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1886">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1887">
            <paramref name="optionOutValue" /> 매개 변수의 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1887">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1888">합니다 <xref:System.Net.Sockets.Socket.IOControl%2A> 메서드는 운영 체제에 대 한 하위 수준 액세스를 제공 <xref:System.Net.Sockets.Socket> 의 현재 인스턴스의 내부는 <xref:System.Net.Sockets.Socket> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1888">The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="bc823-1889">자세한 내용은 MSDN library에서 WSAIoctl 설명서를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1889">For more information, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1890">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1890">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1891">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1891">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1892">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1892">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1893">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1893">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1894">다음 코드 예제에서는 FIONREAD 및 사용할 수 있는 속성의 결과 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1894">The following code example compares the results of FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1895">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1895">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1896">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1896">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1897">
            <see cref="P:System.Net.Sockets.Socket.Blocking" /> 속성을 사용하지 않고 블로킹 모드를 변경하려고 한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1897">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-1898">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1898">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="bc823-1899">비관리 코드를 실행 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1899">to execute unmanaged code.</span>
          </span>
          <span data-ttu-id="bc823-1900">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1900">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">
          <span data-ttu-id="bc823-1901">수행할 작업의 컨트롤 코드를 지정하는 <see cref="T:System.Net.Sockets.IOControlCode" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1901">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</span>
          </span>
        </param>
        <param name="optionInValue">
          <span data-ttu-id="bc823-1902">해당 작업에 필요한 입력 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1902">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</span>
          </span>
        </param>
        <param name="optionOutValue">
          <span data-ttu-id="bc823-1903">해당 작업에서 반환된 출력 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1903">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1904">
            <see cref="T:System.Net.Sockets.Socket" /> 열거형으로 컨트롤 코드를 지정하여 <see cref="T:System.Net.Sockets.IOControlCode" />의 하위 수준 운영 모드를 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1904">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-1905">
            <paramref name="optionOutValue" /> 매개 변수의 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1905">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1906">이 메서드는 운영 체제에 대 한 하위 수준 액세스를 제공 <xref:System.Net.Sockets.Socket> 의 현재 인스턴스의 내부는 <xref:System.Net.Sockets.Socket> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1906">This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="bc823-1907">자세한 내용은 MSDN library에서 WSAIoctl 설명서를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1907">For more, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1908">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1908">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1909">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1909">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1910">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1910">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1911">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1911">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1912">다음 코드 예제에서는 호출의 결과 비교 <xref:System.Net.Sockets.Socket.IOControl%2A> 사용 하 여 <xref:System.Net.Sockets.IOControlCode.DataToRead> 하며 <xref:System.Net.Sockets.Socket.Available%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1912">The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1913">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1913">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1914">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1914">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-1915">
            <see cref="P:System.Net.Sockets.Socket.Blocking" /> 속성을 사용하지 않고 블로킹 모드를 변경하려고 한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1915">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="bc823-1916">비관리 코드를 실행 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1916">to execute unmanaged code.</span>
          </span>
          <span data-ttu-id="bc823-1917">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1917">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1918">
            <see cref="T:System.Net.Sockets.Socket" />이 특정 로컬 포트에 바인딩되었는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1918">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1919">
            <see cref="T:System.Net.Sockets.Socket" />이 로컬 포트에 바인딩되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1919">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is bound to a local port; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1920">호출 하 여 명시적으로 바인딩되어 있는 경우 소켓 로컬 포트에 바인딩된 것으로 간주 되는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 같은 멤버를 호출 하 여 암시적으로 바인딩된 <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, 또는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, 임시 로컬 포트 (무료 보다 큰 포트를 사용 하는 1024, 운영 체제에서 선택 합니다.) 서버 사용을 <xref:System.Net.Sockets.Socket.Bind%2A> 클라이언트에 연결할 수 있도록 잘 알려진 포트에 바인딩해야 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1920">A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1921">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.IsBound%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1921">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1922">보류 중인 데이터를 모두 보내려고 할 때 <see cref="T:System.Net.Sockets.Socket" />에서 소켓 닫기를 지연할지 여부를 지정하는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1922">Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1923">소켓을 닫는 동안 링거하는 방법을 지정하는 <see cref="T:System.Net.Sockets.LingerOption" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1923">A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies how to linger while closing a socket.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1924">합니다 <xref:System.Net.Sockets.Socket.LingerState%2A> 속성이 변경 되는 방법은 <xref:System.Net.Sockets.Socket.Close%2A> 메서드 동작 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1924">The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves.</span></span> <span data-ttu-id="bc823-1925">집합 Winsock에서 연결을 다시 설정할는 조건을 수정 하는 경우이 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1925">This property when set modifies the conditions under which the connection can be reset by Winsock.</span></span> <span data-ttu-id="bc823-1926">연결 다시 설정은 IP 프로토콜 동작에 따라 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1926">Connection resets can still occur based on the IP protocol behavior.</span></span>  
  
 <span data-ttu-id="bc823-1927">이 속성을 호출한 후에 연결 지향 연결이 열린 채로 시간의 길이 제어 <xref:System.Net.Sockets.Socket.Close%2A> 데이터 전송 대기 상태인 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1927">This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.</span></span>  
  
 <span data-ttu-id="bc823-1928">피어에 데이터를 보내는 메서드를 호출 하면이 데이터는 나가는 네트워크 버퍼에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1928">When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</span></span> <span data-ttu-id="bc823-1929">이 데이터는 하기 전에 원격 호스트에 전송 되도록 하려면이 속성을 사용할 수는 <xref:System.Net.Sockets.TcpClient.Close%2A> 메서드가 연결을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1929">This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.</span></span>  
  
 <span data-ttu-id="bc823-1930">활성화 하려면 만들기를 <xref:System.Net.Sockets.LingerOption> 원하는 값이 포함 된 인스턴스 및 설정의 <xref:System.Net.Sockets.Socket.LingerState%2A> 이 인스턴스에 대 한 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1930">To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.</span></span>  
  
 <span data-ttu-id="bc823-1931">동작을 설명 하는 다음 표에서 <xref:System.Net.Sockets.Socket.Close%2A> 의 가능한 값에 대 한 메서드를 <xref:System.Net.Sockets.LingerOption.Enabled%2A> 속성 및 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 속성에 저장 됩니다는 <xref:System.Net.Sockets.Socket.LingerState%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1931">The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
|<span data-ttu-id="bc823-1932">LingerState.Enabled</span><span class="sxs-lookup"><span data-stu-id="bc823-1932">LingerState.Enabled</span></span>|<span data-ttu-id="bc823-1933">LingerState.LingerTime</span><span class="sxs-lookup"><span data-stu-id="bc823-1933">LingerState.LingerTime</span></span>|<span data-ttu-id="bc823-1934">동작</span><span class="sxs-lookup"><span data-stu-id="bc823-1934">Behavior</span></span>|  
|-------------------------|----------------------------|--------------|  
|<span data-ttu-id="bc823-1935">`false` (사용 안 함), 기본값</span><span class="sxs-lookup"><span data-stu-id="bc823-1935">`false` (disabled), the default value</span></span>|<span data-ttu-id="bc823-1936">제한 시간이 적용 되지 않습니다 (기본값).</span><span class="sxs-lookup"><span data-stu-id="bc823-1936">The time-out is not applicable, (default).</span></span>|<span data-ttu-id="bc823-1937">기본 IP 프로토콜 제한 시간이 만료 될 때까지 보류 중인 데이터 보내려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1937">Attempts to send pending data until the default IP protocol time-out expires.</span></span>|  
|<span data-ttu-id="bc823-1938">`true` (사용)</span><span class="sxs-lookup"><span data-stu-id="bc823-1938">`true` (enabled)</span></span>|<span data-ttu-id="bc823-1939">0이 아닌 제한 시간</span><span class="sxs-lookup"><span data-stu-id="bc823-1939">A nonzero time-out</span></span>|<span data-ttu-id="bc823-1940">지정된 된 제한 시간이 만료 되 면 시도가 실패 하면 다음 Winsock 연결을 다시 설정 될 때까지 보류 중인 데이터 보내려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1940">Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</span></span>|  
|<span data-ttu-id="bc823-1941">`true` (사용)</span><span class="sxs-lookup"><span data-stu-id="bc823-1941">`true` (enabled)</span></span>|<span data-ttu-id="bc823-1942">0 시간 제한입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1942">A zero timeout.</span></span>|<span data-ttu-id="bc823-1943">보류 중인 데이터를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1943">Discards any pending data.</span></span> <span data-ttu-id="bc823-1944">Winsock 소켓 연결 지향 (예: TCP)에 대 한 연결을 다시 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1944">For connection-oriented socket (TCP, for example), Winsock resets the connection.</span></span>|  
  
 <span data-ttu-id="bc823-1945">IP 스택이 연결의 왕복 시간을 기준으로 사용 하려면 기본 IP 프로토콜 제한 시간을 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1945">The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</span></span> <span data-ttu-id="bc823-1946">대부분의 경우에서 시간 제한이 스택에 의해 계산 응용 프로그램에 의해 정의 된 보다 상대적입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1946">In most cases, the time-out computed by the stack is more relevant than one defined by an application.</span></span> <span data-ttu-id="bc823-1947">소켓에 대 한 기본 동작은이 때는 <xref:System.Net.Sockets.Socket.LingerState%2A> 속성이 설정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1947">This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.</span></span>  
  
 <span data-ttu-id="bc823-1948">경우는 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 속성에 저장 됩니다는 <xref:System.Net.Sockets.Socket.LingerState%2A> 속성의 기본 IP 프로토콜 제한 보다 큰, 기본 IP 프로토콜 제한 시간이 적용 되 고 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1948">When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1949">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.LingerState%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1949">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1950">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1950">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1951">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1951">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">
          <span data-ttu-id="bc823-1952">보류 중인 연결 큐의 최대 길이입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1952">The maximum length of the pending connections queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-1953">
            <see cref="T:System.Net.Sockets.Socket" />을 수신 상태로 둡니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1953">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1954"><xref:System.Net.Sockets.Socket.Listen%2A> 연결 지향 하면 <xref:System.Net.Sockets.Socket> 들어오는 연결 시도를 수신 대기 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1954"><xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts.</span></span> <span data-ttu-id="bc823-1955">`backlog` 매개 변수는 들어오는 연결 수락 대기할 수 있는 횟수를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1955">The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance.</span></span> <span data-ttu-id="bc823-1956">지정할 수 있습니다 하는 연결의 최대 수를 확인 하려면 검색을 <xref:System.Net.Sockets.SocketOptionName.MaxConnections> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1956">To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value.</span></span> <span data-ttu-id="bc823-1957"><xref:System.Net.Sockets.Socket.Listen%2A> 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1957"><xref:System.Net.Sockets.Socket.Listen%2A> does not block.</span></span>  
  
 <span data-ttu-id="bc823-1958">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1958">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1959">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1959">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="bc823-1960">사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 큐에서 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1960">Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1961">호출 해야 합니다는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.Listen%2A>, 또는 <xref:System.Net.Sockets.Socket.Listen%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1961">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1962">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1962">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1963">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1963">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1964">백로그 매개 변수는 운영 체제에 따라 다른 값으로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1964">The backlog parameter is limited to different values depending on the Operating System.</span></span> <span data-ttu-id="bc823-1965">더 높은 값을 지정할 수 있지만 백로그 제한 됩니다 운영 체제에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1965">You may specify a higher value, but the backlog will be limited based on the Operating System.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1966">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket> 들어오는 연결을 수신 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1966">The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.</span></span>  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1967">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1967">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1968">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1968">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1969">로컬 끝점을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1969">Gets the local endpoint.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1970">
            <see cref="T:System.Net.EndPoint" />이 통신하는 데 사용하는 <see cref="T:System.Net.Sockets.Socket" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1970">The <see cref="T:System.Net.EndPoint" /> that the <see cref="T:System.Net.Sockets.Socket" /> is using for communications.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1971"><xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 속성을 가져옵니다는 <xref:System.Net.EndPoint> 로컬 IP 주소 및 포트 번호를 포함 하는 프로그램 <xref:System.Net.Sockets.Socket> 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1971">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound.</span></span> <span data-ttu-id="bc823-1972">이 캐스팅 해야 <xref:System.Net.EndPoint> 에 <xref:System.Net.IPEndPoint> 모든 정보를 검색 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1972">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="bc823-1973">호출할 수 있습니다 합니다 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 로컬 검색 하는 방법 <xref:System.Net.IPAddress>, 및 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 로컬 포트 번호를 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1973">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the local port number.</span></span>  
  
 <span data-ttu-id="bc823-1974">합니다 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 에 대 한 호출을 수행한 후에 일반적으로 속성을 설정 합니다 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1974">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="bc823-1975">시스템에서 소켓의 로컬 IP 주소 및 포트 번호 할당을 허용 하는 경우는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 속성이 첫 번째 I/O 작업 후 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1975">If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation.</span></span> <span data-ttu-id="bc823-1976">연결 지향 프로토콜에 대 한 첫 번째 I/O 작업에 대 한 호출 수를 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-1976">For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-1977">연결 없는 프로토콜에 대 한 첫 번째 I/O 작업은 송신 중 하나일 또는 호출을 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1977">For connectionless protocols, the first I/O operation would be any of the send or receive calls.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1978">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1978">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-1979">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-1979">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-1980">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1980">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-1981">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1981">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1982">다음 코드 예제를 검색 하 고 로컬과 원격 끝점을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1982">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1983">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1983">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1984">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1984">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1985">나가는 멀티캐스트 패킷을 보내는 응용 프로그램에 전달할지 여부를 지정하는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1985">Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1986">
            <see cref="T:System.Net.Sockets.Socket" />이 나가는 멀티캐스트 패킷을 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1986">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> receives outgoing multicast packets; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1987">멀티 캐스트는 인터넷에서 다 대 다 통신을 위한 확장 가능한 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1987">Multicast is a scalable method for many-to-many communication on the Internet.</span></span> <span data-ttu-id="bc823-1988">멀티 캐스트 주소로; 프로세스 구독 그런 다음 구독된 프로세스에서 보낸 모든 패킷이 멀티 캐스트 주소를 구독 하는 다른 모든 프로세스에서 수신 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1988">A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</span></span>  
  
 <span data-ttu-id="bc823-1989">프로토콜 TCP (Transmission Control) 소켓에서이 속성을 설정 하는 아무런 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1989">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-1990">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1990">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-1991">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1991">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-1992">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1992">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-1993">
            <see cref="T:System.Boolean" /> 스트림에서 Nagle 알고리즘을 사용하는지 여부를 나타내는 <see cref="T:System.Net.Sockets.Socket" /> 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1993">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-1994">
            <see cref="T:System.Net.Sockets.Socket" />에서 Nagle 알고리즘을 사용하면 <see langword="false" />이고, 그렇지 않으면 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1994">
              <see langword="false" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses the Nagle algorithm; otherwise, <see langword="true" />.</span>
          </span>
          <span data-ttu-id="bc823-1995">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-1995">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-1996">Nagle 알고리즘은 작은 패킷 버퍼 및 다음 결합 하 고 상황에 따라 하나의 패킷으로 보낼은 소켓에서 네트워크 트래픽을 줄이기 위해 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1996">The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</span></span> <span data-ttu-id="bc823-1997">TCP 패킷 헤더와 전송 되는 데이터의 40 바이트로 이루어져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1997">A TCP packet consists of 40 bytes of header plus the data being sent.</span></span> <span data-ttu-id="bc823-1998">TCP를 사용 하 여 작은 데이터 패킷을 전송 될 때 TCP 헤더에서 발생 하는 오버 헤드는 네트워크 트래픽의 주요 부분이 될 수 있습니다. 과도 하 게 로드 네트워크에서이 오버 헤드로 정체 인해 과도 하 게 전파 시간 뿐만 아니라 데이터 그램 손실된 하 고, 재전송 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1998">When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</span></span> <span data-ttu-id="bc823-1999">Nagle 알고리즘은 보내는 새 TCP segmentswhen 새 연결에서 이전 데이터가 남아 승인 되지 않은 경우 사용자 로부터 도착 나가는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-1999">The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</span></span>  
  
 <span data-ttu-id="bc823-2000">대부분의 네트워크 응용 프로그램에서 Nagle 알고리즘을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2000">The majority of network applications should use the Nagle algorithm.</span></span>  
  
 <span data-ttu-id="bc823-2001">사용자 데이터 그램 프로토콜 (UDP) 소켓에서이 속성을 설정 하는 아무런 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2001">Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2002">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.NoDelay%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2002">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2003">
            <see cref="T:System.Net.Sockets.Socket" />에 액세스하려고 시도하는 동안 오류가 발생한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2003">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2004">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2004">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-2005">내부 운영 체제 및 네트워크 어댑터에서 IPv4(인터넷 프로토콜 버전 4)를 지원하는지 여부를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2005">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-2006">운영 체제 및 네트워크 어댑터에서 IPv4 프로토콜을 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2006">
              <see langword="true" /> if the operating system and network adaptors support the IPv4 protocol; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2007">운영 체제는 IPv4 및 IPv6 프로토콜을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2007">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-2008">내부 운영 체제 및 네트워크 어댑터에서 IPv6(인터넷 프로토콜 버전 6)을 지원하는지 여부를 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2008">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-2009">운영 체제 및 네트워크 어댑터에서 IPv6 프로토콜을 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2009">
              <see langword="true" /> if the operating system and network adaptors support the IPv6 protocol; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2010">운영 체제는 IPv4 및 IPv6 프로토콜을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2010">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">
          <span data-ttu-id="bc823-2011">응답을 기다릴 시간(마이크로초)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2011">The time to wait for a response, in microseconds.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="bc823-2012">
            <see cref="T:System.Net.Sockets.SelectMode" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2012">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2013">
            <see cref="T:System.Net.Sockets.Socket" />의 상태를 결정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2013">Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2014">
            <paramref name="mode" /> 매개 변수에 전달된 폴링 모드 값에 따른 <see cref="T:System.Net.Sockets.Socket" />의 상태입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2014">The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</span>
          </span>
          <span data-ttu-id="bc823-2015">
            <list type="table">
              <listheader>
                <term> 모드  </term>
                <description> 반환 값  </description>
              </listheader>
              <item>
                <term>
                  <see cref="F:System.Net.Sockets.SelectMode.SelectRead" />
                </term>
                <description>
                  <see langword="true" />
                  <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />가 호출되었고 연결이 대기중입니다.  -또는-  <see langword="true" /> 데이터를 읽을 수 있습니다.  -또는-  <see langword="true" /> 연결이 닫히거나 재설정되거나 종료됩니다. 그렇지 않으면 <see langword="false" />를 반환합니다.  <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />를 처리하는 경우 </description>
              </item>
              <item>
                <term>
                  <see cref="F:System.Net.Sockets.SelectMode.SelectWrite" />
                </term>
                <description>
                  <see langword="true" />가 되고, 연결이 성공했습니다.  -또는-  데이터를 보낼 수 있는 경우 <see langword="true" />가 되고, 그렇지 않으면 <see langword="false" />를 반환합니다.  차단하지 않는 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />를 처리하는 경우 </description>
              </item>
              <item>
                <term>
                  <see cref="F:System.Net.Sockets.SelectMode.SelectError" />
                </term>
                <description>
                  <see langword="true" />가 되고 연결이 실패했습니다.  -또는-  <see langword="true" /><see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" />이 설정되지 않고 대역 외 데이터를 사용할 수 없습니다. 그렇지 않으면 <see langword="false" />를 반환합니다.  </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2015">
              <list type="table">
                <listheader>
                  <term> Mode  </term>
                  <description> Return Value  </description>
                </listheader>
                <item>
                  <term>
                    <see cref="F:System.Net.Sockets.SelectMode.SelectRead" />
                  </term>
                  <description>
                    <see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending;  -or-  <see langword="true" /> if data is available for reading;  -or-  <see langword="true" /> if the connection has been closed, reset, or terminated;  otherwise, returns <see langword="false" />.  </description>
                </item>
                <item>
                  <term>
                    <see cref="F:System.Net.Sockets.SelectMode.SelectWrite" />
                  </term>
                  <description>
                    <see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded;  -or-  <see langword="true" /> if data can be sent;  otherwise, returns <see langword="false" />.  </description>
                </item>
                <item>
                  <term>
                    <see cref="F:System.Net.Sockets.SelectMode.SelectError" />
                  </term>
                  <description>
                    <see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed;  -or-  <see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available;  otherwise, returns <see langword="false" />.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2016">합니다 <xref:System.Net.Sockets.Socket.Poll%2A> 메서드는 상태를 확인 합니다 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2016">The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-2017">지정 <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> 에 대 한는 `selectMode` 매개 변수에 지정 된 경우는 <xref:System.Net.Sockets.Socket> 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2017">Specify <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable.</span></span> <span data-ttu-id="bc823-2018">지정 <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> 여부를 확인 하는 <xref:System.Net.Sockets.Socket> 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2018">Specify <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> to determine if the <xref:System.Net.Sockets.Socket> is writable.</span></span> <span data-ttu-id="bc823-2019">사용 하 여 <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> 오류 조건을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2019">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> to detect an error condition.</span></span> <span data-ttu-id="bc823-2020"><xref:System.Net.Sockets.Socket.Poll%2A> 단위의 지정한 시간 기간이 경과할 때까지 실행이 차단 됩니다 `microseconds`, 경과 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2020"><xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses.</span></span> <span data-ttu-id="bc823-2021">설정 된 `microSeconds` 매개 변수를 음의 정수로 응답을 무기한 대기 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="bc823-2021">Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response.</span></span> <span data-ttu-id="bc823-2022">여러 소켓의 상태를 확인 하려는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.Select%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2022">If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2023">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2023">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2024">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2024">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2025">이 메서드는 특정 유형의 끊어진된 네트워크 케이블을 같은 연결 문제를 검색할 수 없습니다 또는 원격 호스트를 비정상적으로 종료 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2025">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="bc823-2026">이러한 종류의 오류를 검색 하는 데이터 전송 및 수신 하려고 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2026">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2027">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2027">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2028">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2028">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2029">다음 코드 예제에서는 서버에 연결 하 고 사용 하 여 소켓을 만듭니다 <xref:System.Net.Sockets.Socket.Poll%2A> 소켓의 상태를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2029">The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.</span></span>  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-2030">
            <paramref name="mode" /> 매개 변수가 <see cref="T:System.Net.Sockets.SelectMode" /> 값이 아닌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2030">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2031">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2031">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-2032">아래 설명 부분을 참조하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2032">See remarks below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2033">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2033">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-2034">
            <see cref="T:System.Net.Sockets.Socket" />의 프로토콜 종류를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2034">Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-2035">
            <see cref="T:System.Net.Sockets.ProtocolType" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2035">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2036">합니다 <xref:System.Net.Sockets.Socket.ProtocolType%2A> 속성을 설정 하는 경우는 <xref:System.Net.Sockets.Socket> 생성 되 고 사용 하는 프로토콜을 지정 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2036">The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2037">다음 코드 예제는 <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, 및 <xref:System.Net.Sockets.ProtocolType> 콘솔.</span><span class="sxs-lookup"><span data-stu-id="bc823-2037">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-2038">바인딩된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 받습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2038">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2039">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2039">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2040">수신 버퍼에 바인딩된 <see cref="T:System.Net.Sockets.Socket" />의 데이터를 받습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2040">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2041">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2041">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2042"><xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼 매개 변수로 데이터를 읽고 성공적으로 읽은 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2042">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="bc823-2043">호출할 수 있습니다 <xref:System.Net.Sockets.Socket.Receive%2A> 모두 연결 지향 프로토콜과 소켓에서.</span><span class="sxs-lookup"><span data-stu-id="bc823-2043">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="bc823-2044">이 오버 로드 하기만 수신 버퍼를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2044">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="bc823-2045">버퍼 크기에 대 한 기본값으로 버퍼 매개 변수의 길이 0으로 오프셋 및 <xref:System.Net.Sockets.SocketFlags> 기본값은 <xref:System.Net.Sockets.SocketFlags.None>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2045">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="bc823-2046">호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2046">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="bc823-2047"><xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 설정 된 원격 호스트에서 도착 하는 읽기만 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2047">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2048">연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2048">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2049"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2049"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="bc823-2050">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2050">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2051">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2051">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2052">비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2052">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2053">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2053">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2054">때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2054">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2055">사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼의 크기까지 가능한 한 많은 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2055">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="bc823-2056">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2056">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="bc823-2057">연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 대기 중인된 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2057">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="bc823-2058">받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffer` 매개 변수를 `buffer` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2058">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2059">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2059">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2060">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2060">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2061">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2061">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2062">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2062">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2063">다음 코드 예제에서는 연결에서 데이터를 받습니다 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2063">The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2064">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2064">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2065">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2065">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2066">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2066">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-2067">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2067">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2068">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2068">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2069">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2069">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="bc823-2070">받은 데이터를 포함하는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2070">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2071">바인딩된 <see cref="T:System.Net.Sockets.Socket" />의 데이터를 받아 수신 버퍼 목록에 넣습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2071">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2072">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2072">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2073">이 메서드는 데이터 버퍼 매개 변수를 읽고 성공적으로 읽은 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2073">This method reads data into the buffers parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="bc823-2074">모두 연결 지향 프로토콜과 소켓에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2074">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="bc823-2075">이 오버 로드를 제공 해야 하거나 이상의 버퍼를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2075">This overload requires you to provide one or more receive buffers.</span></span>  
  
 <span data-ttu-id="bc823-2076">호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2076">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="bc823-2077">합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 원격 호스트에 연결 되어에서 도착 하는 데이터만 읽습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2077">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2078">연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2078">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2079"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2079"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="bc823-2080">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2080">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2081">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2081">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2082">비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2082">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2083">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2083">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2084">때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2084">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2085">사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼의 크기까지 가능한 한 많은 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2085">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="bc823-2086">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2086">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="bc823-2087">연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 큐에 넣은 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2087">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="bc823-2088">받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffers` 매개 변수를 `buffers` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2088">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2089">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2089">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2090">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2090">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="bc823-2091">**참고** 이 멤버는 응용 프로그램에서 네트워크 추적을 사용 하도록 설정 하면 추적 정보를 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2091">**Note** This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2092">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2092">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2093">
            <paramref name="buffer" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2093">The <paramref name="buffer" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2094">소켓에 액세스하려고 시도하는 동안 오류가 발생한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2094">An error occurred while attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2095">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2095">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2096">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2096">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2097">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2097">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2098">지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 수신 버퍼에 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />의 데이터를 받습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2098">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2099">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2099">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2100"><xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼 매개 변수로 데이터를 읽고 성공적으로 읽은 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2100">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="bc823-2101">호출할 수 있습니다 <xref:System.Net.Sockets.Socket.Receive%2A> 모두 연결 지향 프로토콜과 소켓에서.</span><span class="sxs-lookup"><span data-stu-id="bc823-2101">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="bc823-2102">이 오버 로드만 제공 해야 수신 버퍼 및 필요한 <xref:System.Net.Sockets.SocketFlags>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2102">This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="bc823-2103">버퍼를 0으로 오프셋 이며 크기 기본값 바이트 매개 변수의 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2103">The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</span></span>  
  
 <span data-ttu-id="bc823-2104">호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2104">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="bc823-2105"><xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 설정 된 원격 호스트에서 도착 하는 읽기만 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2105">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2106">연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2106">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2107"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2107"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="bc823-2108">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 데이터가 있을 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2108">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available.</span></span> <span data-ttu-id="bc823-2109">비차단 모드에 있고 프로토콜 스택 버퍼에 사용할 수 있는 데이터가 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2109">If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2110">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2110">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2111">때 <xref:System.Net.Sockets.Socket.Available%2A> 0이 아닌, 다시 시도 수신 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2111">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2112">연결 지향 사용 중인 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 크기 버퍼의 최대 수 만큼의 데이터를 읽이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2112">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer.</span></span> <span data-ttu-id="bc823-2113">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2113">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="bc823-2114">연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 큐에 넣은 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2114">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="bc823-2115">받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffer` 매개 변수를 `buffer` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2115">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2116">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2116">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2117">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2117">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2118">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2118">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2119">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2119">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2120">다음 코드 예제에서는 데이터 버퍼를 지정 하 고 <xref:System.Net.Sockets.SocketFlags> 에 연결 된 데이터를 받기 위해 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2120">The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2121">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2121">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2122">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2122">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2123">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2123">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-2124">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2124">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2125">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2125">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2126">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2126">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="bc823-2127">받은 데이터를 포함하는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2127">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2128">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2128">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2129">지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />의 데이터를 받아 수신 버퍼 목록에 넣습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2129">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2130">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2130">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2131">이 메서드는 데이터를 읽습니다는 `buffers` 매개 변수 및 성공적으로 읽은 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2131">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="bc823-2132">모두 연결 지향 프로토콜과 소켓에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2132">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="bc823-2133">이 오버 로드를 제공 해야 하거나 이상의 버퍼를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2133">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="bc823-2134">합니다 <xref:System.Net.Sockets.SocketFlags> 기본값은 <xref:System.Net.Sockets.SocketFlags.None>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2134">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="bc823-2135">호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2135">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="bc823-2136">합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 원격 호스트에 연결 되어에서 도착 하는 데이터만 읽습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2136">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2137">연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2137">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2138"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2138"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="bc823-2139">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2139">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2140">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> throw 호출을 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2140">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2141">비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2141">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2142">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2142">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2143">때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2143">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2144">사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼의 크기까지 가능한 한 많은 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2144">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="bc823-2145">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2145">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="bc823-2146">연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 큐에 넣은 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2146">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="bc823-2147">받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffers` 매개 변수를 `buffers` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2147">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2148">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2148">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2149">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2149">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2150">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2150">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2151">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2151">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2152">다음 코드 예제에서 연결 된 데이터를 수신 하는 방법에 설명 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2152">The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2153">
            <paramref name="buffers" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2153">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-2154">-또는-  <paramref name="buffers" />.Count가 0입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2154">-or-  <paramref name="buffers" />.Count is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2155">소켓에 액세스하려고 시도하는 동안 오류가 발생한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2155">An error occurred while attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2156">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2156">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2157">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2157">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2158">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2158">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2159">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2159">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-2160">수신 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2160">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2161">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2161">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2162">지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 수신 버퍼에 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />에서 원하는 바이트 수의 데이터를 받습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2162">Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2163">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2163">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2164">합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수 및 성공적으로 읽은 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2164">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="bc823-2165">호출할 수 있습니다 <xref:System.Net.Sockets.Socket.Receive%2A> 모두 연결 지향 프로토콜과 소켓에서.</span><span class="sxs-lookup"><span data-stu-id="bc823-2165">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="bc823-2166">이 오버 로드 하기만 하면 수신 버퍼, 바이트를 수신 하려는 및 필요한 수가 <xref:System.Net.Sockets.SocketFlags>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2166">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 <span data-ttu-id="bc823-2167">호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2167">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="bc823-2168"><xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 설정 된 원격 호스트에서 도착 하는 읽기만 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2168">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2169">연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2169">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2170"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2170"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="bc823-2171">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2171">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2172">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2172">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2173">비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2173">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2174">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2174">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2175">때 <xref:System.Net.Sockets.Socket.Available%2A> 0이 아닌, 다시 시도 수신 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2175">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2176">연결 지향 사용 중인 경우 <xref:System.Net.Sockets.Socket>는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 지정 된 바이트 수까지 사용 가능한 데이터 읽습니다는 `size` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2176">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="bc823-2177">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2177">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="bc823-2178">연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 대기 중인된 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2178">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="bc823-2179">받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffer` 매개 변수를 `buffer` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2179">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2180">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2180">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2181">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2181">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2182">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2182">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2183">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2183">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2184">다음 데이터를 수신 `buffer`를 지정 하 고 <xref:System.Net.Sockets.SocketFlags.None> 에 대 한 <xref:System.Net.Sockets.SocketFlags>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2184">The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2185">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2185">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2186">
            <paramref name="size" />가 <paramref name="buffer" />의 크기를 초과한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2186">
              <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2187">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2187">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2188">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2188">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-2189">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2189">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2190">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2190">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2191">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2191">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="bc823-2192">받은 데이터를 포함하는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2192">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2193">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2193">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="bc823-2194">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2194">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2195">지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />의 데이터를 받아 수신 버퍼 목록에 넣습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2195">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2196">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2196">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2197">이 메서드는 데이터를 읽습니다는 `buffers` 매개 변수 및 성공적으로 읽은 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2197">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="bc823-2198">모두 연결 지향 프로토콜과 소켓에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2198">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="bc823-2199">이 오버 로드를 제공 해야 하거나 이상의 버퍼를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2199">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="bc823-2200">합니다 <xref:System.Net.Sockets.SocketFlags> 기본값은 <xref:System.Net.Sockets.SocketFlags.None>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2200">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="bc823-2201">호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2201">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="bc823-2202">합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 원격 호스트에 연결 되어에서 도착 하는 데이터만 읽습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2202">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2203">연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2203">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2204"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2204"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="bc823-2205">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2205">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2206">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> throw 호출을 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2206">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2207">비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2207">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2208">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2208">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2209">때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2209">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2210">사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼의 크기까지 가능한 한 많은 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2210">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="bc823-2211">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2211">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="bc823-2212">연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 대기 중인된 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2212">If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="bc823-2213">받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffers` 매개 변수를 `buffers` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2213">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2214">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2214">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2215">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2215">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2216">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2216">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2217">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2217">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2218">
            <paramref name="buffers" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2218">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-2219">-또는-  <paramref name="buffers" />.Count가 0입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2219">-or-  <paramref name="buffers" />.Count is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2220">소켓에 액세스하려고 시도하는 동안 오류가 발생한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2220">An error occurred while attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2221">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2221">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2222">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2222">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2223">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2223">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2224">수신된 데이터의 저장소 위치에 해당하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2224">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-2225">받은 데이터를 저장할 <c>버퍼</c> 내의 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2225">The location in <c>buffer</c> to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-2226">수신 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2226">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2227">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2227">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2228">지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 수신 버퍼의 특정 오프셋 위치에 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />의 원하는 바이트 수를 받습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2228">Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2229">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2229">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2230"><xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼 매개 변수로 데이터를 읽고 성공적으로 읽은 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2230">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="bc823-2231">호출할 수 있습니다 <xref:System.Net.Sockets.Socket.Receive%2A> 모두 연결 지향 프로토콜과 소켓에서.</span><span class="sxs-lookup"><span data-stu-id="bc823-2231">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="bc823-2232">호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2232">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="bc823-2233"><xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 설정 된 원격 호스트에서 도착 하는 읽기만 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2233">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2234">연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2234">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2235"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2235"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="bc823-2236">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2236">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2237">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2237">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2238">비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2238">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2239">소켓에 액세스하는 동안 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2239">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="bc823-2240">아래 설명을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="bc823-2240">See Remarks below.</span></span> <span data-ttu-id="bc823-2241">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2241">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2242">때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2242">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2243">사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는의 size 매개 변수에 의해 지정 된 바이트 수까지 사용 가능한 많은 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2243">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="bc823-2244">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2244">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="bc823-2245">연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 대기 중인된 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2245">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="bc823-2246">받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffer` 매개 변수를 `buffer` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2246">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2247">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2247">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2248">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2248">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2249">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2249">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2250">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2250">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2251">연결된 된 데이터를 받기 전에 데이터 버퍼, 오프셋, 크기 및 소켓 플래그를 지정 하는 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2251">The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2252">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2252">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2253">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2253">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2254">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2254">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-2255">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2255">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2256">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2256">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2257">
            <paramref name="socketFlags" />가 값의 유효한 조합이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2257">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="bc823-2258">-또는-  <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 속성이 설정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2258">-or-  The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="bc823-2259">-또는-  <see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2259">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2260">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2260">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-2261">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2261">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2262">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2262">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2263">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2263">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2264">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2264">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-2265">수신된 데이터를 저장할 <c>buffer</c> 매개 변수의 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2265">The position in the <c>buffer</c> parameter to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-2266">수신 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2266">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2267">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2267">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="bc823-2268">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2268">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2269">지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 수신 버퍼에 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />의 데이터를 받습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2269">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2270">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2270">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2271"><xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼 매개 변수로 데이터를 읽고 성공적으로 읽은 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2271">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="bc823-2272">호출할 수 있습니다 <xref:System.Net.Sockets.Socket.Receive%2A> 모두 연결 지향 프로토콜과 소켓에서.</span><span class="sxs-lookup"><span data-stu-id="bc823-2272">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="bc823-2273">호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2273">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="bc823-2274"><xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 설정 된 원격 호스트에서 도착 하는 읽기만 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2274">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2275">연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2275">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2276"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2276"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="bc823-2277">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2277">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2278">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2278">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2279">비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2279">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2280">소켓에 액세스하는 동안 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2280">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="bc823-2281">아래 설명을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="bc823-2281">See Remarks below.</span></span> <span data-ttu-id="bc823-2282">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2282">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2283">때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2283">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2284">사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는의 size 매개 변수에 의해 지정 된 바이트 수까지 사용 가능한 많은 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2284">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="bc823-2285">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2285">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="bc823-2286">연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 대기 중인된 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2286">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="bc823-2287">받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffer` 매개 변수를 `buffer` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2287">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2288">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2288">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2289">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2289">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2290">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2290">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2291">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2291">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2292">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2292">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2293">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2293">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2294">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2294">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-2295">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2295">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2296">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2296">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2297">
            <paramref name="socketFlags" />가 값의 유효한 조합이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2297">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="bc823-2298">-또는-  <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 속성이 설정되어 있지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2298">-or-  The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.</span>
          </span>
          <span data-ttu-id="bc823-2299">-또는-  <see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2299">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2300">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2300">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-2301">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2301">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2302">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2302">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2303">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2303">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="bc823-2304">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2304">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2305">연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에서 데이터를 받기 위해 비동기 요청을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2305">Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2306">I/O 작업이 보류 중인 경우 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2306">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="bc823-2307">작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2307">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="bc823-2308">I/O 작업이 동기적으로 완료된 경우 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2308">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="bc823-2309">이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2309">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2310"><xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 메서드 사용에 소켓 또는 바인딩된 연결 소켓을 연결 하 고 들어오는 데이터를 읽는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2310">The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</span></span> <span data-ttu-id="bc823-2311">소켓의 로컬 주소를 알 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2311">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="bc823-2312">바인딩된 연결 없는 소켓에 대 한이 함수는 받은 메시지를 수락할 주소를 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2312">For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</span></span> <span data-ttu-id="bc823-2313">함수는만 연결에서 지정 된 원격 주소에서 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2313">The function only returns messages from the remote address specified in the connection.</span></span> <span data-ttu-id="bc823-2314">다른 주소에서 메시지를 자동으로 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2314">Messages from other addresses are silently discarded.</span></span>  
  
 <span data-ttu-id="bc823-2315">합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 속성에는 `e` 매개 변수는 읽기 요청에 대 한 추가 정보를 사용 하 여 창 소켓 서비스 공급자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2315">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="bc823-2316">이 매개 변수를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2316">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bc823-2317">다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:</span><span class="sxs-lookup"><span data-stu-id="bc823-2317">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="bc823-2318"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 또는 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bc823-2318"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="bc823-2319"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 경우 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 설정</span><span class="sxs-lookup"><span data-stu-id="bc823-2319"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="bc823-2320"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 경우 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 설정</span><span class="sxs-lookup"><span data-stu-id="bc823-2320"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="bc823-2321">호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2321">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="bc823-2322">콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2322">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="bc823-2323">바이트 스트림 스타일 소켓, 들어오는 데이터 버퍼가 채워집니다, 연결을 닫거나 내부적으로 버퍼링 된 데이터를 모두 사용 될 때까지 버퍼에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2323">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span>  
  
 <span data-ttu-id="bc823-2324">메시지 지향 소켓, 들어오는 메시지와 연결 된 버퍼의 총 크기까지 버퍼에 배치 됩니다는 `e` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2324">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter.</span></span> <span data-ttu-id="bc823-2325">메시지 버퍼 보다 큰 경우에 메시지의 첫 번째 부분을 사용 하 여 버퍼가 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2325">If the message is larger than the buffer, the buffer is filled with the first part of the message.</span></span>  
  
 <span data-ttu-id="bc823-2326">연결 지향 소켓을 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 메서드는 바이트 스트림 또는 메시지 지향 소켓 인지에 따라 두 가지 방식 중 하나를 사용 하 여 가상 회로의 정상 종료를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2326">For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</span></span> <span data-ttu-id="bc823-2327">바이트 스트림의 경우 0 바이트를 읽은 것 정상 종료 및 더 이상 바이트를 읽게 됩니다 그 어느 때를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2327">For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</span></span> <span data-ttu-id="bc823-2328">메시지 지향 소켓, 여기서 0 바이트 메시지를 허용 되는 <xref:System.Net.Sockets.SocketException> 사용 하 여는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 네이티브 WSAEDISCON Winsock 오류 코드 (10101)로 설정 정상 종료를 나타내는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2328">For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</span></span> <span data-ttu-id="bc823-2329">어떤 경우에 <xref:System.Net.Sockets.SocketException> 사용 하 여는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 기본 Winsock WSAECONNRESET로 오류 코드 (10054)를 중단 한 닫기를 발생 했음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2329">In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-2330">인수가 잘못된 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2330">An argument was invalid.</span>
          </span>
          <span data-ttu-id="bc823-2331">
            <paramref name="e" /> 매개 변수의 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 또는 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 속성이 올바른 버퍼를 참조하지 않는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2331">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span>
          </span>
          <span data-ttu-id="bc823-2332">이러한 속성 중 하나를 설정할 수 있지만 두 속성을 동시에 설정할 수는 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2332">One or the other of these properties may be set, but not both at the same time.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-2333">
            <paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2333">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-2334">이 메서드에 Windows XP 이상이 필요한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2334">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2335">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2335">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2336">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2336">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-2337">
            <see cref="T:System.Net.Sockets.Socket" />의 수신 버퍼 크기를 지정하는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2337">Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-2338">수신 버퍼의 크기(바이트)가 들어 있는 <see cref="T:System.Int32" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2338">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer.</span>
          </span>
          <span data-ttu-id="bc823-2339">기본값은 8192입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2339">The default is 8192.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2340">더 큰 버퍼 크기를 잠재적으로 빈 승인 (데이터 부분이 없는 TCP 패킷) 수가 줄어들지만 연결 문제를 인식 하는 데 오래 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2340">A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</span></span> <span data-ttu-id="bc823-2341">큰 파일을 전송 하는 경우 높은 대역폭, 대기 시간이 긴 연결 (예: 위성 광대역 공급자입니다.)를 사용 하는 버퍼 크기를 늘리는 것이 좋습니다</span><span class="sxs-lookup"><span data-stu-id="bc823-2341">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2342">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2342">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2343">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2343">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2344">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2344">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2345">set 작업에 지정된 값이 0보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2345">The value specified for a set operation is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-2346">데이터그램을 받고 소스 끝점을 저장합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2346">Receives a datagram and stores the source endpoint.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2347">수신된 데이터의 저장소 위치에 해당하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2347">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-2348">원격 서버를 나타내며 참조에 의해 전달되는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2348">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2349">데이터 버퍼에 데이터그램을 받고 끝점을 저장합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2349">Receives a datagram into the data buffer and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2350">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2350">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2351">합니다 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수를 성공적으로 읽은 바이트 수를 반환 하 고 데이터를 보낸 원격 호스트 끝점을 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2351">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="bc823-2352">이 메서드는 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2352">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="bc823-2353">이 오버 로드만 제공 해야 수신 `buffer`, 및 <xref:System.Net.EndPoint> 원격 호스트를 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2353">This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="bc823-2354">버퍼 오프셋 기본값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2354">The buffer offset defaults to 0.</span></span> <span data-ttu-id="bc823-2355">크기의 길이 기본값으로 합니다 `buffer` 매개 변수 및 `socketFlags` 기본값은 <xref:System.Net.Sockets.SocketFlags.None>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2355">The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2356">호출 하기 전에 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>를 명시적으로 바인딩해야 합니다 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2356">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="bc823-2357">없는 경우 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2357">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-2358">연결 없는 프로토콜을 사용 하 여 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 는 로컬 네트워크 버퍼에 받은 첫 번째 큐에 넣은 데이터 그램을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2358">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="bc823-2359">받게 데이터 그램의 크기 보다 큰 경우 `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 채울 `buffer` 으로 가능한 한 throw 되는 메시지의 대부분을 <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="bc823-2359">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2360">신뢰할 수 없는 프로토콜을 사용 하는 경우 과도 한 데이터 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2360">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="bc823-2361">신뢰할 수 있는 프로토콜을 사용 하는, 과도 한 데이터는 서비스 공급자가 유지 되 고 호출 하 여 검색할 수 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 충분히 큰 버퍼를 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2361">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="bc823-2362">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 데이터가 있을 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2362">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="bc823-2363">비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2363">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2364">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2364">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2365">때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2365">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2366">하지만 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 것 연결 없는 프로토콜에 대 한 연결 지향 프로토콜도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2366">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="bc823-2367">작업을 수행 하려는 경우 먼저 하거나 설정 해야 원격 호스트 연결을 호출 하 여는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 하거나 들어오는 원격 호출 하 여 호스트 연결을 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2367">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2368">설정 하거나 호출 하기 전에 연결을 허용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 받을 수는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2368">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2369">호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2369">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2370">이러한 경우 중를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 무시를 `remoteEP` 매개 변수 및 데이터로 연결된 된 또는 기본 원격 호스트에만 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2370">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="bc823-2371">연결 지향 소켓 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 크기의 최대 수 만큼의 데이터를 읽기는 `buffer`합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2371">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="bc823-2372">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2372">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2373">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2373">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2374">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2374">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2375"><xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 와 일치 해야 합니다 <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2375">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2376">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2376">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2377">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2377">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2378">다음 코드 예제는 원격 호스트에서 연결이 끊긴 데이터 그램을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2378">The following code example receives a connectionless datagram from a remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2379">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2379">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-2380">-또는-  <paramref name="remoteEP" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2380">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2381">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2381">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2382">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2382">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-2383">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2383">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2384">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2384">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2385">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2385">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2386">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2386">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2387">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2387">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-2388">원격 서버를 나타내며 참조에 의해 전달되는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2388">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2389">지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 데이터 버퍼에 데이터그램을 받고 끝점을 저장합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2389">Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2390">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2390">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2391">합니다 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수를 성공적으로 읽은 바이트 수를 반환 하 고 데이터를 보낸 원격 호스트 끝점을 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2391">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="bc823-2392">이 메서드는 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2392">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="bc823-2393">이 오버 로드 하기만 하면 필요한 수신 버퍼를 제공 <xref:System.Net.Sockets.SocketFlags>, 및 <xref:System.Net.EndPoint> 원격 호스트를 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2393">This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="bc823-2394">오프셋된 기본값 0 및 버퍼 매개 변수의 길이 크기 기본값은입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2394">The offset defaults to 0 and the size defaults to the length of the buffer parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2395">호출 하기 전에 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>를 명시적으로 바인딩해야 합니다 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2395">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="bc823-2396">없는 경우 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2396">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-2397">연결 없는 프로토콜을 사용 하 여 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 는 로컬 네트워크 버퍼에 받은 첫 번째 큐에 넣은 데이터 그램을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2397">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="bc823-2398">받게 데이터 그램의 크기 보다 큰 경우 `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 채울 `buffer` 으로 가능한 한 throw 되는 메시지의 대부분을 <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="bc823-2398">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2399">신뢰할 수 없는 프로토콜을 사용 하는 경우 과도 한 데이터 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2399">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="bc823-2400">신뢰할 수 있는 프로토콜을 사용 하는, 과도 한 데이터는 서비스 공급자가 유지 되 고 호출 하 여 검색할 수 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 충분히 큰 버퍼를 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2400">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="bc823-2401">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 데이터가 있을 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2401">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="bc823-2402">비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2402">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2403">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2403">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2404">때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2404">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2405">하지만 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 것 연결 없는 프로토콜에 대 한 연결 지향 프로토콜도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2405">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="bc823-2406">작업을 수행 하려는 경우 먼저 하거나 설정 해야 원격 호스트 연결을 호출 하 여는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 하거나 들어오는 원격 호출 하 여 호스트 연결을 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2406">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2407">설정 하거나 호출 하기 전에 연결을 허용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 받을 수는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2407">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2408">호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2408">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2409">이러한 경우 중를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 무시를 `remoteEP` 매개 변수 및 데이터로 연결된 된 또는 기본 원격 호스트에만 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2409">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="bc823-2410">연결 지향 소켓 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 크기의 최대 수 만큼의 데이터를 읽기는 `buffer`합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2410">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="bc823-2411">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2411">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2412">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2412">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2413">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2413">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2414"><xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 와 일치 해야 합니다 <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2414">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2415">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2415">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2416">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2416">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2417">다음 코드 예제는 원격 호스트에서 연결이 끊긴 데이터 그램을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2417">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="bc823-2418"><xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2418"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2419">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2419">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-2420">-또는-  <paramref name="remoteEP" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2420">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2421">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2421">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2422">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2422">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-2423">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2423">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2424">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2424">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2425">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2425">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2426">수신된 데이터의 저장소 위치에 해당하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2426">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-2427">수신 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2427">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2428">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2428">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-2429">원격 서버를 나타내며 참조에 의해 전달되는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2429">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2430">지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 데이터 버퍼에 원하는 바이트 수를 받고 끝점을 저장합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2430">Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2431">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2431">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2432">합니다 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수를 성공적으로 읽은 바이트 수를 반환 하 고 데이터를 보낸 원격 호스트 끝점을 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2432">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="bc823-2433">이 메서드는 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2433">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="bc823-2434">이 오버 로드만 제공 해야 수신 버퍼를 받으려면를 필요한 바이트 수가 <xref:System.Net.Sockets.SocketFlags>, 및 <xref:System.Net.EndPoint> 원격 호스트를 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2434">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="bc823-2435">버퍼 오프셋 기본값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2435">The buffer offset defaults to 0.</span></span>  
  
 <span data-ttu-id="bc823-2436">연결 없는 프로토콜을 사용 하 여 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 는 로컬 네트워크 버퍼에 받은 첫 번째 큐에 넣은 데이터 그램을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2436">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="bc823-2437">받게 데이터 그램의 크기 보다 큰 경우 `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 채울 `buffer` 으로 가능한 한 throw 되는 메시지의 대부분을 <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="bc823-2437">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2438">신뢰할 수 없는 프로토콜을 사용 하는 경우 과도 한 데이터 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2438">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="bc823-2439">신뢰할 수 있는 프로토콜을 사용 하는, 과도 한 데이터는 서비스 공급자가 유지 되 고 호출 하 여 검색할 수 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 충분히 큰 버퍼를 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2439">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="bc823-2440">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 데이터가 있을 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2440">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="bc823-2441">비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2441">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2442">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2442">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2443">때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2443">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2444">하지만 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 것 연결 없는 프로토콜에 대 한 연결 지향 프로토콜도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2444">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="bc823-2445">작업을 수행 하려는 경우 먼저 하거나 설정 해야 원격 호스트 연결을 호출 하 여는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 하거나 들어오는 원격 호출 하 여 호스트 연결을 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2445">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2446">설정 하거나 호출 하기 전에 연결을 허용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 받을 수는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2446">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2447">호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2447">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2448">이러한 경우 중를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 무시를 `remoteEP` 매개 변수 및 데이터로 연결된 된 또는 기본 원격 호스트에만 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2448">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="bc823-2449">연결 지향 소켓 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 을 사용 하 여 지정 된 바이트 수 만큼 데이터를 읽습니다는 `size` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2449">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="bc823-2450">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2450">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2451">호출 하기 전에 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>를 명시적으로 바인딩해야 합니다 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2451">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="bc823-2452">없는 경우 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2452">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2453">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2453">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2454">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2454">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2455"><xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 와 일치 해야 합니다 <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2455">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2456">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2456">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2457">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2457">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2458">다음 코드 예제는 원격 호스트에서 연결이 끊긴 데이터 그램을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2458">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="bc823-2459">버퍼 크기와 <xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2459">The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2460">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2460">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-2461">-또는-  <paramref name="remoteEP" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2461">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2462">
            <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2462">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2463">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2463">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2464">
            <paramref name="socketFlags" />가 값의 유효한 조합이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2464">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="bc823-2465">-또는-  <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 속성이 설정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2465">-or-  The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="bc823-2466">-또는-  <see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2466">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2467">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2467">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-2468">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2468">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2469">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2469">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2470">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2470">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2471">수신된 데이터의 저장소 위치에 해당하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2471">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-2472">수신된 데이터를 저장할 <c>buffer</c> 매개 변수의 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2472">The position in the <c>buffer</c> parameter to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-2473">수신 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2473">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2474">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2474">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-2475">원격 서버를 나타내며 참조에 의해 전달되는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2475">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2476">지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 데이터 버퍼의 지정된 위치에 지정된 바이트 수의 데이터를 수신하고 끝점을 저장합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2476">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2477">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2477">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2478">합니다 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수를 성공적으로 읽은 바이트 수를 반환 하 고 데이터를 보낸 원격 호스트 끝점을 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2478">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="bc823-2479">이 메서드는 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2479">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="bc823-2480">연결 없는 프로토콜을 사용 하 여 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 는 로컬 네트워크 버퍼에 받은 첫 번째 큐에 넣은 데이터 그램을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2480">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="bc823-2481">받게 데이터 그램의 크기 보다 큰 경우 `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 채울 `buffer` 으로 가능한 한 throw 되는 메시지의 대부분을 <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="bc823-2481">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2482">신뢰할 수 없는 프로토콜을 사용 하는 경우 과도 한 데이터 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2482">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="bc823-2483">신뢰할 수 있는 프로토콜을 사용 하는, 과도 한 데이터는 서비스 공급자가 유지 되 고 호출 하 여 검색할 수 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 충분히 큰 버퍼를 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2483">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="bc823-2484">읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 데이터가 있을 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2484">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="bc823-2485">비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2485">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2486">사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2486">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="bc823-2487">때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2487">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="bc823-2488">하지만 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 것 연결 없는 프로토콜에 대 한 연결 지향 프로토콜도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2488">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="bc823-2489">작업을 수행 하려는 경우 먼저 하거나 설정 해야 원격 호스트 연결을 호출 하 여는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 하거나 들어오는 원격 호출 하 여 호스트 연결을 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2489">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2490">설정 하거나 호출 하기 전에 연결을 허용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 받을 수는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2490">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2491">호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2491">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="bc823-2492">이러한 경우 중를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 무시를 `remoteEP` 매개 변수 및 데이터로 연결된 된 또는 기본 원격 호스트에만 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2492">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="bc823-2493">연결 지향 소켓 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 을 사용 하 여 지정 된 바이트 크기의 데이터 읽습니다는 `size` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2493">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="bc823-2494">원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2494">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2495">호출 하기 전에 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>를 명시적으로 바인딩해야 합니다 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2495">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="bc823-2496">없는 경우 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2496">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2497">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2497">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2498">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2498">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2499"><xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 와 일치 해야 합니다 <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2499">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2500">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2500">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2501">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2501">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2502">다음 코드 예제는 원격 호스트에서 연결이 끊긴 데이터 그램을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2502">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="bc823-2503">오프셋, 버퍼 크기와 <xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2503">The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2504">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2504">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-2505">-또는-  <paramref name="remoteEP" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2505">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2506">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2506">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2507">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2507">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-2508">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2508">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2509">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 오프셋 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2509">-or-  <paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2510">
            <paramref name="socketFlags" />가 값의 유효한 조합이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2510">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="bc823-2511">-또는-  <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 속성이 설정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2511">-or-  The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="bc823-2512">-또는-  소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2512">-or-  An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2513">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2513">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2514">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2514">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2515">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2515">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="bc823-2516">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2516">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2517">지정된 네트워크 장치에서 비동기적으로 데이터를 받기 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2517">Begins to asynchronously receive data from a specified network device.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2518">I/O 작업이 보류 중인 경우 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2518">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="bc823-2519">작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2519">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="bc823-2520">I/O 작업이 동기적으로 완료된 경우 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2520">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="bc823-2521">이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2521">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2522"><xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 메서드는 연결 없는 소켓에서 데이터를 수신 하는 데 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2522">The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket.</span></span> <span data-ttu-id="bc823-2523">소켓의 로컬 주소를 알 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2523">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="bc823-2524">호출자에 게 설정 해야 합니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 속성을는 <xref:System.Net.IPEndPoint> 받을 수는 데이터를 원격 호스트의 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2524">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="bc823-2525">합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 속성에는 `e` 매개 변수는 읽기 요청에 대 한 추가 정보를 사용 하 여 창 소켓 서비스 공급자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2525">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="bc823-2526">이 매개 변수를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2526">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bc823-2527">다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:</span><span class="sxs-lookup"><span data-stu-id="bc823-2527">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="bc823-2528">호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2528">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="bc823-2529">콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2529">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="bc823-2530">메시지 지향 소켓, 들어오는 메시지 버퍼의 총 크기까지 버퍼에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2530">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="bc823-2531">합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 고 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 속성 버퍼의 데이터를 배치할 위치와 데이터의 양을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2531">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="bc823-2532">바이트 스트림 스타일 소켓, 들어오는 데이터 버퍼가 채워집니다, 연결을 닫거나 내부적으로 버퍼링 된 데이터를 모두 사용 될 때까지 버퍼에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2532">For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span> <span data-ttu-id="bc823-2533">합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 고 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 속성 버퍼의 데이터를 배치할 위치와 데이터의 양을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2533">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2534">
            <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />가 null인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2534">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-2535">
            <paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2535">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-2536">이 메서드에 Windows XP 이상이 필요한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2536">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2537">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2537">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2538">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2538">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2539">수신된 데이터의 저장소 위치에 해당하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2539">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-2540">수신된 데이터를 저장할 <c>buffer</c> 매개 변수의 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2540">The position in the <c>buffer</c> parameter to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-2541">수신 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2541">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2542">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2542">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-2543">원격 서버를 나타내며 참조에 의해 전달되는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2543">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <param name="ipPacketInformation">
          <span data-ttu-id="bc823-2544">
            <see cref="T:System.Net.Sockets.IPPacketInformation" /> 보유 주소 및 인터페이스 정보입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2544">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2545">지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 데이터 버퍼의 지정된 위치에 지정된 바이트 수의 데이터를 수신하고 끝점 및 패킷 정보를 저장합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2545">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2546">받은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2546">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2547">합니다 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수를 성공적으로 읽은 바이트 수를 반환 하 고 받은 패킷에 대 한 정보 뿐만 아니라 데이터를 전송 하는 원격 호스트 끝점을 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2547">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</span></span>  
  
 <span data-ttu-id="bc823-2548"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드는 연결 없는 소켓에서 메시지 데이터를 수신 하는 데 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2548">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="bc823-2549">소켓의 로컬 주소를 알 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2549">The socket's local address must be known.</span></span> <span data-ttu-id="bc823-2550">이 메서드가 데이터 그램 및 원시 소켓을 사용 하 여 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2550">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="bc823-2551">소켓이 소켓 유형 설정으로 초기화 되어야 합니다 <xref:System.Net.Sockets.SocketType.Dgram> 또는 <xref:System.Net.Sockets.SocketType.Raw> 이 메서드를 호출 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2551">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="bc823-2552">소켓을 사용 하 여 생성할 때이 수행할 수 있습니다 <xref:System.Net.Sockets.Socket.%23ctor%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2552">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="bc823-2553">메시지 지향 소켓에 대 한 들어오는 메시지에 놓입니다 합니다 `buffer` 매개 변수에서 지정한 총 크기는 최대를 `size` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2553">For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter.</span></span> <span data-ttu-id="bc823-2554">합니다 `offset` 위치를 결정 하는 매개 변수는 `buffer` 데이터 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2554">The `offset` parameter determines where in the `buffer` the data is placed.</span></span> <span data-ttu-id="bc823-2555">데이터의 실제 량에 배치 합니다 `buffer` 에서 반환 되는 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2555">The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-2556"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드를 자동으로 메서드 설정 합니다 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 소켓 옵션을 `true` 처음 호출 될를 지정 된 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2556">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-2557">그러나 반환 된 <xref:System.Net.Sockets.IPPacketInformation> 개체 소켓 옵션을 설정한 후에 로컬 컴퓨터에 도착 하는 패킷에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2557">However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="bc823-2558">로컬 끝점에 바인딩될 때 소켓 사이 패킷을 보내면 (의해 명시적으로 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드 또는 중 하나에 의해 암시적으로 <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, 또는 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 메서드) 및 첫 번째 호출을 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드를 호출 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드는 잘못 된 반환 <xref:System.Net.Sockets.IPPacketInformation> 이러한 패킷에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2558">If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="bc823-2559">되도록 모든 <xref:System.Net.Sockets.IPPacketInformation> 개체는 유효, 응용 프로그램 설정 해야 합니다 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 소켓 옵션을 `true` 사용 하 여 로컬 끝점에 연결 되기 전에 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2559">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="bc823-2560">응용 프로그램을 검사할 수는 `ipPacketInformation` 유니캐스트, 멀티 캐스트 또는 브로드캐스트 주소를 사용 하 여 데이터 그램을 보냈는지를 알고 있어야 하는 경우 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2560">An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2561"><xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 와 일치 해야 합니다 <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2561">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2562">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2562">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2563">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2563">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2564">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2564">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-2565">\- 또는-  <paramref name="remoteEP" />가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2565">\- or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2566">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2566">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2567">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2567">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-2568">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2568">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2569">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 오프셋 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2569">-or-  <paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2570">
            <paramref name="socketFlags" />가 값의 유효한 조합이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2570">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="bc823-2571">-또는-  <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 속성이 설정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2571">-or-  The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="bc823-2572">-또는-  .NET Framework가 AMD 64비트 프로세서에서 실행 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2572">-or-  The .NET Framework is running on an AMD 64-bit processor.</span>
          </span>
          <span data-ttu-id="bc823-2573">-또는-  소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2573">-or-  An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2574">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2574">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-2575">이 메서드에는 Windows XP가 필요한데 운영 체제가 Windows 2000 또는 그 이전 버전인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2575">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="bc823-2576">네트워크에서 연결을 허용 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2576">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="bc823-2577">연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2577">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="bc823-2578">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2578">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2579">지정된 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />를 사용하여 원하는 바이트 수의 데이터를 데이터 버퍼의 특정 위치로 받는 비동기 작업을 시작하고 끝점 및 패킷 정보를 저장합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2579">Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2580">I/O 작업이 보류 중인 경우 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2580">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="bc823-2581">작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2581">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="bc823-2582">I/O 작업이 동기적으로 완료된 경우 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2582">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="bc823-2583">이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2583">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2584"><xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 메서드는 연결 없는 소켓에서 메시지 데이터를 수신 하는 데 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2584">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="bc823-2585">소켓의 로컬 주소를 알 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2585">The socket's local address must be known.</span></span> <span data-ttu-id="bc823-2586">이 메서드가 데이터 그램 및 원시 소켓을 사용 하 여 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2586">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="bc823-2587">소켓이 소켓 유형 설정으로 초기화 되어야 합니다 <xref:System.Net.Sockets.SocketType.Dgram> 또는 <xref:System.Net.Sockets.SocketType.Raw> 이 메서드를 호출 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2587">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="bc823-2588">소켓을 사용 하 여 생성할 때이 수행할 수 있습니다 <xref:System.Net.Sockets.Socket.%23ctor%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2588">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="bc823-2589">호출자에 게 설정 해야 합니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 속성을는 <xref:System.Net.IPEndPoint> 받을 수는 데이터를 원격 호스트의 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2589">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="bc823-2590">다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:</span><span class="sxs-lookup"><span data-stu-id="bc823-2590">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="bc823-2591">호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2591">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="bc823-2592">콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2592">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="bc823-2593">메시지 지향 소켓, 들어오는 메시지 버퍼의 총 크기까지 버퍼에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2593">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="bc823-2594">합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 고 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 속성 버퍼의 데이터를 배치할 위치와 데이터의 양을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2594">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="bc823-2595"><xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 메서드를 자동으로 설정 합니다 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 소켓 옵션을 `true` 처음 호출 될는 지정 된 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2595">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-2596">그러나는 <xref:System.Net.Sockets.IPPacketInformation> 개체 소켓 옵션을 설정한 후에 로컬 컴퓨터에 도착 하는 패킷에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2596">However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="bc823-2597">소켓 로컬 끝점에 바인딩될 때 소켓 사이 패킷을 보내면 (의해 명시적으로 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드 또는 중 하나에 의해 암시적으로 <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, 또는 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 메서드)를 처음으로 호출 하는 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>메서드를 호출 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 메서드를 잘못에서 하면 <xref:System.Net.Sockets.IPPacketInformation> 이러한 패킷에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2597">If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="bc823-2598">되도록 모든 <xref:System.Net.Sockets.IPPacketInformation> 개체는 유효, 응용 프로그램 설정 해야 합니다 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 소켓 옵션을`true` 사용 하 여 로컬 끝점에 연결 되기 전에 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2598">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="bc823-2599">응용 프로그램에서 결과 검사할 수 <xref:System.Net.Sockets.IPPacketInformation> 유니캐스트, 멀티 캐스트 또는 브로드캐스트 주소를 사용 하 여 데이터 그램을 보냈는지 확인 해야 하는 경우 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2599">An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2600">
            <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />가 null인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2600">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-2601">이 메서드에 Windows XP 이상이 필요한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2601">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2602">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2602">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2603">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2603">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-2604">동기 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 호출이 완료되어야 하는 제한 시간을 지정하는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2604">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-2605">시간 제한 값(밀리초)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2605">The time-out value, in milliseconds.</span>
          </span>
          <span data-ttu-id="bc823-2606">기본값은 0으로, 시간 제한이 없음을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2606">The default value is 0, which indicates an infinite time-out period.</span>
          </span>
          <span data-ttu-id="bc823-2607">- 1을 지정해도 시간 제한이 없음을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2607">Specifying -1 also indicates an infinite time-out period.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2608">이 옵션은 동기 <xref:System.Net.Sockets.Socket.Receive%2A> 만 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2608">This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only.</span></span> <span data-ttu-id="bc823-2609">제한 시간이 초과 되 면 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2609">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2610">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2610">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2611">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2611">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2612">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2612">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2613">set 작업에 지정된 값이 -1보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2613">The value specified for a set operation is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-2614">원격 끝점을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2614">Gets the remote endpoint.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-2615">
            <see cref="T:System.Net.EndPoint" />이 통신에 사용하는 <see cref="T:System.Net.Sockets.Socket" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2615">The <see cref="T:System.Net.EndPoint" /> with which the <see cref="T:System.Net.Sockets.Socket" /> is communicating.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2616">연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 속성을 가져옵니다는 <xref:System.Net.EndPoint> 원격 IP 주소 및 포트 번호를 포함 하는 <xref:System.Net.Sockets.Socket> 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2616">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected.</span></span> <span data-ttu-id="bc823-2617">연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 기본 원격 IP 주소 및 포트 번호를 포함 합니다 <xref:System.Net.Sockets.Socket> 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2617">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate.</span></span> <span data-ttu-id="bc823-2618">이 캐스팅 해야 <xref:System.Net.EndPoint> 에 <xref:System.Net.IPEndPoint> 모든 정보를 검색 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2618">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="bc823-2619">호출할 수 있습니다 합니다 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 원격을 검색 하는 방법 <xref:System.Net.IPAddress>, 및 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 원격 포트 번호를 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2619">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the remote port number.</span></span>  
  
 <span data-ttu-id="bc823-2620">합니다 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 중 하나를 호출한 후 설정할지 <xref:System.Net.Sockets.Socket.Accept%2A> 또는 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2620">The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-2621">이전에이 속성에 액세스 하려고 하면 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2621">If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2622">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2622">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2623">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2623">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2624">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2624">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2625">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2625">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2626">다음 코드 예제를 검색 하 고 로컬과 원격 끝점을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2626">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2627">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2627">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2628">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2628">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">
          <span data-ttu-id="bc823-2629">가독성을 확인할 <see cref="T:System.Net.Sockets.Socket" /> 인스턴스의 <see cref="T:System.Collections.IList" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2629">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</span>
          </span>
        </param>
        <param name="checkWrite">
          <span data-ttu-id="bc823-2630">쓰기 가능성을 확인할 <see cref="T:System.Net.Sockets.Socket" /> 인스턴스의 <see cref="T:System.Collections.IList" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2630">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</span>
          </span>
        </param>
        <param name="checkError">
          <span data-ttu-id="bc823-2631">오류를 확인할 <see cref="T:System.Net.Sockets.Socket" /> 인스턴스의 <see cref="T:System.Collections.IList" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2631">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</span>
          </span>
        </param>
        <param name="microSeconds">
          <span data-ttu-id="bc823-2632">시간 제한 값(마이크로초)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2632">The time-out value, in microseconds.</span>
          </span>
          <span data-ttu-id="bc823-2633">값 -1은 시간 제한이 없음을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2633">A -1 value indicates an infinite time-out.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2634">하나 이상의 소켓 상태를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2634">Determines the status of one or more sockets.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2635"><xref:System.Net.Sockets.Socket.Select%2A> 하나 이상의 상태를 확인 하는 정적 메서드는 <xref:System.Net.Sockets.Socket> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="bc823-2635"><xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances.</span></span> <span data-ttu-id="bc823-2636">하나 이상의 소켓에 배치 해야 합니다는 <xref:System.Collections.IList> 사용 하기 전에 <xref:System.Net.Sockets.Socket.Select%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2636">You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span> <span data-ttu-id="bc823-2637">호출 하 여 가독성을 위해 확인할 <xref:System.Net.Sockets.Socket.Select%2A> 사용 하 여 합니다 <xref:System.Collections.IList> 으로 `checkRead` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2637">Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter.</span></span> <span data-ttu-id="bc823-2638">쓰기 가능성에 대 한 소켓을 확인 하려면 사용 된 `checkWrite` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2638">To check your sockets for writability, use the `checkWrite` parameter.</span></span> <span data-ttu-id="bc823-2639">오류 조건을 검색을 사용 하 여 `checkError`입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2639">For detecting error conditions, use `checkError`.</span></span> <span data-ttu-id="bc823-2640">호출한 후 <xref:System.Net.Sockets.Socket.Select%2A>, <xref:System.Collections.IList> 조건을 만족 하는 소켓에만 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2640">After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.</span></span>  
  
 <span data-ttu-id="bc823-2641">가독성에 대 한 호출을 수신 대기 상태에 있는 경우 즉 <xref:System.Net.Sockets.Socket.Accept%2A> 차단 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2641">If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking.</span></span> <span data-ttu-id="bc823-2642">연결이 이미 수락 된 경우 가독성 데이터를 읽을 수 있음을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2642">If you have already accepted the connection, readability means that data is available for reading.</span></span> <span data-ttu-id="bc823-2643">이러한 경우에 모든 수신 작업을 차단 하지 않고 성공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2643">In these cases, all receive operations will succeed without blocking.</span></span> <span data-ttu-id="bc823-2644">가독성을 나타낼 수도 있습니다 있는지 여부를 원격 <xref:System.Net.Sockets.Socket> 가 종료 경우, 연결에 대 한 호출 <xref:System.Net.Sockets.Socket.Receive%2A> 0 바이트가 반환을 즉시 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2644">Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.</span></span>  
  
 <span data-ttu-id="bc823-2645"><xref:System.Net.Sockets.Socket.Select%2A> 반환 될 때 관심 소켓의 하나 이상 (의 소켓을 `checkRead`, `checkWrite`, 및 `checkError` 나열) 지정 된 조건에 맞는 또는 `microSeconds` 매개 변수를 초과 하는 먼저 도달 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2645"><xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first.</span></span> <span data-ttu-id="bc823-2646">설정 `microSeconds` -1로 무기한 시간 제한을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2646">Setting `microSeconds` to -1 specifies an infinite time-out.</span></span>  
  
 <span data-ttu-id="bc823-2647">비블로킹 한다면 <xref:System.Net.Sockets.Socket.Connect%2A>를 성공적으로 연결 하는 것이 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2647">If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully.</span></span> <span data-ttu-id="bc823-2648">설정 되는 연결에 이미 있는 경우 모든 작업을 차단 하지 않고 성공 송신 쓰기 가능성 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2648">If you already have a connection established, writability means that all send operations will succeed without blocking.</span></span>  
  
 <span data-ttu-id="bc823-2649">비 중단 호출을 수행한 <xref:System.Net.Sockets.Socket.Connect%2A>, `checkerror` 소켓 성공적으로 연결 하지 않은 매개 변수를 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2649">If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2650">사용 된 <xref:System.Net.Sockets.Socket.Poll%2A> 메서드는 단일 상태를 확인 하려는 경우 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2650">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2651">이 메서드는 특정 유형의 끊어진된 네트워크 케이블을 같은 연결 문제를 검색할 수 없습니다 또는 원격 호스트를 비정상적으로 종료 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2651">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="bc823-2652">이러한 종류의 오류를 검색 하는 데이터 전송 및 수신 하려고 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2652">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2653">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2653">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2654">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2654">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2655">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.Select%2A> 수신 소켓 연결 요청을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2655">The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.</span></span>  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2656">
            <paramref name="checkRead" /> 매개 변수가 <see langword="null" />이거나 비어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2656">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.</span>
          </span>
          <span data-ttu-id="bc823-2657">-및-  <paramref name="checkWrite" /> 매개 변수가 <see langword="null" />이거나 비어 있습니다.  -및-  <paramref name="checkError" /> 매개 변수가 <see langword="null" />이거나 비어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2657">-and-  The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty  -and-  The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2658">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2658">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-2659">연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2659">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2660">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2660">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2661">연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2661">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2662">
            <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2662">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2663"><xref:System.Net.Sockets.Socket.Send%2A> 에 지정 된 원격 호스트에 데이터를 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드와 성공적으로 보낸 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2663"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="bc823-2664"><xref:System.Net.Sockets.Socket.Send%2A> 연결 지향 및 연결 없는 프로토콜에 대해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2664"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="bc823-2665">이 오버 로드에 보낼 데이터가 들어 있는 버퍼에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2665">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="bc823-2666"><xref:System.Net.Sockets.SocketFlags> 0 값은 기본적으로, 버퍼 오프셋 기본값은 0이 고 기본값은 버퍼의 크기를 보낼 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2666">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>  
  
 <span data-ttu-id="bc823-2667">연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2667">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2668">사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2668">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="bc823-2669">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2669">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="bc823-2670">사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2670">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="bc823-2671">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2671">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-2672">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2672">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="bc823-2673">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 모든 버퍼의 바이트를 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2673">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2674">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2674">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2675">비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 버퍼의 바이트 수보다 적은 데이터를 보내는 경우에 성공적으로 완료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2675">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="bc823-2676">응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 버퍼의 바이트를 보낼 때 까지는 작업을 다시 시도를 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2676">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="bc823-2677">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2677">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-2678">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2678">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-2679">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2679">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2680">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2680">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2681">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2681">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2682">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2682">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-2683">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2683">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2684">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2684">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2685">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2685">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2686">다음 코드 예제에서 연결 된 데이터를 보내는 방법을 보여 줍니다 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2686">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2687">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2687">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2688">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2688">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2689">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2689">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="bc823-2690">보낼 데이터가 들어 있는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2690">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2691">목록에 있는 버퍼 집합을 연결된 <see cref="T:System.Net.Sockets.Socket" />으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2691">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2692">
            <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2692">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2693"><xref:System.Net.Sockets.Socket.Send%2A> 연결 지향 및 연결 없는 프로토콜에 대해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2693"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="bc823-2694">이 오버 로드에 전송 하려는 데이터가 포함 된 하나 이상의 버퍼에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2694">This overload requires at least one buffer that contains the data you want to send.</span></span>  
  
 <span data-ttu-id="bc823-2695">연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2695">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2696">사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2696">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="bc823-2697">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2697">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="bc823-2698">사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2698">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="bc823-2699">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2699">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-2700">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2700">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="bc823-2701">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 모든 버퍼의 바이트를 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2701">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2702">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2702">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2703">비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 버퍼의 바이트 수보다 적은 데이터를 보내는 경우에 성공적으로 완료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2703">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="bc823-2704">응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 버퍼의 바이트를 보낼 때 까지는 작업을 다시 시도를 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2704">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="bc823-2705">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2705">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-2706">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2706">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-2707">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2707">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2708">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2708">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2709">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2709">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2710">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2710">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-2711">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2711">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2712">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2712">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2713">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2713">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2714">
            <paramref name="buffers" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2714">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-2715">
            <paramref name="buffers" />가 비어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2715">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2716">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2716">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-2717">아래의 설명 부분을 참조하십시오.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2717">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2718">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2718">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2719">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2719">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2720">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2720">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2721">지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 데이터를 연결된 <see cref="T:System.Net.Sockets.SocketFlags" />에 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2721">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2722">
            <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2722">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2723"><xref:System.Net.Sockets.Socket.Send%2A> 에 설정 된 원격 호스트에 데이터를 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드와 성공적으로 보낸 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2723"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="bc823-2724"><xref:System.Net.Sockets.Socket.Send%2A> 모두 연결 지향 프로토콜과 프로토콜에 대 한 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2724">The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="bc823-2725">이 오버 로드 해야 전송 하려는 데이터를 포함 하는 버퍼의 비트 조합 <xref:System.Net.Sockets.SocketFlags>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2725">This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="bc823-2726">버퍼 오프셋에 0이 고 기본값은 버퍼의 크기를 보낼 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2726">The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span> <span data-ttu-id="bc823-2727">지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수 값, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2727">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="bc823-2728">연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2728">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2729">사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2729">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="bc823-2730">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2730">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="bc823-2731">사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2731">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="bc823-2732">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2732">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-2733">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2733">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="bc823-2734">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 모든 버퍼의 바이트를 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2734">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2735">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2735">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2736">비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 버퍼의 바이트 수보다 적은 데이터를 보내는 경우에 성공적으로 완료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2736">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="bc823-2737">응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2737">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="bc823-2738">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2738">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-2739">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2739">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-2740">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2740">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2741">버퍼의 크기 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2741">You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-2742">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2742">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2743">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2743">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2744">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2744">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2745">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2745">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-2746">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2746">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2747">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2747">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2748">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2748">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2749">다음 코드 예제에서 연결 된 데이터를 보내는 방법을 보여 줍니다 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2749">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2750">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2750">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2751">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2751">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2752">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2752">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="bc823-2753">보낼 데이터가 들어 있는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2753">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2754">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2754">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2755">지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 목록에 있는 버퍼 집합을 연결된 <see cref="T:System.Net.Sockets.SocketFlags" />으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2755">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2756">
            <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2756">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2757">이 오버 로드에 전송 하려는 데이터가 포함 된 하나 이상의 버퍼에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2757">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="bc823-2758"><xref:System.Net.Sockets.SocketFlags> 기본값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2758">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="bc823-2759">지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketFlags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2759">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="bc823-2760">연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2760">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2761">사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2761">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="bc823-2762">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2762">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="bc823-2763">사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2763">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="bc823-2764">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2764">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-2765">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2765">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="bc823-2766">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 모든 버퍼의 바이트를 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2766">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2767">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2767">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2768">비 중단 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 버퍼의 바이트 수보다 적은 데이터를 보내는 경우에 성공적으로 완료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2768">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="bc823-2769">응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 버퍼의 바이트를 보낼 때 까지는 작업을 다시 시도를 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2769">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="bc823-2770">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2770">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-2771">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2771">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-2772">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2772">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2773">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2773">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2774">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2774">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2775">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2775">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-2776">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2776">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2777">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2777">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2778">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2778">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2779">
            <paramref name="buffers" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2779">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-2780">
            <paramref name="buffers" />가 비어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2780">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2781">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2781">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2782">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2782">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2783">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2783">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-2784">보낼 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2784">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2785">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2785">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2786">지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 원하는 바이트 수의 데이터를 연결된 <see cref="T:System.Net.Sockets.SocketFlags" />에 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2786">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2787">
            <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2787">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2788"><xref:System.Net.Sockets.Socket.Send%2A> 에 설정 된 원격 호스트에 데이터를 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드와 성공적으로 보낸 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2788"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="bc823-2789"><xref:System.Net.Sockets.Socket.Send%2A> 연결 지향 및 연결 없는 프로토콜에 대해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2789"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="bc823-2790">이 오버 로드를 보낼 바이트 수 및의 비트 조합을 전송 하려는 데이터가 포함 된 버퍼 필요 <xref:System.Net.Sockets.SocketFlags>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2790">This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="bc823-2791">지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2791">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="bc823-2792">연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2792">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2793">사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2793">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="bc823-2794">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2794">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="bc823-2795">사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출할 때마다 하기 전에 <xref:System.Net.Sockets.Socket.Send%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2795">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="bc823-2796">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2796">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-2797">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2797">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="bc823-2798">연결 지향 프로토콜로 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 바이트 수가 요청 된 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2798">With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2799">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2799">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2800">비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 보내는 요청 된 바이트 수보다 작을 경우에 성공적으로 완료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2800">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="bc823-2801">응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2801">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="bc823-2802">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2802">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-2803">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2803">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-2804">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2804">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2805">크기가 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2805">You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-2806">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2806">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2807">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2807">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2808">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2808">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2809">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2809">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-2810">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2810">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2811">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2811">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2812">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2812">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2813">다음 코드 예제에서는 버퍼에 있는 데이터를 보내고 지정 <xref:System.Net.Sockets.SocketFlags.None> 에 대 한 <xref:System.Net.Sockets.SocketFlags>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2813">The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2814">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2814">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2815">
            <paramref name="size" />가 0보다 작거나 버퍼 크기를 초과하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2815">
              <paramref name="size" /> is less than 0 or exceeds the size of the buffer.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2816">
            <paramref name="socketFlags" />가 값의 유효한 조합이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2816">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="bc823-2817">-또는-  소켓에 액세스하는 동안 운영 체제 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2817">-or-  An operating system error occurs while accessing the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2818">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2818">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="bc823-2819">보낼 데이터가 들어 있는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2819">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2820">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2820">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="bc823-2821">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2821">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2822">지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 목록에 있는 버퍼 집합을 연결된 <see cref="T:System.Net.Sockets.SocketFlags" />으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2822">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2823">
            <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2823">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2824">이 오버 로드에 전송 하려는 데이터가 포함 된 하나 이상의 버퍼에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2824">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="bc823-2825"><xref:System.Net.Sockets.SocketFlags> 기본값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2825">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="bc823-2826">지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketFlags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2826">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="bc823-2827">연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2827">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2828">사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2828">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="bc823-2829">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2829">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="bc823-2830">사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2830">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="bc823-2831">사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2831">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-2832">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2832">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="bc823-2833">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 모든 버퍼의 바이트를 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2833">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2834">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2834">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2835">비 중단 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 버퍼의 바이트 수보다 적은 데이터를 보내는 경우에 성공적으로 완료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2835">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="bc823-2836">응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 버퍼의 바이트를 보낼 때 까지는 작업을 다시 시도를 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2836">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="bc823-2837">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2837">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-2838">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2838">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-2839">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2839">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2840">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2840">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2841">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2841">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2842">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2842">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-2843">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2843">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2844">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2844">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2845">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2845">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2846">
            <paramref name="buffers" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2846">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-2847">
            <paramref name="buffers" />가 비어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2847">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2848">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2848">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2849">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2849">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2850">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2850">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-2851">데이터 보내기를 시작할 데이터 버퍼의 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2851">The position in the data buffer at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-2852">보낼 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2852">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2853">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2853">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2854">지정된 오프셋에서 시작하고 지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 지정된 바이트 수의 데이터를 연결된 <see cref="T:System.Net.Sockets.Socket" />으로 전송합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2854">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2855">
            <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2855">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2856"><xref:System.Net.Sockets.Socket.Send%2A> 에 지정 된 원격 호스트에 데이터를 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드와 성공적으로 보낸 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2856"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="bc823-2857"><xref:System.Net.Sockets.Socket.Send%2A> 연결 지향 및 연결 없는 프로토콜에 대해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2857"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="bc823-2858">이 오버 로드를 지정 하는 경우에 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2858">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="bc823-2859">연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2859">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2860">사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2860">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="bc823-2861">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2861">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="bc823-2862">사용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A>를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2862">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="bc823-2863">사용 해도 되는지 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2863">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-2864">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2864">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="bc823-2865">크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2865">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-2866">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2866">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-2867">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 바이트 수가 요청 된 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2867">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2868">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2868">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2869">비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 보내는 요청 된 바이트 수보다 작을 경우에 성공적으로 완료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2869">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="bc823-2870">응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2870">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="bc823-2871">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2871">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-2872">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2872">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-2873">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2873">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2874">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2874">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2875">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2875">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2876">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2876">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-2877">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2877">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2878">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2878">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2879">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2879">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2880">다음 코드 예제에서는 데이터 버퍼, 오프셋, 크기를 지정 하 고 <xref:System.Net.Sockets.SocketFlags> 는 연결 된 데이터를 보내기 위해 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2880">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2881">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2881">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2882">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2882">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2883">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2883">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-2884">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2884">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2885">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2885">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2886">
            <paramref name="socketFlags" />가 값의 유효한 조합이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2886">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="bc823-2887">-또는-  <see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2887">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2888">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2888">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-2889">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2889">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-2890">데이터 보내기를 시작할 데이터 버퍼의 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2890">The position in the data buffer at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-2891">보낼 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2891">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-2892">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2892">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="bc823-2893">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2893">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2894">지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 지정된 오프셋부터 원하는 바이트 수의 데이터를 연결된 <see cref="T:System.Net.Sockets.SocketFlags" />에 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2894">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2895">
            <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2895">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2896"><xref:System.Net.Sockets.Socket.Send%2A> 에 지정 된 원격 호스트에 데이터를 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드와 성공적으로 보낸 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2896"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="bc823-2897"><xref:System.Net.Sockets.Socket.Send%2A> 연결 지향 및 연결 없는 프로토콜에 대해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2897"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="bc823-2898">이 오버 로드를 지정 하는 경우에 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2898">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="bc823-2899">연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2899">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2900">사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2900">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="bc823-2901">연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2901">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="bc823-2902">사용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A>를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2902">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="bc823-2903">사용 해도 되는지 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2903">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="bc823-2904">호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2904">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="bc823-2905">크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2905">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-2906">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2906">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-2907">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 바이트 수가 요청 된 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2907">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-2908">시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2908">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-2909">비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 보내는 요청 된 바이트 수보다 작을 경우에 성공적으로 완료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2909">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="bc823-2910">응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2910">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="bc823-2911">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2911">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-2912">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2912">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-2913">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2913">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2914">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2914">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2915">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2915">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2916">송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2916">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="bc823-2917">버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2917">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2918">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2918">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2919">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2919">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2920">다음 코드 예제에서는 데이터 버퍼, 오프셋, 크기를 지정 하 고 <xref:System.Net.Sockets.SocketFlags> 는 연결 된 데이터를 보내기 위해 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2920">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-2921">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2921">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2922">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2922">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2923">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2923">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-2924">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2924">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-2925">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2925">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2926">
            <paramref name="socketFlags" />가 값의 유효한 조합이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2926">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="bc823-2927">-또는-  <see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2927">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2928">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2928">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="bc823-2929">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2929">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2930">데이터를 연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에 비동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2930">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-2931">I/O 작업이 보류 중인 경우 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2931">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="bc823-2932">작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2932">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="bc823-2933">I/O 작업이 동기적으로 완료된 경우 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2933">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="bc823-2934">이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2934">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2935"><xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드 연결 지향 소켓에서 하나 이상의 버퍼에서 나가는 데이터를 쓰는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2935">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</span></span> <span data-ttu-id="bc823-2936">이 메서드 데도 사용할 수 있습니다, 있지만 연결 없는 소켓 connect 작업에서 원격 호스트를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2936">This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</span></span>  
  
 <span data-ttu-id="bc823-2937"><xref:System.Net.Sockets.Socket.SendAsync%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>를 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2937">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-2938">다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:</span><span class="sxs-lookup"><span data-stu-id="bc823-2938">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="bc823-2939"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 또는 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bc823-2939"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="bc823-2940"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 경우 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 설정</span><span class="sxs-lookup"><span data-stu-id="bc823-2940"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="bc823-2941"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 경우 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 설정</span><span class="sxs-lookup"><span data-stu-id="bc823-2941"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="bc823-2942">호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2942">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="bc823-2943">콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2943">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="bc823-2944">합니다 <xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드가 먼저 호출 하지 않으면 예외가 throw 됩니다 <xref:System.Net.Sockets.Socket.Accept%2A>를 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>를 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2944">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span></span>  
  
 <span data-ttu-id="bc823-2945">호출 된 <xref:System.Net.Sockets.Socket.SendAsync%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2945">Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="bc823-2946">메시지 지향 소켓에 대 한 기본 Windows sockets 서비스 공급자의 최대 메시지 크기를 초과 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2946">For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</span></span> <span data-ttu-id="bc823-2947">데이터가 전송 되는 데이터가 너무 길어 기본 서비스 공급자를 통해 원자 단위로 전달 하는 경우 및 <xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드가 throw를 <xref:System.Net.Sockets.SocketException> 사용 하 여는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 네이티브 WSAEMSGSIZE Winsock 오류 코드 (10040)로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2947">If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEMSGSIZE error code (10040).</span></span>  
  
 <span data-ttu-id="bc823-2948">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2948">Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-2949">
            <paramref name="e" /> 매개 변수의 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 또는 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 속성이 올바른 버퍼를 참조하지 않는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2949">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span>
          </span>
          <span data-ttu-id="bc823-2950">이러한 속성 중 하나를 설정할 수 있지만 두 속성을 동시에 설정할 수는 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2950">One or the other of these properties may be set, but not both at the same time.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-2951">
            <paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2951">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-2952">이 메서드에 Windows XP 이상이 필요한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2952">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2953">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2953">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2954">
            <see cref="T:System.Net.Sockets.Socket" />이 아직 연결되지 않았거나 <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 또는 <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> 메서드를 통해 소켓을 가져오지 못한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2954">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-2955">
            <see cref="T:System.Net.Sockets.Socket" />의 송신 버퍼 크기를 지정하는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2955">Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-2956">송신 버퍼의 크기(바이트)가 들어 있는 <see cref="T:System.Int32" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2956">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer.</span>
          </span>
          <span data-ttu-id="bc823-2957">기본값은 8192입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2957">The default is 8192.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2958">큰 버퍼 크기는 연결 문제를 인식을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2958">A larger buffer size might delay the recognition of connection difficulties.</span></span> <span data-ttu-id="bc823-2959">큰 파일을 전송 하는 경우 높은 대역폭, 대기 시간이 긴 연결 (예: 위성 광대역 공급자입니다.)를 사용 하는 버퍼 크기를 늘리는 것이 좋습니다</span><span class="sxs-lookup"><span data-stu-id="bc823-2959">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2960">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.SendBufferSize%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2960">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2961">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2961">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2962">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2962">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-2963">set 작업에 지정된 값이 0보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2963">The value specified for a set operation is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-2964">연결된 <see cref="T:System.Net.Sockets.Socket" />에 파일 및 선택적 데이터를 동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2964">Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="bc823-2965">전송할 파일의 경로 및 이름을 포함하는 <see cref="T:System.String" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2965">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span>
          </span>
          <span data-ttu-id="bc823-2966">이 매개 변수는 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2966">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-2967">
            <see cref="T:System.Net.Sockets.Socket" /> 전송 플래그를 사용하여 <paramref name="fileName" /> 파일을 연결된 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 개체에 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2967">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-2968">이 오버 로드 된 파일을 보냅니다 `fileName` 연결 된 소켓입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2968">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="bc823-2969">합니다 `flags` 매개 변수의 기본값은 <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) 및 `preBuffer` 하 고 `postBuffer` 매개 변수의 기본값은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2969">The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`.</span></span> <span data-ttu-id="bc823-2970">경우 `fileName` 는 로컬 디렉터리에서 식별 된 파일의 이름만 사용 하 여, 그렇지 않으면 전체 경로 및 파일의 이름을 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2970">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="bc823-2971">와일드 카드 ("... \\\myfile.txt ") 및 UNC 공유 이름 ("\\\\\\\shared 디렉터리\\\myfile.txt ")는 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2971">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="bc823-2972">파일이 없는 경우, 예외 <xref:System.IO.FileNotFoundException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2972">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="bc823-2973">이 메서드는 사용 된 `TransmitFile` Windows Sockets 2 api에서 함수를 찾을.</span><span class="sxs-lookup"><span data-stu-id="bc823-2973">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="bc823-2974">에 대 한 자세한 내용은 `TransmitFile` 함수와 해당 플래그를 MSDN Library의 Windows 소켓 설명서를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="bc823-2974">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="bc823-2975"><xref:System.Net.Sockets.Socket.SendFile%2A> 에 지정 된 원격 호스트에 파일을 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-2975"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-2976"><xref:System.Net.Sockets.Socket.SendFile%2A> 연결 없는 프로토콜 및 연결 지향 둘 다에 대해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2976"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="bc823-2977">연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 그렇지 않은 경우이 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendFile%2A> throw를 <xref:System.Net.Sockets.SocketException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2977">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span> <span data-ttu-id="bc823-2978">사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트에 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2978">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="bc823-2979">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendFile%2A> 파일 전송 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2979">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent.</span></span> <span data-ttu-id="bc823-2980">비블로킹 모드로 <xref:System.Net.Sockets.Socket.SendFile%2A> 전체 파일이 전송 되기 전에 성공적으로 완료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2980">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="bc823-2981">보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2981">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-2982">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2982">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-2983">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendFile%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2983">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2984">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2984">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-2985">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-2985">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-2986">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2986">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-2987">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2987">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-2988">다음 코드 예제에서는 만듭니다 소켓 연결 및 원격 호스트에 파일을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2988">The following code example creates and connects a socket and then sends a file to the remote host.</span></span> <span data-ttu-id="bc823-2989">"Test.txt" 파일을 로컬 컴퓨터의 루트 디렉터리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-2989">The file "test.txt" is located in the root directory of the local machine.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-2990">소켓이 원격 호스트에 연결되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2990">The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-2991">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2991">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-2992">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 차단 모드가 아니며 이 동기 호출을 수락할 수 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2992">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="bc823-2993">
            <paramref name="fileName" /> 파일을 찾을 수 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2993">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-2994">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2994">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="bc823-2995">전송할 파일의 경로 및 이름을 포함하는 <see cref="T:System.String" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2995">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span>
          </span>
          <span data-ttu-id="bc823-2996">이 매개 변수는 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2996">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="preBuffer">
          <span data-ttu-id="bc823-2997">파일이 전송되기 전에 전송할 데이터를 포함하는 <see cref="T:System.Byte" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2997">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span>
          </span>
          <span data-ttu-id="bc823-2998">이 매개 변수는 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2998">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="postBuffer">
          <span data-ttu-id="bc823-2999">파일이 전송된 후에 전송할 데이터를 포함하는 <see cref="T:System.Byte" /> 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-2999">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span>
          </span>
          <span data-ttu-id="bc823-3000">이 매개 변수는 <see langword="null" />일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3000">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="bc823-3001">하나 이상의 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3001">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3002">지정된 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 값을 사용하여 연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에 파일 <paramref name="fileName" /> 및 데이터 버퍼를 전송합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3002">Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3003">이 오버 로드의 비트 조합 보낼 파일의 이름이 필요한 <xref:System.Net.Sockets.TransmitFileOptions> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3003">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="bc823-3004">`preBuffer` 매개 변수를 파일 앞에 데이터를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3004">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="bc823-3005">`postBuffer` 파일을 따라 하려는 데이터가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3005">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="bc823-3006">경우 `fileName` 는 현재 작업 디렉터리에서 식별 된 파일의 이름만 사용 하 여, 그렇지 않으면 전체 경로 및 파일의 이름을 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3006">If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="bc823-3007">와일드 카드 ("... \\\myfile.txt ") 및 UNC 공유 이름 ("\\\\\\\shared 디렉터리\\\myfile.txt ")는 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3007">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span>  
  
 <span data-ttu-id="bc823-3008">`flags` 매개 변수는 파일 전송에 대 한 추가 정보를 사용 하 여 창 소켓 서비스 공급자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3008">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="bc823-3009">이 매개 변수를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Net.Sockets.TransmitFileOptions>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3009">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="bc823-3010">이 메서드는 사용 된 `TransmitFile` Windows Sockets 2 api에서 함수를 찾을.</span><span class="sxs-lookup"><span data-stu-id="bc823-3010">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="bc823-3011">에 대 한 자세한 내용은 `TransmitFile` 함수와 해당 플래그를 MSDN Library의 Windows 소켓 설명서를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="bc823-3011">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="bc823-3012"><xref:System.Net.Sockets.Socket.SendFile%2A> 에 지정 된 원격 호스트에 파일을 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3012"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-3013"><xref:System.Net.Sockets.Socket.SendFile%2A> 연결 없는 프로토콜 및 연결 지향 둘 다에 대해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3013"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="bc823-3014">연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 고, 그렇지 <xref:System.Net.Sockets.Socket.SendFile%2A> throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3014">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-3015">사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3015">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="bc823-3016">연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendFile%2A> 전체 파일이 전송 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3016">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="bc823-3017">비블로킹 모드로 <xref:System.Net.Sockets.Socket.SendFile%2A> 전체 파일이 전송 되기 전에 성공적으로 완료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3017">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="bc823-3018">보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3018">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-3019">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3019">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-3020">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendFile%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3020">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3021">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3021">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-3022">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-3022">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3023">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3023">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-3024">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3024">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3025">다음 코드 예제에서는 만들고 소켓을 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3025">The following code example creates and connects a socket.</span></span> <span data-ttu-id="bc823-3026">"Test.txt" 파일을 로컬 컴퓨터의 루트 디렉터리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3026">The file "test.txt" is located in the root directory of the local machine.</span></span> <span data-ttu-id="bc823-3027">이 예제에서는 버퍼 및 데이터의 만들고 파일을 사용 하 여 원격 호스트에 전송 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3027">In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</span></span> <span data-ttu-id="bc823-3028">기본 <xref:System.Net.Sockets.TransmitFileOptions> 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3028">The default <xref:System.Net.Sockets.TransmitFileOptions> are used.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-3029">운영 체제가 Windows NT 이상이 아닌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3029">The operating system is not Windows NT or later.</span>
          </span>
          <span data-ttu-id="bc823-3030">\- 또는 -  소켓이 원격 호스트에 연결되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3030">\- or -  The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3031">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3031">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-3032">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 차단 모드가 아니며 이 동기 호출을 수락할 수 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3032">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="bc823-3033">
            <paramref name="fileName" /> 파일을 찾을 수 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3033">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3034">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3034">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="bc823-3035">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3035">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3036">파일 컬렉션 또는 메모리 내 데이터 버퍼를 연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에 비동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3036">Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-3037">I/O 작업이 보류 중인 경우 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3037">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="bc823-3038">작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3038">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="bc823-3039">I/O 작업이 동기적으로 완료된 경우 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3039">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="bc823-3040">이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3040">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3041"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 메서드는 원격 호스트에 메모리 또는 파일의 컬렉션 데이터 버퍼를 보내는 데 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3041">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host.</span></span> <span data-ttu-id="bc823-3042"><xref:System.Net.Sockets.Socket> 원격 호스트에 이미 연결 되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3042">The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.</span></span>  
  
 <span data-ttu-id="bc823-3043">경우는 <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> 작업 디렉터리에서 파일 참조를 파일의 이름만 사용 하 여 식별;이 고, 그렇지 전체 경로 및 파일의 이름을 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3043">If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="bc823-3044">UNC 공유 이름과 와일드 카드가 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3044">Wildcards and UNC share names are supported.</span></span> <span data-ttu-id="bc823-3045">파일이 없으면 <xref:System.IO.FileNotFoundException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3045">If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="bc823-3046">콜백 메서드를 이벤트 처리기를 구현 하는 완료 알림을 수를 만들어야\<SocketAsyncEventArgs > 대리자를 연결 하는 콜백에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3046">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="bc823-3047">합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> 속성에는 `e` 매개 변수는 파일 전송에 대 한 추가 정보를 사용 하 여 창 소켓 서비스 공급자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3047">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="bc823-3048">이 매개 변수를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Net.Sockets.TransmitFileOptions>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3048">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="bc823-3049">다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:</span><span class="sxs-lookup"><span data-stu-id="bc823-3049">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="bc823-3050">호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3050">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="bc823-3051">콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3051">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="bc823-3052">이 메서드는 Windows 소켓 2 API에 TransmitPackets 함수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3052">This method uses the TransmitPackets function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="bc823-3053">TransmitPackets 함수와 해당 플래그에 대 한 자세한 내용은 MSDN Library의 Windows 소켓 설명서를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="bc823-3053">For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="bc823-3054">연결 지향 프로토콜에서 사용 되지만 합니다 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 메서드 역시 연결 없는 프로토콜에 먼저 호출 된 합니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 기본 원격 호스트를 설정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3054">Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host.</span></span> <span data-ttu-id="bc823-3055">연결 없는 프로토콜 사용도 해야 파일의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3055">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-3056">이 경우 데이터 그램 전송 되지 않습니다 하 고 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throw를 <xref:System.Net.Sockets.SocketException> 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3056">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
 <span data-ttu-id="bc823-3057"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 메서드는 사용 되는 운영 체제에 따라 최적화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3057">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used.</span></span> <span data-ttu-id="bc823-3058">Windows server 버전에는 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 메서드는 높은 성능을 위해 최적화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3058">On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.</span></span>  
  
 <span data-ttu-id="bc823-3059">Windows 클라이언트 버전에는 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 최소 메모리 및 리소스 사용률에 대 한 메서드는 최적화 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3059">On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.</span></span>  
  
 <span data-ttu-id="bc823-3060">사용 합니다 <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> 플래그를 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> 속성에는 `e` 매개 변수는 상당한 성능 이점을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3060">Use of the <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter can deliver significant performance benefits.</span></span> <span data-ttu-id="bc823-3061">하는 경우 시작 하는 스레드가 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 계산이 많은 작업에 대 한 메서드 호출을 되, 것이 가능 하지만 드문 시작 Apc를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3061">If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</span></span> <span data-ttu-id="bc823-3062">사용자 모드 및 커널 Apc 간의 차이 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3062">Note that there is a difference between kernel and user-mode APCs.</span></span> <span data-ttu-id="bc823-3063">커널 Apc 스레드가 대기 상태일 때 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3063">Kernel APCs launch when a thread is in a wait state.</span></span> <span data-ttu-id="bc823-3064">사용자 모드 Apc 스레드 경고 대기 상태가 되 면 시작</span><span class="sxs-lookup"><span data-stu-id="bc823-3064">User-mode APCs launch when a thread is in an alertable wait state</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="bc823-3065">
            <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> 속성에 지정된 파일을 찾을 수 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3065">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-3066">
            <paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3066">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-3067">이 메서드에 Windows XP 이상이 필요한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3067">Windows XP or later is required for this method.</span>
          </span>
          <span data-ttu-id="bc823-3068">
            <see cref="T:System.Net.Sockets.Socket" />이 원격 호스트에 연결되어 있지 않은 경우에도 이 예외가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3068">This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3069">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3069">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3070">연결 없는 <see cref="T:System.Net.Sockets.Socket" />이 사용되고 있고 보내는 파일이 내부 전송의 최대 패킷 크기를 초과하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3070">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-3071">동기 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 호출이 완료되어야 하는 제한 시간을 지정하는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3071">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-3072">시간 제한 값(밀리초)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3072">The time-out value, in milliseconds.</span>
          </span>
          <span data-ttu-id="bc823-3073">1부터 499 사이의 값으로 속성을 설정하면 값이 500으로 변경됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3073">If you set the property with a value between 1 and 499, the value will be changed to 500.</span>
          </span>
          <span data-ttu-id="bc823-3074">기본값은 0으로, 시간 제한이 없음을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3074">The default value is 0, which indicates an infinite time-out period.</span>
          </span>
          <span data-ttu-id="bc823-3075">- 1을 지정해도 시간 제한이 없음을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3075">Specifying -1 also indicates an infinite time-out period.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3076">이 옵션은 동기 <xref:System.Net.Sockets.Socket.Send%2A> 만 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3076">This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only.</span></span> <span data-ttu-id="bc823-3077">제한 시간이 초과 되 면 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드는 throw를 <xref:System.Net.Sockets.SocketException>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3077">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3078">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.SendTimeout%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3078">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3079">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3079">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3080">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3080">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-3081">set 작업에 지정된 값이 -1보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3081">The value specified for a set operation is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-3082">특정 끝점에 데이터를 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3082">Sends data to a specific endpoint.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-3083">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3083">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-3084">데이터의 대상을 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3084">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3085">지정된 끝점에 데이터를 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3085">Sends data to the specified endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-3086">보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3086">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3087">이 오버 로드는 버퍼 오프셋의 크기를 기본값 보낼 바이트 수는 0을 `buffer` 매개 변수 및 <xref:System.Net.Sockets.SocketFlags> 기본값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3087">In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span>  
  
 <span data-ttu-id="bc823-3088">연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3088">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="bc823-3089">호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3089">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="bc823-3090">호출 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>는 `remoteEP` 작업만 송신 하는 매개 변수에서 지정 된 기본 원격 호스트를 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3090">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="bc823-3091">또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 하기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3091">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="bc823-3092">할당 된 로컬 네트워크 주소 및 포트 번호를 확인 해야 하는 경우 사용할 수 있습니다는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드가 성공적으로 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3092">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="bc823-3093">연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.SendTo%2A> 연결 지향 프로토콜과 함께 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3093">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="bc823-3094">원격 호스트 연결을 호출 하 여 먼저 설정 해야 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 사용 하 여 들어오는 연결 요청을 수락 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3094">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-3095">설정 하거나 원격 호스트 연결을 허용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3095">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-3096">호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3096">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="bc823-3097">이러한 경우 중 <xref:System.Net.Sockets.Socket.SendTo%2A> 는 무시 합니다 `remoteEP` 매개 변수와 연결 된 송신 데이터 또는 기본 원격 호스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3097">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="bc823-3098">소켓을 차단 하면 버퍼의 바이트 모든 전송 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3098">Blocking sockets will block until the all of the bytes in the buffer are sent.</span></span> <span data-ttu-id="bc823-3099">있으므로 비차단 <xref:System.Net.Sockets.Socket> 완료 즉시 보낼 수 있습니다 하지 모든 바이트를 `buffer`.</span><span class="sxs-lookup"><span data-stu-id="bc823-3099">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="bc823-3100">응용 프로그램의 책임 보낸 바이트 수를 추적 하는 응용 프로그램에서 모든 바이트를 보낼 때 까지는 작업을 다시 시도 하는 것은 `buffer`합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3100">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="bc823-3101">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3101">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-3102">네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3102">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="bc823-3103">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3103">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="bc823-3104">블로킹 모드에서 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 데이터 그램 전송 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3104">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="bc823-3105">먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3105">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-3106">보낸 바이트 수 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3106">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-3107">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3107">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3108">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3108">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-3109">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-3109">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3110">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3110">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-3111">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3111">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3112">다음 코드 예제에서는 지정된 된 원격 호스트에 연결 없는 데이터 그램을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3112">The following code example sends a connectionless datagram to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-3113">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3113">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-3114">-또는-  <paramref name="remoteEP" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3114">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3115">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3115">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3116">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3116">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-3117">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3117">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-3118">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3118">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-3119">해당 데이터의 대상 위치를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3119">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3120">지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 특정 끝점에 데이터를 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3120">Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-3121">보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3121">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3122">이 오버 로드는 버퍼 오프셋 0이 고 기본값의 크기를 보낼 바이트 수를 `buffer`입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3122">In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`.</span></span> <span data-ttu-id="bc823-3123">지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3123">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="bc823-3124">연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3124">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="bc823-3125">호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3125">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="bc823-3126">호출 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>는 `remoteEP` 작업만 송신 하는 매개 변수에서 지정 된 기본 원격 호스트를 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3126">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="bc823-3127">또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 하기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3127">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="bc823-3128">할당 된 로컬 네트워크 주소 및 포트 번호를 확인 해야 하는 경우 사용할 수 있습니다는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드가 성공적으로 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3128">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="bc823-3129">연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.SendTo%2A> 연결 지향 프로토콜과 함께 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3129">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="bc823-3130">원격 호스트 연결을 호출 하 여 먼저 설정 해야 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 사용 하 여 들어오는 연결 요청을 수락 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3130">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-3131">설정 하거나 원격 호스트 연결을 허용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3131">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-3132">호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3132">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="bc823-3133">이러한 경우 중 <xref:System.Net.Sockets.Socket.SendTo%2A> 는 무시 합니다 `remoteEP` 매개 변수와 연결 된 송신 데이터 또는 기본 원격 호스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3133">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="bc823-3134">소켓 차단 됩니다 될 때까지 차단 요청한 모든 바이트를 `buffer` 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3134">Blocking sockets will block until the requested all of the bytes in the `buffer` are sent.</span></span> <span data-ttu-id="bc823-3135">있으므로 비차단 <xref:System.Net.Sockets.Socket> 완료 즉시 보낼 수 있습니다 하지 모든 바이트를 `buffer`.</span><span class="sxs-lookup"><span data-stu-id="bc823-3135">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="bc823-3136">응용 프로그램의 책임 보낸 바이트 수를 추적 하는 응용 프로그램에서 모든 바이트를 보낼 때 까지는 작업을 다시 시도 하는 것은 `buffer`합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3136">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="bc823-3137">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3137">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-3138">네트워크 효율성을 높입니다 상당한 나가는 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3138">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="bc823-3139">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3139">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="bc823-3140">블로킹 모드에서 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 데이터 그램 전송 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3140">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="bc823-3141">먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3141">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-3142">보낸 바이트 수 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3142">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-3143">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3143">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3144">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3144">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-3145">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-3145">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3146">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3146">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-3147">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3147">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3148">다음 코드 예제에서는 지정된 된 원격 호스트에 연결 없는 데이터 그램을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3148">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="bc823-3149"><xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3149"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-3150">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3150">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-3151">-또는-  <paramref name="remoteEP" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3151">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3152">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3152">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3153">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3153">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-3154">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3154">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-3155">보낼 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3155">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-3156">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3156">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-3157">해당 데이터의 대상 위치를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3157">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3158">지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 특정 끝점에 원하는 바이트 수의 데이터를 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3158">Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-3159">보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3159">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3160">이 오버 로드는 버퍼에는 기본값 0으로 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3160">In this overload, the buffer offset defaults to 0.</span></span> <span data-ttu-id="bc823-3161">지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3161">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="bc823-3162">연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3162">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="bc823-3163">호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3163">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="bc823-3164">호출 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>는 `remoteEP` 작업만 송신 하는 매개 변수에서 지정 된 기본 원격 호스트를 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3164">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="bc823-3165">또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 하기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3165">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="bc823-3166">할당 된 로컬 네트워크 주소 및 포트 번호를 확인 해야 하는 경우 사용할 수 있습니다는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드가 성공적으로 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3166">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="bc823-3167">연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.SendTo%2A> 연결 지향 프로토콜과 함께 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3167">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="bc823-3168">원격 호스트 연결을 호출 하 여 먼저 설정 해야 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 사용 하 여 들어오는 연결 요청을 수락 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3168">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-3169">설정 하거나 원격 호스트 연결을 허용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3169">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-3170">호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3170">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="bc823-3171">이러한 경우 중 <xref:System.Net.Sockets.Socket.SendTo%2A> 는 무시 합니다 `remoteEP` 매개 변수와 연결 된 송신 데이터 또는 기본 원격 호스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3171">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="bc823-3172">소켓을 차단 하면 바이트 수가 요청 된 전송 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3172">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="bc823-3173">하므로 비차단 <xref:System.Net.Sockets.Socket> 완료를 즉시 보낼 수 있습니다 하지의 모든 단일 작업에서 요청 된 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3173">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="bc823-3174">응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3174">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="bc823-3175">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3175">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-3176">네트워크 효율성을 높입니다 상당한 나가는 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3176">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="bc823-3177">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3177">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="bc823-3178">블로킹 모드에서 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 데이터 그램 전송 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3178">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="bc823-3179">먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3179">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-3180">보낸 바이트 수 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3180">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-3181">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3181">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3182">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3182">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-3183">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-3183">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3184">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3184">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-3185">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3185">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3186">다음 코드 예제에서는 지정된 된 원격 호스트에 연결 없는 데이터 그램을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3186">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="bc823-3187">크기와 <xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3187">The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-3188">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3188">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-3189">-또는-  <paramref name="remoteEP" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3189">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-3190">지정된 <paramref name="size" />가 <paramref name="buffer" />의 크기를 초과한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3190">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3191">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3191">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3192">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3192">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="bc823-3193">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3193">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="bc823-3194">데이터 보내기를 시작할 데이터 버퍼의 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3194">The position in the data buffer at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="bc823-3195">보낼 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3195">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="bc823-3196">
            <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3196">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="bc823-3197">해당 데이터의 대상 위치를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3197">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3198">버퍼의 지정된 위치에서 시작하여 특정 <see cref="T:System.Net.Sockets.SocketFlags" />를 통해 원하는 바이트 수의 데이터를 지정된 끝점으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3198">Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-3199">보낸 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3199">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3200">이 오버 로드를 지정 하는 경우에 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3200">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="bc823-3201">연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3201">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="bc823-3202">호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3202">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="bc823-3203">호출 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>는 `remoteEP` 작업만 송신 하는 매개 변수에서 지정 된 기본 원격 호스트를 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3203">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="bc823-3204">또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 하기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3204">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="bc823-3205">할당 된 로컬 네트워크 주소 및 포트 번호를 확인 해야 하는 경우 사용할 수 있습니다는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드가 성공적으로 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3205">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="bc823-3206">연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.SendTo%2A> 연결 지향 프로토콜과 함께 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3206">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="bc823-3207">원격 호스트 연결을 호출 하 여 먼저 설정 해야 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 사용 하 여 들어오는 연결 요청을 수락 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3207">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="bc823-3208">설정 하거나 원격 호스트 연결을 허용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3208">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-3209">호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3209">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="bc823-3210">이러한 경우 중 <xref:System.Net.Sockets.Socket.SendTo%2A> 는 무시 합니다 `remoteEP` 매개 변수와 연결 된 송신 데이터 또는 기본 원격 호스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3210">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="bc823-3211">소켓을 차단 하면 바이트 수가 요청 된 전송 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3211">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="bc823-3212">비블로킹 이후 <xref:System.Net.Sockets.Socket> 완료를 즉시 보낼 수 있습니다 하지의 모든 단일 작업에서 요청 된 바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3212">Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="bc823-3213">이 응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3213">It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="bc823-3214">보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3214">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="bc823-3215">네트워크 효율성을 높입니다 상당한 나가는 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3215">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="bc823-3216">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3216">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="bc823-3217">블로킹 모드에서 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 데이터 그램 전송 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3217">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="bc823-3218">먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3218">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc823-3219">크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3219">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-3220">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3220">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3221">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3221">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-3222">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-3222">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3223">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3223">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-3224">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3224">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3225">다음 코드 예제에서는 지정된 된 원격 호스트에 연결 없는 데이터 그램을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3225">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="bc823-3226">오프셋, 크기 및 <xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3226">The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-3227">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3227">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc823-3228">-또는-  <paramref name="remoteEP" />이 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3228">-or-  <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-3229">
            <paramref name="offset" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3229">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-3230">-또는-  <paramref name="offset" />가 <paramref name="buffer" />의 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3230">-or-  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="bc823-3231">-또는-  <paramref name="size" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3231">-or-  <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="bc823-3232">-또는-  <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3232">-or-  <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3233">
            <paramref name="socketFlags" />가 값의 유효한 조합이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3233">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="bc823-3234">-또는-  <see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3234">-or-  An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3235">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3235">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="bc823-3236">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3236">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="bc823-3237">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3237">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3238">특정 원격 호스트에 데이터를 비동기적으로 보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3238">Sends data asynchronously to a specific remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc823-3239">I/O 작업이 보류 중인 경우 <see langword="true" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3239">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="bc823-3240">작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3240">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="bc823-3241">I/O 작업이 동기적으로 완료된 경우 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3241">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="bc823-3242">이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3242">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3243"><xref:System.Net.Sockets.Socket.SendToAsync%2A> 에 지정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 의 속성을 `e` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3243">The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property of the `e` parameter.</span></span> <span data-ttu-id="bc823-3244">호출 된 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3244">Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="bc823-3245">이 메서드는 연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 프로토콜과 연결 지향 프로토콜 모두 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3245">Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="bc823-3246">콜백 메서드를 이벤트 처리기를 구현 하는 완료 알림을 수를 만들어야\<SocketAsyncEventArgs > 대리자를 연결 하는 콜백에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3246">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="bc823-3247">다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:</span><span class="sxs-lookup"><span data-stu-id="bc823-3247">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="bc823-3248">호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3248">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="bc823-3249">콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3249">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="bc823-3250">먼저 호출 해야 합니다는 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>를 <xref:System.Net.Sockets.Socket.BeginAccept%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>를 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3250">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span> <span data-ttu-id="bc823-3251">그렇지 않으면 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3251">Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-3252">연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 메서드는 무시 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 속성 및 송신 데이터를를 <xref:System.Net.EndPoint?displayProperty=nameWithType> 에 설정 된를 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>를 <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3252">When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property and send data to the <xref:System.Net.EndPoint?displayProperty=nameWithType> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-3253">연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendToAsync%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3253">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span></span> <span data-ttu-id="bc823-3254">호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 또는 <xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3254">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods.</span></span> <span data-ttu-id="bc823-3255">호출 하는 경우는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendToAsync%2A>는 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 작업만 송신 하는 속성에서 지정 된 기본 원격 호스트를 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3255">If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="bc823-3256">또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3256">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="bc823-3257">이 경우 기본 서비스 공급자는 가장 적절 한 로컬 네트워크 IP 주소 및 포트 번호를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3257">In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</span></span> <span data-ttu-id="bc823-3258">기본 서비스 공급자가 사용 가능한 포트를 선택 하려는 경우 0의 포트 번호를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3258">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="bc823-3259">할당 된 로컬 네트워크 IP 주소와 포트 번호를 식별 해야 하는 경우 사용할 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트가 신호를 받 및 연결 된 대리자가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3259">If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event is signaled and the associated delegates are called.</span></span>  
  
 <span data-ttu-id="bc823-3260">먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> true로 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3260">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> to true.</span></span> <span data-ttu-id="bc823-3261">버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3261">You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="bc823-3262">이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3262">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="bc823-3263">DontRoute 플래그를 지정 하는 경우는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 속성, 데이터 전송 라우팅되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3263">If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="bc823-3264">메시지 지향 소켓에 대 한 기본 전송의 최대 메시지 크기를 초과 필요가 주의 기울여 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3264">For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</span></span> <span data-ttu-id="bc823-3265">버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하면 데이터 그램 전송 되지 않습니다 하 고 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3265">If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="bc823-3266">성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 메서드 데이터를 성공적으로 배달 된 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3266">The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-3267">
            <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />가 null인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3267">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-3268">
            <paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3268">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-3269">이 메서드에 Windows XP 이상이 필요한 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3269">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3270">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3270">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3271">연결 지향 프로토콜이 지정되었는데 <see cref="T:System.Net.Sockets.Socket" />이 아직 연결되지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3271">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">
          <span data-ttu-id="bc823-3272">이 소켓에 설정할 IP 보호 수준입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3272">The IP protection level to set on this socket.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3273">소켓에 IP 보호 수준을 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3273">Set the IP protection level on a socket.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3274"><xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> 제한 메서드를 사용 하면는 IPv6 또는 IP 소켓 주소와 같은 링크 로컬 또는 사이트 로컬 접두사가 같은 지정된 된 범위에서 수신 대기 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3274">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</span></span> <span data-ttu-id="bc823-3275">이 소켓 옵션에는 응용 프로그램을으로 IPv6 또는 IP 소켓에 액세스 제한을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3275">This socket option enables applications to place access restrictions on IPv6 or IP sockets.</span></span> <span data-ttu-id="bc823-3276">이러한 제한을 사용하면 사설 LAN에서 실행되는 응용 프로그램을 간단하고 강력하게 외부 공격으로부터 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3276">Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</span></span> <span data-ttu-id="bc823-3277">이 소켓 옵션을 사용 하 여 액세스 제한을 제거 하는 경우에 수를 `level` 매개 변수는 설정 <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3277">This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span></span> <span data-ttu-id="bc823-3278">이 소켓 옵션을 통해 적절한 경우 공용 및 개인 사용자의 무제한 액세스를 허용하거나 필요에 따라 같은 사이트로만 액세스를 제한하여 수신 소켓의 범위를 넓히거나 좁힐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3278">This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</span></span>  
  
 <span data-ttu-id="bc823-3279">이 소켓 옵션은 <xref:System.Net.Sockets.IPProtectionLevel> 열거형에 지정된 보호 수준을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3279">This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.</span></span>  
  
 <span data-ttu-id="bc823-3280">합니다 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> 메서드를 사용 하도록 설정 하거나 통과 NAT (Network Address)에 대 한 사용 하지 않도록를 사용 하는 <xref:System.Net.Sockets.Socket> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="bc823-3280">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance.</span></span> <span data-ttu-id="bc823-3281">Teredo, 6to4 또는 ISATAP 터널을 사용 하 여 NAT 통과 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3281">NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</span></span>  
  
 <span data-ttu-id="bc823-3282">경우는 `level` 매개 변수는 설정 <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, 또는 <xref:System.Net.Sockets.IPProtectionLevel.Restricted>,이 명시적으로 사용 하지 않도록 설정에 대 한 NAT 통과 <xref:System.Net.Sockets.Socket> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="bc823-3282">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.</span></span>  
  
 <span data-ttu-id="bc823-3283">경우는 `level` 매개 변수는 설정 <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>,이 수에 대 한 NAT 통과 <xref:System.Net.Sockets.Socket> 시스템에서 방화벽 규칙에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3283">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc823-3284">
            <paramref name="level" /> 매개 변수는 <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />일 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3284">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span>
          </span>
          <span data-ttu-id="bc823-3285">IP 보호 수준은 미지정으로 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3285">The IP protection level cannot be set to unspecified.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-3286">소켓의 설정은 <see cref="T:System.Net.Sockets.AddressFamily" />는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />여야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3286">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-3287">
            <see cref="T:System.Net.Sockets.Socket" /> 옵션을 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3287">Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="bc823-3288">
            <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3288">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="bc823-3289">
            <see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3289">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="bc823-3290">
            <see cref="T:System.Boolean" />으로 나타낸 옵션 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3290">The value of the option, represented as a <see cref="T:System.Boolean" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3291">지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션을 지정된 <see cref="T:System.Boolean" /> 값으로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3291">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3292"><xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3292"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-3293">설정 `optionValue` 하 `true` 옵션을 사용할 수 있도록 또는 `false` 옵션을 사용 하지 않도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3293">Set `optionValue` to `true` to enable the option, or to `false` to disable the option.</span></span>  
  
 <span data-ttu-id="bc823-3294"><xref:System.Net.Sockets.Socket> 옵션은 프로토콜 지원 수준에 따라 그룹화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3294"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="bc823-3295">다음은 다양 한 <xref:System.Net.Sockets.Socket> 이 오버 로드를 사용 하 여 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3295">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="bc823-3296">이러한 옵션은 적절 한 별로 그룹화 됩니다 <xref:System.Net.Sockets.SocketOptionLevel> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3296">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value.</span></span> <span data-ttu-id="bc823-3297">이러한 옵션 중 하나를 설정 하려는 경우 사용 해야 적절 한 <xref:System.Net.Sockets.SocketOptionLevel> 에 대 한 값을 `optionLevel` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3297">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter.</span></span> <span data-ttu-id="bc823-3298">설정 하려는 옵션을 지정 해야 합니다 `optionName` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3298">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="bc823-3299">나열 된 옵션의 현재 값을 사용 하려는 경우는 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3299">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-3300"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3300"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <span data-ttu-id="bc823-3301"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3301"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="bc823-3302"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3302"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="bc823-3303"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3303"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="bc823-3304">이러한 옵션에 대 한 자세한 내용은 참조는 <xref:System.Net.Sockets.SocketOptionName> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3304">For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3305">표시 되 면을 <xref:System.Net.Sockets.SocketException> 예외를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3305">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-3306">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-3306">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3307">다음 코드 예제에서는 소켓을 열고 사용 하도록 설정 합니다 `DontLinger` 하며 `OutOfBandInline` 소켓 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3307">The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3308">
            <see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3308">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3309">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3309">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="bc823-3310">
            <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3310">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="bc823-3311">
            <see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3311">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="bc823-3312">해당 옵션 값을 나타내는 <see cref="T:System.Byte" /> 형식의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3312">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3313">지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션을 바이트 배열로 나타내는 특정 값으로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3313">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3314"><xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3314"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-3315">이 오버 로드를 사용 하 여 설정 된 <xref:System.Net.Sockets.Socket> 옵션 값으로 바이트 배열을 필요로 하는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3315">Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3316">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3316">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-3317">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-3317">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3318">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3318">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-3319">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3319">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3320">다음 코드 예제에서는 합니다 <xref:System.Net.Sockets.LingerOption> 고 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3320">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3321">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3321">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3322">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3322">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="bc823-3323">
            <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3323">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="bc823-3324">
            <see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3324">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="bc823-3325">해당 옵션의 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3325">A value of the option.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3326">지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션을 원하는 정수 값으로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3326">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3327"><xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3327"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-3328">옵션을 사용 하 여를 <xref:System.Boolean> 데이터 형식에 옵션을 사용 하도록 설정 하려면 0이 아닌 값 및 옵션을 사용 하지 않으려면 0을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3328">For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</span></span> <span data-ttu-id="bc823-3329">정수 데이터 형식이 있는 옵션에 대 한 적절 한 값을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3329">For an option with an integer data type, specify the appropriate value.</span></span> <span data-ttu-id="bc823-3330"><xref:System.Net.Sockets.Socket> 옵션은 프로토콜 지원 수준에 따라 그룹화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3330"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="bc823-3331">다음은 다양 한 <xref:System.Net.Sockets.Socket> 이 오버 로드를 사용 하 여 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3331">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="bc823-3332">이러한 옵션은 적절 한 별로 그룹화 됩니다 <xref:System.Net.Sockets.SocketOptionLevel>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3332">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>.</span></span> <span data-ttu-id="bc823-3333">이러한 옵션 중 하나를 설정 하려는 경우 사용 해야 적절 한 <xref:System.Net.Sockets.SocketOptionLevel> 에 대 한는 `optionLevel` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3333">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter.</span></span> <span data-ttu-id="bc823-3334">설정 하려는 옵션을 지정 해야 합니다 `optionName` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3334">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="bc823-3335">나열 된 옵션의 현재 값을 사용 하려는 경우는 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3335">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="bc823-3336"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3336"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <span data-ttu-id="bc823-3337"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3337"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="bc823-3338"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3338"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="bc823-3339"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3339"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="bc823-3340"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3340"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 <span data-ttu-id="bc823-3341">이러한 옵션에 대 한 자세한 내용은 참조는 <xref:System.Net.Sockets.SocketOptionName> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3341">For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3342">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3342">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-3343">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-3343">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3344">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3344">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-3345">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3345">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3346">다음 코드 예제에서는 합니다 <xref:System.Net.Sockets.LingerOption> 고 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3346">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3347">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3347">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3348">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3348">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="bc823-3349">
            <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3349">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="bc823-3350">
            <see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3350">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="bc823-3351">해당 옵션의 값이 들어 있는 <see cref="T:System.Net.Sockets.LingerOption" /> 또는 <see cref="T:System.Net.Sockets.MulticastOption" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3351">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3352">지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션을 개체로 나타내는 특정 값으로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3352">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3353"><xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3353"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-3354">이 오버 로드를 사용 하 여 설정 합니다 <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, 및 <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3354">Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="bc823-3355">에 대 한 합니다 <xref:System.Net.Sockets.SocketOptionName.Linger> 옵션을 사용 하 여 <xref:System.Net.Sockets.Socket> 에 대 한는 `optionLevel` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3355">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="bc823-3356">에 대 한 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 하 고 <xref:System.Net.Sockets.SocketOptionName.DropMembership>를 사용 하 여 <xref:System.Net.Sockets.SocketOptionLevel.IP>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3356">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="bc823-3357">위에 나열 된 옵션의 현재 값을 사용 하려는 경우는 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="bc823-3357">If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3358">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3358">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-3359">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-3359">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3360">다음 코드 예제에서는 합니다 <xref:System.Net.Sockets.LingerOption> 고 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3360">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc823-3361">
            <paramref name="optionValue" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3361">
              <paramref name="optionValue" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3362">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3362">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3363">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3363">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">
          <span data-ttu-id="bc823-3364">더 이상 허용하지 않을 작업을 지정하는 <see cref="T:System.Net.Sockets.SocketShutdown" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3364">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc823-3365">
            <see cref="T:System.Net.Sockets.Socket" />에서 보내기 및 받기를 사용할 수 없도록 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3365">Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3366">연결 지향를 사용 하는 경우 <xref:System.Net.Sockets.Socket>를 항상 호출 합니다 <xref:System.Net.Sockets.Socket.Shutdown%2A> 닫기 전에 메서드를 <xref:System.Net.Sockets.Socket>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3366">When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-3367">이렇게 하면 모든 데이터가 전송 및 연결이 닫히기 전에 연결된 된 소켓에서 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3367">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="bc823-3368">호출 된 <xref:System.Net.Sockets.Socket.Close%2A> 메서드를 사용 가능한 관리 및 연관 된 리소스를 관리 되지 않는 <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="bc823-3368">Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="bc823-3369">다시 사용 하지 마십시오는 <xref:System.Net.Sockets.Socket> 닫으면 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3369">Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.</span></span>  
  
 <span data-ttu-id="bc823-3370">다음 표는 합니다 <xref:System.Net.Sockets.SocketShutdown> 에 대 한 유효한 열거형 값의 `how` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3370">The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.</span></span>  
  
|<span data-ttu-id="bc823-3371">값</span><span class="sxs-lookup"><span data-stu-id="bc823-3371">Value</span></span>|<span data-ttu-id="bc823-3372">설명</span><span class="sxs-lookup"><span data-stu-id="bc823-3372">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="bc823-3373">보내기</span><span class="sxs-lookup"><span data-stu-id="bc823-3373">Send</span></span>|<span data-ttu-id="bc823-3374">이 비활성화 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3374">Disable sending on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="bc823-3375">받기</span><span class="sxs-lookup"><span data-stu-id="bc823-3375">Receive</span></span>|<span data-ttu-id="bc823-3376">수신이를 사용 하지 않도록 설정 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3376">Disable receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="bc823-3377">Both</span><span class="sxs-lookup"><span data-stu-id="bc823-3377">Both</span></span>|<span data-ttu-id="bc823-3378">보내기 및 받기에 모두 사용 하지 않도록 설정 <xref:System.Net.Sockets.Socket>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3378">Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
  
 <span data-ttu-id="bc823-3379">설정 `how` 하 <xref:System.Net.Sockets.SocketShutdown.Send> 다음에 대 한 호출 <xref:System.Net.Sockets.Socket.Send%2A> 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3379">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed.</span></span> <span data-ttu-id="bc823-3380">연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>지정, <xref:System.Net.Sockets.SocketShutdown.Send> 영향을 주지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3380">If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.</span></span>  
  
 <span data-ttu-id="bc823-3381">설정 `how` 하 <xref:System.Net.Sockets.SocketShutdown.Receive> 다음에 대 한 호출 <xref:System.Net.Sockets.Socket.Receive%2A> 허용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3381">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed.</span></span> <span data-ttu-id="bc823-3382">하위 프로토콜 계층에서 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3382">This has no effect on lower protocol layers.</span></span> <span data-ttu-id="bc823-3383">다음 조건 중 하나를 호출한 후 존재 하는 경우 연결이 종료 되며 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span><span class="sxs-lookup"><span data-stu-id="bc823-3383">If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span></span>  
  
-   <span data-ttu-id="bc823-3384">데이터는 수신 대기 중인 들어오는 네트워크 버퍼입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3384">Data is in the incoming network buffer waiting to be received.</span></span>  
  
-   <span data-ttu-id="bc823-3385">더 많은 데이터가 전송 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3385">More data has arrived.</span></span>  
  
 <span data-ttu-id="bc823-3386">연결 없는 프로토콜을 사용 중인 데이터 그램 허용 되며 큐에 대기 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3386">If you are using a connectionless protocol, datagrams are accepted and queued.</span></span> <span data-ttu-id="bc823-3387">그러나 버퍼 공간이 추가로 들어오는 데이터 그램에 대 한 사용 가능한 경우 이러한 삭제 되 고 보낸 사람에 게 오류가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3387">However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</span></span> <span data-ttu-id="bc823-3388">사용 하 여 <xref:System.Net.Sockets.Socket.Shutdown%2A> 연결에 <xref:System.Net.Sockets.Socket> 권장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3388">Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.</span></span>  
  
 <span data-ttu-id="bc823-3389">설정 `how` 에 <xref:System.Net.Sockets.SocketShutdown.Both> 모두 보냅니다를 사용 하지 않도록 설정 하 고 위에서 설명한 것 처럼 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3389">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3390">수신 되 면를 <xref:System.Net.Sockets.SocketException> 호출할 때 합니다 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3390">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-3391">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-3391">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc823-3392">응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3392">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="bc823-3393">자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3393">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3394">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.Shutdown%2A> 사용 하지 않도록 설정 하 여 <xref:System.Net.Sockets.Socket>입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3394">The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3395">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3395">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3396">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3396">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-3397">
            <see cref="T:System.Net.Sockets.Socket" />의 형식을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3397">Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-3398">
            <see cref="T:System.Net.Sockets.SocketType" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3398">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3399"><xref:System.Net.Sockets.Socket.SocketType%2A> 읽기 전용 이며 경우 설정 됩니다는 <xref:System.Net.Sockets.Socket> 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3399"><xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3400">다음 코드 예제는 <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, 및 <xref:System.Net.Sockets.ProtocolType> 콘솔.</span><span class="sxs-lookup"><span data-stu-id="bc823-3400">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-3401">IPv4 지원이 사용 가능하며 현재 호스트에서 사용하도록 설정되어 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3401">Gets a value indicating whether IPv4 support is available and enabled on the current host.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-3402">현재 호스트에서 IPv4 프로토콜을 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3402">
              <see langword="true" /> if the current host supports the IPv4 protocol; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3403">운영 체제는 IPv4 및 IPv6 프로토콜을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3403">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-3404">Framework에서 더 이상 사용되지 않는 특정 <see cref="T:System.Net.Dns" /> 멤버에 대해 IPv6을 지원하는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3404">Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-3405">Framework에서 더 이상 사용되지 않는 특정 <see cref="T:System.Net.Dns" /> 메서드에 대해 IPv6을 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3405">
              <see langword="true" /> if the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> methods; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3406">운영 체제는 IPv4 및 IPv6 프로토콜을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3406">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-3407">
            <see cref="T:System.Net.Sockets.Socket" />에서 보낸 IP(인터넷 프로토콜) 패킷의 TTL(Time-To-Live) 값을 지정하는 값을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3407">Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-3408">TTL 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3408">The TTL value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3409">TTL 값은 라우터 라우터 패킷 및는 제어 메시지 ICMP (Internet Protocol) "TTL 초과"를 삭제 하기 전에 패킷이 이동할 수의 최대 수를 나타내는 오류 메시지가 보낸 사람에 게 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3409">The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</span></span>  
  
 <span data-ttu-id="bc823-3410">TTL 값은 0 ~ 255 값으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3410">The TTL value may be set to a value from 0 to 255.</span></span> <span data-ttu-id="bc823-3411">이 속성은 설정 되지 않은 경우에 소켓에 대 한 기본 TTL 값은 32입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3411">When this property is not set, the default TTL value for a socket is 32.</span></span>  
  
 <span data-ttu-id="bc823-3412">프로토콜 TCP (Transmission Control) 소켓에서이 속성을 설정할 연결에 성공 하면 소켓을 사용 하 여 설정 된 경우 TCP/IP 스택을 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3412">Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</span></span>  
  
 <span data-ttu-id="bc823-3413">수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3413">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="bc823-3414">이 코드를 가져온 후 가리킵니다 Windows 소켓 버전 2 API 오류 코드 설명서는 MSDN 라이브러리에서에 대 한 자세한 설명은 오류.</span><span class="sxs-lookup"><span data-stu-id="bc823-3414">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc823-3415">다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.Ttl%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3415">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc823-3416">TTL 값은 음수로 설정할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3416">The TTL value can't be set to a negative number.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc823-3417">
            <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 패밀리의 소켓이 아닌 소켓에 대해 이 속성을 설정한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3417">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="bc823-3418">소켓에 액세스하는 동안 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3418">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="bc823-3419">TTL을 255보다 큰 값으로 설정하고자 할 때에도 이 오류가 반환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3419">This error is also returned when an attempt was made to set TTL to a value higher than 255.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc823-3420">
            <see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3420">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc823-3421">소켓에서 중첩된 I/O 모드만 사용해야 하는지 여부를 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3421">Specifies whether the socket should only use Overlapped I/O mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc823-3422">
            <see cref="T:System.Net.Sockets.Socket" />에서 중첩된 I/O 모드만 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3422">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses only overlapped I/O; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="bc823-3423">기본값은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3423">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc823-3424">이 속성을 설정 `true` 에 대 한는 <xref:System.Net.Sockets.Socket> 호출 하려는 <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3424">Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span> <span data-ttu-id="bc823-3425">프레임 워크는 사용을 금지 하는 소켓 완료 포트를 할당할 수 있습니다이 고, 그렇지 <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="bc823-3425">Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc823-3426">소켓이 완료 포트에 바인딩된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc823-3426">The socket has been bound to a completion port.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>