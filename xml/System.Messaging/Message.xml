<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="aca17eb5c1214cd7837f89c181242c98095e8144" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36477556" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides access to the properties needed to define a Message Queuing message.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Messaging.Message> 클래스는 큐에서 메시지를 받거나 피킹 하거나 큐에 메시지를 보낼 때 메시지 속성 세밀 하 게 제어 하도록 합니다.  
  
 <xref:System.Messaging.MessageQueue> 사용 하 여는 <xref:System.Messaging.Message> 관찰 합니다. 또는 큐에서 메시지를 수신 하기 때문에 클래스 모두는 <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> 및 <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> 메서드의 새 인스턴스를 만들고는 <xref:System.Messaging.Message> 클래스와 인스턴스 속성을 설정 합니다. <xref:System.Messaging.Message> 클래스의 읽기 전용 속성은 읽기/쓰기 속성은 전송 및 메시지 검색에 적용 하는 동안에 큐에서 메시지를 검색에 적용 합니다. 때 <xref:System.Messaging.MessageQueue> 관찰 합니다. 또는 큐에서 메시지를 받고 해당 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 속성 검색 되는 메시지의 속성을 결정 합니다.  
  
 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Send%2A> 메서드를 해당 큐로 송신할 메시지에 대 한 모든 개체 형식을 지정할 수 있습니다. 사용할 수는 <xref:System.Messaging.MessageQueue> 인스턴스의 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성을 통해 큐에 전송 되는 제네릭 메시지에 대 한 설정을 지정 합니다. 설정의 형식 포맷터, 레이블, 암호화 및 인증을 포함 합니다. 에 대 한 적절 한 값을 지정할 수도 있습니다 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 승인 및 보고 메시지에 응답 하도록 메시징 응용 프로그램을 조정 하는 경우에 멤버입니다. 사용 하는 <xref:System.Messaging.Message> 인스턴스 메시지를 보낼 큐에 액세스 하 고 이러한 속성 중 상당수 수정 유연성을 제공 — 단일 메시지 또는 메시지-메시지 별로 합니다. <xref:System.Messaging.Message> 속성 보다 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>합니다.  
  
 메시지 데이터에 저장 됩니다는 <xref:System.Messaging.Message.Body%2A> 속성 및 어느 정도 <xref:System.Messaging.Message.AppSpecific%2A> 및 <xref:System.Messaging.Message.Extension%2A> 속성입니다. 메시지 데이터를 암호화, serialize 하거나 deserialize의 내용만 <xref:System.Messaging.Message.Body%2A> 속성에 영향을 받습니다.  
  
 내용을 <xref:System.Messaging.Message.Body%2A> 속성이 메시지를 보낼 때 사용 하 여 serialize 되는 <xref:System.Messaging.Message.Formatter%2A> 지정한 속성입니다. serialize 된 내용을 발견 되는 <xref:System.Messaging.Message.BodyStream%2A> 속성입니다. 설정할 수도 있습니다는 <xref:System.Messaging.Message.BodyStream%2A> 속성을 직접 예를 들어, 메시지의 데이터 내용으로 파일을 보낼 수 있습니다. 변경할 수는 <xref:System.Messaging.Message.Body%2A> 또는 <xref:System.Messaging.Message.Formatter%2A> 메시지 및 데이터를 보내기 전에 언제 든 지 serialize 할 속성을 적절 하 게 호출 하는 경우 <xref:System.Messaging.MessageQueue.Send%2A>합니다.  
  
 정의 하는 속성은 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> 형식이 아닌 메시지에만 속성이 적용 <xref:System.Messaging.Message>합니다. 지정 하는 경우는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성에 대 한는 <xref:System.Messaging.MessageQueue>, 동일한 이름의 속성으로는 <xref:System.Messaging.Message> 인스턴스가 전송 큐 야기 하는 기본 속성이 무시 됩니다.  
  
 인스턴스에 대 한 초기 속성 값 목록은 <xref:System.Messaging.Message>, 참조는 <xref:System.Messaging.Message.%23ctor%2A> 생성자입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 서식을 사용 하 여 메시지 본문을 보여 줍니다. <xref:System.Messaging.BinaryMessageFormatter>합니다.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 다음 코드 예제에서는 서식을 사용 하 여 메시지 본문을 보여 줍니다. <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.Message" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.Message" /> class with an empty body.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여의 새 인스턴스를 만드는 <xref:System.Messaging.Message> 본문이 비어 있는 클래스입니다.  
  
 지정 된 <xref:System.Messaging.Message.Body%2A> 속성 또는 <xref:System.Messaging.Message.BodyStream%2A> 보내기 전에 속성은 <xref:System.Messaging.Message> 개체입니다. <xref:System.Messaging.Message.Body%2A> 속성 텍스트 문자열, 구조 개체, 클래스 인스턴스 또는 포함된 된 개체와 같은 serialize 할 수 있는 모든 개체 일 수 있습니다.  
  
 메시지의 내용을 직접 작성 하지 않는 경우는 <xref:System.Messaging.Message.BodyStream%2A> 속성 설정에서 <xref:System.Messaging.Message.Formatter%2A> 메시지를 보내기 전에 속성입니다. 사용 하 여 본문은 직렬화는 <xref:System.Messaging.Message.Formatter%2A> 시간에 대 한 속성의 값의 <xref:System.Messaging.MessageQueue.Send%2A> 메서드가 호출 되는 <xref:System.Messaging.MessageQueue> 인스턴스.  
  
 <xref:System.Messaging.XmlMessageFormatter> 는 느슨하게 결합 되어 있으므로이 형식을 사용 하는 경우에 발신자와 수신자 입력 동일한 개체를 설정할 필요가 없습니다. <xref:System.Messaging.ActiveXMessageFormatter> 및 <xref:System.Messaging.BinaryMessageFormatter> 이진 표현으로 데이터를 직렬화 합니다. <xref:System.Messaging.ActiveXMessageFormatter> COM 구성 요소를 받거나 보낼 때 사용 됩니다.  
  
 다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.Message>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 버전 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 다음 코드 예제에서는 서로 다른 우선의 두 메시지를 보내고 큐로 검색 합니다.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">The object to be serialized into the body of the message.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.Message" /> class, using the <see cref="T:System.Messaging.XmlMessageFormatter" /> to serialize the specified object into the body of the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여의 새 인스턴스를 만드는 <xref:System.Messaging.Message> 클래스를 포함 하는 <xref:System.Messaging.Message.Body%2A> 에 지정 된는 `body` 매개 변수입니다. `body` 매개 변수는 텍스트 문자열, 구조 개체, 클래스 인스턴스 또는 포함된 된 개체와 같은 serialize 할 수 있는 모든 개체 일 수 있습니다. 사용 하 여 본문은 직렬화는 <xref:System.Messaging.XmlMessageFormatter> 변경 하지 않는 한는 <xref:System.Messaging.Message.Formatter%2A> 하기 전에 속성은 <xref:System.Messaging.Message> 전송 됩니다. 변경 하는 경우는 <xref:System.Messaging.Message.Body%2A> 또는 <xref:System.Messaging.Message.Formatter%2A> 언제 든 지 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%2A>, 메시지가 새 속성 값에 따라 직렬화 됩니다.  
  
 <xref:System.Messaging.XmlMessageFormatter> 는 느슨하게 결합 되어 있으므로이 형식을 사용 하는 경우에 발신자와 수신자 입력 동일한 개체를 설정할 필요가 없습니다. <xref:System.Messaging.ActiveXMessageFormatter> 및 <xref:System.Messaging.BinaryMessageFormatter> 이진 표현으로 데이터를 직렬화 합니다. <xref:System.Messaging.ActiveXMessageFormatter> COM 구성 요소를 받거나 보낼 때 사용 됩니다.  
  
 다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.Message>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 버전 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 매개 변수입니다.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 다음 코드 예제에서는 새 큐를 만듭니다, 그리고에 주문이 포함 하 고 검색 하는 메시지를 보냅니다.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">The object to be serialized into the body of the message.</param>
        <param name="formatter">A <see cref="T:System.Messaging.IMessageFormatter" /> that specifies the formatter with which to serialize the message body.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.Message" /> class using the specified formatter to serialize the specified object into the body of the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여의 새 인스턴스를 만드는 <xref:System.Messaging.Message> 클래스를 포함 하는 <xref:System.Messaging.Message.Body%2A> 에 지정 된는 `body` 하 고 매개 변수를 사용 하 여 유효한 포맷터 본문을 serialize 합니다. `body` 매개 변수는 텍스트 문자열, 구조 개체, 클래스 인스턴스 또는 포함된 된 개체와 같은 serialize 할 수 있는 모든 개체입니다. 변경 하는 경우는 <xref:System.Messaging.Message.Body%2A> 또는 <xref:System.Messaging.Message.Formatter%2A> 언제 든 지 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%2A>, 메시지가 새 속성 값에 따라 직렬화 됩니다.  
  
 <xref:System.Messaging.XmlMessageFormatter> 는 느슨하게 결합 되어 있으므로이 형식을 사용 하는 경우에 발신자와 수신자 입력 동일한 개체를 설정할 필요가 없습니다. <xref:System.Messaging.ActiveXMessageFormatter> 및 <xref:System.Messaging.BinaryMessageFormatter> 이진 표현으로 데이터를 직렬화 합니다. <xref:System.Messaging.ActiveXMessageFormatter> COM 구성 요소를 받거나 보낼 때 사용 됩니다.  
  
 다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.Message>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 버전 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 매개 변수입니다.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.Formatter%2A>|`formatter` 매개 변수입니다.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of acknowledgment message to be returned to the sending application.</summary>
        <value>중 하나는 <see cref="T:System.Messaging.AcknowledgeTypes" /> 시스템이 관리 큐는 승인이 보내는 응용 프로그램으로 반환 되는 조건에 게시 하는 승인 메시지의 형식을 나타내는 값입니다. 기본값은 <see langword="None" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A> 속성 보내는 응용 프로그램에 필요한 승인 메시지의 형식을 지정 합니다. 설정의 <xref:System.Messaging.Message.AcknowledgeType%2A> 특정 항목에 대 한 알림을 요청 하는 메시지를 보내기 전에 속성-예를 들어 대상 큐에 메시지, 메시지가 검색 되 고 또는 도달 하거나에서 검색 하 고에서 메시지를 방지 하는 제한 시간 대상 큐입니다.  
  
 메시지 큐에서 알림 승인 메시지를 전송 하 여 반환 된 <xref:System.Messaging.Message.AdministrationQueue%2A> 원본 메시지에서 지정 된 속성입니다. 승인 메시지의 <xref:System.Messaging.Message.Acknowledgment%2A> 속성 나타내는 승인의 유형을 나타냅니다. 예를 들어 메시지 하기 전에 대상에 도달 하지 않으므로 승인 메시지를 보낼 수는 <xref:System.Messaging.Message.TimeToReachQueue%2A> 간격이 만료 된 <xref:System.Messaging.Message.Acknowledgment%2A> 승인 메시지의 속성 값이 포함 됩니다 `ReachQueueTimeout`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 큐에서 주문을 포함 하는 메시지를 송수신 설정 합니다. 원본 메시지가 도달 하거나이 긍정 승인을 특별히 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message is filtered to ignore the <see cref="P:System.Messaging.Message.AcknowledgeType" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the classification of acknowledgment that this message represents.</summary>
        <value>
          <see cref="T:System.Messaging.Acknowledgment" /> 열거형 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 관리 큐에서 메시지를 받으면 읽기는 <xref:System.Messaging.Message.Acknowledgment%2A> 원본 메시지의 상태를 확인 하는 속성입니다.  
  
 대상 큐로 메시지를 보낼 때 메시지 큐 하도록 요청할 수 있습니다는 승인 메시지를 게시 합니다. 예를 들어 이러한 메시지 배달 하지 못한 경우 오류의 원인을 나타낼 수 있습니다 메시지 도착 하 고 지정 된 제한 시간 내에 검색 되었는지 여부를 나타낼 수 있습니다. 승인 메시지를 원본 메시지에 지정 된 관리 큐를 대상 큐 반환 <xref:System.Messaging.Message.AdministrationQueue%2A> 속성입니다. <xref:System.Messaging.Message.Id%2A> 승인 메시지의 속성은 원본 메시지가 아닌 승인 메시지를 식별 합니다. 승인에서 원본 메시지의 식별자를 찾을 수 있습니다 <xref:System.Messaging.Message> 인스턴스의 <xref:System.Messaging.Message.CorrelationId%2A> 속성입니다.  
  
 이 경우 <xref:System.Messaging.Message> 인스턴스가 승인 메시지를 나타내는 <xref:System.Messaging.Message.Acknowledgment%2A> 속성 승인의 유형을 지정 합니다. 그렇지 않은 경우는 <xref:System.Messaging.Message.Acknowledgment%2A> 속성 값이 들어 `Normal`합니다.  
  
 사용 하 여는 <xref:System.Messaging.Message.AcknowledgeType%2A> 승인이 반환 되는 상황을 지정 하 고 원본 메시지의 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the queue that receives the acknowledgement messages that Message Queuing generates.</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" /> 시스템 생성 승인 메시지에 사용 되는 관리 큐를 지정 하는 합니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 지정 된 큐는 <xref:System.Messaging.Message.AdministrationQueue%2A> 속성 모든 비트랜잭션 큐를 사용할 수 있습니다. 관리 큐에 보낸 승인 메시지는 원본 메시지가 대상 큐에 도달했는지 여부 및 메시지가 큐에서 제거되었는지 여부를 나타낼 수 있습니다.  
  
 경우는 <xref:System.Messaging.Message.AcknowledgeType%2A> 속성 이외의 모든 값을 가지 `None`, 보내는 응용 프로그램에서 관리 큐로 사용할 큐를 지정 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 큐에서 주문을 포함 하는 메시지를 송수신 설정 합니다. 원본 메시지가 도달 하거나이 긍정 승인을 특별히 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.AdministrationQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets additional, application-specific information.</summary>
        <value>응용 프로그램에만 적용 되는 정보입니다. 기본값은 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A> 속성 다양 한 유형의 메시지를 구성 하는 데 사용할 수 있는 응용 프로그램 관련 정보를 포함 합니다. 예를 들어 응용 프로그램 관련 인덱스를 사용할 수 있습니다. 응용 프로그램에서 해석할 작업은 <xref:System.Messaging.Message.AppSpecific%2A> 속성 정보입니다.  
  
 메시지의 본문에 메시지 데이터를 포함 해야 가능 하면 보다는 <xref:System.Messaging.Message.AppSpecific%2A> 속성입니다.  
  
 사용 하 여 외부 큐를 사용할 때의 <xref:System.Messaging.Message.Extension%2A> 속성을 통해 메시지 큐에 존재 하지 않는 메시지 속성을 지정 합니다. 과 마찬가지로 <xref:System.Messaging.Message.AppSpecific%2A> 속성의 내용을 이해 하는 응용 프로그램의 책임 이며는 <xref:System.Messaging.Message.Extension%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.AppSpecific" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the message arrived in the destination queue.</summary>
        <value>A <see cref="T:System.DateTime" /> 대상 큐에 메시지의 도착 시간을 나타내는입니다. 시간은 GMT에서 대상 큐가 있는 컴퓨터의 현지 시간으로 조정 됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지의 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성 대상 큐 로부터 메시지를 수신할 수 있어야 하는 속도 나타냅니다. <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성 타이머 메시지를 보낼 때 메시지가 큐에 도착할 때가 아니라 시작 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.ArrivedTime%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.ArrivedTime" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the sender ID should be attached to the message.</summary>
        <value>
          <see langword="true" /> 경우는 <see cref="P:System.Messaging.Message.SenderId" /> 메시지에 첨부 된 건너뛸 필요가 없으면, <see langword="false" />합니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A> 속성은 보내는 사용자의 식별자를 나타내는 바이트 배열입니다. 보낸 사람 ID는 메시지 큐에서 설정 되 고 보낸 사람에는 큐에 액세스 권한이 있는지 여부를 확인 하려면 수신 큐 관리자에서 사용 됩니다.  
  
 받는 큐에 보낸 사람 ID가는 메시지 큐 해야 하지 않으며 메시지의 보낸 사람 유효성 검사도 보낸 사람의 액세스를 확인 하는 보내는 응용 프로그램이 없는 경우 권한입니다. <xref:System.Messaging.Message.SenderId%2A> 은 메시지가 대상 큐에 도달 했을 때 인증 된 경우에 신뢰할 수 있습니다. 큐와 인증 된 메시지만 허용 하는 경우 대상 큐에 도달 하면 메시지는 거부 된 <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> 또는 <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> 속성은 `false`합니다.  
  
> [!CAUTION]
>  메시지가 거부 될 경우 배달 못 한 편지 큐로 보내지거나 (경우 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 은 `true`), 무시 됩니다. 메시지는 큐에 도달 하지 못할 때 승인을 요청할 수 있습니다. 경우에, 그렇지 않으면 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 은 `false` 메시지는 경고 없이 손실 될 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 설정 가져오고 <xref:System.Messaging.Message.AttachSenderId%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.AttachSenderId" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the message was authenticated.</summary>
        <value>
          <see langword="true" /> 큐에 도달 했을 때 인증 메시지에 대 한 요청 된 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A> 속성은 메시지와 상호 작용 되 고 인증이 요청 되었는지 확인 하는 동안 응용 프로그램에 의해서만 사용 됩니다. 메시지가 큐에 있으면 메시지가 인증 되었는지 합니다. 반대로 하는 경우는 <xref:System.Messaging.Message.Authenticated%2A> 속성은 `true`, 수신 큐 관리자는 해당 메시지를 받으면 메시지를 인증 합니다.  
  
 메시지가 해당 속성을 확인 하 여 인증 실패를 확인할 수 없습니다. 메시지 큐에 메시지가 배달 되기 전에 인증에 실패 하는 메시지 큐에서 삭제 합니다. 그러나 배달이 실패 하면 메시지가 메시지 큐에 도착는 것을 방지 한 경우 승인 메시지를 보내도록 요청할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.Authenticated%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Authenticated" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the cryptographic provider used to generate the digital signature of the message.</summary>
        <value>메시지의 디지털 서명을 생성 하는 데 사용 되는 암호화 공급자의 이름입니다. 기본값은 Microsoft Base Cryptographic Provider 1.0 버전.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 사용 된 <xref:System.Messaging.Message.AuthenticationProviderName%2A> 외부 큐에서 작업 하는 경우. 메시지 큐는 인증 공급자 이름 및 외부 큐로 전송 된 메시지와 메시지에 전달 된 메시지의 디지털 서명 유효성을 검사 하려면 (인증 공급자) 암호화 공급자의 인증 공급자 형식이 필요 외부 큐에서 큐입니다.  
  
 메시지를 보낼 때 항상 설정 된 <xref:System.Messaging.Message.AuthenticationProviderName%2A> 및 <xref:System.Messaging.Message.ConnectorType%2A> 속성을 함께 합니다. 메시지를 보낼 때 메시지 큐 무시 인증 공급자 이름 커넥터 종류가 설정 되지 않은 경우.  
  
 <xref:System.Messaging.Message.AuthenticationProviderName%2A> 속성 수 없습니다 `null`, 있지만 빈 문자열일 수 있습니다 ("").  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> property could not be set.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> property.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> was set to <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of cryptographic provider used to generate the digital signature of the message.</summary>
        <value>
          <see cref="T:System.Messaging.CryptographicProviderType" /> 값 중 하나입니다. 기본값은 <see langword="RSA_FULL" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 사용 된 <xref:System.Messaging.Message.AuthenticationProviderType%2A> 클래스는 메시지와 연결 된 암호화 서비스 공급자를 지정 하는 경우이 속성입니다. 메시지 큐는 인증 공급자 이름 및 외부 큐로 전송 된 메시지와 메시지에 전달 된 메시지의 디지털 서명 유효성을 검사 하려면 (인증 공급자) 암호화 공급자의 인증 공급자 형식이 필요 외부 큐에서 큐입니다.  
  
 만 `RsaFull` messaging과 함께 사용 하기에 적합 합니다.  
  
 메시지를 보낼 때 항상 설정 된 <xref:System.Messaging.Message.AuthenticationProviderType%2A> 및 <xref:System.Messaging.Message.ConnectorType%2A> 속성을 함께 합니다. 메시지를 보낼 때 메시지 큐 무시 인증 공급자 유형 커넥터 종류가 설정 되지 않은 경우.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> property could not be set.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the content of the message.</summary>
        <value>메시지 콘텐츠를 지정 하는 개체입니다. 개체를 문자열, 날짜, 통화, 숫자, 바이트의 배열 또는 관리 되는 개체 수 있습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지의 <xref:System.Messaging.Message.Body%2A> 속성은 일반적으로 메시지에 연결 된 데이터를 포함 합니다. 응용 프로그램 관련 데이터를 보낼 수도 있지만 <xref:System.Messaging.Message.AppSpecific%2A> 및 <xref:System.Messaging.Message.Extension%2A> 속성, 메시지 데이터를 포함 해야는 <xref:System.Messaging.Message.Body%2A> 가능 하면 메시지의 합니다. 만 <xref:System.Messaging.Message.Body%2A> 속성 내용을 serialize 되거나 암호화 합니다.  
  
 <xref:System.Messaging.Message.Body%2A> 속성 필요에 따라 크기가 4MB를 초과 하지 않는 개체를 포함할 수 있습니다. 사용 하는 경우 <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> 다른 형식의 모든 개체를 보내려면 <xref:System.Messaging.Message> 에 <xref:System.Messaging.MessageQueue>, 해당 개체에 배치 됩니다는 <xref:System.Messaging.Message.Body%2A> 의 속성은 <xref:System.Messaging.Message> 에서 반환한 인스턴스 <xref:System.Messaging.MessageQueue.Peek%2A> 또는 <xref:System.Messaging.MessageQueue.Receive%2A>합니다.  
  
 문자열 인수에 `MessageQueue.Send("hello.")` 은 예제는 이러한 일반 개체입니다.  
  
 <xref:System.Messaging.Message.BodyType%2A> 속성에는 메시지 본문에 저장 된 정보의 유형을 나타냅니다. 메시지 큐의 형식을 식별 하기 위해이 정보를 사용 하 여는 <xref:System.Messaging.Message.Body%2A> 속성 내용입니다.  
  
 지정 된 <xref:System.Messaging.Message.Body%2A> 속성 또는 <xref:System.Messaging.Message.BodyStream%2A> 보내기 전에 속성은 <xref:System.Messaging.Message> 개체입니다. <xref:System.Messaging.Message.Body%2A> 속성은 모든 텍스트 문자열 같은 직렬화 가능 개체, 구조체, 클래스 인스턴스 또는 포함 된 개체 일 수 있습니다.  
  
 메시지의 내용을 직접 작성 하지 않는 경우는 <xref:System.Messaging.Message.BodyStream%2A> 속성 설정에서 <xref:System.Messaging.Message.Formatter%2A> 메시지를 보내기 전에 속성입니다. 경우는 <xref:System.Messaging.MessageQueue.Send%2A> 메서드가 호출 되는 <xref:System.Messaging.MessageQueue> 인스턴스가, 본문에 포함 된 포맷터를 사용 하 여 serialize 되는 <xref:System.Messaging.Message.Formatter%2A> 속성입니다. 에 대 한 값을 지정 하지 않고 메시지를 보내기는 <xref:System.Messaging.Message.Formatter%2A> 속성, 포맷터의 기본값은 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
> [!NOTE]
>  메시지의 본문을 설정 하는 <xref:System.Decimal.MaxValue> 하면는 <xref:System.OverflowException> 때는 `Send` 의 메서드는 <xref:System.Messaging.MessageQueue> 클래스 라고 및 <xref:System.Messaging.ActiveXMessageFormatter> 사용 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 서로 다른 우선의 두 메시지를 보내고 큐로 검색 합니다.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Messaging.Message.Formatter" /> property is <see langword="null" />.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Body" /> property.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the information in the body of the message.</summary>
        <value>A <see cref="T:System.IO.Stream" /> 에 포함 된 직렬화 된 정보를 포함 하는 <see cref="P:System.Messaging.Message.Body" /> 메시지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지의 본문 모든 종류의 정보로 구성 될 수-문자열, 날짜, 통화, 숫자, 바이트의 배열 또는 관리 되는 개체 예를 들어 있습니다. 이 정보로 serialize 되는 <xref:System.IO.Stream> 를 큐에 전달 합니다.  
  
 지정 된 <xref:System.Messaging.Message.Body%2A> 속성 또는 <xref:System.Messaging.Message.BodyStream%2A> 보내기 전에 속성은 <xref:System.Messaging.Message> 개체입니다. 설정 하는 경우는 <xref:System.Messaging.Message.Body%2A> 속성 내용을로 serialize 되는 <xref:System.Messaging.Message.BodyStream%2A> 속성입니다. 그러나 작성 하도록 선택할 수는 <xref:System.Messaging.Message.BodyStream%2A> 속성을 직접 합니다. 예를 들어 파일에 대 한 연결을 열고 스트림 그 내용을 메시지의 본문으로 하려는 경우 유용, 합니다.  
  
 메시지의 내용을 직접 작성 하지 않는 경우는 <xref:System.Messaging.Message.BodyStream%2A> 속성 설정에서 <xref:System.Messaging.Message.Formatter%2A> 메시지를 보내기 전에 속성입니다. 경우는 <xref:System.Messaging.MessageQueue.Send%2A> 메서드가 호출 되는 <xref:System.Messaging.MessageQueue> 인스턴스가, 본문에 포함 된 포맷터를 사용 하 여 serialize 되는 <xref:System.Messaging.Message.Formatter%2A> 속성입니다. 에 대 한 값을 지정 하지 않고 메시지를 보내기는 <xref:System.Messaging.Message.Formatter%2A> 속성, 포맷터의 기본값은 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 설정 하는 경우는 <xref:System.Messaging.Message.UseEncryption%2A> 속성을 `true` 이 메시지의 본문, 메시지를 암호화할 전송 될 때, 설정한 때가 아니라는 <xref:System.Messaging.Message.Body%2A> 속성입니다. 따라서는 <xref:System.Messaging.Message.BodyStream%2A> 속성 암호화 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Body" /> property.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of data that the message body contains.</summary>
        <value>메시지 본문의 실제 형식, 문자열, 날짜, 통화, 또는 숫자와 같은 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐 개체 또는 serialize 된 스트림으로 본문 콘텐츠를 인식합니다. <xref:System.Messaging.Message.BodyType%2A> 속성 내에서 개체의 형식을 나타냅니다는 <xref:System.Messaging.Message.Body%2A> 메시지의 속성입니다.  
  
 <xref:System.Messaging.XmlMessageFormatter> 메시지 본문에서 네이티브 형식과 개체 간에 바인딩을 수행 합니다. 사용 하는 경우는 <xref:System.Messaging.XmlMessageFormatter>, 설정은 <xref:System.Messaging.Message.BodyType%2A> 속성이 있습니다.  
  
 다른 포맷터는 또한 다음 C# 코드에서와 같이 바인딩 기능을 제공할 수 있습니다.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.BodyType%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Body" /> property.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates that some message properties typically set by Message Queuing were set by the sending application.</summary>
        <value>A <see cref="T:System.Guid" /> 응용 프로그램에 의해 정의 되며 커넥터 응용 프로그램 또는 메시지 암호화와 함께 사용 합니다. 이 <see cref="T:System.Guid" /> 보내는 응용 프로그램에서 설정 하는 일반적으로 메시지 큐에서 설정 되었지만 메시지 속성을 해석 하는 수신 응용 프로그램을 허용 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐는 <xref:System.Messaging.Message.ConnectorType%2A> 설정할 때마다 응용 프로그램은 일반적으로 메시지 큐에서 설정 하는 메시지 속성을 설정 합니다. 응용 프로그램에서 일반적으로 사용 하는 <xref:System.Messaging.Message.ConnectorType%2A> 다음 두 가지 경우에서:  
  
-   때마다 커넥터 응용 프로그램에 메시지를 전달 합니다. <xref:System.Messaging.Message.ConnectorType%2A> 송신 및 수신 응용 프로그램 메시지의 보안 및 승인 속성을 해석 하는 방법을 설명 합니다.  
  
-   때마다는 보내는 응용 프로그램 보다는 메시지 큐에서 메시지를 암호화합니다. <xref:System.Messaging.Message.ConnectorType%2A> 메시지 큐가 사용 하도록 지시는 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 속성 값을 메시지의 암호를 해독 합니다.  
  
 설정 해야 합니다는 <xref:System.Messaging.Message.ConnectorType%2A> 다음과 같은 속성을 설정 하는 경우 속성 (그렇지 않으면 큐 무시 이러한 속성은 메시지를 보낼 때):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.ConnectorType" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the message identifier used by acknowledgment, report, and response messages to reference the original message.</summary>
        <value>로 지정 된 메시지 식별자는 <see cref="P:System.Messaging.Message.Id" /> 원본 메시지의 속성입니다. 응답 메시지를 생성할 때 상관 관계 식별자는 메시지는 승인 또는 보고 메시지를 생성할 때 큐에서 및 응용 프로그램에 의해 사용 됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐에서 승인 또는 보고 메시지를 생성할 때에 상관 관계 식별자 속성을 사용 하 여 원본 메시지의 메시지 식별자를 지정 합니다. 이러한 방식으로 상관 관계 식별자는 보고 메시지나 승인 메시지를 원본 메시지에 연결합니다.  
  
 보내는 응용 프로그램 일치 시킬 수 있습니다 승인 또는 보고 원본 메시지와 함께 사용 하 여는 <xref:System.Messaging.Message.CorrelationId%2A> 원본 메시지를 식별 하기 위해 속성 <xref:System.Messaging.Message.Id%2A> 속성입니다.  
  
 커넥터 응용 프로그램도 설정 해야 합니다는 <xref:System.Messaging.Message.CorrelationId%2A> 원본 메시지의 메시지 식별자를 승인 및 보고 메시지의 속성입니다.  
  
 응용 프로그램 응답 메시지를 보내면 송신 응용 프로그램을 설정할 수는 <xref:System.Messaging.Message.CorrelationId%2A> 원본 메시지의 메시지 식별자로 응답 메시지의 속성입니다. 보내는 응용 프로그램에서 보낸 메시지에 응답 메시지를 일치 시킬 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 큐에서 주문에 포함 된 메시지 송수신 설정 합니다. 원본 메시지가 도달 하거나이 긍정 승인을 특별히 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.CorrelationId" /> property.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.CorrelationId" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the intended destination queue for a message.</summary>
        <value>A <see cref="T:System.Messaging.MessageQueue" /> 메시지에 대 한 의도 한 대상 큐를 지정 하는 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A> 속성은 가장 일반적으로 업무 일지 나 배달 못 한 편지 큐에 도착 한 메시지의 원래 대상을 확인 하는 데 사용 됩니다. 일반적으로 않아도이 속성을 검사 하려면 일반적으로 대상 큐에서 메시지를 검색 하기 때문에 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.DestinationQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.DestinationQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the symmetric key used to encrypt application-encrypted messages or messages sent to foreign queues.</summary>
        <value>메시지를 암호화 하는 데 사용 하는 대상 대칭 키를 지정 하는 바이트 값의 배열입니다. 기본값은 빈 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두 가지 시나리오를 사용할 필요는 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 속성입니다. 첫 번째 응용 프로그램을 대신 메시지 큐에서 메시지를 암호화 하는 합니다. 두 번째 메시지 큐가 아닌 큐 시스템에 암호화 된 메시지를 보낼 때가 있습니다.  
  
 이 속성을 설정 하기 전에 수신 큐 관리자의 공개 키와 대칭 키를 암호화 해야 합니다. 응용 프로그램 암호화 된 메시지를 보내면 수신 큐 관리자를 사용 하 여 대칭 키 대상 큐로 보내기 전에 메시지를 암호 해독 합니다.  
  
 외부 큐로 메시지를 보내는 경우 메시지는 먼저 수신 응용 프로그램에 연결 된 대칭 키로 암호화 된 메시지를 전달 하는 적절 한 커넥터 응용 프로그램에서 수신 됩니다. 대칭 키를 사용 하 여 메시지를 해독 하는 수신 응용 프로그램에서 수행 됩니다.  
  
 설정 하는 경우는 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 속성을 설정 해야는 <xref:System.Messaging.Message.ConnectorType%2A> 속성입니다. 메시지를 보낼 때 무시 메시지 큐는 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 속성 경우는 <xref:System.Messaging.Message.ConnectorType%2A> 에서도 속성이 설정 되지 않은 합니다.  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 속성에는 최대 배열 크기는 256 자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> property.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the digital signature that Message Queuing uses to authenticate the message.</summary>
        <value>메시지를 인증 하는 데 사용 하는 메시지 큐 1.0 디지털 서명을 지정 하는 바이트 값의 배열입니다. 기본값은 빈 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐는 메시지 버전 1.0 큐에서 전송 된 메시지를 인증할 때 디지털 서명을 사용 합니다. 대부분의 경우에서 메시지 큐 생성 하 고 설정 된 <xref:System.Messaging.Message.DigitalSignature%2A> 보내는 응용 프로그램이 인증을 요청 하는 경우이 속성입니다. 수신 응용 프로그램이이 속성을 사용 하 여 메시지에 첨부 된 디지털 서명을 검색 합니다.  
  
 만 사용할 수 있습니다는 <xref:System.Messaging.Message.DigitalSignature%2A> 메시지 큐 2.0 버전을 실행 하는 경우에 속성입니다. 인증을 요청할 때 보내는 응용 프로그램 버전 1.0 서명을 메시지 큐를 지정 해야 합니다. 보내는 응용 프로그램 메시지 큐 버전 2.0 서명의 보내는 경우이 속성의 4 바이트를 0이 포함 된 각 버퍼를 포함 합니다.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> 속성을 함께 <xref:System.Messaging.Message.SenderCertificate%2A> 속성에는 또한 커넥터 응용 프로그램에서 메시지를 보낼 때. 이 시나리오에서는 커넥터 응용 프로그램-메시지 큐가 아닌-메시지를 보내는 사용자의 인증서를 기반는 디지털 서명을 생성 합니다.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> 속성에는 최대 배열 크기는 256 자입니다.  
  
 설정 하는 경우는 <xref:System.Messaging.Message.DigitalSignature%2A> 속성을 설정 해야는 <xref:System.Messaging.Message.ConnectorType%2A> 속성입니다. 메시지를 보낼 때 무시 메시지 큐는 <xref:System.Messaging.Message.DigitalSignature%2A> 속성 경우는 <xref:System.Messaging.Message.ConnectorType%2A> 에서도 속성이 설정 되지 않은 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.DigitalSignature" /> property.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.DigitalSignature" /> property is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the encryption algorithm used to encrypt the body of a private message.</summary>
        <value>
          <see cref="T:System.Messaging.EncryptionAlgorithm" /> 열거형 값 중 하나입니다. 기본값은 <see langword="RC2" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지의 경우 개인 (암호화 됨)를 보내고 받을 때 암호가 해독 하기 전에 암호화 됩니다. <xref:System.Messaging.Message.EncryptionAlgorithm%2A> 속성 개인 메시지의 메시지 본문을 암호화 하는 데 사용 하는 알고리즘을 지정 합니다.  
  
 큐에서는 들어오는 메시지를 암호화할 수 있습니다. 응용 프로그램 개인 메시지만 허용 하는 큐에 암호화 되지 않은 (private이 아닌) 메시지를 보냅니다. private이 아닌 메시지만 허용 하는 개인 메시지 큐에 보내는 경우, 큐에서 메시지를 거부 합니다. 보내는 응용 프로그램 부정 승인 메시지 이런 경우에서 반환 되도록 요청할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.EncryptionAlgorithm" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets additional, application-defined information associated with the message.</summary>
        <value>메시지와 관련 된 응용 프로그램 정의 정보를 제공 하는 바이트 값의 배열입니다. 기본값은 빈 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A> 속성은 메시지와 연결 된 큰 이진 개체와 같은 응용 프로그램 정의 정보를 제공 합니다. 내용을 해석 하는 수신 응용 프로그램 작업은는 <xref:System.Messaging.Message.Extension%2A> 속성입니다.  
  
 가능한 경우, 메시지 데이터를 포함 해야는 <xref:System.Messaging.Message.Body%2A> 메시지의 속성 보다는 <xref:System.Messaging.Message.Extension%2A> 속성입니다.  
  
 사용 하 여 외부 큐를 사용할 때의 <xref:System.Messaging.Message.Extension%2A> 속성을 통해 메시지 큐에 존재 하지 않는 메시지 속성을 지정 합니다.  
  
 외부 큐 Microsoft 메시지 큐가 아닌 큐 시스템에 존재합니다. 메시지 큐는 커넥터 응용 프로그램을 통해 이러한 큐와 통신합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Extension" /> property.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.Extension" /> property is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the formatter used to serialize an object into or deserialize an object from the message body.</summary>
        <value>
          <see cref="T:System.Messaging.IMessageFormatter" /> 에 기록 하거나 메시지 본문에서 읽을 수 스트림을 만드는입니다. 기본값은 <see cref="T:System.Messaging.XmlMessageFormatter" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Messaging.Message.Formatter%2A> 읽고 메시지를 쓸 때 속성입니다. 포맷터가 serialize 큐로 메시지를 보낼 때의 <xref:System.Messaging.Message.Body%2A> 메시지 큐로 보낼 수 있는 스트림으로 속성입니다. 포맷터는 메시지 데이터를 큐에서 읽을 때의 <xref:System.Messaging.Message.Body%2A> 속성입니다.  
  
 메시지의 내용을 직접 작성 하지 않는 경우는 <xref:System.Messaging.Message.BodyStream%2A> 속성 설정에서 <xref:System.Messaging.Message.Formatter%2A> 메시지를 보내기 전에 속성입니다. 경우는 <xref:System.Messaging.MessageQueue.Send%2A> 메서드가 호출 되는 <xref:System.Messaging.MessageQueue> 인스턴스가, 본문에 포함 된 포맷터를 사용 하 여 serialize 되는 <xref:System.Messaging.Message.Formatter%2A> 속성입니다. 에 대 한 값을 지정 하지 않고 메시지를 보내기는 <xref:System.Messaging.Message.Formatter%2A> 속성, 포맷터의 기본값은 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 <xref:System.Messaging.XmlMessageFormatter> 는 느슨하게 결합 되어 있으므로이 형식을 사용 하는 경우에 발신자와 수신자 입력 동일한 개체를 설정할 필요가 없습니다. <xref:System.Messaging.ActiveXMessageFormatter> 및 <xref:System.Messaging.BinaryMessageFormatter> 이진 표현으로 데이터를 직렬화 합니다. <xref:System.Messaging.ActiveXMessageFormatter> COM 구성 요소를 받거나 보낼 때 사용 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 서식을 사용 하 여 메시지 본문을 보여 줍니다. <xref:System.Messaging.BinaryMessageFormatter>합니다.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 다음 코드 예제에서는 서식을 사용 하 여 메시지 본문을 보여 줍니다. <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.Message.Formatter" /> property is <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the hashing algorithm that Message Queuing uses when authenticating a message or creating a digital signature for a message.</summary>
        <value>
          <see cref="T:System.Messaging.HashAlgorithm" /> 열거형 값 중 하나입니다. 기본값은 Windows xp <see langword="SHA" />합니다. 그렇지 않으면 기본값은 <see langword="MD5" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 원본 컴퓨터 메시지 큐는 메시지에 대 한 디지털 서명을 만들 때 해시 알고리즘을 사용 합니다. 대상 큐 관리자는 다음 수신 될 때 메시지를 인증 하 동일한 해시 알고리즘을 사용 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.HashAlgorithm" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the message's identifier.</summary>
        <value>메시지의 고유 식별자를 메시지 큐에서 생성 된입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐는 메시지를 보낼 때 메시지 식별자를 생성 합니다. 식별자는 20 바이트로 구성 하며 두 개의 항목을 포함: 컴퓨터 <xref:System.Guid> 보내는 컴퓨터와 컴퓨터에 메시지에 대 한 고유 식별자입니다. 이 두 항목을 결합하여 네트워크에서 고유한 메시지 식별자를 만듭니다.  
  
 큐에서는 모든 메시지에 대 한 메시지 식별자를 생성 하는 메시지-승인 및 보고 메시지를 포함 합니다. 승인 메시지 원본, 보낸 메시지의 도착 여부에 대 한 응답의 메시지 큐에서 일반적으로 전송 됩니다. 찾을 수 있습니다는 <xref:System.Messaging.Message.Id%2A> 에서 원본 메시지의 속성 값은 <xref:System.Messaging.Message.CorrelationId%2A> 승인 메시지의 속성입니다.  
  
 사용할 수도 있습니다는 <xref:System.Messaging.Message.Id%2A> 응답 큐로 응답 메시지를 보낼 때 속성입니다. 응답 메시지의 원본 메시지의 식별자를 포함 하려면 설정는 <xref:System.Messaging.Message.CorrelationId%2A> 응답 메시지의 속성은 <xref:System.Messaging.Message.Id%2A> 원본 메시지의 속성입니다. 응답 메시지를 읽는 응용 프로그램 원본 메시지를 식별 하는 응답 메시지의 상관 관계 식별자를 유도할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 큐에서 주문을 포함 하는 메시지를 송수신 설정 합니다. 원본 메시지가 도달 하거나이 긍정 승인을 특별히 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Id" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies that no time-out exists.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> 및 <xref:System.Messaging.Message.TimeToReachQueue%2A> 제한 시간을 지정 하는 값이 필요 합니다. 전자의 경우에 대 한 시간 제한은 큐에서 받을 메시지에 허용 된 최대 시간입니다. 후자의 경우 시간 제한은 큐에 도달 하는 메시지에 대 한 허용 되는 시간입니다. 두 경우 모두 다양 한 시간 (초)로 제한 시간을 지정 하거나 사용할 수 있습니다 <xref:System.Messaging.Message.InfiniteTimeout> 제한 시간이 없도록 나타냅니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.Message.InfiniteTimeout> 필드입니다.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the message was the first message sent in a transaction.</summary>
        <value>
          <see langword="true" /> 트랜잭션에서; 보낸 첫 번째 메시지 인지 하는 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 사용 하 여 수신 된 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 메시지가 단일 트랜잭션에서 단일 대기열으로 보낸 첫 번째 메시지 인지를 확인 하려면.  
  
 이 속성이 메시지 큐 버전 2.0에만 사용할 수 이상입니다.  
  
 트랜잭션 경계를 확인 하려면 사용할 수 있습니다는 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 두 개의 다른 속성과 함께 속성: <xref:System.Messaging.Message.IsLastInTransaction%2A> 및 <xref:System.Messaging.Message.TransactionId%2A>합니다. 전자는 트랜잭션에서 보내진 마지막 메시지 인지 여부를 확인 하 고 트랜잭션 식별자를 검색 하 고 후자를 사용 하십시오.  
  
 경우에, 트랜잭션에서 하나의 메시지가 보내집니다는 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 및 <xref:System.Messaging.Message.IsLastInTransaction%2A> 속성은 모두로 설정 됩니다 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.IsFirstInTransaction" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the message was the last message sent in a transaction.</summary>
        <value>
          <see langword="true" /> 메시지가 단일 트랜잭션에서 보내진 마지막 메시지 이면 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 사용 하 여 수신 된 <xref:System.Messaging.Message.IsLastInTransaction%2A> 메시지가 단일 트랜잭션에서 단일 대기열으로 보낸 마지막 메시지 인지를 확인 하려면.  
  
 이 속성이 메시지 큐 버전 2.0에만 사용할 수 이상입니다.  
  
 트랜잭션 경계를 확인 하려면 사용할 수 있습니다는 <xref:System.Messaging.Message.IsLastInTransaction%2A> 두 개의 다른 속성과 함께 속성: <xref:System.Messaging.Message.IsFirstInTransaction%2A> 및 <xref:System.Messaging.Message.TransactionId%2A>합니다. 전자는 트랜잭션에서 보낸 첫 번째 메시지 인지 여부를 확인 하 고 트랜잭션 식별자를 검색 하 고 후자를 사용 하십시오.  
  
 경우에, 트랜잭션에서 하나의 메시지가 보내집니다는 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 및 <xref:System.Messaging.Message.IsLastInTransaction%2A> 속성은 모두로 설정 됩니다 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.IsLastInTransaction%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.IsLastInTransaction" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an application-defined Unicode string that describes the message.</summary>
        <value>메시지의 레이블입니다. 기본값은 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 레이블은 여러 용도로 사용할 수 있습니다. 예를 들어 메시지 레이블을 사용하여 해당 내용을 표시하거나 레이블 값을 기반으로 메시지를 선택적으로 처리할 수 있습니다. 레이블을은 메시지에서 고유할 필요는 없습니다.  
  
 메시지 큐와 메시지 레이블은 읽을 수 있는 용어로 만들어진 메시지나 큐를 식별할 수 있도록 응용 프로그램 정의 값을 나타냅니다. 것은 아무 의미도 메시지 큐 응용 프로그램에 포함 하는 레이블 내용을 해석 하는 응용 프로그램의 책임입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 설정 가져오고 <xref:System.Messaging.Message.Label%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Label" /> property.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introduced in MSMQ 3.0. Gets the message's lookup identifier.</summary>
        <value>메시지 큐에서 생성 되 고 해당 메시지가 있는 큐에 고유한 됩니다는 메시지의 조회 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A> 속성은 메시지의 조회 식별자에 대 한 읽기 전용 액세스를 제공 합니다. MSMQ 3.0에 도입 된 조회 식별자는 메시지 큐에서 생성 되 고 메시지를 큐에 배치 하면 각 메시지에 할당 되는 64 비트 식별자입니다. 조회 식별자는 메시지를 보낼 때 생성 되는 메시지 식별자와 같지 않습니다.  
  
 메시지 큐는 커넥터 및 보내는 큐 시스템에서 생성 된 저널에 배달 못 뿐만 아니라 대상 응용 프로그램에서 생성, 관리 및 보고서 큐를 비롯 한 모든 큐에 배치 된 모든 메시지에 대 한 조회 식별자를 생성 합니다. 즉, 전송 및 메시지 큐 송신 응용 프로그램에서 메시지를 모두 포함 됩니다. 조회 식별자는 큐에 고유 하며 큐 외부에서는 의미가 없습니다.  
  
 여러 대상 큐로 전송 됩니다 또는 메시지의 복사본은 컴퓨터 저널 또는 업무 일지 큐에 저장 하는 경우에 메시지의 각 복사본 각 큐에 배치 된 경우 고유한 조회 식별자에는 됩니다.  
  
 <xref:System.Messaging.Message.LookupId%2A> 속성은 큐에서 검색 된 메시지에서 읽을 수만 있습니다.  
  
 조회 식별자 큐에서 특정 메시지를 읽는 데 사용 됩니다. 메시지의 조회 식별자 확인 되 면 수신 응용 프로그램이 호출할 수는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 또는 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 함수를 해당 메시지에 직접 이동 하 고 보거나 큐의 앞에서 시작 해야 하는 커서와 달리 큐에서 검색 하 고 큐에 끝 방향으로 이동  
  
 큐에 있는 메시지의 조회 식별자를 가져오는 하는 것은 응용 프로그램의 책임입니다. 한 가지 방법을 조회 식별자를 가져올 수는 큐에 배치 될 때 각 메시지의 식별자를 캐시 하는 구성 요소를 호출 하는 대상 큐에 대 한 트리거를 만드는 것입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.LookupId" /> property.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the message type: <see langword="Normal" />, <see langword="Acknowledgment" />, or <see langword="Report" />.</summary>
        <value>
          <see cref="P:System.Messaging.Message.MessageType" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 메시지 큐는 메시지를 보낼 때이 속성을 설정 합니다. 메시지 큐 메시지는 다음 형식 중 하나입니다.  
  
-   `Normal`를 응용 프로그램에서 큐로 보낸 일반 메시지 또는 보내는 응용 프로그램에 응답 메시지를 반환 합니다.  
  
-   `Acknowledgement`메시지 큐는 보내는 응용 프로그램에서 요청할 때마다 생성 됩니다. 예를 들어 메시지 큐는 원본 메시지가 도착하거나 원본 메시지를 읽었다는 것을 나타내는 긍정 또는 부정 메시지를 생성할 수 있습니다. 메시지 큐는 보내는 응용 프로그램이 지정한 관리 큐에 적절한 승인 메시지를 반환합니다.  
  
-   `Report`메시지 큐 보고 큐가 소스 큐 관리자에서 정의 될 때마다 생성 됩니다. 추적 기능이 활성화되어 있으면 원본 메시지가 메시지 큐 서버에 들어가거나 나올 때마다 메시지 큐는 보고서 큐에 보고 메시지를 보냅니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.MessageType%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.MessageType" /> property.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the message priority, which determines where in the queue the message is placed.</summary>
        <value>중 하나는 <see cref="T:System.Messaging.MessagePriority" /> 메시지의 우선 순위 수준을 나타내는 값입니다. 기본값은 <see langword="Normal" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A> 방법을 메시지 큐 메시지를 처리 하 큐 중일 때와 대상에 도달 하는 속성에 영향을 줍니다. 높은 우선 순위의 메시지는 보내는 동안 우선 순위가 부여되고 대상 큐의 앞 부분에 삽입됩니다. 우선 순위가 같은 메시지는 도착 시간에 따라 큐에 배치됩니다.  
  
 트랜잭션이 아닌 메시지에 대 한 우선 순위를 설정할 수 있습니다. 메시지 큐를 트랜잭션 메시지에 대 한 우선 순위를 자동으로 설정 `Lowest`, 이르게 우선 무시 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 서로 다른 우선의 두 메시지를 보내고 큐로 검색 합니다.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Priority" /> property.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the message is guaranteed to be delivered in the event of a computer failure or network problem.</summary>
        <value>
          <see langword="true" /> 메시지 배달 (동안 디스크에 메시지를 저장)를 통해 보장 되는; 경우 <see langword="false" /> 경우 배달이 보장 되지 않습니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Recoverable%2A> 속성 메시지를 배달 보장 되는지 여부를 나타냅니다.-대상 큐에 메시지는 동안 컴퓨터가 충돌 하는 경우에 합니다.  
  
 메시지 배달 보장 되는 경우 메시지는 로컬에 저장 경로 따르는 모든 단계 다음 컴퓨터를 성공적으로 전달 될 때까지. 설정의 <xref:System.Messaging.Message.Recoverable%2A> 속성을 `true` 처리량에 영향을 줄 수 있습니다.  
  
 트랜잭션 된 메시지의 경우 메시지 큐 메시지의 값에 관계 없이 복구할 수 있는 <xref:System.Messaging.Message.Recoverable%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 설정 가져오고 <xref:System.Messaging.Message.Recoverable%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.Recoverable" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the queue that receives application-generated response messages.</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" /> 어떤 응용 프로그램 생성 응답 메시지가 반환 됩니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A> 속성 수신 응용 프로그램이 보내는 응용 프로그램에 반환 되는 응용 프로그램에서 생성 한 응답 메시지를 받는 큐를 식별 합니다. 보내는 응용 프로그램은 메시지를 보낼 때 응답 큐를 지정합니다. 사용 가능한 모든 큐는 응답 큐로 지정할 수 있습니다.  
  
 응답 큐에 반환된 메시지는 응용 프로그램 관련 메시지입니다. 해당 응용 프로그램에서는 메시지의 내용뿐만 아니라 메시지를 받을 때 취할 동작을 정의해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 설정 가져오고 <xref:System.Messaging.Message.ResponseQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.ResponseQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the security context for a message.</summary>
        <value>A <see cref="T:System.Messaging.SecurityContext" /> 속성이 이미 설정 되어 있으면 메시지의 경우 보안 컨텍스트를 포함 하는 개체가; 그렇지 않은 경우 NULL입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the security certificate used to authenticate messages.</summary>
        <value>보안 인증서를 메시지 보낸 사람을 확인을 사용 하 여 메시지 큐를 나타내는 바이트 값의 배열입니다. 기본값은 빈 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 수신 응용 프로그램이 사용 하는 <xref:System.Messaging.Message.SenderCertificate%2A> 메시지에 외부 보안 인증서를 포함 하는 경우이 속성입니다.  
  
 메시지 큐 내부 또는 외부 보안 인증서 중 하나를 사용 하는 메시지를 인증할 수 있습니다. 메시지 큐는 메시지 무결성을 확인 하는 데 사용 되는 내부 인증서를 제공 합니다. 인증 기관을 통해 액세스할 수 있는 외부 인증서를 제공는 <xref:System.Messaging.Message.SenderCertificate%2A> 메시지의 속성입니다. 메시지를 인증할 메시지 큐를 허용 하는 것 외에도 외부 인증서에는 수신 응용 프로그램을 보낸 사람에 게 더 확인 수 있습니다. 내부 인증서에는 수신 응용 프로그램을 사용할 수 있는 값 없음.  
  
 메시지 큐 시스템의 디렉터리 서비스를 사용 하는 외부 인증서를 등록 합니다. 외부 인증서는 인증 기관, 인증서 사용자, 인증서의 유효 기간, 인증서 사용자 및 인증 기관의 서명 공개 키에 대 한 정보를 포함합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.SenderCertificate" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the identifier of the sending user.</summary>
        <value>보낸 사람을 식별 하는 바이트 값의 배열입니다. 수신 큐 관리자 식별자를 사용 하 여 메시지와 큐에 대 한 액세스 권한을 보낸 사람의의 보낸 사람에 게 확인 메시지를 인증 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Messaging.Message.AttachSenderId%2A> 속성은 `false`에 지정 된 보낸 사람 식별자는 <xref:System.Messaging.Message.SenderId%2A> 전송 될 때 메시지에 속성 연결 되지 않습니다. 표시 메시지 큐 대상 큐로 메시지를 보낼 때 보낸 사람에 게 확인 하지 않음이 됩니다. 경우는 <xref:System.Messaging.Message.AttachSenderId%2A> 속성은 `true`, <xref:System.Messaging.Message.SenderId%2A> 속성 값은 메시지가 인증 된 경우에 신뢰할 수 있습니다. 사용 하 여는 <xref:System.Messaging.Message.Authenticated%2A> 속성과 함께 <xref:System.Messaging.Message.SenderId%2A> 보낸 사람의 액세스 권한을 확인 하는 속성입니다.  
  
 커넥터 응용 프로그램은 메시지 큐와 큐 다른 시스템 간의 통신을 제공 하려면 커넥터 서버를 사용 하는 응용 프로그램. 메시지 큐는 보낸 사람 id를 제공 하려면 커넥터 응용 프로그램을 필요 합니다. 설정 해야 합니다는 <xref:System.Messaging.Message.ConnectorType%2A> 커넥터 응용 프로그램을 통해 메시지를 보낼 때 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.SenderId" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the version of Message Queuing used to send the message.</summary>
        <value>메시지 큐 메시지를 보내는 데의 버전입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A> 속성은 특정 기능에 대 한 중요 합니다. 예를 들어 메시지 큐 2.0에 의해서만 이상 버전에서는 트랜잭션 처리는 지원 및 디지털 서명을 MSMQ 1.0에서 보낸 메시지를 인증 하는 데 사용 됩니다.  
  
 보내는 큐 관리자 집합에서 <xref:System.Messaging.Message.SenderVersion%2A> 속성은 메시지를 보낼 때.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.SenderVersion%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.SenderVersion" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the date and time on the sending computer that the message was sent by the source queue manager.</summary>
        <value>A <see cref="T:System.DateTime" /> 메시지를 보낸 시간을 나타내는입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SentTime%2A> 속성은이 컴퓨터의 현지 시간으로 조정의 인스턴스는 <xref:System.Messaging.Message> 클래스 생성 합니다. 이 표준 시간대는 원본 및 대상 큐의에서 다를 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.SentTime%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.SentTime" /> property.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the computer from which the message originated.</summary>
        <value>메시지를 보낸 컴퓨터의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식은 <xref:System.Messaging.Message.SourceMachine%2A> 속성 앞에 두 개의 슬래시를 포함 하지 않습니다 (\\\\). 예를 들어 `myServer` 유효한 <xref:System.Messaging.Message.SourceMachine%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.SourceMachine%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.SourceMachine" /> property.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The computer information or directory service could not be accessed.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum amount of time for the message to be received from the destination queue.</summary>
        <value>대상 큐 로부터 받이 보낸된 메시지에 대 한 총 시간입니다. 기본값은 <see cref="F:System.Messaging.Message.InfiniteTimeout" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성은 보낸된 메시지를 대상 큐에서 받을 수에 대 한 총 시간을 지정 합니다. 제한 시간 대상 큐 및 메시지를 받기 전에 큐에서 대기 하는 데 걸린 시간을 검색 하는 데 걸린 시간을 포함 합니다.  
  
> [!CAUTION]
>  종속 클라이언트 컴퓨터를 사용할 때 클라이언트 컴퓨터에 있는 시계가 메시지 큐를 실행 하는 서버에 시계와 동기화 해야 합니다. 메시지를 보낼 때 예기치 않은 동작이 발생할 수 있습니다는 그렇지 않은 경우 해당 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성은 <xref:System.Messaging.Message.InfiniteTimeout>합니다.  
  
 으로 지정한 간격이 하는 경우는 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성에는 메시지 큐에서 제거 되기 전에 만료 되 면 메시지 큐 메시지에 두 가지 방법 중 하나를 삭제 합니다. 메시지의 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성이 `true`이면 배달 못 한 편지 큐로 메시지가 보내집니다. 경우 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 은 `false`, 메시지는 무시 됩니다.  
  
 메시지의 설정할 수 있습니다 <xref:System.Messaging.Message.AcknowledgeType%2A> 타이머가 만료 되기 전에 메시지가 검색 되지 않으면 메시지를 보내도록 메시지 큐는 부정 승인에 속성을 보내는 응용 프로그램을 다시 합니다.  
  
 지정 된 값의 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성을 사용 하면 지정 된 값 보다 작으면는 <xref:System.Messaging.Message.TimeToReachQueue%2A> 속성을 <xref:System.Messaging.Message.TimeToBeReceived%2A> 우선적으로 적용 합니다.  
  
 단일 트랜잭션 내에서 여러 메시지를 보내면 메시지 큐에서 사용 하 여 <xref:System.Messaging.Message.TimeToBeReceived%2A> 첫 번째 메시지의 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 설정 가져오고 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.TimeToBeReceived" /> property.</exception>
        <exception cref="T:System.ArgumentException">The value specified for <see cref="P:System.Messaging.Message.TimeToBeReceived" /> is invalid.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum amount of time for the message to reach the queue.</summary>
        <value>대상 큐에 도달 하는 메시지에 대 한 제한 시간 메시지 시간부터 시작 보내집니다. 기본값은 <see cref="F:System.Messaging.Message.InfiniteTimeout" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 으로 지정한 간격이 하는 경우는 <xref:System.Messaging.Message.TimeToReachQueue%2A> 메시지가 대상에 도달 하기 전에 속성 만료, 메시지 큐 메시지에 두 가지 방법 중 하나를 삭제 합니다. 메시지의 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성이 `true`이면 배달 못 한 편지 큐로 메시지가 보내집니다. 경우 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 은 `false`, 메시지는 무시 됩니다.  
  
 메시지의 설정할 수 있습니다 <xref:System.Messaging.Message.AcknowledgeType%2A> 타이머가 만료 되기 전에 메시지가 도착 하지 않으면 송신 응용 프로그램에 메시지를 보내도록 메시지 큐는 부정 승인에 속성을 다시 합니다.  
  
 경우는 <xref:System.Messaging.Message.TimeToReachQueue%2A> 속성이 0 초로 설정 되어 있으면 한 번만 대상으로 메시지를 보내려고 시도 메시지 큐-큐 대기 하는 메시지에 대 한 경우. 큐가 로컬 이면 메시지가 항상 큐에 도달 합니다.  
  
 지정 된 값은 <xref:System.Messaging.Message.TimeToReachQueue%2A> 속성이 지정 된 값 보다 크면는 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성을 <xref:System.Messaging.Message.TimeToBeReceived%2A> 우선적으로 적용 합니다.  
  
 단일 트랜잭션 내에서 여러 메시지를 보내면 메시지 큐에서 사용 하 여 <xref:System.Messaging.Message.TimeToReachQueue%2A> 첫 번째 메시지의 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 설정 가져오고 <xref:System.Messaging.Message.TimeToReachQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.TimeToReachQueue" /> property.</exception>
        <exception cref="T:System.ArgumentException">The value specified for <see cref="P:System.Messaging.Message.TimeToReachQueue" /> is invalid. It might represent a negative number.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the identifier for the transaction of which the message was a part.</summary>
        <value>메시지에 연결 된 트랜잭션에 대 한 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 사용을 받기는 <xref:System.Messaging.Message.TransactionId%2A> 속성을 특정 트랜잭션의 일부로 보낸 메시지를 확인 합니다. 트랜잭션 식별자 뒤에 4 바이트 트랜잭션 시퀀스 번호를 보내는 컴퓨터 (첫 번째 16 비트)의 식별자를 포함 합니다.  
  
 이 속성이 메시지 큐 버전 2.0에만 사용할 수 이상입니다.  
  
 트랜잭션 식별자 없기 때문에 트랜잭션 시퀀스 번호 영구적으로 2에서 다시 시작은 고유 해야 하는데, 보장 되지 <sup>20</sup>합니다. 메시지 큐 보장만 후속 트랜잭션에서 다른 트랜잭션 시퀀스 번호를 포함 합니다.  
  
 사용할 수 있습니다는 <xref:System.Messaging.Message.TransactionId%2A> 와 함께 속성은 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 및 <xref:System.Messaging.Message.IsLastInTransaction%2A> 속성을 트랜잭션 경계를 확인 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.TransactionId%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.TransactionId" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the transaction status queue on the source computer.</summary>
        <value>보내는 응용 프로그램에 다시 확인 메시지를 보내는 데 사용 되는 원본 컴퓨터에서 트랜잭션 상태 큐입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A> 속성 커넥터 응용 프로그램에서 읽기 수신 확인을 수신 하는 원본 컴퓨터의 한 트랜잭션 큐를 식별 합니다. 메시지 큐 속성을 설정 하 고 커넥터 응용 프로그램 외부 큐로 보낸 트랜잭션 메시지를 검색할 때 속성을 사용 합니다.  
  
 외부 큐 Microsoft 메시지 큐가 아닌 큐 시스템에 존재합니다. 메시지 큐는 커넥터 응용 프로그램을 통해 이러한 큐와 통신합니다.  
  
 커넥터 응용 프로그램의 트랜잭션 상태 큐를 사용 하는 승인 메시지를 보내는 응용 프로그램 다시 전송할 수 있습니다. 트랜잭션 상태 큐는 보내는 응용 프로그램에 다른 승인을 요청 하지 않을 경우에이 승인을 받아야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.TransactionStatusQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message has not been sent. This property can only be read on messages retrieved from a queue.  -or-  The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.TransactionStatusQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the message was (or must be) authenticated before being sent.</summary>
        <value>
          <see langword="true" /> 보내는 응용 프로그램에서 메시지에 대 한 인증을 요청 하는 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A> 속성 메시지를 인증 해야 하는지 여부를 지정 합니다. 보내는 응용 프로그램에서 인증을 요청 하는 경우 메시지 큐 디지털 서명을 만들고 사용 하 여 전송 될 때 메시지에 서명 하는 메시지를 받을 때 인증 합니다.  
  
 경우 <xref:System.Messaging.Message.UseAuthentication%2A> 은 `false` 및 인증 된 메시지만 허용 하는 큐에 메시지, 메시지 큐에 도달 하면 거부 됩니다.  
  
 메시지가 해당 속성을 확인 하 여 인증 실패를 확인할 수 없습니다. 큐에 메시지가 배달 되기 전에 메시지 큐에서 그러한 메시지를 삭제 합니다. 그러나 배달이 실패 하면 메시지가 메시지 큐에 도착는 것을 방지 한 경우 승인 메시지를 보내도록 요청할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.UseAuthentication" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a copy of the message that could not be delivered should be sent to a dead-letter queue.</summary>
        <value>
          <see langword="true" /> 메시지 배달 실패는 배달 못 한 편지 큐로 송신할 메시지의 복사본에 있는 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A> 및 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성을 메시지 큐 메시지를 추적 하는 방법을 지정 합니다. 경우 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 은 `true`, 배달이 실패 (트랜잭션이 아닌 메시지의 경우) 하면 메시지가 메시지를 배달 하지 못한 컴퓨터에 대 한 비트랜잭션 배달 못 한 편지 큐로 보낼 수 있습니다. 배달이 실패 메시지 타이머가 만료 되는 경우 예를 들어 것일 수도 있습니다.  
  
 트랜잭션 메시지를 배달 하지 못한 경우 메시지 큐 음수 트랜잭션과 미결 항상에서 원본 컴퓨터 트랜잭션 배달 못 한 편지 큐로 메시지를 보냅니다.  
  
 배달 못 한 편지 큐에 메시지를 저장할 때 더 이상 필요 없는 메시지를 제거 하는 정기적으로 큐를 지워야 합니다. 메시지 큐가 있는 컴퓨터에 대 한 크기 할당량에 대해 배달 못 한 편지 큐 수에 저장 합니다. 컴퓨터 할당량 관리자가 설정 되 고 단일 큐에서 뿐 아니라 전체 컴퓨터에 메시지 저장을 위해 할당 된 크기를 나타냅니다.  
  
 저널 또는 배달 못 한 편지 큐를 만들지 않습니다. 다음은 메시지 큐가 생성 하는 두 시스템 큐입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 설정 가져오고 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.UseDeadLetterQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to make the message private.</summary>
        <value>
          <see langword="true" /> 메시지 큐에서 메시지를 암호화를 요구 하도록 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 개인 메시지의 경우 전송 되 고 수신 될 때 암호를 해독 하기 전에 해당 본문이 암호화 되어 있습니다. 개인 메시지를 보내려면 보내는 응용 프로그램에서 암호화를 사용 하도록 지정 해야 하 고, 필요에 따라 암호화 알고리즘입니다.  
  
 개인 메시지를 보내는 경우 응용 프로그램 메시지 암호화를 수행 하지 않아도 됩니다. 메시지 큐는 응용 프로그램 디렉터리 서비스에 대 한 액세스 권한이 있는 Microsoft Windows 2000 엔터프라이즈 환경 내에서 메시지를 보내는 경우 메시지 본문을 암호화할 수 있습니다. 개인 메시지를 받을 수신 큐 관리자는 항상 메시지 본문에 암호 해독 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 설정 가져오고 <xref:System.Messaging.Message.UseEncryption%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.UseEncryption" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a copy of the message should be kept in a machine journal on the originating computer.</summary>
        <value>
          <see langword="true" /> 메시지 이후에 원래 컴퓨터의 컴퓨터 업무 일지에 메시지의 복사본을 보관 될 요청을 전송한 다음 서버에 원래 컴퓨터) (에서; 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A> 및 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성을 메시지 큐 메시지를 추적 하는 방법을 지정 합니다. 경우 <xref:System.Messaging.Message.UseJournalQueue%2A> 은 `true`, 복사본은 메시지가 전송 되는 각 단계에서 원래 컴퓨터의 컴퓨터 저널에 보관 합니다.  
  
 보낸된 메시지가 대상 큐가 원격 컴퓨터에 있는 경우에 업무 일지 큐에 복사 됩니다. 메시지가 큐에 직접 보내집니다 대상이 로컬 컴퓨터에 있으면 저널링을 요구 하도록 중간 단계가 있습니다.  
  
 업무 일지 큐에 메시지를 저장할 때 더 이상 필요 없는 메시지를 제거 하는 정기적으로 큐의 선택을 취소 합니다. 메시지 큐가 있는 컴퓨터에 대 한 할당량에 대 한 업무 일지 큐 수에 저장 합니다. (컴퓨터 할당량 관리자가 설정 됩니다.)  
  
 저널 또는 배달 못 한 편지 큐를 만들지 않습니다. 다음은 메시지 큐가 생성 하는 두 시스템 큐입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 설정 가져오고 <xref:System.Messaging.Message.UseJournalQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.UseJournalQueue" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to trace a message as it moves toward its destination queue.</summary>
        <value>
          <see langword="true" /> 시스템의 보고서 큐로 보낼 보고서를 생성 하는 각 중간 단계를 대상 큐로 전달 되는 도중에 원본 메시지를 수행한 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A> 속성 대상 큐로 이동할 때 메시지의 경로 추적 여부를 지정 합니다. 경우 `true`, 보고 메시지 (메시지 큐에서 생성)은 라우팅 메시지 큐 서버를 통해 메시지가 전달 될 때마다 보고서 큐로 전송 합니다. 보고서 큐 소스 큐 관리자에서 지정 됩니다. 보고서 큐에서 메시지 큐; 생성 된 메시지를 보고 하려면 제한 되지 않습니다. 보고서 큐로 프로그램 응용 프로그램에서 생성 된 메시지를 보낼 수도 있습니다.  
  
 추적을 사용 하 여 Active Directory 설정 하 고 메시지 큐 엔터프라이즈에 대 한 보고서 큐를 지정 해야 합니다. 관리자가 이러한 설정을 구성합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 설정 가져오고 <xref:System.Messaging.Message.UseTracing%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The message queue is filtered to ignore the <see cref="P:System.Messaging.Message.UseTracing" /> property.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>