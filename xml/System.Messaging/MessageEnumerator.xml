<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6a3039a11d941cd3db611cb997eb17835525e4da" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="04179-101">메시지 큐의 메시지를 열거하는 정방향 전용 커서를 제공합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="04179-101">Provides a forward-only cursor to enumerate through messages in a message queue.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-102">사용 하 여 <xref:System.Messaging.MessageEnumerator> 큐에 메시지와 함께 동적 상호 작용 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-102">Use <xref:System.Messaging.MessageEnumerator> for dynamic interaction with messages in a queue.</span></span> <span data-ttu-id="04179-103">통해 사용할 수 있는 메서드는 <xref:System.Messaging.MessageQueue> 클래스 중 하나를 반환할 수는 <xref:System.Messaging.MessageEnumerator> 호출 된 지정된 된 메서드를 큐 또는 시간에 큐의 특정된 시점 스냅숏에 복사본을 포함 하는 배열에 있는 메시지의 동적 목록을 가리키는 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-103">Methods available through the <xref:System.Messaging.MessageQueue> class can return either a <xref:System.Messaging.MessageEnumerator> pointing to a dynamic list of messages in the queue, or an array that contains a copy at a given instant - a snapshot - of the queue at the time the specified method was called.</span></span>  
  
 <span data-ttu-id="04179-104">정적 스냅샷 달리는 열거자를 사용 하면 해당 컬렉션을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-104">Unlike a static snapshot, an enumerator allows you to modify the collection.</span></span> <span data-ttu-id="04179-105">사용 하는 <xref:System.Messaging.MessageEnumerator>큐에서 메시지를 제거 하 고 변경 내용을 큐에 즉시 반영 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04179-105">Using a <xref:System.Messaging.MessageEnumerator>, you can remove messages from the queue, and the change is immediately reflected in the queue.</span></span>  
  
 <span data-ttu-id="04179-106">열거자는 큐를 쿼리할 때 메시지 큐에서 제거 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-106">An enumerator does not remove the messages from the queue when it queries the queue.</span></span> <span data-ttu-id="04179-107">현재 커서 위치에 메시지에 대 한 정보를 반환 하지만 해당 메시지를 큐에 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-107">It returns information about the message at the current cursor position, but it leaves the message in the queue.</span></span>  
  
 <span data-ttu-id="04179-108">A <xref:System.Messaging.MessageEnumerator> 는 목록 헤드를 동적으로 초기화 하는 커서입니다.</span><span class="sxs-lookup"><span data-stu-id="04179-108">A <xref:System.Messaging.MessageEnumerator> is a cursor, initialized to the head of a dynamic list.</span></span> <span data-ttu-id="04179-109">목록 순서가 큐에서 메시지의 순서와 동일 메시지의 우선 순위에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-109">The list order is the same as the order of the messages in the queue, according to message priority.</span></span> <span data-ttu-id="04179-110">큐의 첫 번째 메시지를 호출 하 여 커서를 이동할 수 <xref:System.Messaging.MessageEnumerator.MoveNext%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-110">You can move the cursor to the first message in the queue by calling <xref:System.Messaging.MessageEnumerator.MoveNext%2A>.</span></span> <span data-ttu-id="04179-111">열거자가 초기화 된 후 사용할 수 있습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 나머지 메시지 앞으로 단계별로 실행 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-111">After the enumerator has been initialized, you can use <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to step forward through the remaining messages.</span></span> <span data-ttu-id="04179-112">제한 시간을 전달 하 여 사용할 수 있게 하는 메시지를 기다리는 여부를 지정할 수는 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="04179-112">You can specify whether to wait for a message to become available by passing a timeout into the <xref:System.Messaging.MessageEnumerator.MoveNext%2A> method.</span></span>  
  
 <span data-ttu-id="04179-113">열거자는 동적 커서의 현재 위치 (예를 들어 때문에 낮은 우선 순위) 뒤에 추가 된 메시지 열거자가 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-113">Because the enumerator is dynamic, a message that is appended beyond the cursor's current position (for example, due to low priority), can be accessed by the enumerator.</span></span> <span data-ttu-id="04179-114">커서의 현재 위치에 액세스할 수 없습니다 전에 삽입 되는 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="04179-114">A message that is inserted before the cursor's current position cannot be accessed.</span></span> <span data-ttu-id="04179-115">여 뒤로 이동 불가능 한 <xref:System.Messaging.MessageEnumerator>합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-115">It is not possible to step backward with a <xref:System.Messaging.MessageEnumerator>.</span></span> <span data-ttu-id="04179-116">커서 앞 으로만 이동 가능한 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-116">A cursor allows forward-only movement.</span></span> <span data-ttu-id="04179-117"><xref:System.Messaging.MessageEnumerator.Reset%2A> 메서드를 사용 하면 큐의 시작 부분에서 다시 커서에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-117">The <xref:System.Messaging.MessageEnumerator.Reset%2A> method enables you to place the cursor back at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="04179-118">인스턴스 <xref:System.Messaging.MessageEnumerator> 특정된 큐에 대 한 독립적으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-118">Instances of <xref:System.Messaging.MessageEnumerator> for a given queue work independently.</span></span> <span data-ttu-id="04179-119">두 개를 만든 <xref:System.Messaging.MessageEnumerator> 동일한 큐에 적용 되는 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="04179-119">You can create two <xref:System.Messaging.MessageEnumerator> instances that apply to the same queue.</span></span> <span data-ttu-id="04179-120">변경 내용을 하나 <xref:System.Messaging.MessageEnumerator> 큐에서 메시지를 위한 즉시 반영 됩니다에 두 번째 열거자가 첫 번째 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="04179-120">The changes that one <xref:System.Messaging.MessageEnumerator> makes to the messages in the queue will be reflected immediately in a second enumerator if the second enumerator is positioned before the first.</span></span> <span data-ttu-id="04179-121">그러나 두 열거자는 동일한 위치 하는 경우 해당 위치에서 메시지를 제거 중 예외가 throw 됩니다 다른 열거자의 값을 가져오려고 시도 하는 경우는 <xref:System.Messaging.MessageEnumerator.Current%2A> 방금 삭제 메시지의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="04179-121">However, if two enumerators have the same position and one of them removes the message at that position, an exception is thrown if the other enumerator attempts to get the value of the <xref:System.Messaging.MessageEnumerator.Current%2A> property on the now-deleted message.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04179-122">인스턴스를 만들 경우 <xref:System.Messaging.MessageQueue> 와 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> 로 설정 `true`, 큐에 연결 해야 하는 동안 다른 응용 프로그램에서 해당 열거형의에서 메시지를 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-122">If you create an instance of <xref:System.Messaging.MessageQueue> with <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> set to `true`, no other application can modify the messages in your enumerator while you have the connection to the queue.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04179-123">다음 예제에서는 큐에 있는 메시지의 동적 목록을 가져오고 있는 모든 메시지가 계산 된 <xref:System.Messaging.Message.Priority%2A> 속성이로 설정 <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-123">The following example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="04179-124">해당 열거자와 관련된 리소스를 삭제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-124">Frees the resources associated with the enumerator.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-125">운영 체제는 큐에 대해 열린 핸들이 커서의 수명 동안 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-125">The operating system retains an open handle to the queue during the lifetime of the cursor.</span></span> <span data-ttu-id="04179-126">에서는 열거자와 함께 작업을 완료 하면, 호출 <xref:System.Messaging.MessageEnumerator.Close%2A> 핸들에 연결 된 리소스를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-126">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release the resources associated with the handle.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="04179-127">이 열거자가 가리키는 현재 <see cref="T:System.Messaging.Message" />를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-127">Gets the current <see cref="T:System.Messaging.Message" /> that this enumerator points to.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="04179-128">현재 메시지입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-128">The current message.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-129">열거자를 만들 때 첫 번째 메시지 앞에 큐의 시작 부분을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="04179-129">When the enumerator is created, it points to the head of the queue, at a location before the first message.</span></span> <span data-ttu-id="04179-130">이 경우 <xref:System.Messaging.MessageEnumerator.Current%2A> 올바르지 않으며 액세스 하는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04179-130">In this case, <xref:System.Messaging.MessageEnumerator.Current%2A> is not valid and will throw an exception if it is accessed.</span></span> <span data-ttu-id="04179-131">호출 해야 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 큐의 첫 번째 메시지에 커서를 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-131">You must call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to position the cursor at the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="04179-132">
            <see cref="P:System.Messaging.MessageEnumerator.Current" />를 처음 호출하기 전에 <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />를 호출하여</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-132">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> before the first call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />.</span>
          </span>
          <span data-ttu-id="04179-133">즉, 커서가 메시지 열거형의 첫 번째 요소 앞에 배치된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-133">The cursor is located before the first element of the message enumeration.</span>
          </span>
          <span data-ttu-id="04179-134">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-134">-or-</span>
          </span>
          <span data-ttu-id="04179-135">
            <see cref="P:System.Messaging.MessageEnumerator.Current" />를 호출하여 <see langword="false" />를 반환한 후에 <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />를 호출한 경우(커서가 메시지 열거형의 마지막 요소 뒤에 배치됨을 나타냄)</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-135">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> after a call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> had returned <see langword="false" /> (indicating the cursor is located after the last element of the message enumeration.)</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="04179-136">열거자가 현재 가리키고 있는 메시지가 더 이상 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-136">The message the enumerator is currently pointing to no longer exists.</span>
          </span>
          <span data-ttu-id="04179-137">삭제되었을 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-137">It might have been deleted.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="04179-138">큐에서 메시지를 찾는 데 사용되는 네이티브 메시지 큐 커서 핸들을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-138">Gets the native Message Queuing cursor handle used to browse messages in the queue.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="04179-139">기본 커서 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-139">The native cursor handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-140">이 속성을 열거형에 대 한 기본 핸들을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-140">This property contains the native handle to the enumeration.</span></span> <span data-ttu-id="04179-141">에서는 열거자와 함께 작업을 완료 하면, 호출 <xref:System.Messaging.MessageEnumerator.Close%2A> 이 리소스를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-141">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release this resource.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="04179-142">핸들이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-142">The handle does not exist.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="04179-143">
            <see cref="T:System.Messaging.MessageEnumerator" />에서 사용하는 리소스를 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-143">Releases the resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="04179-144">
            <see cref="T:System.Messaging.MessageEnumerator" />에서 사용하는 모든 리소스를 해제합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-144">Releases all resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-145">호출 <xref:System.Messaging.MessageEnumerator.Dispose%2A> 에서 사용 하는 리소스는 <xref:System.Messaging.MessageEnumerator> 다른 용도에 다시 할당 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-145">Calling <xref:System.Messaging.MessageEnumerator.Dispose%2A> allows the resources used by the <xref:System.Messaging.MessageEnumerator> to be reallocated for other purposes.</span></span> <span data-ttu-id="04179-146">에 대 한 자세한 내용은 <xref:System.Messaging.MessageEnumerator.Dispose%2A>, 참조 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-146">For more information about <xref:System.Messaging.MessageEnumerator.Dispose%2A>, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="04179-147">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-147">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="04179-148">
            <see cref="T:System.Messaging.MessageEnumerator" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-148">Releases the unmanaged resources used by the <see cref="T:System.Messaging.MessageEnumerator" /> and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-149">이 메서드는 public <xref:System.Messaging.MessageEnumerator.Dispose%2A> 메서드 및 <xref:System.Object.Finalize%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="04179-149">This method is called by the public <xref:System.Messaging.MessageEnumerator.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="04179-150">`Dispose()` 보호 된 호출 `Dispose(Boolean)` 메서드는 `disposing` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-150">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="04179-151"><xref:System.Object.Finalize%2A> 호출 `Dispose` 와 `disposing` 로 설정 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-151"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="04179-152">`disposing` 매개 변수가 `true`인 경우 이 메서드는 이 <xref:System.Messaging.MessageEnumerator>에서 참조하는 관리 개체가 보유하고 있는 리소스를 모두 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-152">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Messaging.MessageEnumerator> references.</span></span> <span data-ttu-id="04179-153">이 메서드는 참조되는 각 개체의 `Dispose()` 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-153">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="04179-154">
              <see langword="Dispose" />는 다른 개체에서 여러 번 호출할 수 있습니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="04179-154">
                <see langword="Dispose" /> can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="04179-155">
              <see langword="Dispose(Boolean)" />를 재정의할 때 이전 <see langword="Dispose" /> 호출에서 삭제된 개체를 참조하지 않도록 주의하십시오.</span>
            <span class="sxs-lookup">
              <span data-stu-id="04179-155">When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span>
            </span>
            <span data-ttu-id="04179-156">구현 하는 방법에 대 한 자세한 내용은 <see langword="Dispose" />, 참조 [Dispose 메서드를 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="04179-156">For more information about how to implement <see langword="Dispose" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            </span>
            <span data-ttu-id="04179-157">에 대 한 자세한 내용은 <see langword="Dispose" /> 및 <see langword="Finalize" />, 참조 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md) 및 [Finalize 메서드를 재정의](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)합니다.</span>
            <span class="sxs-lookup">
              <span data-stu-id="04179-157">For more information about <see langword="Dispose" /> and <see langword="Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="04179-158">열거자를 큐의 다음 메시지로 이동합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-158">Advances the enumerator to the next message in the queue.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="04179-159">가능한 경우 열거자를 큐의 다음 메시지로 이동합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-159">Advances the enumerator to the next message in the queue, if one is currently available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="04179-160">열거자가 다음 메시지로 이동하면 <see langword="true" />를 반환하고, 큐의 끝에 도달하면 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-160">
              <see langword="true" /> if the enumerator was succesfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-161">이 오버 로드는 큐에 메시지가 없는 경우 즉시 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04179-161">This overload returns immediately if there is no message in the queue.</span></span> <span data-ttu-id="04179-162">지정 된 대기 하는 다른 오버 로드는 <xref:System.TimeSpan> 메시지 도착에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-162">There is another overload that waits a specified <xref:System.TimeSpan> for a message to arrive.</span></span>  
  
 <span data-ttu-id="04179-163">큐가 비어 있거나는 컬렉션의 마지막 요소를 뒤로 이동 했기 때문에 메시지를 현재 사용할 수 없는 경우 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 반환 `false` 호출 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="04179-163">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> returns `false` to the calling method.</span></span>  
  
 <span data-ttu-id="04179-164">만들어지면 열거자는 일반적으로 배치 된 큐 및 첫 번째 호출의 첫 번째 메시지 앞 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 뷰로 큐의 첫 번째 메시지를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04179-164">Upon creation, an enumerator is conceptually positioned before the first message of the queue, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the queue into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="04179-165">메시지 큐에 대한 특정 예외가 throw된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-165">An exception specific to Message Queuing was thrown.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="04179-166">열거자가 큐의 끝에 배치되는 경우 메시지를 사용할 수 있을 때까지 대기하는 <see cref="T:System.TimeSpan" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-166">The <see cref="T:System.TimeSpan" /> to wait for a message to be available if the enumerator is positioned at the end of the queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="04179-167">열거자를 큐의 다음 메시지로 이동합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-167">Advances the enumerator to the next message in the queue.</span>
          </span>
          <span data-ttu-id="04179-168">열거자가 큐의 끝에 배치되는 경우 <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />는 메시지를 사용할 수 있거나 지정된 제한 시간이 만료될 때까지 대기합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-168">If the enumerator is positioned at the end of the queue, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> waits until a message is available or the given timeout expires.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="04179-169">열거자가 다음 메시지로 이동하면 <see langword="true" />를 반환하고, 해당 열거자가 큐의 끝에 도달하고 <paramref name="timeout" /> 매개 변수에서 지정한 시간 내에 메시지를 사용할 수 없으면 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-169">
              <see langword="true" /> if the enumerator successfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue and a message does not become available within the time specified by the <paramref name="timeout" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-170">이 오버 로드에는 큐에 메시지가 없는 경우 또는 커서 큐의 끝에 도달한 경우 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-170">This overload waits if there is no message in the queue or if the cursor has reached the end of the queue.</span></span> <span data-ttu-id="04179-171">큐가 비어 있거나는 컬렉션의 마지막 요소를 뒤로 이동 했기 때문에 메시지를 현재 사용할 수 없는 경우 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 지정된 된 제한 시간을 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-171">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> waits the specified timeout.</span></span>  
  
 <span data-ttu-id="04179-172">커서가 이미 큐의 끝에 있으면 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 반환 `true` 보다 우선 순위가 낮은 모든 메시지가 현재 큐에 지정 된 시간 간격 내에서 새 메시지가 도착 하는 경우 및 큐의 끝에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04179-172">If the cursor is already at the end of the queue, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> only returns `true` if the new message arrives within the specified time interval, has lower priority than all messages currently in the queue and is placed at the end of the queue.</span></span> <span data-ttu-id="04179-173">매개 변수가 없는 오버 로드는 더 이상 메시지가 큐에 있는 경우 즉시 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04179-173">An overload with no parameter returns immediately if no further messages are in the queue.</span></span>  
  
 <span data-ttu-id="04179-174">만들어지면 열거자는 일반적으로 배치 된 열거형에 대 한 첫 번째 호출은의 첫 번째 메시지 앞 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 으로 열거형의 첫 번째 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="04179-174">Upon creation, an enumerator is conceptually positioned before the first message of the enumeration, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the enumeration into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04179-175">제한 시간 매개 변수에 지정된 값이 올바르지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-175">The value specified for the timeout parameter is invalid.</span>
          </span>
          <span data-ttu-id="04179-176">(예: 음수가 지정된 경우)</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-176">It might represent a negative number.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="04179-177">메시지 큐에 대한 특정 예외가 throw된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-177">An exception specific to Message Queuing was thrown.</span>
          </span>
          <span data-ttu-id="04179-178">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-178">-or-</span>
          </span>
          <span data-ttu-id="04179-179">제한 시간이 만료된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-179">The timeout has expired.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="04179-180">큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-180">Removes the current message from the queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="04179-181">메시지를 제거하면 큐에서도 해당 메시지가 삭제됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-181">Removing the message deletes it from the queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-182">이러한 오버 로드에 대해 설명 된 동작은 적용 가능한 경우에만 <xref:System.Messaging.MessageEnumerator> 인스턴스를 사용 하 여 검색 하는 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-182">The behavior described for these overloads is applicable only if the <xref:System.Messaging.MessageEnumerator> instance is retrieved by using the <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>.</span></span> <span data-ttu-id="04179-183">사용 하지 마십시오 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 의 인스턴스를 검색 <xref:System.Messaging.MessageEnumerator> 이 메서드는 사용 되지 않는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="04179-183">Do not use <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> to retrieve an instance of <xref:System.Messaging.MessageEnumerator> as this method has been deprecated.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="04179-184">트랜잭션 큐 및 비트랜잭션 큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-184">Removes the current message from a transactional or non-transactional queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="04179-185">큐에 도착하는 메시지에 대해 제한 시간이 지정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-185">There is no timeout specified for a message to arrive in the queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="04179-186">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-186">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-187"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 커서의 현재 위치에 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-187"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span>  
  
 <span data-ttu-id="04179-188">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-188">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="04179-189">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04179-189">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="04179-190">호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-190">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="04179-191">이 오버 로드를 호출 하는 트랜잭션 큐에서 메시지 큐 내부 트랜잭션당을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="04179-191">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <span data-ttu-id="04179-192">메시지가 제거되는 트랜잭션을 지정하는 <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-192">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction in which the message will be removed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="04179-193">트랜잭션 큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-193">Removes the current message from a transactional queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="04179-194">큐에 도착하는 메시지에 대해 제한 시간이 지정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-194">There is no timeout specified for a message to arrive in the queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="04179-195">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-195">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-196"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 제거 하 고 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 커서의 현재 위치에서 메시지를 반환 합니다.는 `transaction` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="04179-196"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using the internal transaction context defined by the `transaction` parameter.</span></span>  
  
 <span data-ttu-id="04179-197">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-197">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="04179-198">트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐를 사용할 때는 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 큐로 반환 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-198">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="04179-199">트랜잭션이 커밋될 때까지 제거를 취소할 수 없는있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-199">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="04179-200">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04179-200">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="04179-201">호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-201">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="04179-202">
            <paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-202">The <paramref name="transaction" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">
          <span data-ttu-id="04179-203">
            <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-203">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="04179-204">큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-204">Removes the current message from a queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="04179-205">큐에 도착하는 메시지에 대해 제한 시간이 지정되지 않았습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-205">There is no timeout specified for a message to arrive in the queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="04179-206">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-206">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-207"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 제거 하 고 정의 된 트랜잭션 컨텍스트를 사용 하 여 커서의 현재 위치에서 메시지를 반환 합니다.는 `transactionType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="04179-207"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span>  
  
 <span data-ttu-id="04179-208">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="04179-208">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="04179-209">지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="04179-209">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="04179-210">지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="04179-210">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="04179-211">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-211">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="04179-212">트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐를 사용할 때는 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 큐로 반환 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-212">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="04179-213">트랜잭션이 커밋될 때까지 제거를 취소할 수 없는있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-213">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="04179-214">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04179-214">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="04179-215">호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-215">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="04179-216">
            <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-216">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="04179-217">큐에 메시지가 도착할 때까지 대기하는 시간 간격입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-217">The interval of time to wait for a message to arrive in the queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="04179-218">큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-218">Removes the current message from the queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="04179-219">제거할 메시지가 있으면 메서드는 해당 메시지를 즉시 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-219">If there is a message to remove, the method returns it immediately.</span>
          </span>
          <span data-ttu-id="04179-220">제거할 메시지가 없으면 메서드는 새 메시지가 도착할 때까지 지정한 제한 시간 동안 대기합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-220">Otherwise, the method waits the specified timeout for a new message to arrive.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="04179-221">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-221">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-222"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 커서의 현재 위치에 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-222"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="04179-223">메서드의이 오버 로드는 메시지를 사용할 수 있거나으로 지정한 간격이 될 때까지 대기 커서가 큐의 끝에 있는 경우는 `timeout` 매개 변수 만료 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-223">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="04179-224">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-224">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="04179-225">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04179-225">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="04179-226">호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-226">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="04179-227">이 오버 로드를 호출 하는 트랜잭션 큐에서 메시지 큐 내부 트랜잭션당을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="04179-227">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04179-228">
            <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-228">The value specified for the <paramref name="timeout" /> parameter is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="04179-229">제한 시간이 만료된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-229">The timeout has expired.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="04179-230">메시지가 제거될 때까지 대기하는 시간 간격입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-230">The interval of time to wait for the message to be removed.</span>
          </span>
        </param>
        <param name="transaction">
          <span data-ttu-id="04179-231">메시지의 트랜잭션 컨텍스트를 지정하는 <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-231">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction context for the message.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="04179-232">트랜잭션 큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-232">Removes the current message from a transactional queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="04179-233">제거할 메시지가 있으면 메서드는 해당 메시지를 즉시 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-233">If there is a message to remove, the method returns it immediately.</span>
          </span>
          <span data-ttu-id="04179-234">제거할 메시지가 없으면 메서드는 새 메시지가 도착할 때까지 지정한 제한 시간 동안 대기합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-234">Otherwise, the method waits the specified timeout for a new message to arrive.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="04179-235">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-235">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-236"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 커서의 현재 위치에 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-236"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="04179-237">메서드의이 오버 로드는 메시지를 사용할 수 있거나으로 지정한 간격이 될 때까지 대기 커서가 큐의 끝에 있는 경우는 `timeout` 매개 변수 만료 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-237">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="04179-238">트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐를 사용할 때는 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 큐로 반환 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-238">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="04179-239">트랜잭션이 커밋될 때까지 제거를 취소할 수 없는있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-239">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="04179-240">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-240">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="04179-241">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04179-241">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="04179-242">호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-242">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04179-243">
            <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-243">The value specified for the <paramref name="timeout" /> parameter is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="04179-244">
            <paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-244">The <paramref name="transaction" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="04179-245">제한 시간이 만료된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-245">The timeout has expired.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="04179-246">메시지가 제거될 때까지 대기하는 시간 간격입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-246">The interval of time to wait for the message to be removed.</span>
          </span>
        </param>
        <param name="transactionType">
          <span data-ttu-id="04179-247">
            <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-247">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="04179-248">큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-248">Removes the current message from a queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="04179-249">제거할 메시지가 있으면 메서드는 해당 메시지를 즉시 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-249">If there is a message to remove, the method returns it immediately.</span>
          </span>
          <span data-ttu-id="04179-250">제거할 메시지가 없으면 메서드는 새 메시지가 도착할 때까지 지정한 제한 시간 동안 대기합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-250">Otherwise, the method waits the specified timeout for a new message to arrive.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="04179-251">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-251">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-252"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 제거 하 고 정의 된 트랜잭션 컨텍스트를 사용 하 여 커서의 현재 위치에서 메시지를 반환 합니다.는 `transactionType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="04179-252"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="04179-253">메서드의이 오버 로드는 메시지를 사용할 수 있거나으로 지정한 간격이 될 때까지 대기 커서가 큐의 끝에 있는 경우는 `timeout` 매개 변수 만료 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-253">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="04179-254">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="04179-254">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="04179-255">지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="04179-255">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="04179-256">지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="04179-256">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="04179-257">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-257">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="04179-258">트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐를 사용할 때는 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 큐로 반환 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-258">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="04179-259">트랜잭션이 커밋될 때까지 제거를 취소할 수 없는있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-259">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="04179-260">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04179-260">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="04179-261">호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-261">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04179-262">
            <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-262">The value specified for the <paramref name="timeout" /> parameter is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="04179-263">제한 시간이 만료된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-263">The timeout has expired.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="04179-264">
            <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-264">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="04179-265">현재 열거자가 큐의 처음을 가리키도록 다시 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-265">Resets the current enumerator so it points to the head of the queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04179-266">열거자는 앞쪽 방향으로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04179-266">An enumerator can only move in a forward direction.</span></span> <span data-ttu-id="04179-267">이 메서드를 사용 하 여 큐의 시작 부분에서 다시 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-267">Use this method to start over at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="04179-268">호출한 후 <xref:System.Messaging.MessageEnumerator.Reset%2A>, 커서에서 첫 번째 메시지를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="04179-268">After calling <xref:System.Messaging.MessageEnumerator.Reset%2A>, the cursor points to the first message.</span></span> <span data-ttu-id="04179-269">호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.Reset%2A> 큐에 있는 첫 번째 메시지에 커서를 앞으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="04179-269">You do not need to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.Reset%2A> to move the cursor forward to the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="04179-270">현재 커서 위치에 있는 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-270">Returns a <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="04179-271">현재 커서 위치에 있는 메시지를 참조하는 <see cref="T:System.Messaging.Message" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="04179-271">A <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>