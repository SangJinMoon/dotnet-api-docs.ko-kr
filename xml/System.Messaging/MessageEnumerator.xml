<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MessageEnumerator.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac56a3039a11d941cd3db611cb997eb17835525e4da.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6a3039a11d941cd3db611cb997eb17835525e4da</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageEnumerator">
          <source>Provides a forward-only cursor to enumerate through messages in a message queue.</source>
          <target state="translated">메시지 큐의 메시지를 열거하는 정방향 전용 커서를 제공합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>Use <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> for dynamic interaction with messages in a queue.</source>
          <target state="translated">사용 하 여 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> 큐에 메시지와 함께 동적 상호 작용 합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>Methods available through the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class can return either a <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> pointing to a dynamic list of messages in the queue, or an array that contains a copy at a given instant - a snapshot - of the queue at the time the specified method was called.</source>
          <target state="translated">통해 사용할 수 있는 메서드는 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> 클래스 중 하나를 반환할 수는 <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> 호출 된 지정된 된 메서드를 큐 또는 시간에 큐의 특정된 시점 스냅숏에 복사본을 포함 하는 배열에 있는 메시지의 동적 목록을 가리키는 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>Unlike a static snapshot, an enumerator allows you to modify the collection.</source>
          <target state="translated">정적 스냅샷 달리는 열거자를 사용 하면 해당 컬렉션을 수정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>Using a <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph>, you can remove messages from the queue, and the change is immediately reflected in the queue.</source>
          <target state="translated">사용 하는 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph>큐에서 메시지를 제거 하 고 변경 내용을 큐에 즉시 반영 됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>An enumerator does not remove the messages from the queue when it queries the queue.</source>
          <target state="translated">열거자는 큐를 쿼리할 때 메시지 큐에서 제거 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>It returns information about the message at the current cursor position, but it leaves the message in the queue.</source>
          <target state="translated">현재 커서 위치에 메시지에 대 한 정보를 반환 하지만 해당 메시지를 큐에 유지 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>A <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> is a cursor, initialized to the head of a dynamic list.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> 는 목록 헤드를 동적으로 초기화 하는 커서입니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>The list order is the same as the order of the messages in the queue, according to message priority.</source>
          <target state="translated">목록 순서가 큐에서 메시지의 순서와 동일 메시지의 우선 순위에 따라 합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>You can move the cursor to the first message in the queue by calling <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">큐의 첫 번째 메시지를 호출 하 여 커서를 이동할 수 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>After the enumerator has been initialized, you can use <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> to step forward through the remaining messages.</source>
          <target state="translated">열거자가 초기화 된 후 사용할 수 있습니다 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 나머지 메시지 앞으로 단계별로 실행 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>You can specify whether to wait for a message to become available by passing a timeout into the <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> method.</source>
          <target state="translated">제한 시간을 전달 하 여 사용할 수 있게 하는 메시지를 기다리는 여부를 지정할 수는 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>Because the enumerator is dynamic, a message that is appended beyond the cursor's current position (for example, due to low priority), can be accessed by the enumerator.</source>
          <target state="translated">열거자는 동적 커서의 현재 위치 (예를 들어 때문에 낮은 우선 순위) 뒤에 추가 된 메시지 열거자가 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>A message that is inserted before the cursor's current position cannot be accessed.</source>
          <target state="translated">커서의 현재 위치에 액세스할 수 없습니다 전에 삽입 되는 메시지입니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>It is not possible to step backward with a <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph>.</source>
          <target state="translated">여 뒤로 이동 불가능 한 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>A cursor allows forward-only movement.</source>
          <target state="translated">커서 앞 으로만 이동 가능한 이동할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Reset%2A&gt;</ph> method enables you to place the cursor back at the beginning of the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Reset%2A&gt;</ph> 메서드를 사용 하면 큐의 시작 부분에서 다시 커서에 배치할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>Instances of <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> for a given queue work independently.</source>
          <target state="translated">인스턴스 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> 특정된 큐에 대 한 독립적으로 작동 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>You can create two <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> instances that apply to the same queue.</source>
          <target state="translated">두 개를 만든 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> 동일한 큐에 적용 되는 인스턴스.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>The changes that one <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> makes to the messages in the queue will be reflected immediately in a second enumerator if the second enumerator is positioned before the first.</source>
          <target state="translated">변경 내용을 하나 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> 큐에서 메시지를 위한 즉시 반영 됩니다에 두 번째 열거자가 첫 번째 위치입니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>However, if two enumerators have the same position and one of them removes the message at that position, an exception is thrown if the other enumerator attempts to get the value of the <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Current%2A&gt;</ph> property on the now-deleted message.</source>
          <target state="translated">그러나 두 열거자는 동일한 위치 하는 경우 해당 위치에서 메시지를 제거 중 예외가 throw 됩니다 다른 열거자의 값을 가져오려고 시도 하는 경우는 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Current%2A&gt;</ph> 방금 삭제 메시지의 속성입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>If you create an instance of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> with <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType&gt;</ph> set to <ph id="ph3">`true`</ph>, no other application can modify the messages in your enumerator while you have the connection to the queue.</source>
          <target state="translated">인스턴스를 만들 경우 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType&gt;</ph> 로 설정 <ph id="ph3">`true`</ph>, 큐에 연결 해야 하는 동안 다른 응용 프로그램에서 해당 열거형의에서 메시지를 수정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>The following example gets a dynamic list of messages in a queue and counts all messages with the <ph id="ph1">&lt;xref:System.Messaging.Message.Priority%2A&gt;</ph> property set to <ph id="ph2">&lt;xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 큐에 있는 메시지의 동적 목록을 가져오고 있는 모든 메시지가 계산 된 <ph id="ph1">&lt;xref:System.Messaging.Message.Priority%2A&gt;</ph> 속성이로 설정 <ph id="ph2">&lt;xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.Close">
          <source>Frees the resources associated with the enumerator.</source>
          <target state="translated">해당 열거자와 관련된 리소스를 삭제합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Close">
          <source>The operating system retains an open handle to the queue during the lifetime of the cursor.</source>
          <target state="translated">운영 체제는 큐에 대해 열린 핸들이 커서의 수명 동안 유지합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Close">
          <source>When you have finished working with the enumerator, call <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Close%2A&gt;</ph> to release the resources associated with the handle.</source>
          <target state="translated">에서는 열거자와 함께 작업을 완료 하면, 호출 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Close%2A&gt;</ph> 핸들에 연결 된 리소스를 해제 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageEnumerator.Current">
          <source>Gets the current <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that this enumerator points to.</source>
          <target state="translated">이 열거자가 가리키는 현재 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageEnumerator.Current">
          <source>The current message.</source>
          <target state="translated">현재 메시지입니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageEnumerator.Current">
          <source>When the enumerator is created, it points to the head of the queue, at a location before the first message.</source>
          <target state="translated">열거자를 만들 때 첫 번째 메시지 앞에 큐의 시작 부분을 가리킵니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageEnumerator.Current">
          <source>In this case, <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Current%2A&gt;</ph> is not valid and will throw an exception if it is accessed.</source>
          <target state="translated">이 경우 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Current%2A&gt;</ph> 올바르지 않으며 액세스 하는 경우 예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageEnumerator.Current">
          <source>You must call <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> to position the cursor at the first message in the queue.</source>
          <target state="translated">호출 해야 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 큐의 첫 번째 메시지에 커서를 배치할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageEnumerator.Current">
          <source>You called <ph id="ph1">&lt;see cref="P:System.Messaging.MessageEnumerator.Current" /&gt;</ph> before the first call to <ph id="ph2">&lt;see cref="M:System.Messaging.MessageEnumerator.MoveNext" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Messaging.MessageEnumerator.Current" /&gt;</ph>를 처음 호출하기 전에 <ph id="ph2">&lt;see cref="M:System.Messaging.MessageEnumerator.MoveNext" /&gt;</ph>를 호출하여</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageEnumerator.Current">
          <source>The cursor is located before the first element of the message enumeration.</source>
          <target state="translated">즉, 커서가 메시지 열거형의 첫 번째 요소 앞에 배치된 경우</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageEnumerator.Current">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageEnumerator.Current">
          <source>You called <ph id="ph1">&lt;see cref="P:System.Messaging.MessageEnumerator.Current" /&gt;</ph> after a call to <ph id="ph2">&lt;see cref="M:System.Messaging.MessageEnumerator.MoveNext" /&gt;</ph> had returned <ph id="ph3">&lt;see langword="false" /&gt;</ph> (indicating the cursor is located after the last element of the message enumeration.)</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Messaging.MessageEnumerator.Current" /&gt;</ph>를 호출하여 <ph id="ph3">&lt;see langword="false" /&gt;</ph>를 반환한 후에 <ph id="ph2">&lt;see cref="M:System.Messaging.MessageEnumerator.MoveNext" /&gt;</ph>를 호출한 경우(커서가 메시지 열거형의 마지막 요소 뒤에 배치됨을 나타냄)</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageEnumerator.Current">
          <source>The message the enumerator is currently pointing to no longer exists.</source>
          <target state="translated">열거자가 현재 가리키고 있는 메시지가 더 이상 없는 경우</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageEnumerator.Current">
          <source>It might have been deleted.</source>
          <target state="translated">삭제되었을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageEnumerator.CursorHandle">
          <source>Gets the native Message Queuing cursor handle used to browse messages in the queue.</source>
          <target state="translated">큐에서 메시지를 찾는 데 사용되는 네이티브 메시지 큐 커서 핸들을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageEnumerator.CursorHandle">
          <source>The native cursor handle.</source>
          <target state="translated">기본 커서 핸들입니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageEnumerator.CursorHandle">
          <source>This property contains the native handle to the enumeration.</source>
          <target state="translated">이 속성을 열거형에 대 한 기본 핸들을 포함합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageEnumerator.CursorHandle">
          <source>When you have finished working with the enumerator, call <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Close%2A&gt;</ph> to release this resource.</source>
          <target state="translated">에서는 열거자와 함께 작업을 완료 하면, 호출 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Close%2A&gt;</ph> 이 리소스를 해제 합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageEnumerator.CursorHandle">
          <source>The handle does not exist.</source>
          <target state="translated">핸들이 없는 경우</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageEnumerator">
          <source>Releases the resources used by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageEnumerator" /&gt;</ph>.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Messaging.MessageEnumerator" /&gt;</ph>에서 사용하는 리소스를 해제합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.Dispose">
          <source>Releases all resources used by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageEnumerator" /&gt;</ph>.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Messaging.MessageEnumerator" /&gt;</ph>에서 사용하는 모든 리소스를 해제합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Dispose">
          <source>Calling <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Dispose%2A&gt;</ph> allows the resources used by the <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> to be reallocated for other purposes.</source>
          <target state="translated">호출 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Dispose%2A&gt;</ph> 에서 사용 하는 리소스는 <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> 다른 용도에 다시 할당 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Dispose">
          <source>For more information about <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Dispose%2A&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Dispose%2A&gt;</ph>, 참조 <bpt id="p1">[</bpt>관리 되지 않는 리소스 정리<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>로 설정하고, 관리되지 않는 리소스만 해제하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageEnumerator" /&gt;</ph> and optionally releases the managed resources.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageEnumerator" /&gt;</ph>에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Dispose%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">이 메서드는 public <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Dispose%2A&gt;</ph> 메서드 및 <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)">
          <source><ph id="ph1">`Dispose()`</ph> invokes the protected <ph id="ph2">`Dispose(Boolean)`</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">`Dispose()`</ph> 보호 된 호출 <ph id="ph2">`Dispose(Boolean)`</ph> 메서드는 <ph id="ph3">`disposing`</ph> 매개 변수 설정 <ph id="ph4">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">`Dispose`</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 호출 <ph id="ph2">`Dispose`</ph> 와 <ph id="ph3">`disposing`</ph> 로 설정 <ph id="ph4">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> references.</source>
          <target state="translated"><ph id="ph1">`disposing`</ph> 매개 변수가 <ph id="ph2">`true`</ph>인 경우 이 메서드는 이 <ph id="ph3">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph>에서 참조하는 관리 개체가 보유하고 있는 리소스를 모두 해제합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">`Dispose()`</ph> method of each referenced object.</source>
          <target state="translated">이 메서드는 참조되는 각 개체의 <ph id="ph1">`Dispose()`</ph> 메서드를 호출합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph>는 다른 개체에서 여러 번 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>를 재정의할 때 이전 <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph> 호출에서 삭제된 개체를 참조하지 않도록 주의하십시오.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">구현 하는 방법에 대 한 자세한 내용은 <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph>, 참조 <bpt id="p1">[</bpt>Dispose 메서드를 구현<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> and <ph id="ph2">&lt;see langword="Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Overriding the Finalize Method<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> 및 <ph id="ph2">&lt;see langword="Finalize" /&gt;</ph>, 참조 <bpt id="p1">[</bpt>관리 되지 않는 리소스 정리<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> 및 <bpt id="p2">[</bpt>Finalize 메서드를 재정의<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageEnumerator">
          <source>Advances the enumerator to the next message in the queue.</source>
          <target state="translated">열거자를 큐의 다음 메시지로 이동합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext">
          <source>Advances the enumerator to the next message in the queue, if one is currently available.</source>
          <target state="translated">가능한 경우 열거자를 큐의 다음 메시지로 이동합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the enumerator was succesfully advanced to the next message; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the enumerator has reached the end of the queue.</source>
          <target state="translated">열거자가 다음 메시지로 이동하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>를 반환하고, 큐의 끝에 도달하면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.MoveNext">
          <source>This overload returns immediately if there is no message in the queue.</source>
          <target state="translated">이 오버 로드는 큐에 메시지가 없는 경우 즉시 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.MoveNext">
          <source>There is another overload that waits a specified <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> for a message to arrive.</source>
          <target state="translated">지정 된 대기 하는 다른 오버 로드는 <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> 메시지 도착에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.MoveNext">
          <source>If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph2">`false`</ph> to the calling method.</source>
          <target state="translated">큐가 비어 있거나는 컬렉션의 마지막 요소를 뒤로 이동 했기 때문에 메시지를 현재 사용할 수 없는 경우 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph2">`false`</ph> 호출 하는 메서드.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.MoveNext">
          <source>Upon creation, an enumerator is conceptually positioned before the first message of the queue, and the first call to <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> brings the first message of the queue into view.</source>
          <target state="translated">만들어지면 열거자는 일반적으로 배치 된 큐 및 첫 번째 호출의 첫 번째 메시지 앞 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 뷰로 큐의 첫 번째 메시지를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext">
          <source>An exception specific to Message Queuing was thrown.</source>
          <target state="translated">메시지 큐에 대한 특정 예외가 throw된 경우</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> to wait for a message to be available if the enumerator is positioned at the end of the queue.</source>
          <target state="translated">열거자가 큐의 끝에 배치되는 경우 메시지를 사용할 수 있을 때까지 대기하는 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>Advances the enumerator to the next message in the queue.</source>
          <target state="translated">열거자를 큐의 다음 메시지로 이동합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>If the enumerator is positioned at the end of the queue, <ph id="ph1">&lt;see cref="M:System.Messaging.MessageEnumerator.MoveNext" /&gt;</ph> waits until a message is available or the given timeout expires.</source>
          <target state="translated">열거자가 큐의 끝에 배치되는 경우 <ph id="ph1">&lt;see cref="M:System.Messaging.MessageEnumerator.MoveNext" /&gt;</ph>는 메시지를 사용할 수 있거나 지정된 제한 시간이 만료될 때까지 대기합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the enumerator successfully advanced to the next message; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the enumerator has reached the end of the queue and a message does not become available within the time specified by the <ph id="ph3">&lt;paramref name="timeout" /&gt;</ph> parameter.</source>
          <target state="translated">열거자가 다음 메시지로 이동하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>를 반환하고, 해당 열거자가 큐의 끝에 도달하고 <ph id="ph3">&lt;paramref name="timeout" /&gt;</ph> 매개 변수에서 지정한 시간 내에 메시지를 사용할 수 없으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>This overload waits if there is no message in the queue or if the cursor has reached the end of the queue.</source>
          <target state="translated">이 오버 로드에는 큐에 메시지가 없는 경우 또는 커서 큐의 끝에 도달한 경우 대기 합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> waits the specified timeout.</source>
          <target state="translated">큐가 비어 있거나는 컬렉션의 마지막 요소를 뒤로 이동 했기 때문에 메시지를 현재 사용할 수 없는 경우 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 지정된 된 제한 시간을 대기 합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>If the cursor is already at the end of the queue, <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> only returns <ph id="ph2">`true`</ph> if the new message arrives within the specified time interval, has lower priority than all messages currently in the queue and is placed at the end of the queue.</source>
          <target state="translated">커서가 이미 큐의 끝에 있으면 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph2">`true`</ph> 보다 우선 순위가 낮은 모든 메시지가 현재 큐에 지정 된 시간 간격 내에서 새 메시지가 도착 하는 경우 및 큐의 끝에 배치 됩니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>An overload with no parameter returns immediately if no further messages are in the queue.</source>
          <target state="translated">매개 변수가 없는 오버 로드는 더 이상 메시지가 큐에 있는 경우 즉시 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>Upon creation, an enumerator is conceptually positioned before the first message of the enumeration, and the first call to <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> brings the first message of the enumeration into view.</source>
          <target state="translated">만들어지면 열거자는 일반적으로 배치 된 열거형에 대 한 첫 번째 호출은의 첫 번째 메시지 앞 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 으로 열거형의 첫 번째 메시지입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>The value specified for the timeout parameter is invalid.</source>
          <target state="translated">제한 시간 매개 변수에 지정된 값이 올바르지 않은 경우</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>It might represent a negative number.</source>
          <target state="translated">(예: 음수가 지정된 경우)</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>An exception specific to Message Queuing was thrown.</source>
          <target state="translated">메시지 큐에 대한 특정 예외가 throw된 경우</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)">
          <source>The timeout has expired.</source>
          <target state="translated">제한 시간이 만료된 경우</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageEnumerator">
          <source>Removes the current message from the queue and returns the message to the calling application.</source>
          <target state="translated">큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageEnumerator">
          <source>Removing the message deletes it from the queue.</source>
          <target state="translated">메시지를 제거하면 큐에서도 해당 메시지가 삭제됩니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>The behavior described for these overloads is applicable only if the <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> instance is retrieved by using the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A&gt;</ph>.</source>
          <target state="translated">이러한 오버 로드에 대해 설명 된 동작은 적용 가능한 경우에만 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> 인스턴스를 사용 하 여 검색 하는 <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageEnumerator">
          <source>Do not use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A&gt;</ph> to retrieve an instance of <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> as this method has been deprecated.</source>
          <target state="translated">사용 하지 마십시오 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A&gt;</ph> 의 인스턴스를 검색 <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> 이 메서드는 사용 되지 않는 것입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent">
          <source>Removes the current message from a transactional or non-transactional queue and returns the message to the calling application.</source>
          <target state="translated">트랜잭션 큐 및 비트랜잭션 큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent">
          <source>There is no timeout specified for a message to arrive in the queue.</source>
          <target state="translated">큐에 도착하는 메시지에 대해 제한 시간이 지정되지 않았습니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> removes and returns the message at the cursor's current location.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> 커서의 현재 위치에 메시지를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent">
          <source>If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class's <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method does.</source>
          <target state="translated">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> 클래스의 <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> 메서드 수행 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent">
          <source>When you remove the current message, the cursor is moved to the next message.</source>
          <target state="translated">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent">
          <source>You do not have to call <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> after calling <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>.</source>
          <target state="translated">호출할 필요가 없습니다 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 호출한 후 <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent">
          <source>If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</source>
          <target state="translated">이 오버 로드를 호출 하는 트랜잭션 큐에서 메시지 큐 내부 트랜잭션당을 만듭니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object that specifies the transaction in which the message will be removed.</source>
          <target state="translated">메시지가 제거되는 트랜잭션을 지정하는 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)">
          <source>Removes the current message from a transactional queue and returns the message to the calling application.</source>
          <target state="translated">트랜잭션 큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)">
          <source>There is no timeout specified for a message to arrive in the queue.</source>
          <target state="translated">큐에 도착하는 메시지에 대해 제한 시간이 지정되지 않았습니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> removes and returns the message at the cursor's current location, using the internal transaction context defined by the <ph id="ph2">`transaction`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> 제거 하 고 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 커서의 현재 위치에서 메시지를 반환 합니다.는 <ph id="ph2">`transaction`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)">
          <source>If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class's <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method does.</source>
          <target state="translated">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> 클래스의 <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> 메서드 수행 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)">
          <source>When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> to be returned to the queue.</source>
          <target state="translated">트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐를 사용할 때는 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> 큐로 반환 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)">
          <source>The removal is not irreversible until the transaction is committed.</source>
          <target state="translated">트랜잭션이 커밋될 때까지 제거를 취소할 수 없는있지 않습니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)">
          <source>When you remove the current message, the cursor is moved to the next message.</source>
          <target state="translated">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)">
          <source>You do not have to call <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> after calling <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>.</source>
          <target state="translated">호출할 필요가 없습니다 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 호출한 후 <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values, describing the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>Removes the current message from a queue and returns the message to the calling application.</source>
          <target state="translated">큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>There is no timeout specified for a message to arrive in the queue.</source>
          <target state="translated">큐에 도착하는 메시지에 대해 제한 시간이 지정되지 않았습니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> removes and returns the message at the cursor's current location, using a transaction context defined by the <ph id="ph2">`transactionType`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> 제거 하 고 정의 된 트랜잭션 컨텍스트를 사용 하 여 커서의 현재 위치에서 메시지를 반환 합니다.는 <ph id="ph2">`transactionType`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</source>
          <target state="translated">지정 <ph id="ph1">`Automatic`</ph> 에 대 한는 <ph id="ph2">`transactionType`</ph> 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to receive the message as a single internal transaction.</source>
          <target state="translated">지정 <ph id="ph1">`Single`</ph> 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to receive a message from a transactional queue outside of a transaction context.</source>
          <target state="translated">지정할 수 있습니다 <ph id="ph1">`None`</ph> 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class's <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method does.</source>
          <target state="translated">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> 클래스의 <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> 메서드 수행 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> to be returned to the queue.</source>
          <target state="translated">트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐를 사용할 때는 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> 큐로 반환 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>The removal is not irreversible until the transaction is committed.</source>
          <target state="translated">트랜잭션이 커밋될 때까지 제거를 취소할 수 없는있지 않습니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>When you remove the current message, the cursor is moved to the next message.</source>
          <target state="translated">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>You do not have to call <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> after calling <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>.</source>
          <target state="translated">호출할 필요가 없습니다 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 호출한 후 <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 멤버 중 하나가 아닌 경우</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>The interval of time to wait for a message to arrive in the queue.</source>
          <target state="translated">큐에 메시지가 도착할 때까지 대기하는 시간 간격입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>Removes the current message from the queue and returns the message to the calling application.</source>
          <target state="translated">큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>If there is a message to remove, the method returns it immediately.</source>
          <target state="translated">제거할 메시지가 있으면 메서드는 해당 메시지를 즉시 반환합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>Otherwise, the method waits the specified timeout for a new message to arrive.</source>
          <target state="translated">제거할 메시지가 없으면 메서드는 새 메시지가 도착할 때까지 지정한 제한 시간 동안 대기합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> removes and returns the message at the cursor's current location.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> 커서의 현재 위치에 메시지를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the <ph id="ph1">`timeout`</ph> parameter has expired.</source>
          <target state="translated">메서드의이 오버 로드는 메시지를 사용할 수 있거나으로 지정한 간격이 될 때까지 대기 커서가 큐의 끝에 있는 경우는 <ph id="ph1">`timeout`</ph> 매개 변수 만료 되었습니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class's <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method does.</source>
          <target state="translated">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> 클래스의 <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> 메서드 수행 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>When you remove the current message, the cursor is moved to the next message.</source>
          <target state="translated">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>You do not have to call <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> after calling <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>.</source>
          <target state="translated">호출할 필요가 없습니다 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 호출한 후 <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</source>
          <target state="translated">이 오버 로드를 호출 하는 트랜잭션 큐에서 메시지 큐 내부 트랜잭션당을 만듭니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 매개 변수에 지정된 값이 잘못된 경우</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)">
          <source>The timeout has expired.</source>
          <target state="translated">제한 시간이 만료된 경우</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The interval of time to wait for the message to be removed.</source>
          <target state="translated">메시지가 제거될 때까지 대기하는 시간 간격입니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object that specifies the transaction context for the message.</source>
          <target state="translated">메시지의 트랜잭션 컨텍스트를 지정하는 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Removes the current message from a transactional queue and returns the message to the calling application.</source>
          <target state="translated">트랜잭션 큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>If there is a message to remove, the method returns it immediately.</source>
          <target state="translated">제거할 메시지가 있으면 메서드는 해당 메시지를 즉시 반환합니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Otherwise, the method waits the specified timeout for a new message to arrive.</source>
          <target state="translated">제거할 메시지가 없으면 메서드는 새 메시지가 도착할 때까지 지정한 제한 시간 동안 대기합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> removes and returns the message at the cursor's current location.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> 커서의 현재 위치에 메시지를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the <ph id="ph1">`timeout`</ph> parameter has expired.</source>
          <target state="translated">메서드의이 오버 로드는 메시지를 사용할 수 있거나으로 지정한 간격이 될 때까지 대기 커서가 큐의 끝에 있는 경우는 <ph id="ph1">`timeout`</ph> 매개 변수 만료 되었습니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> to be returned to the queue.</source>
          <target state="translated">트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐를 사용할 때는 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> 큐로 반환 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The removal is not irreversible until the transaction is committed.</source>
          <target state="translated">트랜잭션이 커밋될 때까지 제거를 취소할 수 없는있지 않습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class's <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method does.</source>
          <target state="translated">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> 클래스의 <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> 메서드 수행 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>When you remove the current message, the cursor is moved to the next message.</source>
          <target state="translated">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>You do not have to call <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> after calling <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>.</source>
          <target state="translated">호출할 필요가 없습니다 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 호출한 후 <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 매개 변수에 지정된 값이 잘못된 경우</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The timeout has expired.</source>
          <target state="translated">제한 시간이 만료된 경우</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The interval of time to wait for the message to be removed.</source>
          <target state="translated">메시지가 제거될 때까지 대기하는 시간 간격입니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values, describing the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Removes the current message from a queue and returns the message to the calling application.</source>
          <target state="translated">큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If there is a message to remove, the method returns it immediately.</source>
          <target state="translated">제거할 메시지가 있으면 메서드는 해당 메시지를 즉시 반환합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Otherwise, the method waits the specified timeout for a new message to arrive.</source>
          <target state="translated">제거할 메시지가 없으면 메서드는 새 메시지가 도착할 때까지 지정한 제한 시간 동안 대기합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> removes and returns the message at the cursor's current location, using a transaction context defined by the <ph id="ph2">`transactionType`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> 제거 하 고 정의 된 트랜잭션 컨텍스트를 사용 하 여 커서의 현재 위치에서 메시지를 반환 합니다.는 <ph id="ph2">`transactionType`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the <ph id="ph1">`timeout`</ph> parameter has expired.</source>
          <target state="translated">메서드의이 오버 로드는 메시지를 사용할 수 있거나으로 지정한 간격이 될 때까지 대기 커서가 큐의 끝에 있는 경우는 <ph id="ph1">`timeout`</ph> 매개 변수 만료 되었습니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</source>
          <target state="translated">지정 <ph id="ph1">`Automatic`</ph> 에 대 한는 <ph id="ph2">`transactionType`</ph> 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to receive the message as a single internal transaction.</source>
          <target state="translated">지정 <ph id="ph1">`Single`</ph> 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to receive a message from a transactional queue outside of a transaction context.</source>
          <target state="translated">지정할 수 있습니다 <ph id="ph1">`None`</ph> 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class's <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method does.</source>
          <target state="translated">일지 큐를 사용 하는 경우 해당 메시지를 제거 하면 복사본이와 마찬가지로 업무 일지 큐에 보관 되는 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> 클래스의 <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> 메서드 수행 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> to be returned to the queue.</source>
          <target state="translated">트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐를 사용할 때는 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> 큐로 반환 되도록 합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The removal is not irreversible until the transaction is committed.</source>
          <target state="translated">트랜잭션이 커밋될 때까지 제거를 취소할 수 없는있지 않습니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>When you remove the current message, the cursor is moved to the next message.</source>
          <target state="translated">현재 메시지를 제거 하면 다음 메시지로 커서 이동 됩니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>You do not have to call <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> after calling <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>.</source>
          <target state="translated">호출할 필요가 없습니다 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 호출한 후 <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 매개 변수에 지정된 값이 잘못된 경우</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The timeout has expired.</source>
          <target state="translated">제한 시간이 만료된 경우</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 매개 변수가 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 멤버 중 하나가 아닌 경우</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageEnumerator.Reset">
          <source>Resets the current enumerator so it points to the head of the queue.</source>
          <target state="translated">현재 열거자가 큐의 처음을 가리키도록 다시 설정합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Reset">
          <source>An enumerator can only move in a forward direction.</source>
          <target state="translated">열거자는 앞쪽 방향으로 이동할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Reset">
          <source>Use this method to start over at the beginning of the queue.</source>
          <target state="translated">이 메서드를 사용 하 여 큐의 시작 부분에서 다시 시작 합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Reset">
          <source>After calling <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Reset%2A&gt;</ph>, the cursor points to the first message.</source>
          <target state="translated">호출한 후 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Reset%2A&gt;</ph>, 커서에서 첫 번째 메시지를 가리킵니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageEnumerator.Reset">
          <source>You do not need to call <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> after calling <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.Reset%2A&gt;</ph> to move the cursor forward to the first message in the queue.</source>
          <target state="translated">호출할 필요가 없습니다 <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.MoveNext%2A&gt;</ph> 호출한 후 <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator.Reset%2A&gt;</ph> 큐에 있는 첫 번째 메시지에 커서를 앞으로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the message at the current cursor position.</source>
          <target state="translated">현재 커서 위치에 있는 메시지를 참조하는 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the message at the current cursor position.</source>
          <target state="translated">현재 커서 위치에 있는 메시지를 참조하는 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>입니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>