<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f362dd97709b65574ff7b9474682818d0cb2c4b1" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32038296" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>메시지 큐 서버에 있는 큐에 대한 액세스를 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐 기술을 실행 중인 응용 프로그램이 서로 다른 시간에 다른 유형의 네트워크와 일시적으로 오프 라인 시스템 간에 통신할 수 있습니다. 응용 프로그램 송신, 수신, 또는 큐에서 메시지 (제거 하지 않고 읽기) 피크 (peek). 메시지 큐의 선택적 구성 요소는 [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 및 Windows NT 별도로 설치 해야 합니다.  
  
 <xref:System.Messaging.MessageQueue> 클래스는 메시지 큐에 대 한 래퍼입니다. 메시지 큐를 사용 하 여 여러 버전의 <xref:System.Messaging.MessageQueue> 사용 중인 운영 체제에 따라, 클래스 약간 다른 동작이 발생할 수 있습니다. 메시지 큐의 각 버전의 특정 기능에 대 한 정보를 msdn에서 Platform SDK의 새로운 기능 "을 메시지 큐에서" 항목을 참조 합니다.  
  
 <xref:System.Messaging.MessageQueue> 클래스는 메시지 큐에 대 한 참조를 제공 합니다. 경로 지정할 수는 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자는 기존 리소스에 연결 하는 서버에서 새 큐를 만들 수 있습니다. 호출 하기 전에 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, 또는 <xref:System.Messaging.MessageQueue.Receive%2A>의 새 인스턴스를 연결 해야 합니다는 <xref:System.Messaging.MessageQueue> 기존 큐를 사용 하 여 클래스입니다. 와 같은 큐 속성을 조작할 수는 해당 시점에 <xref:System.Messaging.MessageQueue.Category%2A> 및 <xref:System.Messaging.MessageQueue.Label%2A>합니다.  
  
 <xref:System.Messaging.MessageQueue> 두 가지 유형의 메시지 검색 지원: 동기 및 비동기입니다. 동기 메서드 <xref:System.Messaging.MessageQueue.Peek%2A> 및 <xref:System.Messaging.MessageQueue.Receive%2A>, 프로세스 스레드가 지정된 된 시간 간격을 큐에 도착할 때까지 새 메시지에 대해 기다려야 합니다. 비동기 메서드를 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 및 <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 별도의 스레드에서 계속 하면 메시지가 큐에 도착할 때까지 주 응용 프로그램 작업을 허용 합니다. 이러한 메서드는 스레드 간의 의사 소통이 콜백 개체 및 상태 개체를 사용 하 여 작동 합니다.  
  
 새 인스턴스를 만들 때는 <xref:System.Messaging.MessageQueue> 클래스를 만들지 않고 새 메시지 큐입니다. 대신 사용할 수는 <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, 및 <xref:System.Messaging.MessageQueue.Purge%2A> 서버에서 큐를 관리 하는 방법입니다.  
  
 와 달리 <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> 및 <xref:System.Messaging.MessageQueue.Delete%28System.String%29> 는 `static` 멤버의 새 인스턴스를 만들지 않고 전화할 수 이므로 <xref:System.Messaging.MessageQueue> 클래스입니다.  
  
 설정할 수 있습니다는 <xref:System.Messaging.MessageQueue> 개체의 <xref:System.Messaging.MessageQueue.Path%2A> 세 가지 이름 중 하나를 사용 하 여 속성: 이름는 <xref:System.Messaging.MessageQueue.FormatName%2A>, 또는 <xref:System.Messaging.MessageQueue.Label%2A>합니다. 큐의 문자로 정의 되는 식별 이름을 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성은 <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> 공개 큐에 대 한 및 <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> 개인 큐에 대 한 합니다. <xref:System.Messaging.MessageQueue.FormatName%2A> 속성 메시지 큐에 대 한 오프 라인 액세스를 허용 합니다. 마지막으로 큐의 사용할 수 있습니다 <xref:System.Messaging.MessageQueue.Label%2A> 속성을 설정 큐의 <xref:System.Messaging.MessageQueue.Path%2A>합니다.  
  
 인스턴스에 대 한 초기 속성 값 목록은 <xref:System.Messaging.MessageQueue>, 참조는 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 다양 한 경로 이름 구문 형식을 사용 하 여 개체입니다. 각각의 경우에서 경로가 생성자에 정의 된 큐로 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 다음 코드 예제에서는 큐에 메시지를 보내고 라고 하는 응용 프로그램 관련 클래스를 사용 하 여 큐에서 메시지를 받은 `Order`합니다.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>만 <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> 메서드는 스레드로부터 안전 합니다.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다. 기본 생성자가 새 인스턴스를 초기화하면, 이 인스턴스를 사용하기 전에 인스턴스의 <see cref="P:System.Messaging.MessageQueue.Path" /> 속성을 설정해야 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여의 새 인스턴스를 만드는 <xref:System.Messaging.MessageQueue> 메시지 큐 서버에 있는 큐에 바로 연결 되지 않은 클래스입니다. 이 인스턴스를 사용 하기 전에 연결 해야 기존 메시지 큐 큐를 설정 하 여는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다. 설정할 수 있습니다는 <xref:System.Messaging.MessageQueue> 에 대 한 참조는 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 여는 새 메시지 큐를 만들 메서드의 반환 값입니다.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자의 새 인스턴스를 인스턴스화하는 <xref:System.Messaging.MessageQueue> 클래스입니다; 새 메시지 큐를 만들지 않습니다.  
  
 다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.MessageQueue>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.DefaultPropertiesToSend> 클래스입니다.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.MessagePropertyFilter> 클래스입니다. 모든 필터 값으로 설정 된 `true`합니다.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue>합니다.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치입니다.</param>
        <summary>지정된 경로에 있는 메시지 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 연결 하려는 경우이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue> 경로, 형식 이름 또는 레이블을 알아야 특정 메시지 큐 인스턴스. 큐를 참조 하는 첫 번째 응용 프로그램에 대 한 단독 액세스 권한을 부여 하려는 경우 설정 해야 합니다는 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 속성을 `true` 하거나 읽기 액세스 제한 매개 변수를 전달 하는 생성자를 사용 합니다.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자의 새 인스턴스를 인스턴스화하는 <xref:System.Messaging.MessageQueue> 클래스입니다; 새 메시지 큐를 만들지 않습니다. 메시지 큐에서 새 큐를 만들려면 사용 <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.  
  
 구문은 `path` 매개 변수 유형에 따라 다릅니다 큐의 해당 참조는 다음 표에 나와 있는 것 처럼 합니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
|저널 큐|`MachineName`\\`QueueName`\\`Journal$`|  
|컴퓨터 저널 큐|`MachineName`\\`Journal$`|  
|컴퓨터 배달 못 한 편지 큐|`MachineName`\\`Deadletter$`|  
|컴퓨터 트랜잭션 배달 못 한 편지 큐|`MachineName`\\`XactDeadletter$`|  
  
 사용할 수 있습니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 또는 <xref:System.Messaging.MessageQueue.Label%2A> 다음 표에 나와 있는 것 처럼 큐 경로 설명 하기 위해 합니다.  
  
|참조|구문|예|  
|---------------|------------|-------------|  
|형식 이름|`FormatName:` [ *형식 이름을* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|레이블|`Label:` [ *레이블* ]|`Label:` TheLabel|  
  
 오프 라인으로 작업 하는 경로 이름 구문을 사용 하지 않고 생성자에 대 한 형식 이름 구문을 사용 해야 합니다. 그렇지 않으면 주 도메인 컨트롤러를 형식 이름에 경로 확인할 수 없기 때문에 예외가 throw 됩니다.  
  
 다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.MessageQueue>합니다. 이러한 값은 지정 된 경로와 메시지 큐의 속성에 기반는 `path` 매개 변수입니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.DefaultPropertiesToSend> 클래스입니다.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`"Body"; 경우 메시지 큐의 개인 정보 수준 설정 그렇지 않으면 `false`합니다.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|메시지 큐의 컴퓨터 이름 속성의 값입니다.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.MessagePropertyFilter> 클래스입니다.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>을 생성자에 의해 설정 되지 않은 경우.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>을 생성자에 의해 설정 되지 않은 경우.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`메시지 큐 개체의 저널 설정을 사용 합니다. 그렇지 않으면 `false`합니다.|  
  
   
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 다양 한 경로 이름 구문 형식을 사용 하 여 개체입니다. 각각의 경우에서 경로가 생성자에 정의 된 큐로 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 유효하지 않습니다(예: 속성을 설정하지 않은 경우).</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</param>
        <param name="sharedModeDenyReceive">
          첫 번째로 큐에 액세스하는 응용 프로그램에 단독 읽기 권한을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 경로에 위치하고 읽기 액세스 제한이 설정된 메시지 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 연결 하려는 경우이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue> 경로, 형식 이름 또는 레이블을 알아야 특정 메시지 큐에 있습니다. 큐를 참조 하는 첫 번째 응용 프로그램에 대 한 단독 액세스 권한을 부여 하려면, 설정 된 `sharedModeDenyReceive` 매개 변수를 `true`합니다. 그렇지 않으면 설정 `sharedModeDenyReceive` 를 `false` 만 생성자를 사용 하거나는 `path` 매개 변수입니다.  
  
 설정 `sharedModeDenyReceive` 를 `true` 다른 응용 프로그램을 포함 하 여 메시지 큐 큐에 액세스 하는 모든 개체에 영향을 줍니다. 매개 변수의 효과이 응용 프로그램에 제한 되지 않습니다.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자의 새 인스턴스를 만듭니다.는 <xref:System.Messaging.MessageQueue> 클래스입니다; 새 메시지 큐를 만들지 않습니다. 메시지 큐에서 새 큐를 만들려면 사용 <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.  
  
 구문은 `path` 매개 변수는 큐의 형식에 따라 달라 집니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
|저널 큐|`MachineName`\\`QueueName`\\`Journal$`|  
|컴퓨터 저널 큐|`MachineName`\\`Journal$`|  
|컴퓨터 배달 못 한 편지 큐|`MachineName`\\`Deadletter$`|  
|컴퓨터 트랜잭션 배달 못 한 편지 큐|`MachineName`\\`XactDeadletter$`|  
  
 또는 형식 이름 또는 메시지 큐의 레이블을 큐 경로 설명 하기 위해 사용할 수 있습니다.  
  
|참조|구문|예|  
|---------------|------------|-------------|  
|형식 이름|`FormatName:` [ *형식 이름을* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|레이블|`Label:` [ *레이블* ]|`Label:` TheLabel|  
  
 오프 라인으로 작업 하려면 이름 구문이 아닌 형식 이름 구문을 사용 해야 합니다. 그렇지 않으면 주 도메인 컨트롤러 (Active Directory 상주 하는) 형식 이름에 경로 확인할 수 없기 때문에 예외가 throw 됩니다.  
  
 경우는 <xref:System.Messaging.MessageQueue> 된 큐는 `sharedModeDenyReceive` 매개 변수 설정 `true`있으면 모든 <xref:System.Messaging.MessageQueue> 이후에 큐에서 읽으려 할 때마다 생성 하는 <xref:System.Messaging.MessageQueueException> 공유 위반입니다. A <xref:System.Messaging.MessageQueueException> 경우 throw 됩니다는 <xref:System.Messaging.MessageQueue> 할당이 단독 모드로 큐에에서 액세스 하려고 <xref:System.Messaging.MessageQueue> 이미 비독점적 큐에 액세스할 수 있습니다.  
  
 다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.MessageQueue>합니다. 이러한 값은 지정 된 경로와 메시지 큐 큐의 속성에 기반는 `path` 매개 변수입니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.DefaultPropertiesToSend> 클래스입니다.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`"Body"; 경우 메시지 큐의 개인 정보 수준 설정 그렇지 않으면 `false`합니다.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|메시지 큐의 컴퓨터 이름 속성의 값입니다.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.MessagePropertyFilter> 클래스입니다.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>을 생성자에 의해 설정 되지 않은 경우.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>을 생성자에 의해 설정 되지 않은 경우.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`sharedModeDenyReceive` 매개 변수의 값입니다.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`메시지 큐 개체의 저널 설정을 사용 합니다. 그렇지 않으면 `false`합니다.|  
  
   
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 단독 액세스 권한을 갖는 해당 경로 설정 하 고 큐에 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 유효하지 않습니다(예: 속성을 설정하지 않은 경우).</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</param>
        <param name="accessMode">
          <see cref="T:System.Messaging.QueueAccessMode" /> 값 중 하나입니다.</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</param>
        <param name="sharedModeDenyReceive">
          첫 번째로 큐에 액세스하는 응용 프로그램에 단독 읽기 권한을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="enableCache">
          연결 캐시를 만들어 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 단독 읽기 액세스 권한을 갖는 및 연결 캐싱을 사용할 수 있습니다.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</param>
        <param name="sharedModeDenyReceive">
          첫 번째로 큐에 액세스하는 응용 프로그램에 단독 읽기 권한을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="enableCache">
          연결 캐시를 만들어 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="accessMode">
          <see cref="T:System.Messaging.QueueAccessMode" /> 값 중 하나입니다.</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐의 액세스 모드를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Messaging.QueueAccessMode" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐에 대 한 기본 액세스 모드 `QueueAccessMode.SendAndReceive`생성자를 호출할 때 달리 지정 하지 않는 한 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐가 인증된 메시지만 허용하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          큐가 인증된 메시지만 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 인증에는 메시지 무결성을 보장 하 고 메시지를 보낸 사람을 확인 하는 방법을 제공 합니다. 인증을 요청 하려면 보내는 응용 프로그램 메시지의 인증 수준을 설정 합니다.  
  
 설정 하는 경우 <xref:System.Messaging.MessageQueue.Authenticate%2A> 를 `true`를 제한 하는 뿐만 아니라를이 서버에 있는 큐에 대 한 액세스 <xref:System.Messaging.MessageQueue> 인스턴스. 같은 메시지 큐에 대해 작동 하는 모든 클라이언트 적용 됩니다.  
  
 인증 된 메시지만 허용 하는 큐는 인증 되지 않은 메시지를 거부 합니다. 요청 거부 메시지의 알림, 보내는 응용 프로그램 설정 수는 <xref:System.Messaging.Message.AcknowledgeType%2A> 메시지의 속성입니다. 있기 때문에 거부 메시지의 다른 표시 되지 보내는 응용 프로그램 배달 못 한 편지 큐로 전송 될 것을 요청 하지 않으면 메시지가 손실 될 수 있습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.Authenticate%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>네트워크에서 공개 큐의 메시지를 라우팅하는 데 사용하는 기본 우선 순위 메시지 큐를 가져오거나 설정합니다.</summary>
        <value>(공개) 큐에 보내진 모든 메시지에 대한 단일 기본 우선 순위입니다. 기본값은 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐의 기본 우선 순위 네트워크를 통해 이동할 때 큐는 처리 되는 메시지 라우팅 방법을 지정 합니다. 설정할 수 있습니다는 <xref:System.Messaging.MessageQueue.BasePriority%2A> 속성을 높거나 더 낮은 우선 순위를 다른 큐에 전송 하는 것 보다 지정 된 큐로 보낸 모든 메시지를 제공 합니다. 이 속성을 설정 하면 메시지 큐를 수정 합니다. 따라서 다른 모든 <xref:System.Messaging.MessageQueue> 인스턴스 변경의 영향을 받는 합니다.  
  
 메시지 큐의 <xref:System.Messaging.MessageQueue.BasePriority%2A> 관련이 없는 <xref:System.Messaging.Message.Priority%2A> 들어오는 메시지가 큐에 배치 되는 순서를 지정 하는 메시지의 속성입니다.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> 공개 큐에만 형식 이름을 사용 하 여 해당 경로 지정 하는 적용 됩니다. 개인 큐의 기본 우선 순위는 항상 0입니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.BasePriority%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">기본 우선 순위가 잘못된 값으로 설정되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <summary>메시지 큐가 메시지 피킹(peeking)을 시작하도록 한 후, 작업을 마치면 이벤트 처리기에 알리도록 하여 비동기 피킹(peeking) 작업을 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>시간 제한이 없는 비동기 피킹(peeking) 작업을 시작합니다. 큐에서 메시지를 사용할 수 있을 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 메시지를 큐에 사용할 수 있습니다.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.  
  
 사용 하도록 <xref:System.Messaging.MessageQueue.BeginPeek%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다. <xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업; 시작 <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 도착할 때. <xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 또는 사용 하 여 결과 검색 하 여는 <xref:System.Messaging.PeekCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐를 피킹할 수 있습니다. 큐를 피킹할 동기적으로 처리를 사용 하 여는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.  
  
 비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.  
  
 <xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다. 이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 됩니다. 그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`완료 이벤트가 발생 하지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 라는 이벤트 처리기를 만들고 `MyPeekCompleted`에 연결는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자 및 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 경로에 있는 큐에서 비동기 작업을 시작 하려면 ". \myQueue"입니다. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하면이 예에서는 메시지를 관찰 합니다. 한 화면으로 해당 본문을 작성 합니다. 이 예에서는 다음 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 새 비동기 작업을 시작 하려면 다시 합니다.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>시간 제한이 지정된 비동기 피킹(peeking) 작업을 시작합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 메시지를 큐에 또는 지정된 된 시간 간격이 만료 될 때 사용할 수 있습니다.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.  
  
 사용 하도록 <xref:System.Messaging.MessageQueue.BeginPeek%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다. <xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업; 시작 <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 도착할 때. <xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 또는 사용 하 여 결과 검색 하 여는 <xref:System.Messaging.PeekCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐를 피킹할 수 있습니다. 큐를 피킹할 동기적으로 처리를 사용 하 여는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.  
  
 비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.  
  
 <xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다. 이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 됩니다. 그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 이 오버 로드 제한 시간을 지정 합니다. 으로 지정한 간격이 하는 경우는 `timeout` 매개 변수 만료 되 면이 구성 요소는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트입니다. 메시지가 없으므로 한 후속 호출에 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 예외가 throw 됩니다.  
  
 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`완료 이벤트가 발생 하지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 경로 사용 하 여 비동기 작업을 ". \myQueue"입니다. 이벤트 처리기를 만듭니다 `MyPeekCompleted`에 연결 된 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자입니다. <xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업을 시작 하는 1 분 시간 제한으로 호출 됩니다. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 또는 제한 시간이 만료 되 면 하나 있고, 해당 본문은 화면에 표시 하는 경우 메시지를 검색 합니다. 그런 다음 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 동일한 시간 제한 사용 하 여 새 비동기 작업을 시작 하기 위해 다시 호출 됩니다.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="stateObject">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</param>
        <summary>시간 제한 및 상태 개체가 지정되어 있는 비동기 피킹(peeking) 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 메시지를 큐에 또는 지정된 된 시간 간격이 만료 될 때 사용할 수 있습니다.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.  
  
 작업의 수명 주기 동안 유지 해야 하는 작업과 정보를 연결 하기 위해이 오버 로드를 사용 합니다. 이벤트 처리기 확인 하 여이 정보에 액세스할 수는 <xref:System.IAsyncResult.AsyncState%2A> 의 속성은 <xref:System.IAsyncResult> 작업과 연결 된입니다.  
  
 사용 하도록 <xref:System.Messaging.MessageQueue.BeginPeek%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다. <xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업; 시작 <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 도착할 때. <xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 또는 사용 하 여 결과 검색 하 여는 <xref:System.Messaging.PeekCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐를 피킹할 수 있습니다. 큐를 피킹할 동기적으로 처리를 사용 하 여는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.  
  
 비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 된 <xref:System.IAsyncResult> 는 메서드가 시작 된 비동기 작업을 식별 합니다. 이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 됩니다. 그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 이 오버 로드는 제한 시간 및 상태 개체를 지정합니다. 으로 지정한 간격이 하는 경우는 `timeout` 매개 변수 만료 되 면이 구성 요소는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트입니다. 메시지가 없으므로 한 후속 호출에 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 예외가 throw 됩니다.  
  
 상태 개체는 작업 상태 정보를 연결합니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다. 이 시나리오의 예시의 경우 "예" 섹션을 참조 하십시오.  
  
 또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다. 스레드 시작 되었지만 비동기 시나리오의 다른 스레드에서 콜백이, 하는 경우 상태 개체 마샬링되고 이벤트에서 정보와 함께 다시 전달 합니다.  
  
 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`완료 이벤트가 발생 하지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 경로 사용 하 여 비동기 작업을 ". \myQueue"입니다. 이벤트 처리기를 만듭니다 `MyPeekCompleted`에 연결 된 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자입니다. <xref:System.Messaging.MessageQueue.BeginPeek%2A> 라고, 1 분의 시간 제한을 사용 합니다. 호출할 때마다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 특정 작업을 식별 하는 연결 된 고유한 정수에 있습니다. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 제한 시간이 만료 또는 이벤트는 메시지에 있는 경우 검색 되 고 해당 본문 및 작업 별로 정수 식별자는 화면에 기록 됩니다. 그런 다음 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 동일한 제한 시간 및 완료 된 작업의 연결 된 정수 새 비동기 작업을 시작 하기 위해 다시 호출 됩니다.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="stateObject">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</param>
        <param name="callback">비동기 작업 완료에 대한 알림을 수신할 <see cref="T:System.AsyncCallback" />입니다.</param>
        <summary>시간 제한 및 상태 개체가 지정되어 있는 비동기 피킹(peeking) 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다. 이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 콜백 매개 변수에 지정 된 콜백 됩니다 때 직접 호출 메시지를 큐에 또는 지정된 된 시간 간격이 만료 되 면 사용할 수 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하지 않습니다. 다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면이 구성 요소에 의존는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐를 피킹할 수 있습니다. 큐를 피킹할 동기적으로 처리를 사용 하 여는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.  
  
 비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 된 <xref:System.IAsyncResult> 는 메서드가 시작 된 비동기 작업을 식별 합니다. 이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 됩니다. 그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 상태 개체는 작업 상태 정보를 연결합니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 작업을 만듭니다. 메시지를 로컬 메시지 큐는 코드 예제에서는 보낸 다음 호출 <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>를: 시간 제한 값이 10 초, 특정 메시지; 및의 새 인스턴스를 식별 하는 고유한 정수 <xref:System.AsyncCallback> 이벤트 처리기를 식별 하는 `MyPeekCompleted`. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하면 이벤트 처리기는 메시지를 관찰 하 고 화면에 메시지 본문 및 정수 메시지 식별자를 씁니다.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <param name="action">
          <see cref="T:System.Messaging.PeekAction" /> 값 중 하나입니다. 이 값은 큐의 현재 메시지를 피킹할지 또는 다음 메시지를 피킹할지 여부를 나타냅니다.</param>
        <param name="state">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</param>
        <param name="callback">비동기 작업 완료에 대한 알림을 수신하는 <see cref="T:System.AsyncCallback" />입니다.</param>
        <summary>지정된 제한 시간이 있고 지정된 커서, 지정된 피킹(peeking) 작업 및 지정된 상태 개체를 사용하는 비동기 피킹(peeking) 작업을 초기화합니다. 상태 개체는 전체 작업 기간 동안 관련 정보를 제공합니다. 이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하면 메시지는 큐 나 지정된 된 시간 간격이 만료 될 때 사용할 수 있을 때 콜백 매개 변수에 지정 된 콜백 직접 호출 됩니다. <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하지 않습니다. 다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면이 구성 요소에 의존는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐를 피킹할 수 있습니다. 큐를 피킹할 동기적으로 처리를 사용 하 여는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.  
  
 비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 된 <xref:System.IAsyncResult> 메서드에 의해 시작 된 비동기 작업을 식별 하는 합니다. 이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 됩니다. 그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 이 경우에 사용 된 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 상태 개체는 작업 상태 정보를 연결합니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="action" /> 매개 변수에 대해 <see langword="PeekAction.Current" /> 또는 <see langword="PeekAction.Next" /> 이외의 값을 지정했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <summary>메시지 큐가 메시지 수신을 시작하도록 한 후, 작업을 마치면 이벤트 처리기에 알리도록 하여 비동기 수신 작업을 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>시간 제한이 없는 비동기 수신 작업을 시작합니다. 큐에서 메시지를 사용할 수 있을 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트는 메시지 큐에서 제거 되었습니다.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.  
  
 사용 하도록 <xref:System.Messaging.MessageQueue.BeginReceive%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다. <xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 작업입니다. <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때. <xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐에서 메시지를 받을 수 있습니다. 사용 하 여 동기적으로 메시지를 받으려면는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.  
  
 비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.  
  
 <xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다. 이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 됩니다. 그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`완료 이벤트가 발생 하지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>합니다.  
  
 비동기 호출을 사용 하지 마십시오 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다. 트랜잭션 비동기 작업을 수행 하려는 경우 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, (동기) 하 여 트랜잭션을 저장 <xref:System.Messaging.MessageQueue.Receive%2A> 피크 (peek) 작업에 대해 만들 이벤트 처리기 내에서 메서드. 이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 요청을 연결 합니다. "MyQueue" 라는 로컬 컴퓨터에는 큐가 가정 합니다. `Main` 에서 처리 하는 비동기 작업을 시작 하는 함수는 `MyReceiveCompleted` 루틴입니다. `MyReceiveCompleted` 현재 메시지를 처리 하 고 새 시작 비동기 수신 작업입니다.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 다음 코드 예제에서는 비동기 요청을 대기합니다. 에 대 한 호출 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 사용 하 여는 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 해당 반환 값에 있습니다. `Main` 루틴 모든 비동기 작업을 종료 하기 전에 완료할 때까지 대기 합니다.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>시간 제한이 지정된 비동기 수신 작업을 시작합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 메시지를 큐에 또는 지정된 된 시간 간격이 만료 될 때 사용할 수 있습니다.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.  
  
 사용 하도록 <xref:System.Messaging.MessageQueue.BeginReceive%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다. <xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 작업입니다. <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때. <xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 하거나 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐에서 메시지를 받을 수 있습니다. 사용 하 여 동기적으로 메시지를 받으려면는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.  
  
 비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.  
  
 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`완료 이벤트가 발생 하지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>합니다.  
  
 <xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다. 이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 됩니다. 그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 이 오버 로드 제한 시간을 지정 합니다. 으로 지정한 간격이 하는 경우는 `timeout` 매개 변수 만료 되 면이 구성 요소는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트입니다. 메시지가 없으므로 한 후속 호출에 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 예외가 throw 됩니다.  
  
 비동기 호출을 사용 하지 마십시오 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다. 트랜잭션 비동기 작업을 수행 하려는 경우 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, (동기) 하 여 트랜잭션을 저장 <xref:System.Messaging.MessageQueue.Receive%2A> 피크 (peek) 작업에 대해 만들 이벤트 처리기 내에서 메서드. 이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 수신 작업입니다. 코드 예제에서는 이벤트 처리기를 `MyReceiveCompleted`에 연결 된 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 처리기 대리자입니다. 메시지를 로컬 메시지 큐는 코드 예제에서는 보낸 다음 호출 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>시간 제한 값이 10 초 이내에 전달 합니다. 경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면 이벤트 처리기는 메시지를 수신 하 고 화면에 메시지 본문을 씁니다.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우 (예: 값이 음수인 경우)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="stateObject">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</param>
        <summary>시간 제한 및 상태 개체가 지정되어 있는 비동기 수신 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 메시지를 큐에 또는 지정된 된 시간 간격이 만료 될 때 사용할 수 있습니다.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.  
  
 작업의 수명 주기 동안 유지 해야 하는 작업과 정보를 연결 하기 위해이 오버 로드를 사용 합니다. 이벤트 처리기 확인 하 여이 정보를 검색할 수는 <xref:System.IAsyncResult.AsyncState%2A> 의 속성은 <xref:System.IAsyncResult> 작업과 연결 된입니다.  
  
 사용 하도록 <xref:System.Messaging.MessageQueue.BeginReceive%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다. <xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 작업입니다. <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때. <xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 하거나 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐에서 메시지를 받을 수 있습니다. 사용 하 여 동기적으로 메시지를 받으려면는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.  
  
 비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.  
  
 <xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다. 이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 됩니다. 그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 이 오버 로드는 제한 시간 및 상태 개체를 지정합니다. 으로 지정한 간격이 하는 경우는 `timeout` 매개 변수 만료 되 면이 구성 요소는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트입니다. 메시지가 없으므로 한 후속 호출에 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 예외가 throw 됩니다.  
  
 상태 개체는 작업 상태 정보를 연결합니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.  
  
 또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다. 스레드 시작 되었지만 비동기 시나리오의 다른 스레드에서 콜백이, 하는 경우 상태 개체 마샬링되고 이벤트에서 정보와 함께 다시 전달 합니다.  
  
 비동기 호출을 사용 하지 마십시오 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다. 트랜잭션 비동기 작업을 수행 하려는 경우 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, (동기) 하 여 트랜잭션을 저장 <xref:System.Messaging.MessageQueue.Receive%2A> 피크 (peek) 작업에 대해 만들 이벤트 처리기 내에서 메서드. 이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 수신 작업입니다. 코드 예제에서는 이벤트 처리기를 `MyReceiveCompleted`에 연결 된 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 처리기 대리자입니다. 메시지를 로컬 메시지 큐는 코드 예제에서는 보낸 다음 호출 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>시간 제한 값이 10 초에 한 및 특정 메시지를 식별 하는 고유한 정수에 전달 합니다. 경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면 이벤트 처리기는 메시지를 받고 메시지 본문과 정수 메시지 식별자를 화면에 출력 합니다.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="stateObject">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</param>
        <param name="callback">비동기 작업 완료에 대한 알림을 수신할 <see cref="T:System.AsyncCallback" />입니다.</param>
        <summary>시간 제한 및 상태 개체가 지정되어 있는 비동기 수신 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다. 이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 콜백 매개 변수에 지정 된 콜백 됩니다 때 직접 호출 메시지를 큐에 또는 지정된 된 시간 간격이 만료 되 면 사용할 수 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하지 않습니다. 다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면이 구성 요소에 의존는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.  
  
 사용 하도록 <xref:System.Messaging.MessageQueue.BeginReceive%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다. <xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 작업입니다. <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때. <xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 하거나 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐에서 메시지를 받을 수 있습니다. 사용 하 여 동기적으로 메시지를 받으려면는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.  
  
 비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.  
  
 <xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다. 이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 됩니다. 그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 상태 개체는 작업 상태 정보를 연결합니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.  
  
 또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다. 스레드 시작 되었지만 비동기 시나리오의 다른 스레드에서 콜백이, 하는 경우 상태 개체 마샬링되고 이벤트에서 정보와 함께 다시 전달 합니다.  
  
 비동기 호출을 사용 하지 마십시오 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다. 트랜잭션 비동기 작업을 수행 하려는 경우 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, (동기) 하 여 트랜잭션을 저장 <xref:System.Messaging.MessageQueue.Receive%2A> 피크 (peek) 작업에 대해 만들 이벤트 처리기 내에서 메서드. 이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 수신 작업입니다. 메시지를 로컬 메시지 큐는 코드 예제에서는 보낸 다음 호출 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>를: 시간 제한 값이 10 초, 특정 메시지; 및의 새 인스턴스를 식별 하는 고유한 정수 <xref:System.AsyncCallback> 이벤트 처리기를 식별 하는 `MyReceiveCompleted`. 경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면 이벤트 처리기는 메시지를 받고 메시지 본문과 정수 메시지 식별자를 화면에 출력 합니다.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <param name="state">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</param>
        <param name="callback">비동기 작업 완료에 대한 알림을 수신하는 <see cref="T:System.AsyncCallback" />입니다.</param>
        <summary>지정된 제한 시간이 있고 지정된 커서 및 지정된 상태 개체를 사용하는 비동기 수신 작업을 초기화합니다. 상태 개체는 전체 작업 기간 동안 관련 정보를 제공합니다. 이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 콜백 매개 변수에 지정 된 콜백 됩니다 때 직접 호출 메시지를 큐에 또는 지정된 된 시간 간격이 만료 되 면 사용할 수 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하지 않습니다. 다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면이 구성 요소에 의존는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.  
  
 사용 하도록 <xref:System.Messaging.MessageQueue.BeginReceive%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다. <xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 작업입니다. <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때. <xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 하거나 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐에서 메시지를 받을 수 있습니다. 사용 하 여 동기적으로 메시지를 받으려면는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.  
  
 비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.  
  
 <xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다. 이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 됩니다. 그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 이 경우에 사용 된 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 상태 개체는 작업 상태 정보를 연결합니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.  
  
 또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다. 스레드 시작 되었지만 비동기 시나리오의 다른 스레드에서 콜백이, 하는 경우 상태 개체 마샬링되고 이벤트에서 정보와 함께 다시 전달 합니다.  
  
 비동기 호출을 사용 하지 마십시오 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다. 트랜잭션 비동기 작업을 수행 하려는 경우 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, (동기) 하 여 트랜잭션을 저장 <xref:System.Messaging.MessageQueue.Receive%2A> 피크 (peek) 작업에 대해 만들 이벤트 처리기 내에서 메서드. 이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" />를 읽을 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" />가 있고 응용 프로그램에서 이 큐를 읽을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> 응용 프로그램 큐에서 메시지를 받거나 피킹 수 인지를 나타냅니다. 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `true`, <xref:System.Messaging.MessageQueue> 받거나 큐에서 메시지를 피킹할 수 있습니다. 그렇지 않으면 만들 수 없습니다.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> `false` 큐가 이미 단독 읽기 권한으로 열려 있으면 (비독점 액세스 하 고이 열려 있는 경우 또는 <xref:System.Messaging.MessageQueue> 단독 액세스를 요청), 응용 프로그램에 액세스할 수 있는 충분 한 권한이 없는 경우 또는 합니다. 응용 프로그램이 큐에서 읽기를 시도 하면 때 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`, 액세스가 거부 되었습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.CanRead%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" />에 쓸 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" />가 있고 응용 프로그램이 여기에 쓸 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> 응용 프로그램은 큐에 메시지를 보낼 수 있는지 여부를 나타냅니다. 경우 <xref:System.Messaging.MessageQueue.CanWrite%2A> 은 `true`, <xref:System.Messaging.MessageQueue> 큐에 메시지를 보낼 수 있습니다. 그렇지 않으면 만들 수 없습니다.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> `false` 큐가 이미 단독 쓰기 권한으로 열려 있으면 (비독점 액세스 하 고이 열려 있는 경우 또는 <xref:System.Messaging.MessageQueue> 단독 액세스를 요청), 응용 프로그램에 액세스할 수 있는 충분 한 권한이 없는 경우 또는 합니다. 응용 프로그램이 큐에 쓰려고 시도 하면 때 <xref:System.Messaging.MessageQueue.CanWrite%2A> 은 `false`, 액세스가 거부 되었습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.CanWrite%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐 범주를 가져오거나 설정합니다.</summary>
        <value>큐 범주(메시지 큐 형식 식별자)를 나타내는 <see cref="T:System.Guid" />입니다. 여기서 응용 프로그램을 사용하여 큐를 분류할 수 있습니다. 기본값은 <see langword="Guid.empty" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐 범주에 응용을 프로그램에서 큐를 분류할 수 있습니다. 예를 들어 하나의 범주 및 다른 모든 주문 큐에 모든 청구 큐를 배치할 수 있습니다.  
  
 <xref:System.Messaging.MessageQueue.Category%2A> 속성은 메시지 큐 형식 ID 속성 (즉, 읽기/쓰기)에 대 한 액세스를 제공을 통해 액세스할 수는 **큐 속성** 컴퓨터 관리 콘솔에서 대화 상자. 새 범주를 정의할 수 있습니다. 사용할 수 있지만 <xref:System.Guid.NewGuid%2A> 는 모든 고유 범주 값을 만들려면 <xref:System.Guid> 값, 이러한 작업이 필요 하지 않습니다. 범주 값이 다른 범주에서가 아니라 다른 모든 구별 되도록 <xref:System.Guid> 값입니다. 할당할 수는 예를 들어 {00000000-0000-0000-0000-000000000001} 로 <xref:System.Messaging.MessageQueue.Category%2A> 한 집합 큐에 대 한 및 {00000000-0000-0000-0000-000000000002} 로 <xref:System.Messaging.MessageQueue.Category%2A> 다른 집합에 대 한 합니다.  
  
 설정 하려면 필요 없는 <xref:System.Messaging.MessageQueue.Category%2A>합니다. 값은 `null`이 될 수 있습니다.  
  
 이 속성을 설정 하면 메시지 큐를 수정 합니다. 따라서 다른 모든 <xref:System.Messaging.MessageQueue> 인스턴스 변경의 영향을 받는 합니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.Category%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">우선 순위 범주가 잘못된 값으로 설정되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>연결 캐시를 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 경우 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, 캐시에 저장 되는 형식 이름을 제거 되 고 핸들이 열리고 캐시에 저장 된 닫혀 있습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>를 호출합니다.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" />가 할당한 리소스를 모두 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> 와 연결 된 모든 리소스를 해제 한 <xref:System.Messaging.MessageQueue>를 포함 하 여 공유 리소스에 해당 하는 경우. 시스템 다시 이러한 리소스를 가져옵니다 자동으로 계속 사용할 수 있는, 예를 들어 호출 하는 경우는 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> 다음 C# 코드와 같이 메서드를 합니다.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 호출 하는 경우 <xref:System.Messaging.MessageQueue.Close%2A>모든 <xref:System.Messaging.MessageQueue> 메시지 큐를 직접 액세스 하는 속성이 지워집니다. <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, 및 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 모두 그대로 유지 됩니다.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> 읽기 및 공유 되어 때문에 큐에 쓰기 핸들 항상 하지 않습니다. 확인 하려면 다음 단계를 사용할 수 있는 <xref:System.Messaging.MessageQueue.Close%2A> 큐에 대 한 읽기 및 쓰기 핸들을 해제 합니다.  
  
-   만들기는 <xref:System.Messaging.MessageQueue> 단독 액세스 권한을 갖는 합니다. 이렇게 하려면 호출는 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> 또는 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 생성자 및 집합은 `sharedModeDenyReceive` 매개 변수를 `true`합니다.  
  
-   만들기는 <xref:System.Messaging.MessageQueue> 연결 캐싱을 사용 하지 않도록 설정 합니다. 이렇게 하려면 호출는 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 집합과, 생성자는 `enableConnectionCache` 매개 변수를 `false`합니다.  
  
-   연결 캐싱을 사용 하지 않도록 설정 합니다. 이 위해 설정 된 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 속성을 `false`합니다.  
  
 호출 해야 <xref:System.Messaging.MessageQueue.Close%2A> 메시지 큐 서버에 있는 큐를 삭제 하기 전에 큐에 대 한 합니다. 그렇지 않은 경우 큐에 전송 된 메시지 예외를 throw 하거나 배달 못 한 편지 큐에 표시 수 없습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐를 닫습니다.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>메시지 큐 서버의 지정된 경로에 새 큐를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">만들 큐의 경로입니다.</param>
        <summary>지정된 경로에 비트랜잭션 메시지 큐를 만듭니다.</summary>
        <returns>새 큐를 나타내는 <see cref="T:System.Messaging.MessageQueue" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 메시지 큐 비트랜잭션 큐를 만들 수 있습니다.  
  
 새 인스턴스를 만드는 <xref:System.Messaging.MessageQueue> 응용 프로그램에서 클래스 및 기존 큐를 바인딩, 사용 하 여는 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자입니다. 메시지 큐에서 새 큐를 만들려면, <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.  
  
 에 대 한 구문에서 `path` 매개 변수 유형에 따라 다릅니다 큐의 해당 참조는 다음 표에 나와 있는 것 처럼 합니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
  
 사용 하 여 "." 로컬 컴퓨터에 대 한 합니다. 자세한 구문에 대 한 참조는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 공용 및 개인 큐를 만듭니다. 선택한 큐에 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">지정된 경로에 큐가 이미 존재합니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">만들 큐의 경로입니다.</param>
        <param name="transactional">
          트랜잭션 큐를 만들려면 <see langword="true" />이고, 비트랜잭션 큐를 만들려면 <see langword="false" />입니다.</param>
        <summary>지정된 경로에 트랜잭션 또는 비트랜잭션 메시지 큐를 만듭니다.</summary>
        <returns>새 큐를 나타내는 <see cref="T:System.Messaging.MessageQueue" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐에서 트랜잭션 큐를 만들려면이 오버 로드를 사용할 수 있습니다. 설정 하 여 비트랜잭션 큐를 만들 수는 `transactional` 매개 변수를 `false` 의 다른 오버 로드를 호출 하 여 <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.  
  
 새 인스턴스를 만드는 <xref:System.Messaging.MessageQueue> 응용 프로그램에서 클래스 및 기존 큐를 바인딩, 사용 하 여는 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자입니다. 메시지 큐에서 새 큐를 만들려면, <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.  
  
 에 대 한 구문에서 `path` 매개 변수 유형에 따라 다릅니다 큐의 해당 참조는 다음 표에 나와 있는 것 처럼 합니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
  
 사용 하 여 "." 로컬 컴퓨터에 대 한 합니다. 자세한 구문에 대 한 참조는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 공용 및 개인 트랜잭션 큐를 만듭니다. 선택한 큐에 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">지정된 경로에 큐가 이미 존재합니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 메시지 큐의 새 <see cref="T:System.Messaging.Cursor" />를 만듭니다.</summary>
        <returns>현재 메시지 큐의 새 <see cref="T:System.Messaging.Cursor" />입니다. 이 커서는 큐의 메시지를 읽을 때 큐의 특정 위치를 유지하는 데 사용됩니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 큐에서 큐가 만들어진 날짜와 시간을 가져옵니다.</summary>
        <value>큐가 만들어진 날짜와 시간을 나타내는 <see cref="T:System.DateTime" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> 메시지 큐 서버에 있는 큐를으로 참조는 <xref:System.Messaging.MessageQueue> 인스턴스.  
  
 큐가 있으면이 속성은 큐가 있는 서버의 현지 시간으로 조정 큐를 만든 시간을 나타냅니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.CreateTime%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 큐에 메시지를 보낼 때 기본적으로 사용되는 메시지 속성 값을 가져오거나 설정합니다.</summary>
        <value>응용 프로그램에서 <see cref="T:System.Messaging.DefaultPropertiesToSend" /> 인스턴스 이외의 개체를 큐에 보낼 때 사용된 기본 메시지 큐 메시지 속성 값이 포함된 <see cref="T:System.Messaging.Message" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다른 형식의 모든 개체를 보낼 때 <xref:System.Messaging.Message> 큐에는 <xref:System.Messaging.MessageQueue> 메시지 큐 메시지 개체를 삽입 합니다. 그 당시는 <xref:System.Messaging.MessageQueue> 속성 값을 지정할 때에 메시지에 적용 되는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성입니다. 반대로, 보내는 경우는 <xref:System.Messaging.Message> 큐에 이러한 속성이 이미 지정 되어 인스턴스 자체에 대 한 하므로 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 에 대해 무시 됩니다는 <xref:System.Messaging.Message>합니다.  
  
 통해 속성을 설정할 수 있지만 <xref:System.Messaging.MessageQueue> 개체는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 큐 자체 큐로 전송 된 메시지의 속성을 참조 합니다.  
  
 속성에 대 한 기본 값은 다음 표에 표시 됩니다.  
  
|속성|기본값|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|영 (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|바이트 길이가 0 인 배열|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 보낼 메시지에 대 한 기본 속성을 확인 하는 메시지의 우선 순위를 사용 합니다.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">큐에 대한 기본 속성을 설정할 수 없습니다(예: 속성 중 하나가 잘못된 경우).</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">삭제할 큐의 위치입니다.</param>
        <summary>메시지 큐 서버에 있는 큐를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 구문에서 `path` 매개 변수는 큐의 형식에 따라 달라 집니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
  
 자세한 구문에 대 한 참조는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.  
  
 사용할 수 있습니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 또는 <xref:System.Messaging.MessageQueue.Label%2A> 큐 경로 설명 하기 위해.  
  
|참조|구문|  
|---------------|------------|  
|형식 이름|FormatName: [ *형식 이름을* ]|  
|레이블|레이블: [ *레이블* ]|  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 있는 경우는 메시지 큐의 큐를 삭제 합니다.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <paramref name="path" /> 매개 변수에 대한 구문이 잘못된 경우.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 메시지 큐에서 메시지를 받기 위한 단독 액세스 권한을 갖는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          이 <see cref="T:System.Messaging.MessageQueue" />가 큐에서 메시지를 받기 위한 단독 권한을 갖는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 이 참조 하는 큐의 공유 모드를 지정 <xref:System.Messaging.MessageQueue>합니다. 설정 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 를 `true` 만 나타내기 위해이 <xref:System.Messaging.MessageQueue> 지정 된 큐에서 메시지를 받거나 피킹에 대해 액세스 권한이 <xref:System.Messaging.MessageQueue.Path%2A>합니다. 다른 경우 <xref:System.Messaging.MessageQueue> 또는 해당 인스턴스는 동일한 큐 리소스와 연결 된 다른 응용 프로그램 또는 응용 프로그램 보기 또는 메시지를 받을 수는 없지만 보낼 여전히 수 있습니다.  
  
 경우 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 은 `false`, 큐를 보내기, 보기, 또는 메시지를 받기 위해 여러 응용 프로그램에 사용할 수 있습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" />에서 사용하는 리소스(메모리 제외)를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 사용을 마치면 <xref:System.Messaging.MessageQueue>를 호출합니다. <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 메서드를 사용하면 <xref:System.Messaging.MessageQueue>를 사용할 수 없게 됩니다. 호출한 후 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>에 대 한 모든 참조를 해제 해야는 <xref:System.Messaging.MessageQueue> 차지 했던 메모리를 가비지 수집에 의해 회수 될 수 있도록 합니다.  
  
 호출 해야 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 에 대 한 마지막 참조를 해제 하기 전에 <xref:System.Messaging.MessageQueue>합니다. 그렇지 않으면 리소스는 <xref:System.Messaging.MessageQueue> 는 사용 하 여 해제 되지 것입니다 가비지 컬렉션 호출할 때까지 <xref:System.Messaging.MessageQueue> 개체의 소멸자가 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결 캐시가 응용 프로그램에 의해 유지 관리될지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          연결 캐시를 만들어 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 캐시는 큐로 쓰기 핸들 또는 읽기를 포함 하는 구조에 대 한 참조의 목록입니다. 때 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 은 `true`, <xref:System.Messaging.MessageQueue> 호출할 때마다 캐시에서 처리를 빌리 기 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, 또는 <xref:System.Messaging.MessageQueue.Receive%2A>, 열려 있는 새 핸들이 대신 합니다. 이 경우 성능을 향상 시킬 수 있습니다. 분리도 연결 캐시를 사용 하 여는 <xref:System.Messaging.MessageQueue> 네트워크 토폴로지에 변경 된 내용입니다.  
  
 연결 캐시 꽉 큐에 새 연결을 만드는 경우는 <xref:System.Messaging.MessageQueue> 새 연결을 가장 최근에 액세스 된 구조를 덮어씁니다. 호출 하 여 완전히 캐시를 지울 수 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, 예를 들어 이전 읽기 및 쓰기 핸들을 사용할 더 이상 사용 하는 큐의 형식 이름이 변경 된 경우.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐에서 비개인(암호화되지 않은) 메시지만 허용하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Messaging.EncryptionRequired" /> 값 중 하나입니다. 기본값은 <see langword="None" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐로 전송 된 메시지에 해당 암호화가 필요한을 지정 하면 메시지 본문에만 암호화 됩니다. 다른 멤버 (예를 들어는 <xref:System.Messaging.Message.Label%2A> 및 <xref:System.Messaging.Message.SenderId%2A> 속성) 암호화할 수 없습니다.  
  
 이 속성을 설정 하면 메시지 큐를 수정 합니다. 따라서 다른 모든 <xref:System.Messaging.MessageQueue> 인스턴스 변경의 영향을 받는 합니다.  
  
 메시지를 암호화 하면 메시지 개인 합니다. 큐의 암호화 요구 사항 수를 지정할 수 있습니다 `None`, `Body`, 또는 `Optional` 설정 하 여는 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> 속성 적절 하 게 합니다. <xref:System.Messaging.Message.UseEncryption%2A> 메시지의 설정을 큐의 암호화 요구 사항 일치 해야 합니다. 메시지가 암호화 되지 않았지만 큐를 지정 하는 경우 `Body`, 메시지를 암호화 하지만 큐를 지정 하는 경우 또는 `None`, 메시지 큐에서 거부 됩니다. 이 이벤트에서 부정 승인 메시지를 요청 하는 송신 응용 프로그램 메시지 큐는 보내는 응용 프로그램 메시지의 거부를 나타냅니다. 경우는 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성은 `true`, 암호화 실패 한 메시지는 배달 못 한 편지 큐로 보내집니다. 그렇지 않은 경우 메시지가 손실 됩니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />는 종료한 후 최종 결과를 검색해 올 비동기 피킹(peeking) 작업을 식별합니다.</param>
        <summary>지정된 비동기 피킹(peeking) 작업을 완료합니다.</summary>
        <returns>완료된 비동기 작업과 관련된 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 의해 시작 된 작업이 완료 되는 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 호출 합니다. 이렇게 하려면 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 메시지를 관찰 합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 로 인해 시간 초과 지정할 수는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 표시 되기 전에 제한 시간이 발생 하는 경우 발생 합니다. 초과 된 경우 후속 호출을 큐에 도착 하는 메시지 없이 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 예외를 throw 합니다.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 시킨 메시지를 읽는 데 사용 되는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 발생 합니다.  
  
 다시 호출 수를 비동기적으로 메시지를 피킹할 계속 하려면 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 호출한 후 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 라는 이벤트 처리기를 만들고 `MyPeekCompleted`에 연결는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자 및 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 경로에 있는 큐에서 비동기 작업을 시작 하려면 ". \myQueue"입니다. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하면이 예에서는 메시지를 관찰 합니다. 한 화면으로 해당 본문을 작성 합니다. 이 예에서는 다음 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 새 비동기 작업을 시작 하려면 다시 합니다.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 매개 변수의 구문이 잘못된 경우.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />는 종료한 후 최종 결과를 검색해 올 비동기 수신 작업을 식별합니다.</param>
        <summary>지정된 비동기 수신 작업을 완료합니다.</summary>
        <returns>완료된 비동기 작업과 관련된 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 의해 시작 된 작업이 완료 되는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 호출 합니다. 이렇게 하려면 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 메시지를 받습니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 로 인해 시간 초과 지정할 수는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 표시 되기 전에 제한 시간이 발생 하는 경우 발생 합니다. 초과 된 경우 후속 호출을 큐에 도착 하는 메시지 없이 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 예외를 throw 합니다.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 메시지를 발생 시킨 (큐에서 제거 됨) 읽는 데 사용 되는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 발생 합니다.  
  
 다시 호출 수를 비동기적으로 메시지를 받을 계속 하려면 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 호출한 후 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 요청을 연결 합니다. "MyQueue" 라는 로컬 컴퓨터에는 큐가 가정 합니다. `Main` 에서 처리 하는 비동기 작업을 시작 하는 함수는 `MyReceiveCompleted` 루틴입니다. `MyReceiveCompleted` 현재 메시지를 처리 하 고 새 시작 비동기 수신 작업입니다.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 매개 변수의 구문이 잘못된 경우.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">찾을 큐의 위치입니다.</param>
        <summary>지정된 경로에 메시지 큐가 있는지 여부를 확인합니다.</summary>
        <returns>
          지정된 경로에 큐가 있으면 <see langword="true" />를 반환하고, 그렇지 않으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 메서드 메시지 큐가 지정된 된 경로에 있는지 여부를 결정 합니다. 지정 된 형식 이름 가진 큐가 있는지 여부를 확인 메서드가 있습니다. 형식 이름 구문 및 다른 경로 구문 형식에 대 한 자세한 내용은 참조는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 부담이 큰 작업이입니다. 응용 프로그램 내에서 필요한 경우에 사용 합니다.  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 방법은 지원 하지 않습니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 접두사입니다.  
  
 에 대 한 구문은 `path` 매개 변수는 다음 표에 나와 있는 것 처럼 큐의 형식에 의존 합니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 원격 개인 큐의 존재 여부를 확인 하려면 호출할 수 없습니다.  
  
 자세한 구문에 대 한 참조는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.  
  
 사용할 수 있습니다는 <xref:System.Messaging.MessageQueue.Label%2A> 큐 경로 설명 하기 위해.  
  
|참조|구문|  
|---------------|------------|  
|레이블|레이블: [ `label` ]|  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐가 있는 경우 한 다음 삭제 여부를 확인 합니다.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 구문이 잘못되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우  
  
 또는  
  
 <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> 메서드가 원격 개인 큐에서 호출되는 경우</exception>
        <exception cref="T:System.InvalidOperationException">큐가 있는지 여부를 확인할 때 응용 프로그램이 형식 이름 구문을 사용했습니다.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐를 작성할 때 메시지 큐가 발생시킨 고유한 큐 이름을 가져옵니다.</summary>
        <value>네트워크에서 고유한 큐 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A> 속성 큐의 형식 이름을 포함 합니다. 메시지 큐 큐를 열려는 및 액세스 하는 방법을 식별 하는 형식 이름을 사용 합니다. 대부분의 큐의 특성에서는 달리 형식 이름을 하지 않으므로 메시지 큐 응용 프로그램 큐 속성을 메시지 큐 관리 도구를 통해 액세스할 수 없습니다. 형식 이름은 큐에 대 한 고유한 이름을 단순히 메시지 큐는 큐 또는 응용 프로그램을 나중에 생성 하는 메시지를 만들 때 생성 됩니다.  
  
 경로 이름 구문을 사용 하 여 경로 지정 하는 경우 (같은 `myComputer\myQueue`) (사용 하 여 Active Directory)는 주 도메인 컨트롤러를 읽거나 큐에 쓸 때 형식 이름 구문을 사용 하는 대신 변환는 <xref:System.Messaging.MessageQueue.Path%2A> 관련된 에<xref:System.Messaging.MessageQueue.FormatName%2A> 큐에 액세스 하기 전에. 형식 이름 구문을;를 사용 해야 응용 프로그램을 오프 라인으로 작업 하는 경우 그렇지 않으면 주 도메인 컨트롤러의 경로 변환 하는 데 사용할 수 없습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.FormatName%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" />이 설정되지 않은 경우  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐에서 읽거나 쓴 메시지 본문으로 개체를 serialize하거나 그 메시지 본문에서 개체를 deserialize하는 데 사용되는 포맷터를 가져오거나 설정합니다.</summary>
        <value>메시지 본문에서 쓰거나 읽는 스트림을 만드는 <see cref="T:System.Messaging.IMessageFormatter" />입니다. 기본값은 <see cref="T:System.Messaging.XmlMessageFormatter" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A> 속성 응용 프로그램을 읽거나 큐에 쓸 때 메시지를 변환 하는 포맷터 개체의 인스턴스를 포함 합니다.  
  
 응용 프로그램 큐로 메시지를 보내면, 포맷터는 개체를 스트림으로 serialize 하 고 메시지 본문에 삽입 합니다. 큐에서 읽을 때 포맷터는 메시지 데이터에는 <xref:System.Messaging.Message.Body%2A> 속성은 <xref:System.Messaging.Message>합니다.  
  
 <xref:System.Messaging.XmlMessageFormatter> 는 느슨하게 결합 되어 있으므로이 형식을 사용 하는 경우에 발신자와 수신자 입력 동일한 개체를 설정할 필요가 없습니다. <xref:System.Messaging.ActiveXMessageFormatter> 및 <xref:System.Messaging.BinaryMessageFormatter> 이진 표현으로 데이터를 직렬화 합니다. <xref:System.Messaging.ActiveXMessageFormatter> COM 구성 요소를 받거나 보낼 때 사용 됩니다.  
  
 <xref:System.Messaging.BinaryMessageFormatter> 및 <xref:System.Messaging.ActiveXMessageFormatter> 보다 더 빠르게 처리는 <xref:System.Messaging.XmlMessageFormatter>합니다. <xref:System.Messaging.ActiveXMessageFormatter> Visual Basic 6.0 메시지 큐 응용 프로그램과 상호 운용성을 허용 합니다.  
  
 응용 프로그램 큐에 메시지를 보낼 때의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 기본 메시지 속성을 사용 하는 해당 메시지에만 적용 됩니다 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>합니다. 보내는 경우는 <xref:System.Messaging.Message> 큐에 메시지 큐 사용 하 여에 정의 된 포맷터는 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 대신 본문을 serialize 할 속성입니다.  
  
 <xref:System.Messaging.MessageQueue> 클래스는 항상 사용는 <xref:System.Messaging.Message> 받거나 큐에서 메시지를 피킹할 합니다. 메시지를 사용 하 여 deserialize 되는 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 서식을 사용 하 여 메시지 본문을 보여 줍니다. <xref:System.Messaging.BinaryMessageFormatter>합니다.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 다음 코드 예제에서는 서식을 사용 하 여 메시지 본문을 보여 줍니다. <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>큐에 있는 메시지를 모두 반환합니다.</summary>
        <returns>큐에 있는 모든 메시지를 메시지 큐에서 표시되는 것과 동일한 순서로 나타내는 <see cref="T:System.Messaging.Message" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 이러한 메시지를 큐에 메시지, 동적 아님 링크의 정적 스냅숏을 반환합니다. 따라서 큐에서 메시지를 수정 하는 배열을 사용할 수 없습니다. (예: 메시지를 삭제 하는 기능) 큐와 상호 작용을 실시간으로 동적 호출의 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 메서드를 큐에 있는 메시지의 동적 목록을 반환 합니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 메서드가 호출 된 시간에 큐에서 메시지의 복사본을 반환, 큐에 도착 하는 새로운 메시지 또는 메시지 큐에서 제거 된 배열을 반영 하지 않습니다.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 에 의해 필터링 되지 속성만 검색는 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>큐의 메시지를 열거합니다. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" />은 사용되지 않습니다. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />를 대신 사용해야 합니다.</summary>
        <returns>큐에 있는 메시지에 대한 동적 연결을 제공하는 <see cref="T:System.Collections.IEnumerator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.GetEnumerator%2A>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">큐가 포함된 컴퓨터의 이름이며 앞에 백슬래시 두 개(\\\\)가 없습니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐가 있는 컴퓨터의 식별자를 가져옵니다.</summary>
        <returns>큐가 있는 컴퓨터의 고유 식별자를 나타내는 <see cref="T:System.Guid" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컴퓨터의 식별자를 사용 하 여 다른 규칙 으로부터 다음 두 가지 목적: 보안 인증서를 설정 하 고 컴퓨터 저널을 읽을 수 있습니다. 그러나 호출할 수 없습니다 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> 작업 하는 경우 오프 라인 도메인 컨트롤러에서 응용 프로그램 디렉터리 서비스에 액세스 해야 하기 때문에 원격 컴퓨터에 대 한 합니다.  
  
 컴퓨터 식별자 (또는 컴퓨터 식별자)는 한 <xref:System.Guid> 메시지 큐 엔터프라이즈에 컴퓨터가 추가 될 때 만들어지는 합니다. 메시지 큐 컴퓨터 식별자와 결합 된 `Machine` 및 `Journal` 키워드 구문을 컴퓨터 저널 형식 이름을 만드는 데 `Machine=<computeridentifier>;Journal`합니다. 라고도 하는 저널 큐로는의 복사본을 저장 하는 시스템 큐 응용 프로그램에서 생성 된 경우 컴퓨터 저널 경우 메시지는 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> 속성은 `true`합니다.  
  
 이 구문은 업무 일지 큐에 대 한 형식 이름을 생성 하는 경우에 유효 합니다. 경로 이름 구문은 `MachineName` \\ `Journal$`합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>를 호출합니다.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">오프라인으로 작업하는 경우와 같이 디렉터리 서비스를 사용할 수 없기 때문에 컴퓨터 식별자를 검색할 수 없습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>큐에 있는 모든 메시지에 대해 열거자 개체를 만듭니다. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />은 사용되지 않습니다. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />를 대신 사용해야 합니다.</summary>
        <returns>큐에 있는 메시지를 보유하는 <see cref="T:System.Messaging.MessageEnumerator" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 큐에 있는 모든 메시지의 동적 목록을 만듭니다. 제거할 수 있습니다는 큐에서 열거자의 현재 위치에서 메시지를 호출 하 여 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 에 대 한는 <xref:System.Messaging.MessageEnumerator> 하 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 반환 합니다.  
  
 커서가 연결 된 큐에 메시지의 동적 목록과 있으므로 열거형 메시지는 현재 커서 위치 초과 하는 경우 큐의 메시지에 대 한 수정 내용을 반영 합니다. 예를 들어 열거자 커서의 현재 위치를 넘어 배치 된 우선 순위가 낮은 메시지 있지만 해당 위치 앞에 삽입 하는 우선 순위가 높은 메시지가 아니라에 자동으로 액세스할 수 있습니다. 그러나 다시 설정할 수 있습니다는 열거 되므로 커서 다시 목록 맨 앞으로 호출 하 여 이동 <xref:System.Messaging.MessageEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageEnumerator>합니다.  
  
 열거형에 있는 메시지의 순서는 우선 순위가 낮은 것 하기 전에 우선 순위가 높은 메시지가 표시 되므로 큐에서의 순서를 반영 합니다.  
  
 동적 연결 하지 않고 큐의 메시지를 정적 스냅숏을 호출 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>합니다. 이 메서드는 배열을 반환 <xref:System.Messaging.Message> 개체를 메서드가 호출 된 시간에 메시지를 나타냅니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에 있는 메시지의 동적 목록을 가져오고 있는 모든 메시지가 계산 된 <xref:System.Messaging.Message.Priority%2A> 속성이로 설정 <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>합니다.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>큐에 있는 모든 메시지에 대해 열거자 개체를 만듭니다.</summary>
        <returns>큐에 있는 메시지를 보유하는 <see cref="T:System.Messaging.MessageEnumerator" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 큐에 있는 모든 메시지의 동적 목록을 만듭니다. 제거할 수 있습니다는 큐에서 열거자의 현재 위치에서 메시지를 호출 하 여 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 에 대 한는 <xref:System.Messaging.MessageEnumerator> 하 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 반환 합니다.  
  
 커서가 연결 된 큐에 메시지의 동적 목록과 있으므로 열거형 메시지는 현재 커서 위치 초과 하는 경우 큐의 메시지에 대 한 수정 내용을 반영 합니다. 예를 들어 열거자 커서의 현재 위치를 넘어 배치 된 우선 순위가 낮은 메시지 있지만 해당 위치 앞에 삽입 하는 우선 순위가 높은 메시지가 아니라에 자동으로 액세스할 수 있습니다. 그러나 다시 설정할 수 있습니다는 열거 되므로 커서 다시 목록 맨 앞으로 호출 하 여 이동 <xref:System.Messaging.MessageEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageEnumerator>합니다.  
  
 열거형에 있는 메시지의 순서는 우선 순위가 낮은 것 하기 전에 우선 순위가 높은 메시지가 표시 되므로 큐에서의 순서를 반영 합니다.  
  
 동적 연결 하지 않고 큐의 메시지를 정적 스냅숏을 호출 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>합니다. 이 메서드는 배열을 반환 <xref:System.Messaging.Message> 개체를 메서드가 호출 된 시간에 메시지를 나타냅니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>네트워크에 있는 공개 큐의 동적 목록에 대한 열거자 개체를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>앞으로만 이동 가능한 커서 의미 체계 기능을 제공하여 네트워크에 있는 모든 공개 큐를 열거합니다.</summary>
        <returns>네트워크에 있는 모든 공개 메시지 큐의 동적 목록을 제공하는 <see cref="T:System.Messaging.MessageQueueEnumerator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드의 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 네트워크에 있는 모든 공개 큐의 열거형을 반환 합니다.  
  
 커서가 동적 목록과 관련 되어 있으므로 열거형에는 삭제 또는 커서의 현재 위치를 벗어나서 추가 큐에 대 한 큐 목록에 대 한 수정 내용을 반영 합니다. 추가 또는 삭제는 커서의 현재 위치 보다 앞에 있는 큐의 반영 되지 않습니다. 예를 들어 열거자의 커서 위치 뒤에 추가 하는 큐 이지만 아닌 해당 위치 앞에 삽입에 자동으로 액세스할 수 있습니다. 그러나 다시 설정할 수 있습니다는 열거 되므로 커서 다시 목록 맨 앞으로 호출 하 여 이동 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageQueueEnumerator>합니다.  
  
 큐는 네트워크에 정의 된 순서가 있지 않습니다. 열거자 정렬 되지 않은, 예를 들어 컴퓨터, 레이블, 공개 또는 개인 상태 또는 다른 액세스할 수 있는 기준으로 합니다.  
  
 동적 연결 하지 않고 네트워크에 있는 큐의 정적 스냅샷 호출 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 또는 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>합니다. 이러한 두 메서드는 각각의 배열을 반환 <xref:System.Messaging.MessageQueue> 개체를 메서드가 호출 된 시간에 큐를 나타냅니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 네트워크의 모든 메시지 큐에서 반복 되며 각 큐에 대 한 경로 검사 합니다. 마지막으로, 네트워크에 공개 큐의 수를 표시합니다.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">사용 가능한 메시지 큐를 필터링하는 데 사용되는 기준이 포함된 <see cref="T:System.Messaging.MessageQueueCriteria" />입니다.</param>
        <summary>앞으로만 이동 가능한 커서 의미 체계 기능 제공하여 네트워크에 있는 공개 큐 중 지정된 기준을 만족하는 큐를 모두 열거합니다.</summary>
        <returns>네트워크에 있는 공개 메시지 큐 중 <paramref name="criteria" /> 매개 변수가 지정한 제한 사항을 만족시키는 큐에 대한 동적 목록을 제공하는 <see cref="T:System.Messaging.MessageQueueEnumerator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드의 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 응용 프로그램 조건에 정의 된 조건을 충족 하는 네트워크에 있는 모든 공개 큐의 목록을 반환 합니다. 를 포함 하는 조건을 작성 또는 수정 시간, 컴퓨터 이름, 레이블, 범주 또는 이러한 조건의 조합을 예를 들어 큐를 지정할 수 있습니다.  
  
 커서가 동적 목록과 관련 되어 있으므로 열거형에는 커서의 현재 위치 뒤에 발생 하는 큐에 대 한 수정 내용을 반영 합니다. 커서의 현재 위치 보다 앞에 있는 큐에 변경 내용이 반영 되지 않습니다. 예를 들어 열거자의 커서 위치 뒤에 추가 하는 큐 이지만 아닌 해당 위치 앞에 삽입에 자동으로 액세스할 수 있습니다. 그러나 다시 설정할 수 있습니다는 열거 되므로 커서 다시 목록 맨 앞으로 호출 하 여 이동 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageQueueEnumerator>합니다.  
  
 큐는 네트워크에 정의 된 순서가 있지 않습니다. 열거자 정렬 되지 않은, 예를 들어 컴퓨터, 레이블, 공개 또는 개인 상태 또는 다른 액세스할 수 있는 기준으로 합니다.  
  
 동적 연결 하지 않고 네트워크에 있는 큐의 정적 스냅샷 하려는 경우에 대 한 조건을 지정 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 호출 또는 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>합니다. 이러한 두 메서드는 각각의 배열을 반환 <xref:System.Messaging.MessageQueue> 개체를 메서드가 호출 된 시간에 큐를 나타냅니다. 호출 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, 또는 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 호출할 때와 같은 결과 얻을 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 의 필터링 기준을 사용 하 여 <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, 및 <xref:System.Messaging.MessageQueue.MachineName%2A>각각.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐를 통해 반복 하 고 "MyComputer" 컴퓨터에 같고 마지막 날에 만들어진 각 큐의 경로 표시 합니다.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">개인 큐를 검색할 컴퓨터입니다.</param>
        <summary>지정된 컴퓨터에 있는 개인 큐를 모두 검색합니다.</summary>
        <returns>검색된 개인 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 지정된 된 컴퓨터에 있는 큐의 정적 스냅숏을 검색합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")입니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>네트워크에 있는 공개 큐를 모두 검색합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>네트워크에 있는 공개 큐를 모두 검색합니다.</summary>
        <returns>검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 네트워크에 있는 모든 공개 큐의 전체 목록을 원하는 경우이 오버 로드를 사용 합니다. 와 같은 특정 조건을 기준으로 목록을 제한 하려는 경우 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, 또는이 메서드의 다른 오버 로드를 사용 하는 마지막으로 수정한 시간입니다. (사용할 수 있습니다 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, 또는 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 큐의 정적 스냅숏을 검색합니다. 큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">큐를 필터링하는 데 사용되는 기준이 포함된 <see cref="T:System.Messaging.MessageQueueCriteria" />입니다.</param>
        <summary>네트워크에 있는 공개 큐 중 지정된 기준을 만족시키는 큐를 모두 검색합니다.</summary>
        <returns>검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 레이블, 범주 또는 컴퓨터 이름으로 네트워크에 있는 모든 공개 큐를 필터링 하려는 경우는 <xref:System.Messaging.MessageQueue> 해당 기능을 제공 하는 특정 메서드를 포함 하는 클래스 (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, 및 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>각각). 이 오버 로드를 사용 하 여 (예를 들어 경우 레이블과 범주 둘 다 지정 하려는) 이러한 조건 중 하나 이상 만족 하는 네트워크에서 공개 큐를 모든 목록을 가져올 수 있습니다. 필터링 할 수도 있습니다 메시지 조건으로 이외의 <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, 및 <xref:System.Messaging.MessageQueue.MachineName%2A>합니다. 예를 들어 큐의 마지막 수정 시간을 기준으로이 오버 로드를 사용 합니다. 새 인스턴스를 만들기만 <xref:System.Messaging.MessageQueueCriteria> 클래스 인스턴스의 적절 한 속성을 설정 하 고 해당 인스턴스를 전달는 `criteria` 매개 변수입니다.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 큐의 정적 스냅숏을 검색합니다. 큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">검색할 큐 집합을 그룹화하는 <see cref="T:System.Guid" />입니다.</param>
        <summary>네트워크에 있는 공개 큐 중 지정된 범주에 속한 큐를 모두 검색합니다.</summary>
        <returns>검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 공개 큐를 범주별으로 필터링 하려면이 메서드를 사용 합니다. <xref:System.Messaging.MessageQueue.Category%2A> 속성은 메시지 큐 유형의 ID 속성 (즉, 읽기/쓰기) 특정 큐에 대 한 액세스를 제공 합니다. 사용할 수 있지만 <xref:System.Guid.NewGuid%2A> 는 모든 고유 범주 값을 만들려면 <xref:System.Guid> 값 필요는 없습니다. 범주 값이 다른 범주에서가 아니라 다른 모든 구별 되도록 <xref:System.Guid> 값입니다. 할당할 수는 예를 들어 {00000000-0000-0000-0000-000000000001} 로 <xref:System.Messaging.MessageQueue.Category%2A> 한 집합 큐에 대 한 및 {00000000-0000-0000-0000-000000000002} 로 <xref:System.Messaging.MessageQueue.Category%2A> 다른 집합에 대 한 합니다.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 큐의 정적 스냅숏을 검색합니다. 큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>합니다. 일부로 범주를 지정할 수는 <xref:System.Messaging.MessageQueueCriteria> 메서드에 전달 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">검색할 큐 집합을 그룹화하는 레이블입니다.</param>
        <summary>네트워크에 있는 공개 큐 중 지정된 레이블이 있는 큐를 모두 검색합니다.</summary>
        <returns>검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 레이블에 의해 공개 큐를 필터링 합니다.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 큐의 정적 스냅숏을 검색합니다. 큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>합니다. 일부분으로 레이블을 지정할 수는 <xref:System.Messaging.MessageQueueCriteria> 메서드에 전달 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">검색할 공개 큐 집합을 포함하는 컴퓨터의 이름입니다.</param>
        <summary>지정된 컴퓨터에 있는 공개 큐를 모두 검색합니다.</summary>
        <returns>컴퓨터에 있는 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컴퓨터별 공개 큐를 필터링 하려면이 메서드를 사용 합니다.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 큐의 정적 스냅숏을 검색합니다. 큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>합니다. 일부분으로 컴퓨터 이름을 지정할 수 있습니다는 <xref:System.Messaging.MessageQueueCriteria> 메서드에 전달 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 매개 변수의 구문이 잘못되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 호출 시 MSMQ가 현재 사용자(스레드 ID)와 연결된 보안 컨텍스트를 검색합니다.</summary>
        <returns>보안 컨텍스트를 포함하는 <see cref="T:System.Messaging.SecurityContext" /> 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐의 고유한 메시지 큐 식별자를 가져옵니다.</summary>
        <value>메시지 큐 응용 프로그램에 의해 생성된 메시지 식별자를 나타내는 <see cref="P:System.Messaging.MessageQueue.Id" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐는 <xref:System.Messaging.MessageQueue.Id%2A> 속성 큐를 만듭니다. 이 속성은 공개 큐에 사용할 수만 있습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.Id%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐에 크기 제한이 없도록 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 설정할 때 사용할 자주 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 또는 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.InfiniteQueueSize> 멤버입니다.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지를 피킹하거나 받는 메서드에 시간 제한이 없도록 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> 두 가지 유형의 메시지 검색 지원: 동기 및 비동기입니다. 동기 메서드 <xref:System.Messaging.MessageQueue.Peek%2A> 및 <xref:System.Messaging.MessageQueue.Receive%2A>, 프로세스 스레드가 지정된 된 시간 간격을 큐에 도착할 때까지 새 메시지에 대해 기다려야 합니다. 지정 된 시간 간격이 <xref:System.Messaging.MessageQueue.InfiniteTimeout>, 새 메시지가 있을 때까지 프로세스 스레드가 차단 됩니다. 반면에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 및 <xref:System.Messaging.MessageQueue.BeginReceive%2A> (비동기 메서드), 주 응용 프로그램 작업을 큐에 메시지가 도착할 때까지 별도의 스레드에서 계속 허용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 멤버입니다.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐 설명을 가져오거나 설정합니다.</summary>
        <value>메시지 큐의 레이블입니다. 기본값은 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐 레이블의 최대 길이 124 자입니다.  
  
 <xref:System.Messaging.MessageQueue.Label%2A> 속성이 모든 큐에서 고유할 필요는 없습니다. 그러나 동일한 여러 큐를 공유 하는 경우 <xref:System.Messaging.MessageQueue.Label%2A>를 사용할 수 없습니다는 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> 모든 사람이 메시지를 브로드캐스팅하려면 메서드. 에 대 한 레이블 구문을 사용 하는 경우는 <xref:System.Messaging.MessageQueue.Path%2A> 메시지를 보낼 때 속성에는 예외가 발생 하는 경우는 <xref:System.Messaging.MessageQueue.Label%2A> 고유 하지 않습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.Label%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">레이블이 잘못된 값으로 설정되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐의 속성이 마지막으로 수정된 시간을 가져옵니다.</summary>
        <value>큐의 속성이 마지막으로 수정된 시간을 알려주는 <see cref="T:System.DateTime" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐를 만들 때 마지막으로 수정한 시간 포함 및 모든 <xref:System.Messaging.MessageQueue> 와 같은 메시지 큐 큐를 수정 하는 속성 <xref:System.Messaging.MessageQueue.BasePriority%2A>합니다. 값은 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성은 로컬 컴퓨터의 시스템 시간을 나타냅니다.  
  
 호출 해야 <xref:System.Messaging.MessageQueue.Refresh%2A> 을 가져오기 전에 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성; 연결 된이 수정 시간, <xref:System.Messaging.MessageQueue> 최신 상태가 아닐 수 있습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 큐가 있는 컴퓨터의 이름을 가져오거나 설정합니다.</summary>
        <value>큐가 있는 컴퓨터의 이름입니다. 메시지 큐의 기본값은 "."이며, 이는 로컬 컴퓨터를 나타냅니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A> 큐의 약식 이름 구문이의 필수 구성 요소인 <xref:System.Messaging.MessageQueue.Path%2A>합니다. 다음 표에서 해당 이름을 사용 하 여 큐 경로 식별 하려는 경우 형식이 지정 된 큐에 대 한 사용 해야 하는 구문을 보여 줍니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
|저널 큐|`MachineName`\\`QueueName`\\`Journal$`|  
|컴퓨터 저널 큐|`MachineName`\\`Journal$`|  
|컴퓨터 배달 못 한 편지 큐|`MachineName`\\`Deadletter$`|  
|컴퓨터 트랜잭션 배달 못 한 편지 큐|`MachineName`\\`XactDeadletter$`|  
  
 사용 하 여 "."를 지정할 때 로컬 컴퓨터에 대 한는 <xref:System.Messaging.MessageQueue.MachineName%2A>합니다. 컴퓨터 이름에만이 속성에 대 한 예를 들어 인식 `Server0`합니다. <xref:System.Messaging.MessageQueue.MachineName%2A> 속성 IP 주소 형식은 지원 하지 않습니다.  
  
 정의 하는 경우는 <xref:System.Messaging.MessageQueue.Path%2A> 의 측면에서 <xref:System.Messaging.MessageQueue.MachineName%2A>, 도메인 컨트롤러에 대 한 경로 변환 필요 하기 때문에 오프 라인으로 작업 하는 경우 응용 프로그램 예외를 throw 합니다. 따라서 사용 해야 합니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 에 대 한는 <xref:System.Messaging.MessageQueue.Path%2A> 구문 오프 라인으로 작업 하는 경우.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성은 서로 관련 됩니다. 변경 된 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성 원인을 <xref:System.Messaging.MessageQueue.Path%2A> 변경할 속성입니다. 새 구성 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A>합니다. 변경 된 <xref:System.Messaging.MessageQueue.Path%2A> (예: 형식 이름 구문 사용) 다시 설정는 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 새 큐를 참조 하는 속성입니다. 경우는 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성이 비어는 <xref:System.Messaging.MessageQueue.Path%2A> 지정한 컴퓨터의 업무 일지 큐에 설정 됩니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">컴퓨터 이름이 잘못되었습니다(예: 구문이 잘못된 경우).</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>업무 일지 큐의 최대 크기를 가져오거나 설정합니다.</summary>
        <value>업무 일지 큐의 최대 크기입니다(단위: KB). 메시지 큐에서는 기본적으로 제한이 없도록 지정합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 저널 메시지 큐 저장 용량 제한에 대 한 액세스를 제공합니다. 인 경우에만 관련 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> 은 `true`합니다. 이 속성을 설정 하면 메시지 큐를 수정 합니다. 따라서 다른 모든 <xref:System.Messaging.MessageQueue> 는 변경의 영향을 받는 인스턴스  
  
 업무 일지 나 배달 못 한 편지 큐에 메시지를 저장 하는 경우 주기적으로 더 이상 필요 없는 메시지를 제거 하려면 큐를 지워야 합니다. 이러한 큐에서 메시지 큐가 있는 컴퓨터에 대 한 메시지 할당량을 차지 합니다. (관리자 컴퓨터 할당량을 설정 합니다.)  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">업무 일지 큐의 최대 크기가 잘못된 값으로 설정되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐의 최대 크기를 가져오거나 설정합니다.</summary>
        <value>큐의 최대 크기입니다(단위: KB). 메시지 큐에서는 기본적으로 제한이 없도록 지정합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> 는 메시지 큐 메시지 저장소 용량 한도 관리자가 정의 하는 컴퓨터의 메시지 할당량와에서 구분 됨에 대 한 액세스를 제공 합니다. 메시지 할당량에 대 한 자세한 내용은 참조 하십시오. <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>합니다.  
  
 이 속성을 설정 하면 메시지 큐를 수정 합니다. 따라서 다른 모든 <xref:System.Messaging.MessageQueue> 는 변경의 영향을 받는 인스턴스  
  
 최대 큐 크기 또는 컴퓨터 메시지 할당량을 초과 하려고 하는 경우 메시지가 손실 될 수 있습니다. 큐 할당량에 도달 하면 메시지 큐는 부정 승인 메시지를 반환 하 여 큐가 꽉 차면를 보내는 응용 프로그램의 관리 큐를 알립니다. 메시지 큐 큐에 메시지의 총 크기 제한 아래로 떨어질 때까지 부정 승인을 보내도록 계속 합니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">큐의 최대 크기에 음수 값이 포함된 경우입니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지를 받거나 또는 피킹하는 데 필요한 속성 필터를 가져오거나 설정합니다.</summary>
        <value>큐가 각각의 메시지에 대해 받거나 피킹하는 속성 집합을 필터링하는 데 사용되는 <see cref="T:System.Messaging.MessagePropertyFilter" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필터는 메시지 속성을 제한 하는 부울 값의 집합입니다는 <xref:System.Messaging.MessageQueue> 받거나를 관찰 합니다. 경우는 <xref:System.Messaging.MessageQueue> 를 수신 하거나 메시지를 관찰 합니다. 서버 큐에서를 해당 속성만 검색는 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 값은 `true`합니다.  
  
 다음에 대 한 초기 속성 값이 표시는 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 속성입니다. 이러한 설정은 호출 동일 <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> 에 <xref:System.Messaging.MessagePropertyFilter>합니다.  
  
|속성|기본값|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 바이트|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 바이트|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 바이트|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 받은 메시지 속성을 제한할 수 있습니다.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">필터가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>MSMQ 3.0에서 도입되었습니다. 큐에 연결된 멀티캐스트 주소를 가져오거나 설정합니다.</summary>
        <value>아래 형식으로 된 올바른 멀티캐스트 주소가 들어 있는 <see cref="T:System.String" />이거나, 큐가 멀티캐스트 주소에 연결되지 않았음을 나타내는 <see langword="null" />입니다.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> 속성은 비트랜잭션 큐 메시지를 보낼 때 사용할 수 있는 멀티 캐스트 주소와 연결 하는 데 사용 됩니다. 멀티 캐스트 주소와 트랜잭션 큐를 연결할 수 없습니다. 해당 주소와 연결 된 모든 큐에 보내는 응용 프로그램 메시지를 보내면 멀티 캐스트 주소를, 메시지 큐 메시지의 사본을 보냅니다.  
  
 IP 멀티 캐스트 주소 224.0.0.0에서 239.255.255.255 처음 네 개의 상위 비트를 1110 설정에 해당 하는 클래스 D 범위에 있어야 합니다. 그러나 특정 범위의이 범위에는 주소는 예약 되지 않은 및 멀티 캐스트 메시지를 보내는 데 사용할 수 있는 합니다. 예약 된 멀티 캐스트 주소 목록이 최신에 대 한 참조는 [번호 기관 IANA (Internet Assigned) 인터넷 멀티 캐스트 주소](http://go.microsoft.com/fwlink/?linkid=3859) 웹 페이지입니다. 포트 번호에서 제한은 없습니다.  
  
 여러 소스 컴퓨터 멀티 캐스트 메시지를 보내는 경우 메시지를 받는 하나의 원본 컴퓨터에서 특정 큐 각 원본 컴퓨터 IP 주소와 포트 번호의 다른 조합에 메시지를 전송 해야 합니다.  
  
 멀티 캐스트 주소에서 큐를 분리 하려면 설정는 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> 속성을 빈 문자열입니다. 설정 하지 마십시오 `null`에서 발생 하므로, 한 <xref:System.ArgumentNullException>합니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐의 경로를 가져오거나 설정합니다. <see cref="P:System.Messaging.MessageQueue.Path" />를 설정하면 <see cref="T:System.Messaging.MessageQueue" />가 새 큐를 가리킵니다.</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐입니다. 기본값은 사용하는 <see cref="M:System.Messaging.MessageQueue.#ctor" /> 생성자에 따라 달라지는데, <see langword="null" />이거나 생성자의 <paramref name="path" /> 매개 변수에 의해 지정됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 구문에서 <xref:System.Messaging.MessageQueue.Path%2A> 속성 유형에 따라 다릅니다 큐의 해당 지점에는 다음 표에 나와 있는 것 처럼 합니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
|저널 큐|`MachineName`\\`QueueName`\\`Journal$`|  
|컴퓨터 저널 큐|`MachineName`\\`Journal$`|  
|컴퓨터 배달 못 한 편지 큐|`MachineName`\\`Deadletter$`|  
|컴퓨터 트랜잭션 배달 못 한 편지 큐|`MachineName`\\`XactDeadletter$`|  
  
 사용 하 여 "." 로컬 컴퓨터를 나타낼 수 있습니다.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성은 서로 관련 됩니다. 변경 된 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성 원인을 <xref:System.Messaging.MessageQueue.Path%2A> 변경할 속성입니다. 새 구성 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A>합니다. 변경 된 <xref:System.Messaging.MessageQueue.Path%2A> (예: 형식 이름 구문 사용) 다시 설정는 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 새 큐를 참조 하는 속성입니다.  
  
 사용할 수 있습니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 또는 <xref:System.Messaging.MessageQueue.Label%2A> 다음 표에 나와 있는 것 처럼 큐 경로 설명 하기 위해 합니다.  
  
|참조|구문|예|  
|---------------|------------|-------------|  
|형식 이름|`FormatName:` [ *형식 이름을* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|레이블|`Label:` [ *레이블* ]|`Label:` TheLabel|  
  
 에 대 한 레이블 구문을 사용 하는 경우는 <xref:System.Messaging.MessageQueue.Path%2A> 메시지를 보낼 때 속성에는 예외가 발생 하는 경우는 <xref:System.Messaging.MessageQueue.Label%2A> 고유 하지 않습니다.  
  
 오프 라인으로 작업 하려면 첫 번째 테이블의 이름 구문이 아닌 형식 이름 구문을 사용 해야 합니다. 그렇지 않으면 주 도메인 컨트롤러 (Active Directory 상주 하는) 형식 이름에 경로 확인할 수 없기 때문에 예외가 throw 됩니다.  
  
 새 경로 설정 하면 메시지 큐 닫고 모든 핸들을 해제 합니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
> [!NOTE]
>  작업 그룹 모드에서 개인 큐의 경우에 사용할 수 있습니다. 개인 큐 구문을 사용 하 여 경로 지정 `MachineName` \\ `Private$` \\ `QueueName`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 다양 한 경로 이름 구문 형식을 사용 하 여 개체입니다. 각각의 경우에서 경로가 생성자에 정의 된 큐로 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">경로가 잘못되었습니다(예: 구문이 잘못된 경우)</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <summary>큐에 있는 첫 번째 메시지의 복사본을 반환하지만 큐에서 메시지를 제거하지는 않습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 첫 번째 메시지를 반환하지만 제거(피킹)하지는 않습니다. <see cref="M:System.Messaging.MessageQueue.Peek" /> 메서드는 동기적이므로 메시지를 사용할 수 있을 때까지 현재 스레드를 차단시킵니다.</summary>
        <returns>큐에 있는 첫 번째 메시지를 나타내는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하는 큐를 피킹할 수 하거나 메시지가 큐에 있는 될 때까지 기다립니다.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드 읽지만 첫 번째 메시지 큐에서 제거 되지 않습니다. 따라서 반복 호출을 <xref:System.Messaging.MessageQueue.Peek%2A> 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 동일한 메시지를 반환 합니다. <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 반면에 모두를 읽는 첫 번째 메시지를 큐에서 제거 합니다. 반복 호출을 <xref:System.Messaging.MessageQueue.Receive%2A>, 따라서 다양 한 메시지를 반환 합니다.  
  
 메시지 큐는 우선 순위와 도착 시간에 따라 큐에 메시지를 정리 합니다. 새 메시지는 우선 순위가 높을 경우에 이전 앞에 배치 됩니다.  
  
 큐에 메시지가 도착할 때까지 대기하는 동안 현재 스레드를 차단하는 것이 허용되는 경우에만 <xref:System.Messaging.MessageQueue.Peek%2A>를 사용합니다. 이 오버 로드는 제한 시간을 지정 하지 않으므로, 응용 프로그램이 무기한 대기 합니다. 대기하지 않고 응용 프로그램 처리를 계속하려면 비동기 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드를 사용합니다. 또는의 오버 로드를 사용 하 여 큐에 도착 하는 메시지에 대 한 제한 시간을 지정할 수 <xref:System.Messaging.MessageQueue.Peek%2A> 하는 제한 시간을 지정 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 예에서는 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메서드.  
  
 첫 번째 예제에서 응용 프로그램 메시지 큐에서 사용할 수 있게 될 때까지 대기 합니다. 첫 번째 예에서는; 도착 하는 메시지에 액세스 하지 않는 참고 단지 메시지가 도착할 때까지 처리 일시 중지 됩니다. 경우 메시지가 큐에 이미 있는 즉시 반환 됩니다.  
  
 두 번째 예제에서는 응용 프로그램 정의 포함 하는 메시지 `Order` 클래스는 큐로 전송 되 고 다음 큐에서 피킹 합니다.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">큐가 메시지를 포함하도록 대기하는 최대 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 첫 번째 메시지를 반환하지만 제거(피킹)하지는 않습니다. <see cref="M:System.Messaging.MessageQueue.Peek" /> 메서드는 동기적이므로 메시지를 사용할 수 있거나 지정된 시간이 초과될 때까지 현재 실행 스레드를 차단시킵니다.</summary>
        <returns>큐에 있는 첫 번째 메시지를 나타내는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 큐를 피킹할 수 또는 지정된 된 시간까지 메시지가 큐에 있는 동안 기다려야 합니다. 메시지가 큐에 이미 있는 경우 메서드가 즉시 반환 됩니다.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드 읽지만 첫 번째 메시지 큐에서 제거 되지 않습니다. 따라서 반복 호출을 <xref:System.Messaging.MessageQueue.Peek%2A> 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 동일한 메시지를 반환 합니다. <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 반면에 모두를 읽는 첫 번째 메시지를 큐에서 제거 합니다. 반복 호출을 <xref:System.Messaging.MessageQueue.Receive%2A>, 따라서 다양 한 메시지를 반환 합니다.  
  
 메시지 큐는 우선 순위와 도착 시간에 따라 큐에 메시지를 정리 합니다. 새 메시지는 우선 순위가 높을 경우에 이전 앞에 배치 됩니다.  
  
 큐에 메시지가 도착할 때까지 대기하는 동안 현재 스레드를 차단하는 것이 허용되는 경우에만 <xref:System.Messaging.MessageQueue.Peek%2A>를 사용합니다. 스레드는 지정 된 시간을 무기한으로 차단 될 다른 사람이 <xref:System.Messaging.MessageQueue.InfiniteTimeout>합니다. 대기하지 않고 응용 프로그램 처리를 계속하려면 비동기 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드를 사용합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드 큐가 비어 있는지 여부를 확인 하려면 0 시간 제한 사용 합니다.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">큐가 메시지를 포함하도록 대기하는 최대 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <param name="action">
          <see cref="T:System.Messaging.PeekAction" /> 값 중 하나입니다. 이 값은 큐의 현재 메시지를 피킹할지 또는 다음 메시지를 피킹할지 여부를 나타냅니다.</param>
        <summary>지정된 커서를 사용하여 큐에 있는 현재 또는 다음 메시지를 제거하지 않고 반환(피킹)합니다. <see cref="M:System.Messaging.MessageQueue.Peek" /> 메서드는 동기적이므로 메시지를 사용할 수 있거나 지정된 시간이 초과될 때까지 현재 실행 스레드를 차단시킵니다.</summary>
        <returns>큐에 있는 메시지를 나타내는 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 큐를 피킹할 수 또는 지정된 된 시간까지 메시지가 큐에 있는 동안 기다려야 합니다. 메시지가 큐에 이미 있는 경우 메서드가 즉시 반환 됩니다.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드 읽지만 큐에서 메시지 제거 되지 않습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 반면에 모두를 읽는 큐에서 메시지를 제거 합니다.  
  
 큐에 메시지가 도착할 때까지 대기하는 동안 현재 스레드를 차단하는 것이 허용되는 경우에만 <xref:System.Messaging.MessageQueue.Peek%2A>를 사용합니다. 스레드는 지정 된 시간을 무기한으로 차단 하면 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout>합니다. 대기하지 않고 응용 프로그램 처리를 계속하려면 비동기 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드를 사용합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="action" /> 매개 변수에 대해 <see langword="PeekAction.Current" /> 또는 <see langword="PeekAction.Next" /> 이외의 값을 지정했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우 <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 피킹합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">피킹할 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 피킹합니다. 지정된 상관 관계 식별자가 포함된 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 하는 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수를 예외가 throw 됩니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하면 큐에서 피킹 메시지를 합니다. <xref:System.Messaging.MessageQueue.Peek%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제는 큐에서 주문에 포함 된 메시지 송수신 설정 합니다. 원본 메시지가 도달 하거나이 긍정 승인을 특별히 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">피킹할 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 피킹하며, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 하는 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수를 새 메시지에 지정 된 기간 내에서 큐에 도착할는 `timeout` 매개 변수를 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다. 될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하는 새 메시지는 `correlationId` 매개 변수입니다. 그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.CorrelationId%2A> 일치는 `correlationId` 매개 변수입니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하면 큐에서 피킹 메시지를 합니다. <xref:System.Messaging.MessageQueue.Peek%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 메시지가 도착하지 않았습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 메시지 식별자가 포함된 메시지의 복사본을 반환하지만 큐에서 해당 메시지를 제거하지는 않습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">피킹할 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <summary>메시지 식별자가 <paramref name="id" /> 매개 변수와 일치하는 메시지를 피킹합니다.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> 속성이 <paramref name="id" /> 매개 변수와 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 큐에서 제거 하지 않고 읽이 알려진된 메시지 식별자를 가진 메시지입니다. 메시지의 식별자가 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다. 이 오버 로드 큐 메시지 포함 하지 않는 경우 예외가 throw 됩니다.  
  
 두 개의 추가 메서드를 사용 하면 메시지를 피킹할 큐에 있는: <xref:System.Messaging.MessageQueue.Peek%2A> 및 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드; 큐에 있는 첫 번째 메시지를 반환 합니다. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />의 메시지가 없습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">피킹할 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>메시지 식별자가 <paramref name="id" /> 매개 변수와 일치하는 메시지를 피킹합니다. 큐에 메시지가 표시되거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> 속성이 <paramref name="id" /> 매개 변수와 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 큐에서 제거 하지 않고 읽이 알려진된 메시지 식별자를 가진 메시지입니다. 메시지의 식별자가 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다. 이 오버 로드 큐 메시지 포함 하지 않는 경우 제한 시간이 발생 하기 전에 새 메시지가 도착 하지 않으면 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다. 될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하는 새 메시지는 `id` 매개 변수입니다. 그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.Id%2A> 일치는 `id` 매개 변수입니다.  
  
 두 개의 추가 메서드를 사용 하면 메시지를 피킹할 큐에 있는: <xref:System.Messaging.MessageQueue.Peek%2A> 및 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드; 큐에 있는 첫 번째 메시지를 반환 합니다. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />가 들어 있는 메시지가 큐에 없고 <paramref name="timeout" /> 매개 변수가 지정한 기간이 만료되기 전에 메시지가 도착하지 않았습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>MSMQ 3.0에서 도입되었습니다. 큐의 특정 메시지를 피킹합니다. 메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">피킹할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다.</param>
        <summary>MSMQ 3.0에서 도입되었습니다. 비트랜잭션 큐에서 지정된 조회 식별자를 갖는 메시지를 피킹합니다.</summary>
        <returns>전달된 <paramref name="lookupId" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.LookupId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 큐에서 제거 하지 않고 알려진된 조회 식별자를 가진 메시지를 읽을 수 있습니다. 이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.  
  
 <xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 해당 메시지가 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 주어진 `lookupId` 매개 변수입니다.  
  
 지정한 lookup 식별자와 메시지를 읽고 큐에서 제거를 사용 하 여는 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 메서드.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">큐에서 메시지를 읽는 방법을 지정하는 <see cref="T:System.Messaging.MessageLookupAction" /> 값 중 하나입니다. 다음 중 하나를 지정합니다.  
  
 <see langword="MessageLookupAction.Current" />: <c>lookupId</c>로 지정된 메시지를 피킹합니다.  
  
 <see langword="MessageLookupAction.Next" />: <c>lookupId</c>로 지정된 메시지의 뒤에 있는 메시지를 피킹합니다.  
  
 <see langword="MessageLookupAction.Previous" />: <c>lookupId</c>로 지정된 메시지의 앞에 있는 메시지를 피킹합니다.  
  
 <see langword="MessageLookupAction.First" />: 큐에 있는 첫 번째 메시지를 피킹합니다. <c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.  
  
 <see langword="MessageLookupAction.Last" />: 큐에 있는 마지막 메시지를 피킹합니다. <c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.</param>
        <param name="lookupId">0에서 피킹할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다. 0은 큐에 있는 첫 번째 또는 마지막 메시지에 액세스할 때 사용됩니다.</param>
        <summary>MSMQ 3.0에서 도입되었습니다. 큐의 특정 메시지를 피킹합니다. 메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</summary>
        <returns>전달된 <paramref name="action" /> 및 <paramref name="lookupId" /> 매개 변수로 지정된 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 큐에서 제거 하지 않고 알려진된 조회 식별자를 가진 메시지를 읽을 수 있습니다. 이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.  
  
 <xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 해당 메시지가 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 주어진 `lookupId` 매개 변수입니다.  
  
 사용 하 여 지정 된 식별자를 갖는 메시지를 큐에서 제거할는 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 메서드.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 매개 변수가 <see cref="T:System.Messaging.MessageLookupAction" /> 멤버 중 하나가 아닌 경우</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐에서 메시지를 제거하지 않고 메시지를 읽는 경우에 발생합니다. 이는 비동기 작업인 <see cref="M:System.Messaging.MessageQueue.BeginPeek" />의 결과입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 처리에서 발생 하는 데 사용 되는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 메시지가 큐에서 사용할 수 있는 때입니다.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 하 여 시작 된 작업을 완료 하는 데는 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 및 메시지 피킹 때는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 합니다.  
  
 <xref:System.Messaging.PeekCompletedEventHandler> 대리자를 만들 때, 이벤트를 처리할 메서드를 식별합니다. 이벤트를 이벤트 처리기와 연결하려면 대리자의 인스턴스를 해당 이벤트에 추가합니다. 대리자를 제거하지 않는 경우 이벤트가 발생할 때마다 이벤트 처리기가 호출됩니다. 이벤트 처리기 대리자에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 라는 이벤트 처리기를 만들고 `MyPeekCompleted`에 연결는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자 및 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 경로에 있는 큐에서 비동기 작업을 시작 하려면 ". \myQueue"입니다. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하면이 예에서는 메시지를 관찰 합니다. 한 화면으로 해당 본문을 작성 합니다. 이 예에서는 다음 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 다시 새 비동기 작업을 시작 하려면  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>큐에 포함된 모든 메시지를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐를 제거로 인해 메시지 큐에 영향을 주는 큐 수정 플래그를 설정 하는 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성입니다. 메시지 큐에서 제거 하는 손실 됩니다. 배달 못 한 편지 큐 또는 저널 큐에 전송 되지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Purge%2A>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐를 식별하는 이름을 가져오거나 설정합니다.</summary>
        <value>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐를 식별하는 이름입니다. 이 값은 <see langword="null" />일 수 없습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결합할 수는 <xref:System.Messaging.MessageQueue.QueueName%2A> 와 <xref:System.Messaging.MessageQueue.MachineName%2A> 친숙 한 만들려는 <xref:System.Messaging.MessageQueue.Path%2A> 큐에 대 한 이름입니다. 이름 변형에 대 한 구문에서 <xref:System.Messaging.MessageQueue.Path%2A> 다음 표에 나와 있는 것 처럼 속성 큐의 형식에 따라 다릅니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
|저널 큐|`MachineName`\\`QueueName`\\`Journal$`|  
  
 사용 하 여 "." 로컬 컴퓨터를 나타낼 수 있습니다.  
  
 변경 된 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성에 영향을 미칩니다는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다. 설정 하는 경우는 <xref:System.Messaging.MessageQueue.QueueName%2A> 설정 하지 않고는 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성에는 <xref:System.Messaging.MessageQueue.Path%2A> 속성은.\\ `QueueName`. 그렇지 않은 경우는 <xref:System.Messaging.MessageQueue.Path%2A> 됩니다 `MachineName` \\ `QueueName`합니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">큐 이름이 <see langword="null" />입니다.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 큐에서 메시지를 읽는 데 사용되는 기본 핸들을 가져옵니다.</summary>
        <value>큐에서 메시지를 피킹하거나 받는 데 사용하는 네이티브 큐 개체에 대한 핸들입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A> 관찰 하 고 큐에서 메시지 수신에 사용 되는 메시지 큐 개체에 대 한 기본 창 핸들을 제공 합니다. 큐의 경로 변경 하면 핸들을 닫고 다시 새 값으로.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <summary>큐에 있는 첫 번째 메시지를 받고, 큐에서 제거합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다. 이 호출은 동기적이므로 메시지를 사용할 수 있을 때까지 현재 실행 스레드를 중단합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 큐에서 메시지를 받거나 큐에 메시지가 도착할 때까지 대기 합니다.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 있는 높은 우선 순위의 메시지가 새로운, 또는 큐에서 다음 메시지를 반환 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.  
  
 에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다. 이 오버 로드 때문에 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 시간 제한이 없음을 지정, 응용 프로그램이 무기한 대기 합니다. 비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에서 메시지를 받은 및 화면으로 해당 메시지에 대 한 정보를 출력 합니다.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다. 이 호출은 동기적이므로 메시지를 사용할 수 있을 때까지 현재 실행 스레드를 중단합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 트랜잭션 큐에서 메시지를 수신 하기는 `transaction` 매개 변수 또는 큐에 메시지가 도착할 때까지 대기 합니다.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.  
  
 트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 에서는 큐의 메시지를 제거 하지 않으며, 호출 하 여 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.  
  
 에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다. 이 오버 로드 때문에 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 시간 제한이 없음을 지정, 응용 프로그램이 무기한 대기 합니다. 비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 로컬 컴퓨터에는 트랜잭션 큐에 연결 하 고 큐에 메시지를 보냅니다. 그런 다음 주문이 포함 된 메시지를 받습니다. Throw 비트랜잭션 큐를 발생 하는 경우 예외 및 트랜잭션 롤백합니다.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우  
  
 또는  
  
 비트랜잭션 큐입니다.</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다. 이 호출은 동기적이므로 메시지를 사용할 수 있을 때까지 현재 실행 스레드를 중단합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에서 메시지를 수신 하기는 `transactionType` 매개 변수 또는 큐에 메시지가 도착할 때까지 대기 합니다.  
  
 지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.  
  
 이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 에서는 큐의 메시지를 제거 하지 않으며, 호출 하 여 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.  
  
 에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다. 이 오버 로드 때문에 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 시간 제한이 없음을 지정, 응용 프로그램이 무기한 대기 합니다. 비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 첫 번째 메시지를 받고, 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버로드를 사용하여 메시지를 받고, 큐에 메시지가 없는 경우에는 지정된 시간 내에 반환합니다.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 동기적으로 메시지를 읽고에 대 한 메서드를 사용 하면 큐에서 제거 합니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 있는 높은 우선 순위의 메시지가 새로운, 또는 큐에서 다음 메시지를 반환 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.  
  
 에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다. 스레드, 또는 무한정 지정된 된 기간에 대 한 차단 될 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다. 비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에서 메시지를 받은 및 화면으로 해당 메시지에 대 한 정보를 출력 합니다. 이 예제에서는 메시지가 큐에 도착할 때까지 기다리는 동안 최대 5 초 동안 실행이 일시 중지 합니다.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <summary>지정된 커서를 사용하여 큐에 있는 현재 메시지를 받습니다. 사용할 수 있는 메시지가 없는 경우 이 메서드는 메시지를 사용할 수 있거나 시간 제한이 만료될 때까지 대기합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우  
  
 이 오버로드를 사용하여 메시지를 받고, 큐에 메시지가 없는 경우에는 지정된 시간 내에 반환합니다.</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐의 첫 번째 메시지를 받으며, 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 트랜잭션 큐에서 메시지를 수신 하기는 `transaction` 매개 변수 및 큐에 메시지가 없는 경우 시간을 지정 된 기간에 반환 합니다.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.  
  
 트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 에서는 큐의 메시지를 제거 하지 않으며, 호출 하 여 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.  
  
 에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다. 스레드, 또는 무한정 지정된 된 기간에 대 한 차단 될 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다. 비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는이 방법 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
 또는  
  
 비트랜잭션 큐입니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다. 이 호출은 동기적이므로 큐에 메시지를 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에서 메시지를 수신 하기는 `transactionType` 매개 변수, 및 지정 된 기간 동안 큐에 메시지가 없는 경우 시간을 반환 합니다.  
  
 지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.  
  
 이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 에서는 큐의 메시지를 제거 하지 않으며, 호출 하 여 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.  
  
 에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다. 스레드, 또는 무한정 지정된 된 기간에 대 한 차단 될 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다. 비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는이 방법 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>지정된 커서를 사용하여 큐에 있는 현재 메시지를 받습니다. 사용할 수 있는 메시지가 없는 경우 이 메서드는 메시지를 사용할 수 있거나 시간 제한이 만료될 때까지 대기합니다.</summary>
        <returns>큐에 있는 메시지를 참조하는 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 트랜잭션 큐에서 메시지를 수신 하기는 `transaction` 매개 변수 및 큐에 메시지가 없는 경우 시간을 지정 된 기간에 반환 합니다.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.  
  
 트랜잭션 큐에서이 메서드는, 때문에 트랜잭션이 중단 되 면 받은 메시지를 큐로 반환 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 큐의 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메시지를 제거 하지 않습니다, 호출 하 여 롤백하지 즉 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.  
  
 에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다. 또는 무한정 지정된 된 기간에 대 한 스레드가 차단 되는 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다. 비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우 <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
 또는  
  
 비트랜잭션 큐입니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <param name="transactionType">메시지와 연결할 트랜잭션 컨텍스트 형식을 설명하는 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나입니다.</param>
        <summary>지정된 커서를 사용하여 큐에 있는 현재 메시지를 받습니다. 사용할 수 있는 메시지가 없는 경우 이 메서드는 메시지를 사용할 수 있거나 시간 제한이 만료될 때까지 대기합니다.</summary>
        <returns>큐에 있는 메시지를 참조하는 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에서 메시지를 수신 하기는 `transactionType` 매개 변수, 및 지정 된 기간 동안 큐에 메시지가 없는 경우 시간을 반환 합니다.  
  
 지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.  
  
 이 메서드는 트랜잭션 큐에서 메시지를 수신 하기, 트랜잭션이 중단 되는 경우 수신 되는 메시지 큐로 반환 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 큐의 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메시지를 제거 하지 않습니다, 호출 하 여 롤백하지 즉 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.  
  
 에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다. 또는 무한정 지정된 된 기간에 대 한 스레드가 차단 되는 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다. 비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우 <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 받습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받습니다. 지정된 상관 관계 식별자가 포함된 메시지가 큐에 현재 존재하지 않는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가 참조 비트랜잭션 큐에서이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수를 예외가 throw 됩니다. 그렇지 않으면 메시지 큐에서 제거 되 고 응용 프로그램에 반환 됩니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 메서드의 고유 식별자를 지정 하 여 메시지를 검색 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제는 큐에서 주문에 포함 된 메시지 송수신 설정 합니다. 원본 메시지가 도달 하거나이 긍정 승인을 특별히 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 트랜잭션 큐로부터 받습니다. 지정된 상관 관계 식별자가 포함된 메시지가 큐에 현재 존재하지 않는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 하는 트랜잭션 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수를 예외가 throw 됩니다. 그렇지 않으면, 메시지 큐에서 제거 고 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 응용 프로그램에 반환 된 `transaction` 매개 변수입니다.  
  
 트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">비트랜잭션 큐입니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 받습니다. 지정된 상관 관계 식별자가 들어 있는 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 하는 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수를 예외가 throw 됩니다. 메시지 큐에서 제거 되 고 정의 된 트랜잭션 컨텍스트를 사용 하 여 응용 프로그램에 반환 되는 그렇지 않은 경우는 `transactionType` 매개 변수입니다.  
  
 지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.  
  
 이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받고, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가 참조 비트랜잭션 큐에서이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 이 메서드는 상관 관계 식별자를 가진 메시지에 지정 된 즉시 반환는 `correlationId` 매개 변수는 큐에 들어갑니다. 그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다. 될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하는 새 메시지는 `correlationId` 매개 변수입니다. 그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.CorrelationId%2A> 일치는 `correlationId` 매개 변수입니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 트랜잭션 큐로부터 받고, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 하는 트랜잭션 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 이 메서드는 상관 관계 식별자를 가진 메시지에 지정 된 즉시 반환는 `correlationId` 매개 변수는 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 큐에는 `transaction` 매개 변수입니다. 그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다. 될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하는 새 메시지는 `correlationId` 매개 변수입니다. 그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.CorrelationId%2A> 일치는 `correlationId` 매개 변수입니다.  
  
 트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.  
  
 또는  
  
 비트랜잭션 큐입니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 받고, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 하는 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 이 메서드는 상관 관계 식별자를 가진 메시지에 지정 된 즉시 반환는 `correlationId` 매개 변수는 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에는 `transactionType` 매개 변수입니다. 그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다. 될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하는 새 메시지는 `correlationId` 매개 변수입니다. 그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.CorrelationId%2A> 일치는 `correlationId` 매개 변수입니다. 지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.  
  
 이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>주어진 식별자를 갖는 메시지를 받고, 큐에서 제거합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <summary>주어진 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받습니다. 지정된 식별자가 들어 있는 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 갖는 메시지를 읽고 큐에서 제거 합니다. 이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.  
  
 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>주어진 식별자를 갖는 메시지를 트랜잭션 큐로부터 받습니다. 지정된 식별자가 포함된 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 가진 포함 된 메시지에 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 하는 `transaction` 매개 변수입니다. 이 메서드에서 예외가 throw 즉시 메시지 큐에 없는 경우  
  
 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.  
  
 트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">비트랜잭션 큐입니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>주어진 식별자를 갖는 메시지를 받습니다. 지정된 식별자가 포함된 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 갖는 메시지를 읽고 큐에서 제거 합니다. 이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다. 메시지 큐에서 제거 되 고 정의 된 트랜잭션 컨텍스트를 사용 하 여 응용 프로그램에 반환 되는 그렇지 않은 경우는 `transactionType` 매개 변수입니다.  
  
 지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.  
  
 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다. 지정한 식별자를 가진 메시지는 큐와 연결 된 것과 다른 경우 <xref:System.Messaging.MessageQueue> 인스턴스 메시지를 찾을 수는 있습니다.  
  
 이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>주어진 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받고, 지정된 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 갖는 메시지를 읽고 큐에서 제거 합니다. 이 메서드는 식별자를 가진 메시지에 지정 된 즉시 반환는 `id` 매개 변수는 큐에 들어갑니다. 그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다. 될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하는 새 메시지는 `id` 매개 변수입니다. 그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.Id%2A> 일치는 `id` 매개 변수입니다.  
  
 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.  
  
 이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 것이 현재 스레드를 차단 하 여 새 메시지에 지정한 제한 시간 내에 큐에 도착 계속으로 허용 되는 `timeout` 매개 변수입니다. 스레드가 차단 됩니다 이상, 또는 무한정 지정된 된 기간 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수를 새 메시지가 계속 하 여 지정 된 제한 시간 내에 큐에 도착 하는 경우 또는 `timeout` 매개 변수입니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 <paramref name="id" />가 지정된 메시지가 큐에 도착하지 않았습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>주어진 식별자를 갖는 메시지를 트랜잭션 큐로부터 받고, 지정된 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 가진 포함 된 메시지에 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 하는 `transaction` 매개 변수입니다. 이 메서드는 식별자를 가진 메시지에 지정 된 즉시 반환는 `id` 매개 변수는 큐에 들어갑니다. 그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다. 될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하는 새 메시지는 `id` 매개 변수입니다. 그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.Id%2A> 일치는 `id` 매개 변수입니다.  
  
 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.  
  
 이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 것이 현재 스레드를 차단 하 여 새 메시지에 지정한 제한 시간 내에 큐에 도착 계속으로 허용 되는 `timeout` 매개 변수입니다. 스레드가 차단 됩니다 이상, 또는 무한정 지정된 된 기간 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수를 새 메시지에 지정 된 시간 제한 기간 내에 큐에 도착 계속 되 면 또는 `timeout` 매개 변수입니다.  
  
 트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 <paramref name="id" />가 지정된 메시지가 큐에 도착하지 않았습니다.  
  
 또는  
  
 비트랜잭션 큐입니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>주어진 식별자를 갖는 메시지를 받고, 지정된 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 갖는 메시지를 읽고 큐에서 제거 합니다. 이 메서드는 식별자를 가진 메시지에 지정 된 즉시 반환는 `id` 매개 변수는 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에는 `transactionType` 매개 변수입니다. 그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다. 될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하는 새 메시지는 `id` 매개 변수입니다. 그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.Id%2A> 일치는 `id` 매개 변수입니다.  
  
 지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.  
  
 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다. 지정한 식별자를 가진 메시지는 큐와 연결 된 것과 다른 경우 <xref:System.Messaging.MessageQueue> 인스턴스 메시지를 찾을 수는 있습니다.  
  
 이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 것이 현재 스레드를 차단 하 여 새 메시지에 지정한 제한 시간 내에 큐에 도착 계속으로 허용 되는 `timeout` 매개 변수입니다. 스레드가 차단 됩니다 이상, 또는 무한정 지정된 된 기간 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수를 새 메시지가 계속 하 여 지정 된 제한 시간 내에 큐에 도착 하는 경우 또는 `timeout` 매개 변수입니다.  
  
 이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 <paramref name="id" />가 지정된 메시지가 큐에 도착하지 않았습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>MSMQ 3.0에서 도입되었습니다. 큐에서 특정 메시지를 받습니다. 메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">받을 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다.</param>
        <summary>MSMQ 3.0에서 도입되었습니다. 비트랜잭션 큐에서 지정된 조회 식별자를 갖는 메시지를 받습니다.</summary>
        <returns>전달된 <paramref name="lookupId" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.LookupId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 조회 식별자를 갖는 메시지를 큐에서 제거 합니다. 이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.  
  
 <xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 해당 메시지가 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 주어진 `lookupId` 매개 변수입니다.  
  
 지정한 lookup 식별자와 메시지를 읽으려면 큐에서 제거 하지 않고, 사용 된 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 메서드.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">큐에서 메시지를 읽는 방법을 지정하는 <see cref="T:System.Messaging.MessageLookupAction" /> 값 중 하나입니다. 다음 중 하나를 지정합니다.  
  
 <see langword="MessageLookupAction.Current" />: <c>lookupId</c>로 지정된 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.Next" />: <c>lookupId</c>로 지정된 메시지의 뒤에 있는 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.Previous" />: <c>lookupId</c>로 지정된 메시지의 앞에 있는 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.First" />: 큐에 있는 첫 번째 메시지를 받고 큐에서 제거합니다. <c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.  
  
 <see langword="MessageLookupAction.Last" />: 큐에 있는 마지막 메시지를 받고 큐에서 제거합니다. <c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.</param>
        <param name="lookupId">0을 수신할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다. 0은 큐에 있는 첫 번째 또는 마지막 메시지에 액세스할 때 사용됩니다.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>MSMQ 3.0에서 도입되었습니다. 트랜잭션 큐에서 특정 메시지를 받습니다. 메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</summary>
        <returns>전달된 <paramref name="lookupId" /> 및 <paramref name="action" /> 매개 변수로 지정된 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 조회 식별자를 갖는 메시지 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 하는 `transaction` 매개 변수입니다. 이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.  
  
 <xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 해당 메시지가 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 주어진 `lookupId` 매개 변수입니다.  
  
 트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 메서드. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 트랜잭션이 중단 된 경우 롤백될 수, 큐에서 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우  
  
 또는  
  
 비트랜잭션 큐입니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 매개 변수가 <see cref="T:System.Messaging.MessageLookupAction" /> 멤버 중 하나가 아닌 경우</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">큐에서 메시지를 읽는 방법을 지정하는 <see cref="T:System.Messaging.MessageLookupAction" /> 값 중 하나입니다. 다음 중 하나를 지정합니다.  
  
 <see langword="MessageLookupAction.Current" />: <c>lookupId</c>로 지정된 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.Next" />: <c>lookupId</c>로 지정된 메시지의 뒤에 있는 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.Previous" />: <c>lookupId</c>로 지정된 메시지의 앞에 있는 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.First" />: 큐에 있는 첫 번째 메시지를 받고 큐에서 제거합니다. <c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.  
  
 <see langword="MessageLookupAction.Last" />: 큐에 있는 마지막 메시지를 받고 큐에서 제거합니다. <c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.</param>
        <param name="lookupId">0을 수신할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다. 0은 큐에 있는 첫 번째 또는 마지막 메시지에 액세스할 때 사용됩니다.</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>MSMQ 3.0에서 도입되었습니다. 지정된 트랜잭션 컨텍스트를 사용하여 큐에서 특정 메시지를 받습니다. 메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</summary>
        <returns>전달된 <paramref name="action" /> 및 <paramref name="lookupId" /> 매개 변수로 지정된 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 조회 식별자를 갖는 메시지 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 하는 `transactionType` 매개 변수입니다. 이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.  
  
 <xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 해당 메시지가 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 주어진 `lookupId` 매개 변수입니다.  
  
 사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 메서드. 에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 트랜잭션이 중단 된 경우 롤백될 수, 큐에서 메시지를 제거 하지 않습니다.  
  
 지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.  
  
 이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 매개 변수가 <see cref="T:System.Messaging.MessageLookupAction" /> 멤버 중 하나가 아닌 경우  
  
 또는  
  
 <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐에서 메시지가 제거된 경우에 발생합니다. 이 이벤트는 비동기 작업인 <see cref="M:System.Messaging.MessageQueue.BeginReceive" />에 의해 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 처리에서 발생 하는 데 사용 되는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 메시지가 큐에서 사용할 수 있는 때입니다.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 하 여 시작 된 작업을 완료 하는 데는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 및 메시지 피킹 때는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 합니다.  
  
 <xref:System.Messaging.ReceiveCompletedEventHandler> 대리자를 만들 때, 이벤트를 처리할 메서드를 식별합니다. 이벤트를 이벤트 처리기와 연결하려면 대리자의 인스턴스를 해당 이벤트에 추가합니다. 대리자를 제거하지 않는 경우 이벤트가 발생할 때마다 이벤트 처리기가 호출됩니다. 이벤트 처리기 대리자에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 라는 이벤트 처리기를 만들고 `MyReceiveCompleted`에 연결는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 처리기 대리자 및 호출 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시작 하는 비동기 수신 작업의 경로에 있는 큐에 ". \myQueue"입니다. 경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면이 예제는 메시지를 받고 화면으로 해당 본문을 작성 합니다. 이 예에서는 다음 호출 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 새 시작을 다시 비동기 수신 작업입니다.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Messaging.MessageQueue" />가 제공하는 속성을 새로 고쳐 리소스의 현재 상태를 반영합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> 속성을 동기화 하는 <xref:System.Messaging.MessageQueue> 리소스가 있는 해당 연결 된 메시지 큐 서버입니다. 경우 속성을 같은 <xref:System.Messaging.MessageQueue.Label%2A> 또는 <xref:System.Messaging.MessageQueue.Category%2A>, 시간 이후 서버에서 변경 되었습니다는 <xref:System.Messaging.MessageQueue> 만들어진 <xref:System.Messaging.MessageQueue.Refresh%2A> 업데이트는 <xref:System.Messaging.MessageQueue> 새 정보로 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Refresh%2A>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>사용 권한 목록을 운영 체제의 기본값으로 다시 설정합니다. 기본 목록에 추가한 큐 권한을 모두 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 경우 <xref:System.Messaging.MessageQueue.ResetPermissions%2A>를 기본값으로 사용 권한 목록을 반환 합니다. 일반적으로이 큐 작성자 모든 사용 권한을 부여 하 고 Everyone 그룹에 게 다음 권한을:  
  
-   큐의 속성을 가져옵니다.  
  
-   큐 권한을 얻습니다.  
  
-   큐에 쓸 수 있습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ResetPermissions%2A>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>큐에 개체를 보냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 비트랜잭션 큐에 개체를 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>합니다. 큐에 보내는 개체 수는 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.  
  
 이 오버 로드를 사용 하 여 트랜잭션 큐로 메시지를 보내려고 하면 메시지가 배달 못 한 편지 큐로 보내집니다. 사용 하는 오버 로드를 사용 하 여 메시지가 다른 메시지를 포함 하는 트랜잭션의 일부가 되도록 하려는 경우는 <xref:System.Messaging.MessageQueueTransaction> 또는 <xref:System.Messaging.MessageQueueTransactionType> 매개 변수로 합니다.  
  
 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다. 지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다. 보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐에 연결 하 고 큐에 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 다음 코드 예제에서는 응용 프로그램 정의 보냅니다 `Order` 큐에 클래스 및 해당 큐에서 메시지를 받습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐에 개체를 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 트랜잭션 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>에 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여는 `transaction` 매개 변수입니다. 큐에 보내는 개체 수는 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.  
  
 비트랜잭션 큐로 메시지를 보내려고이 오버 로드를 사용 하는 경우 예외를 throw 하지 않고 배달 못 한 편지 큐로 메시지를 보낼 수 있습니다.  
  
 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다. 지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다. 보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 <xref:System.Messaging.MessageQueueTransaction> 스레딩 아파트를 인식 아파트 상태가 따라서 `STA`, 트랜잭션이 여러 스레드를 사용할 수 없습니다. 에 주 스레드의 상태를 설정 하는 Visual Basic `STA`적용 해야 하므로 <xref:System.MTAThreadAttribute> 에 `Main` 서브루틴 합니다. 그렇지 않으면 다른 스레드를 사용하여 트랜잭션 메시지를 전달할 때 <xref:System.Messaging.MessageQueueException> 예외가 throw됩니다. 적용 된 <xref:System.MTAThreadAttribute> 다음 부분을 사용 하 여 합니다.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 문자열은 트랜잭션 큐로 보내고 해당 큐에서 메시지를 받습니다.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
 또는  
  
 메시지 큐 응용 프로그램에서 트랜잭션을 잘못 사용했음을 나타냈습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에 개체를 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>, 정의 된 트랜잭션 컨텍스트를 사용 하 여는 `transactionType` 매개 변수입니다. 지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수는 메시지를 보내는 데 사용할 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 전송 하려는 경우. 지정할 수 있습니다 `None` 비트랜잭션 스레드에 트랜잭션 메시지를 전송 하려는 경우.  
  
 큐에 보내는 개체 수는 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.  
  
 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다. 지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다. 보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <param name="label">메시지의 레이블입니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 비트랜잭션 큐에 개체를 보내고 메시지에 레이블을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>합니다. 이 오버 로드를 가진 메시지를 식별 하는 문자열 레이블을 지정할 수 있습니다. 큐에 보내는 개체 수는 <xref:System.Messaging.Message>, 구조체, 데이터 개체 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.  
  
 메시지 레이블에 메시지 큐 레이블 다릅니다 되지만 둘 다 응용 프로그램에 따라 되어 상속 메시지 큐에 의미가 없습니다.  
  
 이 오버 로드를 사용 하 여 트랜잭션 큐로 메시지를 보내려고 하면 메시지가 배달 못 한 편지 큐로 보내집니다. 사용 하는 오버 로드를 사용 하 여 메시지가 다른 메시지를 포함 하는 트랜잭션의 일부가 되도록 하려는 경우는 <xref:System.Messaging.MessageQueueTransaction> 또는 <xref:System.Messaging.MessageQueueTransactionType> 매개 변수로 합니다.  
  
 <xref:System.Messaging.MessageQueue.Path%2A> 이 대 한 속성 <xref:System.Messaging.MessageQueue> 메시지를 보내기 전에 인스턴스를 지정 해야 합니다. 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다. 지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다. 보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <param name="label">메시지의 레이블입니다.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐에 개체를 보내고 메시지에 레이블을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 트랜잭션 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>에 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여는 `transaction` 매개 변수입니다. 이 오버 로드를 가진 메시지를 식별 하는 문자열 레이블을 지정할 수 있습니다. 큐에 보내는 개체 수는 <xref:System.Messaging.Message>, 구조체, 데이터 개체 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.  
  
 메시지 레이블에 메시지 큐 레이블 다릅니다 되지만 둘 다 응용 프로그램에 따라 되어 상속 메시지 큐에 의미가 없습니다.  
  
 비트랜잭션 큐로 메시지를 보내려고이 오버 로드를 사용 하는 경우 예외를 throw 하지 않고 배달 못 한 편지 큐로 메시지를 보낼 수 있습니다.  
  
 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다. 지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다. 보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성  
  
 <xref:System.Messaging.MessageQueueTransaction> 스레딩 아파트를 인식 아파트 상태가 따라서 `STA`, 트랜잭션이 여러 스레드를 사용할 수 없습니다. 에 주 스레드의 상태를 설정 하는 Visual Basic `STA`적용 해야 하므로 <xref:System.MTAThreadAttribute> 에 `Main` 서브루틴 합니다. 그렇지 않으면 다른 스레드를 사용하여 트랜잭션 메시지를 전달할 때 <xref:System.Messaging.MessageQueueException> 예외가 throw됩니다. 적용 된 <xref:System.MTAThreadAttribute> 다음 부분을 사용 하 여 합니다.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 매개 변수가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
 또는  
  
 메시지 큐 응용 프로그램에서 트랜잭션을 잘못 사용했음을 나타냈습니다.  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <param name="label">메시지의 레이블입니다.</param>
        <param name="transactionType">
          <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에 개체를 보내고 메시지에 레이블을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>, 정의 된 트랜잭션 컨텍스트를 사용 하 여는 `transactionType` 매개 변수입니다. 지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수는 메시지를 보내는 데 사용할 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 전송 하려는 경우. 지정할 수 있습니다 `None` 비트랜잭션 스레드에 트랜잭션 메시지를 전송 하려는 경우.  
  
 큐에 보내는 개체 수는 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다. 이 오버 로드를 가진 메시지를 식별 하는 문자열 레이블을 지정할 수 있습니다.  
  
 메시지 레이블에 메시지 큐 레이블 다릅니다 되지만 둘 다 응용 프로그램에 따라 되어 상속 메시지 큐에 의미가 없습니다.  
  
 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다. 지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다. 보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">메시지 큐 응용 프로그램에서 트랜잭션을 잘못 사용했음을 나타냈습니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
 또는  
  
 메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 집합에 사용 권한을 추가합니다. 큐 속성 및 큐에 있는 메시지에 대해 액세스 권한이 있는 사용자를 제어합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">부여할 사용 권한 및 트러스티를 지정하는 액세스 제어 항목이 하나 이상 포함된 <see cref="T:System.Messaging.AccessControlList" />입니다.</param>
        <summary>액세스 제어 목록의 내용을 기준으로 큐에 액세스 권한을 할당합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 권한을 부여, 거부 또는 트러스티 및 사용 권한 정보를 지정 하려면 액세스 제어 항목의 컬렉션을 사용 하 여 권한을 취소 합니다. 이 데, 예를 들어 동시에 여러 사용자에 게 권한을 부여 합니다.  
  
 생성할 때 지정 하는 트러스티는 `ace` 매개 변수는 개별 사용자, 사용자, 그룹 또는 컴퓨터 일 수 있습니다. 트러스티 개별 이면 형식을 사용 `DOMAIN` \\ `user`합니다. 지정할 수 있습니다 "." 트러스티 로컬 컴퓨터에 대 한 합니다.  
  
 통해 할당 한 권한은 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다. 기본적으로 공용 또는 개인 큐의 작성자에 게 모든 권한을 큐 속성, 사용 권한, 가져오고, 큐에 쓸 수 있는 권한이 모든 사용자는 도메인 그룹입니다. 호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보가 기존 목록 맨 아래에 추가 됩니다.  
  
 각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:  
  
-   액세스 거부 됨 <xref:System.Messaging.AccessControlEntry> 는 스레드의 액세스 토큰에 표시 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.  
  
-   하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티는 스레드의 액세스 토큰에 명시적으로 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.  
  
-   모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로,이 경우 암시적으로 액세스할 수 있습니다.  
  
 생성할 때는 `dacl` 추가 매개 변수를 <xref:System.Messaging.AccessControlEntry> 인스턴스 여 <xref:System.Messaging.AccessControlList> 컬렉션입니다. 각 액세스 제어 항목을 생성할 때 일반 또는 표준 액세스 권한을 지정할 수 있습니다. 큐에 대 한 권한은 다음의 조합이 포함 될 수 있습니다.  
  
-   삭제  
  
-   보안 읽기  
  
-   보안 쓰기  
  
-   동기화  
  
-   소유자 수정  
  
-   읽기  
  
-   Write  
  
-   실행  
  
-   필수  
  
-   모두  
  
-   없음  
  
 이러한 권한은 비트 OR 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합으로 구성 합니다.  
  
-   모든 권한  
  
-   메시지를 삭제 합니다.  
  
-   메시지를 수신 합니다.  
  
-   메시지 엿보기  
  
-   저널 메시지 받기  
  
-   큐 속성  
  
-   큐 속성 설정  
  
-   사용 권한 가져오기  
  
-   사용 권한 설정  
  
-   큐 소유권 가져오기  
  
-   메시지 작성  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>의 사용법을 보여줍니다.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">사용자, 액세스 형식 및 사용 권한 형식을 지정하는 <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />입니다.</param>
        <summary>액세스 제어 항목의 내용을 기준으로 큐에 액세스 권한을 할당합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 권한을 부여, 거부 또는 트러스티 및 권한 정보를 지정 하는 액세스 제어 항목을 사용 하 여 권한을 취소 합니다.  
  
 생성할 때 지정 하는 트러스티는 `ace` 매개 변수는 개별 사용자, 사용자, 그룹 또는 컴퓨터 일 수 있습니다. 트러스티 개별 이면 형식을 사용 `DOMAIN` \\ `user`합니다. 지정할 수 있습니다 "." 트러스티 로컬 컴퓨터에 대 한 합니다.  
  
 통해 할당 한 권한은 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다. 기본적으로 공용 또는 개인 큐의 작성자에 게 모든 권한을 큐 속성, 사용 권한, 가져오고, 큐에 쓸 수 있는 권한이 모든 사용자는 도메인 그룹입니다. 호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보가 기존 목록 맨 아래에 추가 됩니다.  
  
 각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:  
  
-   액세스 거부 됨 <xref:System.Messaging.AccessControlEntry> 는 스레드의 액세스 토큰에 표시 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.  
  
-   하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티는 스레드의 액세스 토큰에 명시적으로 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.  
  
-   모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로,이 경우 암시적으로 액세스할 수 있습니다.  
  
 지정 하는 큐에 대 한 권한을 `rights` 매개 변수를 생성할 때 프로그램 <xref:System.Messaging.MessageQueueAccessControlEntry>, 다음의 조합일 수 있습니다.  
  
-   모든 권한  
  
-   메시지를 삭제 합니다.  
  
-   메시지를 수신 합니다.  
  
-   메시지 엿보기  
  
-   저널 메시지 받기  
  
-   큐 속성  
  
-   큐 속성 설정  
  
-   사용 권한 가져오기  
  
-   사용 권한 설정  
  
-   큐 소유권 가져오기  
  
-   메시지 작성  
  
 `rights` 에 대 한 생성자에서 지정한 매개 변수는 `ace` 매개 변수는의 플래그는 <xref:System.Messaging.MessageQueueAccessRights> 열거형입니다. 비트 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합을 나타냅니다를 빌드할 때는 `rights` 매개 변수입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">큐에 대한 추가 권한을 가져오는 개인, 그룹 또는 컴퓨터입니다.</param>
        <param name="rights">전달된 <c>사용자</c>에 메시지 큐 서비스가 할당하는 큐에 대한 권한 집합을 나타내는 <see cref="T:System.Messaging.MessageQueueAccessRights" />입니다.</param>
        <summary>지정된 액세스 권한을 컴퓨터, 그룹, 또는 사용자에게 부여합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 개별 사용자에 지정 된 권한을 부여 합니다. 사용자는 개별 사용자에 게, 사용자, 그룹 또는 컴퓨터를 포함 하는 모든 유효한 트러스티를 수 있습니다. 사용자가 개인을 사용 하 여 형식을 `DOMAIN` \\ `user` 에 대 한는 `user` 매개 변수입니다. 지정할 수 있습니다 "."에 대 한는 `user` 로컬 컴퓨터를 나타내기 위해 매개 변수입니다.  
  
 통해 할당 한 권한은 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다. 기본적으로 공용 또는 개인 큐의 작성자에 게 모든 권한을 큐 속성, 사용 권한, 가져오고, 큐에 쓸 수 있는 권한이 모든 사용자는 도메인 그룹입니다. 호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보가 기존 목록 맨 아래에 추가 됩니다.  
  
 각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:  
  
-   액세스 거부 됨 <xref:System.Messaging.AccessControlEntry> 는 스레드의 액세스 토큰에 표시 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.  
  
-   하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티는 스레드의 액세스 토큰에 명시적으로 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.  
  
-   모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로,이 경우 암시적으로 액세스할 수 있습니다.  
  
 에 지정 된 큐에 대 한 권한을 `rights` 매개 변수를 다음의 조합일 수 있습니다.  
  
-   모든 권한  
  
-   메시지를 삭제 합니다.  
  
-   메시지를 수신 합니다.  
  
-   메시지 엿보기  
  
-   저널 메시지 받기  
  
-   큐 속성  
  
-   큐 속성 설정  
  
-   사용 권한 가져오기  
  
-   사용 권한 설정  
  
-   큐 소유권 가져오기  
  
-   메시지 작성  
  
 <xref:System.Messaging.MessageQueueAccessRights> 열거형은 빌드 또는 비트 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합 나타냅니다는 `rights` 매개 변수입니다.  
  
 이 오버 로드를 가진만 권한을 부여할 수 있습니다. 취소 하거나 거부할 수 없습니다. 명시적으로 부여 된 다른 오버 로드를 사용 해야 <xref:System.Messaging.AccessControlEntryType> 이외의 `Allow`합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="user" />이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">큐에 대한 추가 권한을 가져오는 개인, 그룹 또는 컴퓨터입니다.</param>
        <param name="rights">전달된 <c>사용자</c>에 메시지 큐 서비스가 할당하는 큐에 대한 권한 집합을 나타내는 <see cref="T:System.Messaging.MessageQueueAccessRights" />입니다.</param>
        <param name="entryType">
          <c>rights</c> 매개 변수로 지정된 사용 권한을 부여할지 거부할지 또는 해지할지를 지정하는 <see cref="T:System.Messaging.AccessControlEntryType" />입니다.</param>
        <summary>지정된 액세스 제어 형식(예: 허용, 거부, 해지, 또는 설정)을 포함하여, 지정된 액세스 권한을 컴퓨터, 그룹 또는 사용자에게 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 권한을 부여, 거부 또는 개별 사용자에 대 한 지정 된 권한을 취소 합니다. 사용자는 개별 사용자에 게, 사용자, 그룹 또는 컴퓨터를 포함 하는 모든 유효한 트러스티를 수 있습니다. 사용자가 개인을 사용 하 여 형식을 `DOMAIN` \\ `user` 에 대 한는 `user` 매개 변수입니다. 지정할 수 있습니다 "."에 대 한는 `user` 로컬 컴퓨터를 나타내기 위해 매개 변수입니다.  
  
 통해 할당 한 권한은 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다. 기본적으로 공용 또는 개인 큐의 작성자에 게 모든 권한을 큐 속성, 사용 권한, 가져오고, 큐에 쓸 수 있는 권한이 모든 사용자는 도메인 그룹입니다. 호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보가 기존 목록 맨 아래에 추가 됩니다.  
  
 각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:  
  
-   액세스 거부 됨 <xref:System.Messaging.AccessControlEntry> 는 스레드의 액세스 토큰에 표시 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.  
  
-   하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티는 스레드의 액세스 토큰에 명시적으로 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.  
  
-   모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로,이 경우 암시적으로 액세스할 수 있습니다.  
  
 에 지정 된 큐에 대 한 권한을 `rights` 매개 변수를 다음의 조합일 수 있습니다.  
  
-   모든 권한  
  
-   메시지를 삭제 합니다.  
  
-   메시지를 수신 합니다.  
  
-   메시지 엿보기  
  
-   저널 메시지 받기  
  
-   큐 속성  
  
-   큐 속성 설정  
  
-   사용 권한 가져오기  
  
-   사용 권한 설정  
  
-   큐 소유권 가져오기  
  
-   메시지 작성  
  
 <xref:System.Messaging.MessageQueueAccessRights> 열거형은 빌드 또는 비트 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합 나타냅니다는 `rights` 매개 변수입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 또는 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 이벤트의 결과로 생성된 이벤트 처리기의 호출을 마샬링하는 개체를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> 또는 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 이벤트의 결과로 생성된 이벤트 처리기의 호출을 마샬링하는 개체를 나타내는 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Messaging.MessageQueue.ReceiveCompleted> 또는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트에서 결과 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 또는 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 각각 특정 스레드를 요청 합니다. 일반적으로 <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> 해당 구성 요소에 지정 된 스레드에 바인딩되므로 관련된 구성 요소 컨트롤 또는 폼에 배치 된 경우 설정 됩니다.  
  
 일반적으로 동기화 개체는 메서드 호출을을 단일 스레드를 마샬링합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐가 트랜잭션만 허용하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          큐가 트랜잭션의 일부로서 전달된 메시지만 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 트랜잭션 메시지를 단일 트랜잭션에 관련 된 여러 메시지의 결합을 참조합니다. 트랜잭션의 일부는 메시지가 순서 대로 배달 보장 메시지를 보내는 한 번만 배달 되 고 대상 큐에서 성공적으로 검색 합니다.  
  
 트랜잭션 대기열의 경우에 트랜잭션의 일부로 전송 되는 메시지에만 허용 합니다. 하지만 비트랜잭션 메시지가 수 전송 되거나 명시적으로 트랜잭션를 사용 하지 않고 로컬 트랜잭션 큐에서 수신 <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, 및 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 구문입니다. 비트랜잭션 메시지가 트랜잭션 큐로 전송 되,이 구성 요소는 단일 메시지 트랜잭션을 만듭니다,에 대 한 제외 하 고 직접 형식 이름을 사용 하 여 원격 컴퓨터에 있는 큐를 참조 하는 경우. 이 상황에서 메시지를 보낼 때 트랜잭션 컨텍스트를 지정 하지 않으면 하나 드립니다 만들어지지 않습니다 및 메시지 배달 못 한 편지 큐로 보내집니다.  
  
 비트랜잭션 메시지가 트랜잭션 큐 보내기에서 예외가 발생할 경우 메시지를 롤백할 수 없게 됩니다.  
  
 <xref:System.Messaging.MessageQueueTransaction> 스레딩 아파트를 인식 아파트 상태가 따라서 `STA`, 트랜잭션이 여러 스레드를 사용할 수 없습니다. 에 주 스레드의 상태를 설정 하는 Visual Basic `STA`적용 해야 하므로 <xref:System.MTAThreadAttribute> 에 `Main` 서브루틴 합니다. 그렇지 않으면 다른 스레드를 사용하여 트랜잭션 메시지를 전달할 때 <xref:System.Messaging.MessageQueueException> 예외가 throw됩니다. 적용 된 <xref:System.MTAThreadAttribute> 다음 부분을 사용 하 여 합니다.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.Transactional%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>받은 메시지가 업무 일지 큐로 복사되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          큐에서 받은 메시지가 해당 업무 일지 큐로 복사되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐 응용 프로그램에서 새 응용 프로그램 큐를 동일한 위치에 자동으로 연결 된 저널 큐를 만듭니다. 큐에서 제거 된 메시지를 추적 하는 저널 큐 사용 됩니다. 이 속성을 설정 하면 메시지 큐를 수정 합니다. 따라서 다른 모든 <xref:System.Messaging.MessageQueue> 인스턴스 변경의 영향을 받는 합니다.  
  
 저널 큐의 받는 시간이 타이머가 만료 되었습니다 (Information Store 또는 Active Directory)는 메시지 큐 디렉터리 서비스를 사용 하 여 큐에서 제거 된 메시지 추적 때문에 큐에서 제거 된 메시지를 추적 하지 않습니다.  
  
 응용 프로그램; 업무 일지 큐에 메시지를 보낼 수 없습니다. 이러한 큐의 읽기 전용 액세스로 제한 됩니다. 또한 메시지 큐는 저널 큐에서 메시지를 제거 하지 않습니다. 큐를 사용 하 여 응용 프로그램 받는 하거나 큐를 제거 하 여 이러한 메시지를 지워야 합니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 큐에 메시지를 보내는 데 사용되는 기본 핸들을 가져옵니다.</summary>
        <value>큐에 메시지를 보내는 데 사용하는 네이티브 큐 개체에 대한 핸들입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A> 큐에 메시지를 보내는 데 사용 되는 메시지 큐 개체에 대 한 기본 창 핸들을 제공 합니다. 큐의 경로 변경 하면 핸들을 닫고 다시 새 값으로.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐를 쓰기 작업에 사용할 수 없습니다.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>