<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="79d78-101">메시지 큐 서버에 있는 큐에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-101">Provides access to a queue on a Message Queuing server.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-102">메시지 큐 기술을 실행 중인 응용 프로그램이 서로 다른 시간에 다른 유형의 네트워크와 일시적으로 오프 라인 시스템 간에 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-102">The Message Queuing technology allows applications running at different times to communicate across heterogeneous networks and systems that might be temporarily offline.</span></span> <span data-ttu-id="79d78-103">응용 프로그램 송신, 수신, 또는 큐에서 메시지 (제거 하지 않고 읽기) 피크 (peek).</span><span class="sxs-lookup"><span data-stu-id="79d78-103">Applications send, receive, or peek (read without removing) messages from queues.</span></span> <span data-ttu-id="79d78-104">메시지 큐의 선택적 구성 요소는 [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 및 Windows NT 별도로 설치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-104">Message Queuing is an optional component of [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] and Windows NT, and must be installed separately.</span></span>  
  
 <span data-ttu-id="79d78-105"><xref:System.Messaging.MessageQueue> 클래스는 메시지 큐에 대 한 래퍼입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-105">The <xref:System.Messaging.MessageQueue> class is a wrapper around Message Queuing.</span></span> <span data-ttu-id="79d78-106">메시지 큐를 사용 하 여 여러 버전의 <xref:System.Messaging.MessageQueue> 사용 중인 운영 체제에 따라, 클래스 약간 다른 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-106">There are multiple versions of Message Queuing, and using the <xref:System.Messaging.MessageQueue> class can result in slightly different behavior, depending on the operating system you are using.</span></span> <span data-ttu-id="79d78-107">메시지 큐의 각 버전의 특정 기능에 대 한 정보를 msdn에서 Platform SDK의 새로운 기능 "을 메시지 큐에서" 항목을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-107">For information about specific features of each version of Message Queuing, see the topic "What's New in Message Queuing" in the Platform SDK in MSDN.</span></span>  
  
 <span data-ttu-id="79d78-108"><xref:System.Messaging.MessageQueue> 클래스는 메시지 큐에 대 한 참조를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-108">The <xref:System.Messaging.MessageQueue> class provides a reference to a Message Queuing queue.</span></span> <span data-ttu-id="79d78-109">경로 지정할 수는 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자는 기존 리소스에 연결 하는 서버에서 새 큐를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-109">You can specify a path in the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor to connect to an existing resource, or you can create a new queue on the server.</span></span> <span data-ttu-id="79d78-110">호출 하기 전에 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, 또는 <xref:System.Messaging.MessageQueue.Receive%2A>의 새 인스턴스를 연결 해야 합니다는 <xref:System.Messaging.MessageQueue> 기존 큐를 사용 하 여 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-110">Before you can call <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, or <xref:System.Messaging.MessageQueue.Receive%2A>, you must associate the new instance of the <xref:System.Messaging.MessageQueue> class with an existing queue.</span></span> <span data-ttu-id="79d78-111">와 같은 큐 속성을 조작할 수는 해당 시점에 <xref:System.Messaging.MessageQueue.Category%2A> 및 <xref:System.Messaging.MessageQueue.Label%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-111">At that point, you can manipulate the queue properties such as <xref:System.Messaging.MessageQueue.Category%2A> and <xref:System.Messaging.MessageQueue.Label%2A>.</span></span>  
  
 <span data-ttu-id="79d78-112"><xref:System.Messaging.MessageQueue> 두 가지 유형의 메시지 검색 지원: 동기 및 비동기입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-112"><xref:System.Messaging.MessageQueue> supports two types of message retrieval: synchronous and asynchronous.</span></span> <span data-ttu-id="79d78-113">동기 메서드 <xref:System.Messaging.MessageQueue.Peek%2A> 및 <xref:System.Messaging.MessageQueue.Receive%2A>, 프로세스 스레드가 지정된 된 시간 간격을 큐에 도착할 때까지 새 메시지에 대해 기다려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-113">The synchronous methods, <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.Receive%2A>, cause the process thread to wait a specified time interval for a new message to arrive in the queue.</span></span> <span data-ttu-id="79d78-114">비동기 메서드를 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 및 <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 별도의 스레드에서 계속 하면 메시지가 큐에 도착할 때까지 주 응용 프로그램 작업을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-114">The asynchronous methods, <xref:System.Messaging.MessageQueue.BeginPeek%2A> and <xref:System.Messaging.MessageQueue.BeginReceive%2A>, allow the main application tasks to continue in a separate thread until a message arrives in the queue.</span></span> <span data-ttu-id="79d78-115">이러한 메서드는 스레드 간의 의사 소통이 콜백 개체 및 상태 개체를 사용 하 여 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-115">These methods work by using callback objects and state objects to communicate information between threads.</span></span>  
  
 <span data-ttu-id="79d78-116">새 인스턴스를 만들 때는 <xref:System.Messaging.MessageQueue> 클래스를 만들지 않고 새 메시지 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-116">When you create a new instance of the <xref:System.Messaging.MessageQueue> class, you are not creating a new Message Queuing queue.</span></span> <span data-ttu-id="79d78-117">대신 사용할 수는 <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, 및 <xref:System.Messaging.MessageQueue.Purge%2A> 서버에서 큐를 관리 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-117">Instead, you can use the <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, and <xref:System.Messaging.MessageQueue.Purge%2A> methods to manage queues on the server.</span></span>  
  
 <span data-ttu-id="79d78-118">와 달리 <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> 및 <xref:System.Messaging.MessageQueue.Delete%28System.String%29> 는 `static` 멤버의 새 인스턴스를 만들지 않고 전화할 수 이므로 <xref:System.Messaging.MessageQueue> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-118">Unlike <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> and <xref:System.Messaging.MessageQueue.Delete%28System.String%29> are `static` members, so you can call them without creating a new instance of the <xref:System.Messaging.MessageQueue> class.</span></span>  
  
 <span data-ttu-id="79d78-119">설정할 수 있습니다는 <xref:System.Messaging.MessageQueue> 개체의 <xref:System.Messaging.MessageQueue.Path%2A> 세 가지 이름 중 하나를 사용 하 여 속성: 이름는 <xref:System.Messaging.MessageQueue.FormatName%2A>, 또는 <xref:System.Messaging.MessageQueue.Label%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-119">You can set the <xref:System.Messaging.MessageQueue> object's <xref:System.Messaging.MessageQueue.Path%2A> property with one of three names: the friendly name, the <xref:System.Messaging.MessageQueue.FormatName%2A>, or the <xref:System.Messaging.MessageQueue.Label%2A>.</span></span> <span data-ttu-id="79d78-120">큐의 문자로 정의 되는 식별 이름을 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성은 <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> 공개 큐에 대 한 및 <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> 개인 큐에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-120">The friendly name, which is defined by the queue's <xref:System.Messaging.MessageQueue.MachineName%2A> and <xref:System.Messaging.MessageQueue.QueueName%2A> properties, is <xref:System.Messaging.MessageQueue.MachineName%2A>\\<xref:System.Messaging.MessageQueue.QueueName%2A> for a public queue, and <xref:System.Messaging.MessageQueue.MachineName%2A>\\`Private$`\\<xref:System.Messaging.MessageQueue.QueueName%2A> for a private queue.</span></span> <span data-ttu-id="79d78-121"><xref:System.Messaging.MessageQueue.FormatName%2A> 속성 메시지 큐에 대 한 오프 라인 액세스를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-121">The <xref:System.Messaging.MessageQueue.FormatName%2A> property allows offline access to message queues.</span></span> <span data-ttu-id="79d78-122">마지막으로 큐의 사용할 수 있습니다 <xref:System.Messaging.MessageQueue.Label%2A> 속성을 설정 큐의 <xref:System.Messaging.MessageQueue.Path%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-122">Lastly, you can use the queue's <xref:System.Messaging.MessageQueue.Label%2A> property to set the queue's <xref:System.Messaging.MessageQueue.Path%2A>.</span></span>  
  
 <span data-ttu-id="79d78-123">인스턴스에 대 한 초기 속성 값 목록은 <xref:System.Messaging.MessageQueue>, 참조는 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-123">For a list of initial property values for an instance of <xref:System.Messaging.MessageQueue>, see the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79d78-124">다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 다양 한 경로 이름 구문 형식을 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-124">The following code example creates new <xref:System.Messaging.MessageQueue> objects using various path name syntax types.</span></span> <span data-ttu-id="79d78-125">각각의 경우에서 경로가 생성자에 정의 된 큐로 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-125">In each case, it sends a message to the queue whose path is defined in the constructor.</span></span>  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 <span data-ttu-id="79d78-126">다음 코드 예제에서는 큐에 메시지를 보내고 라고 하는 응용 프로그램 관련 클래스를 사용 하 여 큐에서 메시지를 받은 `Order`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-126">The following code example sends a message to a queue, and receives a message from a queue, using an application-specific class called `Order`.</span></span>  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="79d78-127">만 <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> 메서드는 스레드로부터 안전 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-127">Only the <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> method is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-128"><see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-128">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-129"><see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-129">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</span></span> <span data-ttu-id="79d78-130">기본 생성자가 새 인스턴스를 초기화하면, 이 인스턴스를 사용하기 전에 인스턴스의 <see cref="P:System.Messaging.MessageQueue.Path" /> 속성을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-130">After the default constructor initializes the new instance, you must set the instance's <see cref="P:System.Messaging.MessageQueue.Path" /> property before you can use the instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-131">이 오버 로드를 사용 하 여의 새 인스턴스를 만드는 <xref:System.Messaging.MessageQueue> 메시지 큐 서버에 있는 큐에 바로 연결 되지 않은 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-131">Use this overload to create a new instance of the <xref:System.Messaging.MessageQueue> class that is not immediately tied to a queue on the Message Queuing server.</span></span> <span data-ttu-id="79d78-132">이 인스턴스를 사용 하기 전에 연결 해야 기존 메시지 큐 큐를 설정 하 여는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-132">Before using this instance, you must connect it to an existing Message Queuing queue by setting the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span> <span data-ttu-id="79d78-133">설정할 수 있습니다는 <xref:System.Messaging.MessageQueue> 에 대 한 참조는 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 여는 새 메시지 큐를 만들 메서드의 반환 값입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-133">Alternatively, you can set the <xref:System.Messaging.MessageQueue> reference to the <xref:System.Messaging.MessageQueue.Create%28System.String%29> method's return value, thereby creating a new Message Queuing queue.</span></span>  
  
 <span data-ttu-id="79d78-134"><xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자의 새 인스턴스를 인스턴스화하는 <xref:System.Messaging.MessageQueue> 클래스입니다; 새 메시지 큐를 만들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-134">The <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor instantiates a new instance of the <xref:System.Messaging.MessageQueue> class; it does not create a new Message Queuing queue.</span></span>  
  
 <span data-ttu-id="79d78-135">다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.MessageQueue>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-135">The following table shows initial property values for an instance of <xref:System.Messaging.MessageQueue>.</span></span>  
  
|<span data-ttu-id="79d78-136">속성</span><span class="sxs-lookup"><span data-stu-id="79d78-136">Property</span></span>|<span data-ttu-id="79d78-137">초기 값</span><span class="sxs-lookup"><span data-stu-id="79d78-137">Initial value</span></span>|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|<span data-ttu-id="79d78-138">기본 생성자가 설정한 값은 <xref:System.Messaging.DefaultPropertiesToSend> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-138">The values set by the default constructor of the <xref:System.Messaging.DefaultPropertiesToSend> class.</span></span>|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|<span data-ttu-id="79d78-139">기본 생성자가 설정한 값은 <xref:System.Messaging.MessagePropertyFilter> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-139">The values set by the default constructor of the <xref:System.Messaging.MessagePropertyFilter> class.</span></span> <span data-ttu-id="79d78-140">모든 필터 값으로 설정 된 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-140">All the filter values are set to `true`.</span></span>|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-141">다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-141">The following code example creates a new <xref:System.Messaging.MessageQueue>.</span></span>  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="79d78-142">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-142">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span></param>
        <summary><span data-ttu-id="79d78-143">지정된 경로에 있는 메시지 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-143">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class that references the Message Queuing queue at the specified path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-144">새 연결 하려는 경우이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue> 경로, 형식 이름 또는 레이블을 알아야 특정 메시지 큐 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="79d78-144">Use this overload when you want to tie the new <xref:System.Messaging.MessageQueue> instance to a particular Message Queuing queue, for which you know the path, format name, or label.</span></span> <span data-ttu-id="79d78-145">큐를 참조 하는 첫 번째 응용 프로그램에 대 한 단독 액세스 권한을 부여 하려는 경우 설정 해야 합니다는 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 속성을 `true` 하거나 읽기 액세스 제한 매개 변수를 전달 하는 생성자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-145">If you want to grant exclusive access to the first application that references the queue, you must set the <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> property to `true` or use the constructor that passes a read-access restriction parameter.</span></span>  
  
 <span data-ttu-id="79d78-146"><xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자의 새 인스턴스를 인스턴스화하는 <xref:System.Messaging.MessageQueue> 클래스입니다; 새 메시지 큐를 만들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-146">The <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor instantiates a new instance of the <xref:System.Messaging.MessageQueue> class; it does not create a new Message Queuing queue.</span></span> <span data-ttu-id="79d78-147">메시지 큐에서 새 큐를 만들려면 사용 <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-147">To create a new queue in Message Queuing, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.</span></span>  
  
 <span data-ttu-id="79d78-148">구문은 `path` 매개 변수 유형에 따라 다릅니다 큐의 해당 참조는 다음 표에 나와 있는 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-148">The syntax of the `path` parameter depends on the type of queue it references, as shown in the following table.</span></span>  
  
|<span data-ttu-id="79d78-149">큐 유형</span><span class="sxs-lookup"><span data-stu-id="79d78-149">Queue type</span></span>|<span data-ttu-id="79d78-150">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-150">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="79d78-151">공개 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-151">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="79d78-152">개인 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-152">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
|<span data-ttu-id="79d78-153">저널 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-153">Journal queue</span></span>|`MachineName`\\`QueueName`\\`Journal$`|  
|<span data-ttu-id="79d78-154">컴퓨터 저널 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-154">Machine journal queue</span></span>|`MachineName`\\`Journal$`|  
|<span data-ttu-id="79d78-155">컴퓨터 배달 못 한 편지 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-155">Machine dead-letter queue</span></span>|`MachineName`\\`Deadletter$`|  
|<span data-ttu-id="79d78-156">컴퓨터 트랜잭션 배달 못 한 편지 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-156">Machine transactional dead-letter queue</span></span>|`MachineName`\\`XactDeadletter$`|  
  
 <span data-ttu-id="79d78-157">사용할 수 있습니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 또는 <xref:System.Messaging.MessageQueue.Label%2A> 다음 표에 나와 있는 것 처럼 큐 경로 설명 하기 위해 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-157">Alternatively, you can use the <xref:System.Messaging.MessageQueue.FormatName%2A> or <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path, as shown in the following table.</span></span>  
  
|<span data-ttu-id="79d78-158">참조</span><span class="sxs-lookup"><span data-stu-id="79d78-158">Reference</span></span>|<span data-ttu-id="79d78-159">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-159">Syntax</span></span>|<span data-ttu-id="79d78-160">예</span><span class="sxs-lookup"><span data-stu-id="79d78-160">Example</span></span>|  
|---------------|------------|-------------|  
|<span data-ttu-id="79d78-161">형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-161">Format name</span></span>|<span data-ttu-id="79d78-162">`FormatName:` [ *형식 이름을* ]</span><span class="sxs-lookup"><span data-stu-id="79d78-162">`FormatName:` [ *format name* ]</span></span>|<span data-ttu-id="79d78-163">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span><span class="sxs-lookup"><span data-stu-id="79d78-163">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span></span><br /><br /> <span data-ttu-id="79d78-164">`FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="79d78-164">`FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`</span></span><br /><br /> <span data-ttu-id="79d78-165">`FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="79d78-165">`FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`</span></span><br /><br /> <span data-ttu-id="79d78-166">`FormatName:DIRECT=OS:` `MachineName`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="79d78-166">`FormatName:DIRECT=OS:` `MachineName`\\`QueueName`</span></span>|  
|<span data-ttu-id="79d78-167">레이블</span><span class="sxs-lookup"><span data-stu-id="79d78-167">Label</span></span>|<span data-ttu-id="79d78-168">`Label:` [ *레이블* ]</span><span class="sxs-lookup"><span data-stu-id="79d78-168">`Label:` [ *label* ]</span></span>|<span data-ttu-id="79d78-169">`Label:` TheLabel</span><span class="sxs-lookup"><span data-stu-id="79d78-169">`Label:` TheLabel</span></span>|  
  
 <span data-ttu-id="79d78-170">오프 라인으로 작업 하는 경로 이름 구문을 사용 하지 않고 생성자에 대 한 형식 이름 구문을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-170">To work offline, you must use the format name syntax, not the path name syntax for the constructor.</span></span> <span data-ttu-id="79d78-171">그렇지 않으면 주 도메인 컨트롤러를 형식 이름에 경로 확인할 수 없기 때문에 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-171">Otherwise, an exception is thrown because the primary domain controller is not available to resolve the path to the format name.</span></span>  
  
 <span data-ttu-id="79d78-172">다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.MessageQueue>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-172">The following table shows initial property values for an instance of <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="79d78-173">이러한 값은 지정 된 경로와 메시지 큐의 속성에 기반는 `path` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-173">These values are based on the properties of the Message Queuing queue with the path specified by the `path` parameter.</span></span>  
  
|<span data-ttu-id="79d78-174">속성</span><span class="sxs-lookup"><span data-stu-id="79d78-174">Property</span></span>|<span data-ttu-id="79d78-175">초기 값</span><span class="sxs-lookup"><span data-stu-id="79d78-175">Initial value</span></span>|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|<span data-ttu-id="79d78-176">0</span><span class="sxs-lookup"><span data-stu-id="79d78-176">0</span></span>|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|<span data-ttu-id="79d78-177">기본 생성자가 설정한 값은 <xref:System.Messaging.DefaultPropertiesToSend> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-177">The values set by the default constructor of the <xref:System.Messaging.DefaultPropertiesToSend> class.</span></span>|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|<span data-ttu-id="79d78-178">`true`"Body"; 경우 메시지 큐의 개인 정보 수준 설정 그렇지 않으면 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-178">`true`, if the Message Queuing queue's privacy level setting is "Body"; otherwise, `false`.</span></span>|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|<span data-ttu-id="79d78-179">메시지 큐의 컴퓨터 이름 속성의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-179">The value of the Message Queuing queue's computer name property.</span></span>|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|<span data-ttu-id="79d78-180">기본 생성자가 설정한 값은 <xref:System.Messaging.MessagePropertyFilter> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-180">The values set by the default constructor of the <xref:System.Messaging.MessagePropertyFilter> class.</span></span>|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<span data-ttu-id="79d78-181"><xref:System.String.Empty>을 생성자에 의해 설정 되지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-181"><xref:System.String.Empty>, if not set by the constructor.</span></span>|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<span data-ttu-id="79d78-182"><xref:System.String.Empty>을 생성자에 의해 설정 되지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-182"><xref:System.String.Empty>, if not set by the constructor.</span></span>|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|<span data-ttu-id="79d78-183">`true`메시지 큐 개체의 저널 설정을 사용 합니다. 그렇지 않으면 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-183">`true`, if the Message Queuing object's journal setting is enabled; otherwise, `false`.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-184">다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 다양 한 경로 이름 구문 형식을 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-184">The following code example creates new <xref:System.Messaging.MessageQueue> objects using various path name syntax types.</span></span> <span data-ttu-id="79d78-185">각각의 경우에서 경로가 생성자에 정의 된 큐로 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-185">In each case, it sends a message to the queue whose path is defined in the constructor.</span></span>  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-186"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 유효하지 않습니다(예: 속성을 설정하지 않은 경우).</span><span class="sxs-lookup"><span data-stu-id="79d78-186">The <see cref="P:System.Messaging.MessageQueue.Path" /> property is not valid, possibly because it has not been set.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="79d78-187">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-187">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</span></span></param>
        <param name="sharedModeDenyReceive">
          <span data-ttu-id="79d78-188">첫 번째로 큐에 액세스하는 응용 프로그램에 단독 읽기 권한을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-188"><see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="79d78-189">지정된 경로에 위치하고 읽기 액세스 제한이 설정된 메시지 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-189">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class that references the Message Queuing queue at the specified path and with the specified read-access restriction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-190">새 연결 하려는 경우이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue> 경로, 형식 이름 또는 레이블을 알아야 특정 메시지 큐에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-190">Use this overload when you want to tie the new <xref:System.Messaging.MessageQueue> to a particular Message Queuing queue, for which you know the path, format name, or label.</span></span> <span data-ttu-id="79d78-191">큐를 참조 하는 첫 번째 응용 프로그램에 대 한 단독 액세스 권한을 부여 하려면, 설정 된 `sharedModeDenyReceive` 매개 변수를 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-191">If you want to grant exclusive access to the first application that references the queue, set the `sharedModeDenyReceive` parameter to `true`.</span></span> <span data-ttu-id="79d78-192">그렇지 않으면 설정 `sharedModeDenyReceive` 를 `false` 만 생성자를 사용 하거나는 `path` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-192">Otherwise, set `sharedModeDenyReceive` to `false` or use the constructor that has only a `path` parameter.</span></span>  
  
 <span data-ttu-id="79d78-193">설정 `sharedModeDenyReceive` 를 `true` 다른 응용 프로그램을 포함 하 여 메시지 큐 큐에 액세스 하는 모든 개체에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-193">Setting `sharedModeDenyReceive` to `true` affects all objects that access the Message Queuing queue, including other applications.</span></span> <span data-ttu-id="79d78-194">매개 변수의 효과이 응용 프로그램에 제한 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-194">The effects of the parameter are not restricted to this application.</span></span>  
  
 <span data-ttu-id="79d78-195"><xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자의 새 인스턴스를 만듭니다.는 <xref:System.Messaging.MessageQueue> 클래스입니다; 새 메시지 큐를 만들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-195">The <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor creates a new instance of the <xref:System.Messaging.MessageQueue> class; it does not create a new Message Queuing queue.</span></span> <span data-ttu-id="79d78-196">메시지 큐에서 새 큐를 만들려면 사용 <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-196">To create a new queue in Message Queuing, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.</span></span>  
  
 <span data-ttu-id="79d78-197">구문은 `path` 매개 변수는 큐의 형식에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-197">The syntax of the `path` parameter depends on the type of queue.</span></span>  
  
|<span data-ttu-id="79d78-198">큐 유형</span><span class="sxs-lookup"><span data-stu-id="79d78-198">Queue type</span></span>|<span data-ttu-id="79d78-199">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-199">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="79d78-200">공개 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-200">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="79d78-201">개인 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-201">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
|<span data-ttu-id="79d78-202">저널 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-202">Journal queue</span></span>|`MachineName`\\`QueueName`\\`Journal$`|  
|<span data-ttu-id="79d78-203">컴퓨터 저널 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-203">Machine journal queue</span></span>|`MachineName`\\`Journal$`|  
|<span data-ttu-id="79d78-204">컴퓨터 배달 못 한 편지 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-204">Machine dead-letter queue</span></span>|`MachineName`\\`Deadletter$`|  
|<span data-ttu-id="79d78-205">컴퓨터 트랜잭션 배달 못 한 편지 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-205">Machine transactional dead-letter queue</span></span>|`MachineName`\\`XactDeadletter$`|  
  
 <span data-ttu-id="79d78-206">또는 형식 이름 또는 메시지 큐의 레이블을 큐 경로 설명 하기 위해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-206">Alternatively, you can use the format name or label of a Message Queuing queue to describe the queue path.</span></span>  
  
|<span data-ttu-id="79d78-207">참조</span><span class="sxs-lookup"><span data-stu-id="79d78-207">Reference</span></span>|<span data-ttu-id="79d78-208">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-208">Syntax</span></span>|<span data-ttu-id="79d78-209">예</span><span class="sxs-lookup"><span data-stu-id="79d78-209">Example</span></span>|  
|---------------|------------|-------------|  
|<span data-ttu-id="79d78-210">형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-210">Format name</span></span>|<span data-ttu-id="79d78-211">`FormatName:` [ *형식 이름을* ]</span><span class="sxs-lookup"><span data-stu-id="79d78-211">`FormatName:` [ *format name* ]</span></span>|<span data-ttu-id="79d78-212">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span><span class="sxs-lookup"><span data-stu-id="79d78-212">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span></span><br /><br /> <span data-ttu-id="79d78-213">`FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="79d78-213">`FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`</span></span><br /><br /> <span data-ttu-id="79d78-214">`FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="79d78-214">`FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`</span></span><br /><br /> <span data-ttu-id="79d78-215">`FormatName:DIRECT=OS:` `MachineName`\\`QueueName`</span><span class="sxs-lookup"><span data-stu-id="79d78-215">`FormatName:DIRECT=OS:` `MachineName`\\`QueueName`</span></span>|  
|<span data-ttu-id="79d78-216">레이블</span><span class="sxs-lookup"><span data-stu-id="79d78-216">Label</span></span>|<span data-ttu-id="79d78-217">`Label:` [ *레이블* ]</span><span class="sxs-lookup"><span data-stu-id="79d78-217">`Label:` [ *label* ]</span></span>|<span data-ttu-id="79d78-218">`Label:` TheLabel</span><span class="sxs-lookup"><span data-stu-id="79d78-218">`Label:` TheLabel</span></span>|  
  
 <span data-ttu-id="79d78-219">오프 라인으로 작업 하려면 이름 구문이 아닌 형식 이름 구문을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-219">To work offline, you must use the format name syntax, rather than the friendly name syntax.</span></span> <span data-ttu-id="79d78-220">그렇지 않으면 주 도메인 컨트롤러 (Active Directory 상주 하는) 형식 이름에 경로 확인할 수 없기 때문에 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-220">Otherwise, an exception is thrown because the primary domain controller (on which Active Directory resides) is not available to resolve the path to the format name.</span></span>  
  
 <span data-ttu-id="79d78-221">경우는 <xref:System.Messaging.MessageQueue> 된 큐는 `sharedModeDenyReceive` 매개 변수 설정 `true`있으면 모든 <xref:System.Messaging.MessageQueue> 이후에 큐에서 읽으려 할 때마다 생성 하는 <xref:System.Messaging.MessageQueueException> 공유 위반입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-221">If a <xref:System.Messaging.MessageQueue> opens a queue with the `sharedModeDenyReceive` parameter set to `true`, any <xref:System.Messaging.MessageQueue> that subsequently tries to read from the queue generates a <xref:System.Messaging.MessageQueueException> because of a sharing violation.</span></span> <span data-ttu-id="79d78-222">A <xref:System.Messaging.MessageQueueException> 경우 throw 됩니다는 <xref:System.Messaging.MessageQueue> 할당이 단독 모드로 큐에에서 액세스 하려고 <xref:System.Messaging.MessageQueue> 이미 비독점적 큐에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-222">A <xref:System.Messaging.MessageQueueException> is also thrown if a <xref:System.Messaging.MessageQueue> tries to access the queue in exclusive mode while another <xref:System.Messaging.MessageQueue> already has non-exclusive access to the queue.</span></span>  
  
 <span data-ttu-id="79d78-223">다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.MessageQueue>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-223">The following table shows initial property values for an instance of <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="79d78-224">이러한 값은 지정 된 경로와 메시지 큐 큐의 속성에 기반는 `path` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-224">These values are based on the properties of the Message Queuing queue, with the path specified by the `path` parameter.</span></span>  
  
|<span data-ttu-id="79d78-225">속성</span><span class="sxs-lookup"><span data-stu-id="79d78-225">Property</span></span>|<span data-ttu-id="79d78-226">초기 값</span><span class="sxs-lookup"><span data-stu-id="79d78-226">Initial value</span></span>|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|<span data-ttu-id="79d78-227">`false`.</span><span class="sxs-lookup"><span data-stu-id="79d78-227">`false`.</span></span>|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|<span data-ttu-id="79d78-228">0.</span><span class="sxs-lookup"><span data-stu-id="79d78-228">0.</span></span>|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<span data-ttu-id="79d78-229"><xref:System.Guid.Empty>.</span><span class="sxs-lookup"><span data-stu-id="79d78-229"><xref:System.Guid.Empty>.</span></span>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|<span data-ttu-id="79d78-230">기본 생성자가 설정한 값은 <xref:System.Messaging.DefaultPropertiesToSend> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-230">The values set by the default constructor of the <xref:System.Messaging.DefaultPropertiesToSend> class.</span></span>|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|<span data-ttu-id="79d78-231">`true`"Body"; 경우 메시지 큐의 개인 정보 수준 설정 그렇지 않으면 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-231">`true`, if the Message Queuing queue's privacy level setting is "Body"; otherwise, `false`.</span></span>|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<span data-ttu-id="79d78-232"><xref:System.Messaging.XmlMessageFormatter>.</span><span class="sxs-lookup"><span data-stu-id="79d78-232"><xref:System.Messaging.XmlMessageFormatter>.</span></span>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<span data-ttu-id="79d78-233"><xref:System.String.Empty>.</span><span class="sxs-lookup"><span data-stu-id="79d78-233"><xref:System.String.Empty>.</span></span>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|<span data-ttu-id="79d78-234">메시지 큐의 컴퓨터 이름 속성의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-234">The value of the Message Queuing queue's computer name property.</span></span>|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<span data-ttu-id="79d78-235"><xref:System.Messaging.MessageQueue.InfiniteQueueSize>.</span><span class="sxs-lookup"><span data-stu-id="79d78-235"><xref:System.Messaging.MessageQueue.InfiniteQueueSize>.</span></span>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<span data-ttu-id="79d78-236"><xref:System.Messaging.MessageQueue.InfiniteQueueSize>.</span><span class="sxs-lookup"><span data-stu-id="79d78-236"><xref:System.Messaging.MessageQueue.InfiniteQueueSize>.</span></span>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|<span data-ttu-id="79d78-237">기본 생성자가 설정한 값은 <xref:System.Messaging.MessagePropertyFilter> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-237">The values set by the default constructor of the <xref:System.Messaging.MessagePropertyFilter> class.</span></span>|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<span data-ttu-id="79d78-238"><xref:System.String.Empty>을 생성자에 의해 설정 되지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-238"><xref:System.String.Empty>, if not set by the constructor.</span></span>|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<span data-ttu-id="79d78-239"><xref:System.String.Empty>을 생성자에 의해 설정 되지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-239"><xref:System.String.Empty>, if not set by the constructor.</span></span>|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|<span data-ttu-id="79d78-240">`sharedModeDenyReceive` 매개 변수의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-240">The value of the `sharedModeDenyReceive` parameter.</span></span>|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|<span data-ttu-id="79d78-241">`true`메시지 큐 개체의 저널 설정을 사용 합니다. 그렇지 않으면 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-241">`true`, if the Message Queuing object's journal setting is enabled; otherwise, `false`.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-242">다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 단독 액세스 권한을 갖는 해당 경로 설정 하 고 큐에 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-242">The following code example creates a new <xref:System.Messaging.MessageQueue> with exclusive access, sets its path, and sends a message to the queue.</span></span>  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-243"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 유효하지 않습니다(예: 속성을 설정하지 않은 경우).</span><span class="sxs-lookup"><span data-stu-id="79d78-243">The <see cref="P:System.Messaging.MessageQueue.Path" /> property is not valid, possibly because it has not been set.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="79d78-244">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-244">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</span></span></param>
        <param name="accessMode"><span data-ttu-id="79d78-245"><see cref="T:System.Messaging.QueueAccessMode" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-245">One of the <see cref="T:System.Messaging.QueueAccessMode" /> values.</span></span></param>
        <summary><span data-ttu-id="79d78-246"><see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-246">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="79d78-247">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-247">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</span></span></param>
        <param name="sharedModeDenyReceive">
          <span data-ttu-id="79d78-248">첫 번째로 큐에 액세스하는 응용 프로그램에 단독 읽기 권한을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-248"><see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</span></span></param>
        <param name="enableCache">
          <span data-ttu-id="79d78-249">연결 캐시를 만들어 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-249"><see langword="true" /> to create and use a connection cache; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="79d78-250"><see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-250">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="79d78-251">다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 단독 읽기 액세스 권한을 갖는 및 연결 캐싱을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-251">The following code example creates a new <xref:System.Messaging.MessageQueue> with exclusive read access and with connection caching enabled.</span></span>  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="79d78-252">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-252">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</span></span></param>
        <param name="sharedModeDenyReceive">
          <span data-ttu-id="79d78-253">첫 번째로 큐에 액세스하는 응용 프로그램에 단독 읽기 권한을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-253"><see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</span></span></param>
        <param name="enableCache">
          <span data-ttu-id="79d78-254">연결 캐시를 만들어 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-254"><see langword="true" /> to create and use a connection cache; otherwise, <see langword="false" />.</span></span></param>
        <param name="accessMode"><span data-ttu-id="79d78-255"><see cref="T:System.Messaging.QueueAccessMode" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-255">One of the <see cref="T:System.Messaging.QueueAccessMode" /> values.</span></span></param>
        <summary><span data-ttu-id="79d78-256"><see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-256">Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-257">큐의 액세스 모드를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-257">Gets a value that indicates the access mode for the queue.</span></span></summary>
        <value><span data-ttu-id="79d78-258"><see cref="T:System.Messaging.QueueAccessMode" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-258">One of the <see cref="T:System.Messaging.QueueAccessMode" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-259">큐에 대 한 기본 액세스 모드 `QueueAccessMode.SendAndReceive`생성자를 호출할 때 달리 지정 하지 않는 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-259">The default access mode for a queue is `QueueAccessMode.SendAndReceive`, unless you specify otherwise when calling the constructor.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-260">큐가 인증된 메시지만 허용하는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-260">Gets or sets a value that indicates whether the queue accepts only authenticated messages.</span></span></summary>
        <value>
          <span data-ttu-id="79d78-261">큐가 인증된 메시지만 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-261"><see langword="true" /> if the queue accepts only authenticated messages; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="79d78-262">기본값은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-262">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-263">메시지 인증에는 메시지 무결성을 보장 하 고 메시지를 보낸 사람을 확인 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-263">Message authentication provides a way to ensure message integrity and to verify who sent the message.</span></span> <span data-ttu-id="79d78-264">인증을 요청 하려면 보내는 응용 프로그램 메시지의 인증 수준을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-264">To request authentication, the sending application sets the message's authentication level.</span></span>  
  
 <span data-ttu-id="79d78-265">설정 하는 경우 <xref:System.Messaging.MessageQueue.Authenticate%2A> 를 `true`를 제한 하는 뿐만 아니라를이 서버에 있는 큐에 대 한 액세스 <xref:System.Messaging.MessageQueue> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="79d78-265">When you set <xref:System.Messaging.MessageQueue.Authenticate%2A> to `true`, you are restricting access to the queue on the server, not only to this <xref:System.Messaging.MessageQueue> instance.</span></span> <span data-ttu-id="79d78-266">같은 메시지 큐에 대해 작동 하는 모든 클라이언트 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-266">All clients working against the same Message Queuing queue will be affected.</span></span>  
  
 <span data-ttu-id="79d78-267">인증 된 메시지만 허용 하는 큐는 인증 되지 않은 메시지를 거부 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-267">A queue that accepts only authenticated messages will reject a non-authenticated message.</span></span> <span data-ttu-id="79d78-268">요청 거부 메시지의 알림, 보내는 응용 프로그램 설정 수는 <xref:System.Messaging.Message.AcknowledgeType%2A> 메시지의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-268">To request notification of message rejection, a sending application can set the <xref:System.Messaging.Message.AcknowledgeType%2A> property of the message.</span></span> <span data-ttu-id="79d78-269">있기 때문에 거부 메시지의 다른 표시 되지 보내는 응용 프로그램 배달 못 한 편지 큐로 전송 될 것을 요청 하지 않으면 메시지가 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-269">Because no other indication of message rejection exists, the sending application can lose the message unless you request that it be sent to the dead-letter queue.</span></span>  
  
 <span data-ttu-id="79d78-270">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-270">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-271">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-271">Workgroup mode</span></span>|<span data-ttu-id="79d78-272">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-272">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-273">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-273">Local computer</span></span>|<span data-ttu-id="79d78-274">예</span><span class="sxs-lookup"><span data-stu-id="79d78-274">Yes</span></span>|  
|<span data-ttu-id="79d78-275">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-275">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-276">예</span><span class="sxs-lookup"><span data-stu-id="79d78-276">Yes</span></span>|  
|<span data-ttu-id="79d78-277">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-277">Remote computer</span></span>|<span data-ttu-id="79d78-278">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-278">No</span></span>|  
|<span data-ttu-id="79d78-279">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-279">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-280">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-280">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-281">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.Authenticate%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-281">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.Authenticate%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-282">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-282">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-283">네트워크에서 공개 큐의 메시지를 라우팅하는 데 사용하는 기본 우선 순위 메시지 큐를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-283">Gets or sets the base priority Message Queuing uses to route a public queue's messages over the network.</span></span></summary>
        <value><span data-ttu-id="79d78-284">(공개) 큐에 보내진 모든 메시지에 대한 단일 기본 우선 순위입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-284">The single base priority for all messages sent to the (public) queue.</span></span> <span data-ttu-id="79d78-285">기본값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-285">The default is zero (0).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-286">메시지 큐의 기본 우선 순위 네트워크를 통해 이동할 때 큐는 처리 되는 메시지 라우팅 방법을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-286">A message queue's base priority specifies how a message en route to that queue is treated as it travels through the network.</span></span> <span data-ttu-id="79d78-287">설정할 수 있습니다는 <xref:System.Messaging.MessageQueue.BasePriority%2A> 속성을 높거나 더 낮은 우선 순위를 다른 큐에 전송 하는 것 보다 지정 된 큐로 보낸 모든 메시지를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-287">You can set the <xref:System.Messaging.MessageQueue.BasePriority%2A> property to confer a higher or lower priority to all messages sent to the specified queue than those sent to other queues.</span></span> <span data-ttu-id="79d78-288">이 속성을 설정 하면 메시지 큐를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-288">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="79d78-289">따라서 다른 모든 <xref:System.Messaging.MessageQueue> 인스턴스 변경의 영향을 받는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-289">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.</span></span>  
  
 <span data-ttu-id="79d78-290">메시지 큐의 <xref:System.Messaging.MessageQueue.BasePriority%2A> 관련이 없는 <xref:System.Messaging.Message.Priority%2A> 들어오는 메시지가 큐에 배치 되는 순서를 지정 하는 메시지의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-290">A message queue's <xref:System.Messaging.MessageQueue.BasePriority%2A> is not related to the <xref:System.Messaging.Message.Priority%2A> property of a message, which specifies the order in which an incoming message is placed in the queue.</span></span>  
  
 <span data-ttu-id="79d78-291"><xref:System.Messaging.MessageQueue.BasePriority%2A> 공개 큐에만 형식 이름을 사용 하 여 해당 경로 지정 하는 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-291"><xref:System.Messaging.MessageQueue.BasePriority%2A> applies only to public queues whose paths are specified using the format name.</span></span> <span data-ttu-id="79d78-292">개인 큐의 기본 우선 순위는 항상 0입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-292">The base priority of a private queue is always zero (0).</span></span>  
  
 <span data-ttu-id="79d78-293">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-293">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-294">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-294">Workgroup mode</span></span>|<span data-ttu-id="79d78-295">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-295">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-296">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-296">Local computer</span></span>|<span data-ttu-id="79d78-297">예</span><span class="sxs-lookup"><span data-stu-id="79d78-297">Yes</span></span>|  
|<span data-ttu-id="79d78-298">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-298">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-299">예</span><span class="sxs-lookup"><span data-stu-id="79d78-299">Yes</span></span>|  
|<span data-ttu-id="79d78-300">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-300">Remote computer</span></span>|<span data-ttu-id="79d78-301">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-301">No</span></span>|  
|<span data-ttu-id="79d78-302">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-302">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-303">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-303">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-304">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.BasePriority%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-304">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.BasePriority%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-305">기본 우선 순위가 잘못된 값으로 설정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-305">The base priority was set to an invalid value.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-306">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-306">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe><span data-ttu-id="79d78-307">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-307">The method is not thread safe.</span></span></threadsafe>
        <summary><span data-ttu-id="79d78-308">메시지 큐가 메시지 피킹(peeking)을 시작하도록 한 후, 작업을 마치면 이벤트 처리기에 알리도록 하여 비동기 피킹(peeking) 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-308">Initiates an asynchronous peek operation by telling Message Queuing to begin peeking a message and notify the event handler when finished.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-309">시간 제한이 없는 비동기 피킹(peeking) 작업을 시작합니다. 큐에서 메시지를 사용할 수 있을 때까지 작업이 완료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-309">Initiates an asynchronous peek operation that has no time-out. The operation is not complete until a message becomes available in the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-310">게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-310">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-311">비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 메시지를 큐에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-311">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue.</span></span>  
  
 <span data-ttu-id="79d78-312"><xref:System.Messaging.MessageQueue.PeekCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-312"><xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-313">사용 하도록 <xref:System.Messaging.MessageQueue.BeginPeek%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-313">To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate.</span></span> <span data-ttu-id="79d78-314"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업; 시작 <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 도착할 때.</span><span class="sxs-lookup"><span data-stu-id="79d78-314"><xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="79d78-315"><xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 또는 사용 하 여 결과 검색 하 여는 <xref:System.Messaging.PeekCompletedEventArgs>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-315">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="79d78-316"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-316">The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="79d78-317">때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐를 피킹할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-317">Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="79d78-318">큐를 피킹할 동기적으로 처리를 사용 하 여는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-318">To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-319">비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-319">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="79d78-320"><xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-320">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="79d78-321">이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-321">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="79d78-322">그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-322">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="79d78-323">사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-323">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="79d78-324">경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`완료 이벤트가 발생 하지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-324">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="79d78-325">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-325">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-326">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-326">Workgroup mode</span></span>|<span data-ttu-id="79d78-327">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-327">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-328">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-328">Local computer</span></span>|<span data-ttu-id="79d78-329">예</span><span class="sxs-lookup"><span data-stu-id="79d78-329">Yes</span></span>|  
|<span data-ttu-id="79d78-330">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-330">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-331">예</span><span class="sxs-lookup"><span data-stu-id="79d78-331">Yes</span></span>|  
|<span data-ttu-id="79d78-332">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-332">Remote computer</span></span>|<span data-ttu-id="79d78-333">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-333">No</span></span>|  
|<span data-ttu-id="79d78-334">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-334">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-335">예</span><span class="sxs-lookup"><span data-stu-id="79d78-335">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-336">다음 코드 예제에서는 라는 이벤트 처리기를 만들고 `MyPeekCompleted`에 연결는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자 및 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 경로에 있는 큐에서 비동기 작업을 시작 하려면 ". \myQueue"입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-336">The following code example creates an event handler named `MyPeekCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue".</span></span> <span data-ttu-id="79d78-337">경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하면이 예에서는 메시지를 관찰 합니다. 한 화면으로 해당 본문을 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-337">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the example peeks the message and writes its body to the screen.</span></span> <span data-ttu-id="79d78-338">이 예에서는 다음 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 새 비동기 작업을 시작 하려면 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-338">The example then calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> again to initiate a new asynchronous peek operation.</span></span>  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-339">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-339">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-340">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-340">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-341">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-341">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <summary><span data-ttu-id="79d78-342">시간 제한이 지정된 비동기 피킹(peeking) 작업을 시작합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-342">Initiates an asynchronous peek operation that has a specified time-out. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="79d78-343">게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-343">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-344">비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 메시지를 큐에 또는 지정된 된 시간 간격이 만료 될 때 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-344">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.</span></span>  
  
 <span data-ttu-id="79d78-345"><xref:System.Messaging.MessageQueue.PeekCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-345"><xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-346">사용 하도록 <xref:System.Messaging.MessageQueue.BeginPeek%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-346">To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate.</span></span> <span data-ttu-id="79d78-347"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업; 시작 <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 도착할 때.</span><span class="sxs-lookup"><span data-stu-id="79d78-347"><xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="79d78-348"><xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 또는 사용 하 여 결과 검색 하 여는 <xref:System.Messaging.PeekCompletedEventArgs>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-348">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="79d78-349"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-349">The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="79d78-350">때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐를 피킹할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-350">Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="79d78-351">큐를 피킹할 동기적으로 처리를 사용 하 여는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-351">To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-352">비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-352">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="79d78-353"><xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-353">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginPeek%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="79d78-354">이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-354">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="79d78-355">그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-355">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="79d78-356">사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-356">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="79d78-357">이 오버 로드 제한 시간을 지정 합니다. 으로 지정한 간격이 하는 경우는 `timeout` 매개 변수 만료 되 면이 구성 요소는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-357">This overload specifies a time-out. If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.PeekCompleted> event.</span></span> <span data-ttu-id="79d78-358">메시지가 없으므로 한 후속 호출에 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-358">Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> will throw an exception.</span></span>  
  
 <span data-ttu-id="79d78-359">경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`완료 이벤트가 발생 하지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-359">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="79d78-360">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-360">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-361">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-361">Workgroup mode</span></span>|<span data-ttu-id="79d78-362">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-362">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-363">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-363">Local computer</span></span>|<span data-ttu-id="79d78-364">예</span><span class="sxs-lookup"><span data-stu-id="79d78-364">Yes</span></span>|  
|<span data-ttu-id="79d78-365">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-365">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-366">예</span><span class="sxs-lookup"><span data-stu-id="79d78-366">Yes</span></span>|  
|<span data-ttu-id="79d78-367">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-367">Remote computer</span></span>|<span data-ttu-id="79d78-368">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-368">No</span></span>|  
|<span data-ttu-id="79d78-369">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-369">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-370">예</span><span class="sxs-lookup"><span data-stu-id="79d78-370">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-371">다음 코드 예제에서는 큐 경로 사용 하 여 비동기 작업을 ". \myQueue"입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-371">The following code example creates an asynchronous peek operation, using the queue path ".\myQueue".</span></span> <span data-ttu-id="79d78-372">이벤트 처리기를 만듭니다 `MyPeekCompleted`에 연결 된 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-372">It creates an event handler, `MyPeekCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate.</span></span> <span data-ttu-id="79d78-373"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업을 시작 하는 1 분 시간 제한으로 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-373"><xref:System.Messaging.MessageQueue.BeginPeek%2A> is called with a time-out of one minute, to initiate the asynchronous peek operation.</span></span> <span data-ttu-id="79d78-374">경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 또는 제한 시간이 만료 되 면 하나 있고, 해당 본문은 화면에 표시 하는 경우 메시지를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-374">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised or the time-out expires, the message is retrieved if one exists, and its body is written to the screen.</span></span> <span data-ttu-id="79d78-375">그런 다음 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 동일한 시간 제한 사용 하 여 새 비동기 작업을 시작 하기 위해 다시 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-375">Then <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called again to initiate a new asynchronous peek operation with the same time-out.</span></span>  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-376"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-376">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-377">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-377">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-378">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-378">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-379">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-379">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="stateObject"><span data-ttu-id="79d78-380">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-380">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="79d78-381">시간 제한 및 상태 개체가 지정되어 있는 비동기 피킹(peeking) 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-381">Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</span></span> <span data-ttu-id="79d78-382">큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-382">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="79d78-383">게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-383">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-384">비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 메시지를 큐에 또는 지정된 된 시간 간격이 만료 될 때 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-384">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginPeek%2A> to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.</span></span>  
  
 <span data-ttu-id="79d78-385"><xref:System.Messaging.MessageQueue.PeekCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-385"><xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-386">작업의 수명 주기 동안 유지 해야 하는 작업과 정보를 연결 하기 위해이 오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-386">Use this overload to associate information with the operation that will be preserved throughout the operation's lifetime.</span></span> <span data-ttu-id="79d78-387">이벤트 처리기 확인 하 여이 정보에 액세스할 수는 <xref:System.IAsyncResult.AsyncState%2A> 의 속성은 <xref:System.IAsyncResult> 작업과 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-387">The event handler can access this information by looking at the <xref:System.IAsyncResult.AsyncState%2A> property of the <xref:System.IAsyncResult> that is associated with the operation.</span></span>  
  
 <span data-ttu-id="79d78-388">사용 하도록 <xref:System.Messaging.MessageQueue.BeginPeek%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-388">To use <xref:System.Messaging.MessageQueue.BeginPeek%2A>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate.</span></span> <span data-ttu-id="79d78-389"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업; 시작 <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 도착할 때.</span><span class="sxs-lookup"><span data-stu-id="79d78-389"><xref:System.Messaging.MessageQueue.BeginPeek%2A> initiates an asynchronous peek operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.PeekCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="79d78-390"><xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 또는 사용 하 여 결과 검색 하 여는 <xref:System.Messaging.PeekCompletedEventArgs>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-390">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> or by retrieving the result using the <xref:System.Messaging.PeekCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="79d78-391"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-391">The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="79d78-392">때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐를 피킹할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-392">Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="79d78-393">큐를 피킹할 동기적으로 처리를 사용 하 여는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-393">To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-394">비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-394">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="79d78-395"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 된 <xref:System.IAsyncResult> 는 메서드가 시작 된 비동기 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-395"><xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="79d78-396">이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-396">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="79d78-397">그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-397">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="79d78-398">사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-398">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="79d78-399">이 오버 로드는 제한 시간 및 상태 개체를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-399">This overload specifies a time-out and a state object.</span></span> <span data-ttu-id="79d78-400">으로 지정한 간격이 하는 경우는 `timeout` 매개 변수 만료 되 면이 구성 요소는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-400">If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.PeekCompleted> event.</span></span> <span data-ttu-id="79d78-401">메시지가 없으므로 한 후속 호출에 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-401">Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> will throw an exception.</span></span>  
  
 <span data-ttu-id="79d78-402">상태 개체는 작업 상태 정보를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-402">The state object associates state information with the operation.</span></span> <span data-ttu-id="79d78-403">예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-403">For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span> <span data-ttu-id="79d78-404">이 시나리오의 예시의 경우 "예" 섹션을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="79d78-404">For an illustration of this scenario, see the Example section.</span></span>  
  
 <span data-ttu-id="79d78-405">또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-405">You can also use the state object to pass information across process threads.</span></span> <span data-ttu-id="79d78-406">스레드 시작 되었지만 비동기 시나리오의 다른 스레드에서 콜백이, 하는 경우 상태 개체 마샬링되고 이벤트에서 정보와 함께 다시 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-406">If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</span></span>  
  
 <span data-ttu-id="79d78-407">경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`완료 이벤트가 발생 하지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-407">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="79d78-408">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-408">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-409">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-409">Workgroup mode</span></span>|<span data-ttu-id="79d78-410">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-410">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-411">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-411">Local computer</span></span>|<span data-ttu-id="79d78-412">예</span><span class="sxs-lookup"><span data-stu-id="79d78-412">Yes</span></span>|  
|<span data-ttu-id="79d78-413">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-413">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-414">예</span><span class="sxs-lookup"><span data-stu-id="79d78-414">Yes</span></span>|  
|<span data-ttu-id="79d78-415">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-415">Remote computer</span></span>|<span data-ttu-id="79d78-416">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-416">No</span></span>|  
|<span data-ttu-id="79d78-417">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-417">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-418">예</span><span class="sxs-lookup"><span data-stu-id="79d78-418">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-419">다음 코드 예제에서는 큐 경로 사용 하 여 비동기 작업을 ". \myQueue"입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-419">The following code example creates an asynchronous peek operation, using the queue path ".\myQueue".</span></span> <span data-ttu-id="79d78-420">이벤트 처리기를 만듭니다 `MyPeekCompleted`에 연결 된 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-420">It creates an event handler, `MyPeekCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate.</span></span> <span data-ttu-id="79d78-421"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 라고, 1 분의 시간 제한을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-421"><xref:System.Messaging.MessageQueue.BeginPeek%2A> is called, with a time-out of one minute.</span></span> <span data-ttu-id="79d78-422">호출할 때마다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 특정 작업을 식별 하는 연결 된 고유한 정수에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-422">Each call to <xref:System.Messaging.MessageQueue.BeginPeek%2A> has a unique associated integer that identifies that particular operation.</span></span> <span data-ttu-id="79d78-423">경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 제한 시간이 만료 또는 이벤트는 메시지에 있는 경우 검색 되 고 해당 본문 및 작업 별로 정수 식별자는 화면에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-423">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised or the time-out expired, the message, if one exists, is retrieved and its body and the operation-specific integer identifier are written to the screen.</span></span> <span data-ttu-id="79d78-424">그런 다음 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 동일한 제한 시간 및 완료 된 작업의 연결 된 정수 새 비동기 작업을 시작 하기 위해 다시 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-424">Then <xref:System.Messaging.MessageQueue.BeginPeek%2A> is called again to initiate a new asynchronous peek operation with the same time-out and the associated integer of the just completed operation.</span></span>  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-425"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-425">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-426">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-426">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-427">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-427">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-428">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-428">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="stateObject"><span data-ttu-id="79d78-429">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-429">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <param name="callback"><span data-ttu-id="79d78-430">비동기 작업 완료에 대한 알림을 수신할 <see cref="T:System.AsyncCallback" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-430">The <see cref="T:System.AsyncCallback" /> that will receive the notification of the asynchronous operation completion.</span></span></param>
        <summary><span data-ttu-id="79d78-431">시간 제한 및 상태 개체가 지정되어 있는 비동기 피킹(peeking) 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-431">Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</span></span> <span data-ttu-id="79d78-432">이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-432">This overload receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="79d78-433">큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-433">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="79d78-434">게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-434">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-435">이 오버 로드를 사용 하 여 콜백 매개 변수에 지정 된 콜백 됩니다 때 직접 호출 메시지를 큐에 또는 지정된 된 시간 간격이 만료 되 면 사용할 수 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-435">When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <xref:System.Messaging.MessageQueue.PeekCompleted> event is not raised.</span></span> <span data-ttu-id="79d78-436">다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면이 구성 요소에 의존는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-436">The other overloads of <xref:System.Messaging.MessageQueue.BeginPeek%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event.</span></span>  
  
 <span data-ttu-id="79d78-437"><xref:System.Messaging.MessageQueue.PeekCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-437"><xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-438"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-438">The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="79d78-439">때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐를 피킹할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-439">Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="79d78-440">큐를 피킹할 동기적으로 처리를 사용 하 여는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-440">To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-441">비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-441">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="79d78-442"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 된 <xref:System.IAsyncResult> 는 메서드가 시작 된 비동기 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-442"><xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="79d78-443">이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-443">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="79d78-444">그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-444">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="79d78-445">사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-445">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="79d78-446">상태 개체는 작업 상태 정보를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-446">The state object associates state information with the operation.</span></span> <span data-ttu-id="79d78-447">예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-447">For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span>  
  
 <span data-ttu-id="79d78-448">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-448">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-449">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-449">Workgroup mode</span></span>|<span data-ttu-id="79d78-450">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-450">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-451">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-451">Local computer</span></span>|<span data-ttu-id="79d78-452">예</span><span class="sxs-lookup"><span data-stu-id="79d78-452">Yes</span></span>|  
|<span data-ttu-id="79d78-453">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-453">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-454">예</span><span class="sxs-lookup"><span data-stu-id="79d78-454">Yes</span></span>|  
|<span data-ttu-id="79d78-455">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-455">Remote computer</span></span>|<span data-ttu-id="79d78-456">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-456">No</span></span>|  
|<span data-ttu-id="79d78-457">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-457">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-458">예</span><span class="sxs-lookup"><span data-stu-id="79d78-458">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-459">다음 코드 예제에서는 비동기 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-459">The following code example creates an asynchronous peek operation.</span></span> <span data-ttu-id="79d78-460">메시지를 로컬 메시지 큐는 코드 예제에서는 보낸 다음 호출 <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>를: 시간 제한 값이 10 초, 특정 메시지; 및의 새 인스턴스를 식별 하는 고유한 정수 <xref:System.AsyncCallback> 이벤트 처리기를 식별 하는 `MyPeekCompleted`.</span><span class="sxs-lookup"><span data-stu-id="79d78-460">The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passing in: a time-out value of ten seconds; a unique integer that identifies that particular message; and a new instance of <xref:System.AsyncCallback> that identifies the event handler, `MyPeekCompleted`.</span></span> <span data-ttu-id="79d78-461">경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하면 이벤트 처리기는 메시지를 관찰 하 고 화면에 메시지 본문 및 정수 메시지 식별자를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-461">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the event handler peeks at the message and writes the message body and the integer message identifier to the screen.</span></span>  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-462"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-462">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-463">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-463">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-464">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-464">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-465">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-465">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="cursor"><span data-ttu-id="79d78-466">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-466">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <param name="action"><span data-ttu-id="79d78-467"><see cref="T:System.Messaging.PeekAction" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-467">One of the <see cref="T:System.Messaging.PeekAction" /> values.</span></span> <span data-ttu-id="79d78-468">이 값은 큐의 현재 메시지를 피킹할지 또는 다음 메시지를 피킹할지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-468">Indicates whether to peek at the current message in the queue, or the next message.</span></span></param>
        <param name="state"><span data-ttu-id="79d78-469">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-469">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <param name="callback"><span data-ttu-id="79d78-470">비동기 작업 완료에 대한 알림을 수신하는 <see cref="T:System.AsyncCallback" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-470">The <see cref="T:System.AsyncCallback" /> that receives the notification of the asynchronous operation completion.</span></span></param>
        <summary><span data-ttu-id="79d78-471">지정된 제한 시간이 있고 지정된 커서, 지정된 피킹(peeking) 작업 및 지정된 상태 개체를 사용하는 비동기 피킹(peeking) 작업을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-471">Initiates an asynchronous peek operation that has a specified time-out and that uses a specified cursor, a specified peek action, and a specified state object.</span></span> <span data-ttu-id="79d78-472">상태 개체는 전체 작업 기간 동안 관련 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-472">The state object provides associated information throughout the lifetime of the operation.</span></span> <span data-ttu-id="79d78-473">이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-473">This overload receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="79d78-474">큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-474">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="79d78-475">게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-475">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-476">이 오버 로드를 사용 하면 메시지는 큐 나 지정된 된 시간 간격이 만료 될 때 사용할 수 있을 때 콜백 매개 변수에 지정 된 콜백 직접 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-476">When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired.</span></span> <span data-ttu-id="79d78-477"><xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-477">The <xref:System.Messaging.MessageQueue.PeekCompleted> event is not raised.</span></span> <span data-ttu-id="79d78-478">다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면이 구성 요소에 의존는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-478">The other overloads of <xref:System.Messaging.MessageQueue.BeginPeek%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event.</span></span>  
  
 <span data-ttu-id="79d78-479"><xref:System.Messaging.MessageQueue.PeekCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-479"><xref:System.Messaging.MessageQueue.PeekCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-480"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-480">The <xref:System.Messaging.MessageQueue.BeginPeek%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="79d78-481">때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐를 피킹할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-481">Because <xref:System.Messaging.MessageQueue.BeginPeek%2A> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="79d78-482">큐를 피킹할 동기적으로 처리를 사용 하 여는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-482">To synchronously peek the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-483">비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-483">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="79d78-484"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 된 <xref:System.IAsyncResult> 메서드에 의해 시작 된 비동기 작업을 식별 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-484"><xref:System.Messaging.MessageQueue.BeginPeek%2A> returns a <xref:System.IAsyncResult> that identifies the asynchronous operation started by the method.</span></span> <span data-ttu-id="79d78-485">이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-485">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="79d78-486">그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-486">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="79d78-487">이 경우에 사용 된 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-487">In this case, use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="79d78-488">상태 개체는 작업 상태 정보를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-488">The state object associates state information with the operation.</span></span> <span data-ttu-id="79d78-489">예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-489">For example, if you call <xref:System.Messaging.MessageQueue.BeginPeek%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span>  
  
 <span data-ttu-id="79d78-490">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-490">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-491">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-491">Workgroup mode</span></span>|<span data-ttu-id="79d78-492">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-492">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-493">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-493">Local computer</span></span>|<span data-ttu-id="79d78-494">예</span><span class="sxs-lookup"><span data-stu-id="79d78-494">Yes</span></span>|  
|<span data-ttu-id="79d78-495">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-495">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-496">예</span><span class="sxs-lookup"><span data-stu-id="79d78-496">Yes</span></span>|  
|<span data-ttu-id="79d78-497">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-497">Remote computer</span></span>|<span data-ttu-id="79d78-498">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-498">No</span></span>|  
|<span data-ttu-id="79d78-499">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-499">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-500">예</span><span class="sxs-lookup"><span data-stu-id="79d78-500">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79d78-501"><paramref name="action" /> 매개 변수에 대해 <see langword="PeekAction.Current" /> 또는 <see langword="PeekAction.Next" /> 이외의 값을 지정했습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-501">A value other than <see langword="PeekAction.Current" /> or <see langword="PeekAction.Next" /> was specified for the <paramref name="action" /> parameter.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-502"><paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-502">The <paramref name="cursor" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-503"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-503">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-504">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-504">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-505">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-505">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe><span data-ttu-id="79d78-506">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-506">The method is not thread safe.</span></span></threadsafe>
        <summary><span data-ttu-id="79d78-507">메시지 큐가 메시지 수신을 시작하도록 한 후, 작업을 마치면 이벤트 처리기에 알리도록 하여 비동기 수신 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-507">Initiates an asynchronous receive operation by telling Message Queuing to begin receiving a message and notify the event handler when finished.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-508">시간 제한이 없는 비동기 수신 작업을 시작합니다. 큐에서 메시지를 사용할 수 있을 때까지 작업이 완료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-508">Initiates an asynchronous receive operation that has no time-out. The operation is not complete until a message becomes available in the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-509">게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-509">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-510">비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트는 메시지 큐에서 제거 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-510">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginReceive%2A> to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message has been removed from the queue.</span></span>  
  
 <span data-ttu-id="79d78-511"><xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-511"><xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-512">사용 하도록 <xref:System.Messaging.MessageQueue.BeginReceive%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-512">To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</span></span> <span data-ttu-id="79d78-513"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 작업입니다. <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때.</span><span class="sxs-lookup"><span data-stu-id="79d78-513"><xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="79d78-514"><xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-514">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="79d78-515"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-515">The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="79d78-516">때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-516">Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="79d78-517">사용 하 여 동기적으로 메시지를 받으려면는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-517">To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-518">비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-518">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="79d78-519"><xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-519">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="79d78-520">이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-520">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="79d78-521">그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-521">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="79d78-522">사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-522">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="79d78-523">경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`완료 이벤트가 발생 하지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-523">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="79d78-524">비동기 호출을 사용 하지 마십시오 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-524">Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions.</span></span> <span data-ttu-id="79d78-525">트랜잭션 비동기 작업을 수행 하려는 경우 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, (동기) 하 여 트랜잭션을 저장 <xref:System.Messaging.MessageQueue.Receive%2A> 피크 (peek) 작업에 대해 만들 이벤트 처리기 내에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-525">If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation.</span></span> <span data-ttu-id="79d78-526">이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-526">Your event handler might contain functionality as shown in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 <span data-ttu-id="79d78-527">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-527">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-528">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-528">Workgroup mode</span></span>|<span data-ttu-id="79d78-529">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-529">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-530">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-530">Local computer</span></span>|<span data-ttu-id="79d78-531">예</span><span class="sxs-lookup"><span data-stu-id="79d78-531">Yes</span></span>|  
|<span data-ttu-id="79d78-532">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-532">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-533">예</span><span class="sxs-lookup"><span data-stu-id="79d78-533">Yes</span></span>|  
|<span data-ttu-id="79d78-534">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-534">Remote computer</span></span>|<span data-ttu-id="79d78-535">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-535">No</span></span>|  
|<span data-ttu-id="79d78-536">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-536">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-537">예</span><span class="sxs-lookup"><span data-stu-id="79d78-537">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-538">다음 코드 예제에서는 비동기 요청을 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-538">The following code example chains asynchronous requests.</span></span> <span data-ttu-id="79d78-539">"MyQueue" 라는 로컬 컴퓨터에는 큐가 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-539">It assumes there is a queue on the local computer called "myQueue".</span></span> <span data-ttu-id="79d78-540">`Main` 에서 처리 하는 비동기 작업을 시작 하는 함수는 `MyReceiveCompleted` 루틴입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-540">The `Main` function begins the asynchronous operation that is handled by the `MyReceiveCompleted` routine.</span></span> <span data-ttu-id="79d78-541">`MyReceiveCompleted` 현재 메시지를 처리 하 고 새 시작 비동기 수신 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-541">`MyReceiveCompleted` processes the current message and begins a new asynchronous receive operation.</span></span>  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 <span data-ttu-id="79d78-542">다음 코드 예제에서는 비동기 요청을 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-542">The following code example queues asynchronous requests.</span></span> <span data-ttu-id="79d78-543">에 대 한 호출 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 사용 하 여는 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 해당 반환 값에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-543">The call to <xref:System.Messaging.MessageQueue.BeginReceive%2A> uses the <xref:System.IAsyncResult.AsyncWaitHandle%2A> in its return value.</span></span> <span data-ttu-id="79d78-544">`Main` 루틴 모든 비동기 작업을 종료 하기 전에 완료할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-544">The `Main` routine waits for all asynchronous operations to be completed before exiting.</span></span>  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-545">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-545">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-546">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-546">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-547">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-547">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <summary><span data-ttu-id="79d78-548">시간 제한이 지정된 비동기 수신 작업을 시작합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-548">Initiates an asynchronous receive operation that has a specified time-out. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="79d78-549">게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-549">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-550">비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 메시지를 큐에 또는 지정된 된 시간 간격이 만료 될 때 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-550">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginReceive%2A> to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.</span></span>  
  
 <span data-ttu-id="79d78-551"><xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-551"><xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-552">사용 하도록 <xref:System.Messaging.MessageQueue.BeginReceive%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-552">To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</span></span> <span data-ttu-id="79d78-553"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 작업입니다. <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때.</span><span class="sxs-lookup"><span data-stu-id="79d78-553"><xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="79d78-554"><xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 하거나 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-554">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="79d78-555"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-555">The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="79d78-556">때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-556">Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="79d78-557">사용 하 여 동기적으로 메시지를 받으려면는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-557">To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-558">비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-558">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="79d78-559">경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`완료 이벤트가 발생 하지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-559">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, the completion event is raised, but an exception will be thrown when calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="79d78-560"><xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-560">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="79d78-561">이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-561">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="79d78-562">그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-562">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="79d78-563">사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-563">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="79d78-564">이 오버 로드 제한 시간을 지정 합니다. 으로 지정한 간격이 하는 경우는 `timeout` 매개 변수 만료 되 면이 구성 요소는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-564">This overload specifies a time-out. If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event.</span></span> <span data-ttu-id="79d78-565">메시지가 없으므로 한 후속 호출에 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-565">Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> will throw an exception.</span></span>  
  
 <span data-ttu-id="79d78-566">비동기 호출을 사용 하지 마십시오 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-566">Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions.</span></span> <span data-ttu-id="79d78-567">트랜잭션 비동기 작업을 수행 하려는 경우 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, (동기) 하 여 트랜잭션을 저장 <xref:System.Messaging.MessageQueue.Receive%2A> 피크 (peek) 작업에 대해 만들 이벤트 처리기 내에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-567">If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation.</span></span> <span data-ttu-id="79d78-568">이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-568">Your event handler might contain functionality as shown in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 <span data-ttu-id="79d78-569">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-569">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-570">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-570">Workgroup mode</span></span>|<span data-ttu-id="79d78-571">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-571">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-572">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-572">Local computer</span></span>|<span data-ttu-id="79d78-573">예</span><span class="sxs-lookup"><span data-stu-id="79d78-573">Yes</span></span>|  
|<span data-ttu-id="79d78-574">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-574">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-575">예</span><span class="sxs-lookup"><span data-stu-id="79d78-575">Yes</span></span>|  
|<span data-ttu-id="79d78-576">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-576">Remote computer</span></span>|<span data-ttu-id="79d78-577">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-577">No</span></span>|  
|<span data-ttu-id="79d78-578">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-578">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-579">예</span><span class="sxs-lookup"><span data-stu-id="79d78-579">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-580">다음 코드 예제에서는 비동기 수신 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-580">The following code example creates an asynchronous receive operation.</span></span> <span data-ttu-id="79d78-581">코드 예제에서는 이벤트 처리기를 `MyReceiveCompleted`에 연결 된 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 처리기 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-581">The code example creates an event handler, `MyReceiveCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event handler delegate.</span></span> <span data-ttu-id="79d78-582">메시지를 로컬 메시지 큐는 코드 예제에서는 보낸 다음 호출 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>시간 제한 값이 10 초 이내에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-582">The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, passing in a time-out value of ten seconds.</span></span> <span data-ttu-id="79d78-583">경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면 이벤트 처리기는 메시지를 수신 하 고 화면에 메시지 본문을 씁니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-583">When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the event handler receives the message and writes the message body to the screen.</span></span>  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-584"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우 (예: 값이 음수인 경우)</span><span class="sxs-lookup"><span data-stu-id="79d78-584">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly because it represents a negative number.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-585">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-585">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-586">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-586">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-587">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-587">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="stateObject"><span data-ttu-id="79d78-588">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-588">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="79d78-589">시간 제한 및 상태 개체가 지정되어 있는 비동기 수신 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-589">Initiates an asynchronous receive operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</span></span> <span data-ttu-id="79d78-590">큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-590">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="79d78-591">게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-591">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-592">비동기 처리에 사용 하 여 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 메시지를 큐에 또는 지정된 된 시간 간격이 만료 될 때 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-592">In asynchronous processing, you use <xref:System.Messaging.MessageQueue.BeginReceive%2A> to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message becomes available in the queue or when the specified interval of time has expired.</span></span>  
  
 <span data-ttu-id="79d78-593"><xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-593"><xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-594">작업의 수명 주기 동안 유지 해야 하는 작업과 정보를 연결 하기 위해이 오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-594">Use this overload to associate information with the operation that will be preserved throughout the operation's lifetime.</span></span> <span data-ttu-id="79d78-595">이벤트 처리기 확인 하 여이 정보를 검색할 수는 <xref:System.IAsyncResult.AsyncState%2A> 의 속성은 <xref:System.IAsyncResult> 작업과 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-595">The event handler can detect this information by looking at the <xref:System.IAsyncResult.AsyncState%2A> property of the <xref:System.IAsyncResult> that is associated with the operation.</span></span>  
  
 <span data-ttu-id="79d78-596">사용 하도록 <xref:System.Messaging.MessageQueue.BeginReceive%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-596">To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</span></span> <span data-ttu-id="79d78-597"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 작업입니다. <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때.</span><span class="sxs-lookup"><span data-stu-id="79d78-597"><xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="79d78-598"><xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 하거나 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-598">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="79d78-599"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-599">The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="79d78-600">때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-600">Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="79d78-601">사용 하 여 동기적으로 메시지를 받으려면는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-601">To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-602">비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-602">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="79d78-603"><xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-603">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="79d78-604">이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-604">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="79d78-605">그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-605">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="79d78-606">사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-606">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="79d78-607">이 오버 로드는 제한 시간 및 상태 개체를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-607">This overload specifies a time-out and a state object.</span></span> <span data-ttu-id="79d78-608">으로 지정한 간격이 하는 경우는 `timeout` 매개 변수 만료 되 면이 구성 요소는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-608">If the interval specified by the `timeout` parameter expires, this component raises the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event.</span></span> <span data-ttu-id="79d78-609">메시지가 없으므로 한 후속 호출에 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-609">Because no message exists, a subsequent call to <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> will throw an exception.</span></span>  
  
 <span data-ttu-id="79d78-610">상태 개체는 작업 상태 정보를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-610">The state object associates state information with the operation.</span></span> <span data-ttu-id="79d78-611">예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-611">For example, if you call <xref:System.Messaging.MessageQueue.BeginReceive%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span>  
  
 <span data-ttu-id="79d78-612">또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-612">You can also use the state object to pass information across process threads.</span></span> <span data-ttu-id="79d78-613">스레드 시작 되었지만 비동기 시나리오의 다른 스레드에서 콜백이, 하는 경우 상태 개체 마샬링되고 이벤트에서 정보와 함께 다시 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-613">If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</span></span>  
  
 <span data-ttu-id="79d78-614">비동기 호출을 사용 하지 마십시오 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-614">Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions.</span></span> <span data-ttu-id="79d78-615">트랜잭션 비동기 작업을 수행 하려는 경우 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, (동기) 하 여 트랜잭션을 저장 <xref:System.Messaging.MessageQueue.Receive%2A> 피크 (peek) 작업에 대해 만들 이벤트 처리기 내에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-615">If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation.</span></span> <span data-ttu-id="79d78-616">이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-616">Your event handler might contain functionality as shown in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 <span data-ttu-id="79d78-617">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-617">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-618">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-618">Workgroup mode</span></span>|<span data-ttu-id="79d78-619">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-619">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-620">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-620">Local computer</span></span>|<span data-ttu-id="79d78-621">예</span><span class="sxs-lookup"><span data-stu-id="79d78-621">Yes</span></span>|  
|<span data-ttu-id="79d78-622">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-622">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-623">예</span><span class="sxs-lookup"><span data-stu-id="79d78-623">Yes</span></span>|  
|<span data-ttu-id="79d78-624">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-624">Remote computer</span></span>|<span data-ttu-id="79d78-625">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-625">No</span></span>|  
|<span data-ttu-id="79d78-626">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-626">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-627">예</span><span class="sxs-lookup"><span data-stu-id="79d78-627">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-628">다음 코드 예제에서는 비동기 수신 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-628">The following code example creates an asynchronous receive operation.</span></span> <span data-ttu-id="79d78-629">코드 예제에서는 이벤트 처리기를 `MyReceiveCompleted`에 연결 된 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 처리기 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-629">The code example creates an event handler, `MyReceiveCompleted`, and attaches it to the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event handler delegate.</span></span> <span data-ttu-id="79d78-630">메시지를 로컬 메시지 큐는 코드 예제에서는 보낸 다음 호출 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>시간 제한 값이 10 초에 한 및 특정 메시지를 식별 하는 고유한 정수에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-630">The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, passing in a time-out value of ten seconds and a unique integer that identifies that particular message.</span></span> <span data-ttu-id="79d78-631">경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면 이벤트 처리기는 메시지를 받고 메시지 본문과 정수 메시지 식별자를 화면에 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-631">When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the event handler receives the message and writes the message body and the integer message identifier to the screen.</span></span>  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-632"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-632">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-633">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-633">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-634">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-634">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-635">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-635">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="stateObject"><span data-ttu-id="79d78-636">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-636">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <param name="callback"><span data-ttu-id="79d78-637">비동기 작업 완료에 대한 알림을 수신할 <see cref="T:System.AsyncCallback" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-637">The <see cref="T:System.AsyncCallback" /> that will receive the notification of the asynchronous operation completion.</span></span></param>
        <summary><span data-ttu-id="79d78-638">시간 제한 및 상태 개체가 지정되어 있는 비동기 수신 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-638">Initiates an asynchronous receive operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</span></span> <span data-ttu-id="79d78-639">이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-639">This overload receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="79d78-640">큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-640">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="79d78-641">게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-641">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-642">이 오버 로드를 사용 하 여 콜백 매개 변수에 지정 된 콜백 됩니다 때 직접 호출 메시지를 큐에 또는 지정된 된 시간 간격이 만료 되 면 사용할 수 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-642">When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is not raised.</span></span> <span data-ttu-id="79d78-643">다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면이 구성 요소에 의존는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-643">The other overloads of <xref:System.Messaging.MessageQueue.BeginReceive%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event.</span></span>  
  
 <span data-ttu-id="79d78-644"><xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-644"><xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-645">사용 하도록 <xref:System.Messaging.MessageQueue.BeginReceive%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-645">To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</span></span> <span data-ttu-id="79d78-646"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 작업입니다. <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때.</span><span class="sxs-lookup"><span data-stu-id="79d78-646"><xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="79d78-647"><xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 하거나 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-647">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="79d78-648"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-648">The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="79d78-649">때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-649">Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="79d78-650">사용 하 여 동기적으로 메시지를 받으려면는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-650">To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-651">비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-651">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="79d78-652"><xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-652">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="79d78-653">이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-653">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="79d78-654">그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-654">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="79d78-655">사용 하는 경우에 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-655">In this case, you use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="79d78-656">상태 개체는 작업 상태 정보를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-656">The state object associates state information with the operation.</span></span> <span data-ttu-id="79d78-657">예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-657">For example, if you call <xref:System.Messaging.MessageQueue.BeginReceive%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span>  
  
 <span data-ttu-id="79d78-658">또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-658">You can also use the state object to pass information across process threads.</span></span> <span data-ttu-id="79d78-659">스레드 시작 되었지만 비동기 시나리오의 다른 스레드에서 콜백이, 하는 경우 상태 개체 마샬링되고 이벤트에서 정보와 함께 다시 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-659">If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</span></span>  
  
 <span data-ttu-id="79d78-660">비동기 호출을 사용 하지 마십시오 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-660">Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions.</span></span> <span data-ttu-id="79d78-661">트랜잭션 비동기 작업을 수행 하려는 경우 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, (동기) 하 여 트랜잭션을 저장 <xref:System.Messaging.MessageQueue.Receive%2A> 피크 (peek) 작업에 대해 만들 이벤트 처리기 내에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-661">If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation.</span></span> <span data-ttu-id="79d78-662">이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-662">Your event handler might contain functionality as shown in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 <span data-ttu-id="79d78-663">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-663">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-664">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-664">Workgroup mode</span></span>|<span data-ttu-id="79d78-665">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-665">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-666">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-666">Local computer</span></span>|<span data-ttu-id="79d78-667">예</span><span class="sxs-lookup"><span data-stu-id="79d78-667">Yes</span></span>|  
|<span data-ttu-id="79d78-668">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-668">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-669">예</span><span class="sxs-lookup"><span data-stu-id="79d78-669">Yes</span></span>|  
|<span data-ttu-id="79d78-670">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-670">Remote computer</span></span>|<span data-ttu-id="79d78-671">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-671">No</span></span>|  
|<span data-ttu-id="79d78-672">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-672">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-673">예</span><span class="sxs-lookup"><span data-stu-id="79d78-673">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-674">다음 코드 예제에서는 비동기 수신 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-674">The following code example creates an asynchronous receive operation.</span></span> <span data-ttu-id="79d78-675">메시지를 로컬 메시지 큐는 코드 예제에서는 보낸 다음 호출 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>를: 시간 제한 값이 10 초, 특정 메시지; 및의 새 인스턴스를 식별 하는 고유한 정수 <xref:System.AsyncCallback> 이벤트 처리기를 식별 하는 `MyReceiveCompleted`.</span><span class="sxs-lookup"><span data-stu-id="79d78-675">The code example sends a message to a local message queue, then calls <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passing in: a time-out value of ten seconds; a unique integer that identifies that particular message; and a new instance of <xref:System.AsyncCallback> that identifies the event handler, `MyReceiveCompleted`.</span></span> <span data-ttu-id="79d78-676">경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면 이벤트 처리기는 메시지를 받고 메시지 본문과 정수 메시지 식별자를 화면에 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-676">When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the event handler receives the message and writes the message body and the integer message identifier to the screen.</span></span>  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-677"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-677">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-678">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-678">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-679">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-679">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-680">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-680">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</span></span></param>
        <param name="cursor"><span data-ttu-id="79d78-681">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-681">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <param name="state"><span data-ttu-id="79d78-682">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 응용 프로그램에서 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-682">A state object, specified by the application, that contains information associated with the asynchronous operation.</span></span></param>
        <param name="callback"><span data-ttu-id="79d78-683">비동기 작업 완료에 대한 알림을 수신하는 <see cref="T:System.AsyncCallback" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-683">The <see cref="T:System.AsyncCallback" /> that receives the notification of the asynchronous operation completion.</span></span></param>
        <summary><span data-ttu-id="79d78-684">지정된 제한 시간이 있고 지정된 커서 및 지정된 상태 개체를 사용하는 비동기 수신 작업을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-684">Initiates an asynchronous receive operation that has a specified time-out and uses a specified cursor and a specified state object.</span></span> <span data-ttu-id="79d78-685">상태 개체는 전체 작업 기간 동안 관련 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-685">The state object provides associated information throughout the lifetime of the operation.</span></span> <span data-ttu-id="79d78-686">이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-686">This overload receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="79d78-687">큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-687">The operation is not complete until either a message becomes available in the queue or the time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="79d78-688">게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-688">The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-689">이 오버 로드를 사용 하 여 콜백 매개 변수에 지정 된 콜백 됩니다 때 직접 호출 메시지를 큐에 또는 지정된 된 시간 간격이 만료 되 면 사용할 수 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-689">When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is not raised.</span></span> <span data-ttu-id="79d78-690">다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면이 구성 요소에 의존는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-690">The other overloads of <xref:System.Messaging.MessageQueue.BeginReceive%2A> rely on this component to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event.</span></span>  
  
 <span data-ttu-id="79d78-691"><xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지가 큐에 이미 있는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-691"><xref:System.Messaging.MessageQueue.ReceiveCompleted> is also raised if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-692">사용 하도록 <xref:System.Messaging.MessageQueue.BeginReceive%2A>을 비동기 작업의 결과 처리 하는 이벤트 처리기를 만들고 이벤트 대리자와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-692">To use <xref:System.Messaging.MessageQueue.BeginReceive%2A>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</span></span> <span data-ttu-id="79d78-693"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 작업입니다. <xref:System.Messaging.MessageQueue> 알림을 발생 시켜는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때.</span><span class="sxs-lookup"><span data-stu-id="79d78-693"><xref:System.Messaging.MessageQueue.BeginReceive%2A> initiates an asynchronous receive operation; the <xref:System.Messaging.MessageQueue> is notified, through the raising of the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event, when a message arrives in the queue.</span></span> <span data-ttu-id="79d78-694"><xref:System.Messaging.MessageQueue> 호출 하 여 메시지에 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 하거나 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-694">The <xref:System.Messaging.MessageQueue> can then access the message by calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> or retrieving the result using the <xref:System.Messaging.ReceiveCompletedEventArgs>.</span></span>  
  
 <span data-ttu-id="79d78-695"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지는 비동기 작업이 완료 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-695">The <xref:System.Messaging.MessageQueue.BeginReceive%2A> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</span></span>  
  
 <span data-ttu-id="79d78-696">때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 는 비동기적 이며이 호출 하면 실행의 현재 스레드를 차단 하지 않고 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-696">Because <xref:System.Messaging.MessageQueue.BeginReceive%2A> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</span></span> <span data-ttu-id="79d78-697">사용 하 여 동기적으로 메시지를 받으려면는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-697">To synchronously receive a message, use the <xref:System.Messaging.MessageQueue.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-698">비동기 작업이 완료 되 면 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에서 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-698">Once an asynchronous operation completes, you can call <xref:System.Messaging.MessageQueue.BeginPeek%2A> or <xref:System.Messaging.MessageQueue.BeginReceive%2A> again in the event handler to keep receiving notifications.</span></span>  
  
 <span data-ttu-id="79d78-699"><xref:System.IAsyncResult> 하 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드가 시작 된 비동기 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-699">The <xref:System.IAsyncResult> that <xref:System.Messaging.MessageQueue.BeginReceive%2A> returns identifies the asynchronous operation that the method started.</span></span> <span data-ttu-id="79d78-700">이 사용 하 여 <xref:System.IAsyncResult> 작업의 수명 주기 동안 있지만 일반적으로 사용 하지 않는 때까지 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-700">You can use this <xref:System.IAsyncResult> throughout the lifetime of the operation, although you generally do not use it until <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is called.</span></span> <span data-ttu-id="79d78-701">그러나 몇 가지 비동기 작업을 시작 하는 경우 배치할 수 있습니다 자신의 <xref:System.IAsyncResult> 값을 배열에 하 고 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-701">However, if you start several asynchronous operations, you can place their <xref:System.IAsyncResult> values in an array and specify whether to wait for all operations or any operation to complete.</span></span> <span data-ttu-id="79d78-702">이 경우에 사용 된 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 속성은 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-702">In this case, use the <xref:System.IAsyncResult.AsyncWaitHandle%2A> property of the <xref:System.IAsyncResult> to identify the completed operation.</span></span>  
  
 <span data-ttu-id="79d78-703">상태 개체는 작업 상태 정보를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-703">The state object associates state information with the operation.</span></span> <span data-ttu-id="79d78-704">예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 여러 번 여러 작업을 시작할 수, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-704">For example, if you call <xref:System.Messaging.MessageQueue.BeginReceive%2A> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</span></span>  
  
 <span data-ttu-id="79d78-705">또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-705">You can also use the state object to pass information across process threads.</span></span> <span data-ttu-id="79d78-706">스레드 시작 되었지만 비동기 시나리오의 다른 스레드에서 콜백이, 하는 경우 상태 개체 마샬링되고 이벤트에서 정보와 함께 다시 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-706">If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</span></span>  
  
 <span data-ttu-id="79d78-707">비동기 호출을 사용 하지 마십시오 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-707">Do not use the asynchronous call <xref:System.Messaging.MessageQueue.BeginReceive%2A> with transactions.</span></span> <span data-ttu-id="79d78-708">트랜잭션 비동기 작업을 수행 하려는 경우 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, (동기) 하 여 트랜잭션을 저장 <xref:System.Messaging.MessageQueue.Receive%2A> 피크 (peek) 작업에 대해 만들 이벤트 처리기 내에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-708">If you want to perform a transactional asynchronous operation, call <xref:System.Messaging.MessageQueue.BeginPeek%2A>, and put the transaction and the (synchronous) <xref:System.Messaging.MessageQueue.Receive%2A> method within the event handler you create for the peek operation.</span></span> <span data-ttu-id="79d78-709">이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-709">Your event handler might contain functionality as shown in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 <span data-ttu-id="79d78-710">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-710">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-711">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-711">Workgroup mode</span></span>|<span data-ttu-id="79d78-712">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-712">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-713">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-713">Local computer</span></span>|<span data-ttu-id="79d78-714">예</span><span class="sxs-lookup"><span data-stu-id="79d78-714">Yes</span></span>|  
|<span data-ttu-id="79d78-715">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-715">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-716">예</span><span class="sxs-lookup"><span data-stu-id="79d78-716">Yes</span></span>|  
|<span data-ttu-id="79d78-717">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-717">Remote computer</span></span>|<span data-ttu-id="79d78-718">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-718">No</span></span>|  
|<span data-ttu-id="79d78-719">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-719">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-720">예</span><span class="sxs-lookup"><span data-stu-id="79d78-720">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-721"><paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-721">The <paramref name="cursor" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-722"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-722">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-723">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-723">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-724">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-724">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-725"><see cref="T:System.Messaging.MessageQueue" />를 읽을 수 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-725">Gets a value that indicates whether the <see cref="T:System.Messaging.MessageQueue" /> can be read.</span></span></summary>
        <value>
          <span data-ttu-id="79d78-726"><see cref="T:System.Messaging.MessageQueue" />가 있고 응용 프로그램에서 이 큐를 읽을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-726"><see langword="true" /> if the <see cref="T:System.Messaging.MessageQueue" /> exists and the application can read from it; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-727"><xref:System.Messaging.MessageQueue.CanRead%2A> 응용 프로그램 큐에서 메시지를 받거나 피킹 수 인지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-727"><xref:System.Messaging.MessageQueue.CanRead%2A> indicates whether the application is able to peek or receive messages from the queue.</span></span> <span data-ttu-id="79d78-728">경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `true`, <xref:System.Messaging.MessageQueue> 받거나 큐에서 메시지를 피킹할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-728">If <xref:System.Messaging.MessageQueue.CanRead%2A> is `true`, the <xref:System.Messaging.MessageQueue> can receive or peek messages from the queue.</span></span> <span data-ttu-id="79d78-729">그렇지 않으면 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-729">Otherwise, it cannot.</span></span>  
  
 <span data-ttu-id="79d78-730"><xref:System.Messaging.MessageQueue.CanRead%2A> `false` 큐가 이미 단독 읽기 권한으로 열려 있으면 (비독점 액세스 하 고이 열려 있는 경우 또는 <xref:System.Messaging.MessageQueue> 단독 액세스를 요청), 응용 프로그램에 액세스할 수 있는 충분 한 권한이 없는 경우 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-730"><xref:System.Messaging.MessageQueue.CanRead%2A> is `false` if a queue is already open with exclusive read access (or if it's open with non-exclusive access and this <xref:System.Messaging.MessageQueue> requests exclusive access), or if the application does not have sufficient rights to access it.</span></span> <span data-ttu-id="79d78-731">응용 프로그램이 큐에서 읽기를 시도 하면 때 <xref:System.Messaging.MessageQueue.CanRead%2A> 은 `false`, 액세스가 거부 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-731">If your application tries to read from a queue when <xref:System.Messaging.MessageQueue.CanRead%2A> is `false`, access is denied.</span></span>  
  
 <span data-ttu-id="79d78-732">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-732">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-733">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-733">Workgroup mode</span></span>|<span data-ttu-id="79d78-734">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-734">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-735">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-735">Local computer</span></span>|<span data-ttu-id="79d78-736">예</span><span class="sxs-lookup"><span data-stu-id="79d78-736">Yes</span></span>|  
|<span data-ttu-id="79d78-737">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-737">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-738">예</span><span class="sxs-lookup"><span data-stu-id="79d78-738">Yes</span></span>|  
|<span data-ttu-id="79d78-739">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-739">Remote computer</span></span>|<span data-ttu-id="79d78-740">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-740">No</span></span>|  
|<span data-ttu-id="79d78-741">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-741">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-742">예</span><span class="sxs-lookup"><span data-stu-id="79d78-742">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-743">다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.CanRead%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-743">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.CanRead%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-744"><see cref="T:System.Messaging.MessageQueue" />에 쓸 수 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-744">Gets a value that indicates whether the <see cref="T:System.Messaging.MessageQueue" /> can be written to.</span></span></summary>
        <value>
          <span data-ttu-id="79d78-745"><see cref="T:System.Messaging.MessageQueue" />가 있고 응용 프로그램이 여기에 쓸 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-745"><see langword="true" /> if the <see cref="T:System.Messaging.MessageQueue" /> exists and the application can write to it; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-746"><xref:System.Messaging.MessageQueue.CanWrite%2A> 응용 프로그램은 큐에 메시지를 보낼 수 있는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-746"><xref:System.Messaging.MessageQueue.CanWrite%2A> indicates whether the application is able to send messages to the queue.</span></span> <span data-ttu-id="79d78-747">경우 <xref:System.Messaging.MessageQueue.CanWrite%2A> 은 `true`, <xref:System.Messaging.MessageQueue> 큐에 메시지를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-747">If <xref:System.Messaging.MessageQueue.CanWrite%2A> is `true`, the <xref:System.Messaging.MessageQueue> can send messages to the queue.</span></span> <span data-ttu-id="79d78-748">그렇지 않으면 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-748">Otherwise, it cannot.</span></span>  
  
 <span data-ttu-id="79d78-749"><xref:System.Messaging.MessageQueue.CanWrite%2A> `false` 큐가 이미 단독 쓰기 권한으로 열려 있으면 (비독점 액세스 하 고이 열려 있는 경우 또는 <xref:System.Messaging.MessageQueue> 단독 액세스를 요청), 응용 프로그램에 액세스할 수 있는 충분 한 권한이 없는 경우 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-749"><xref:System.Messaging.MessageQueue.CanWrite%2A> is `false` if a queue is already open with exclusive write access (or if it's open with non-exclusive access and this <xref:System.Messaging.MessageQueue> requests exclusive access), or if the application does not have sufficient rights to access it.</span></span> <span data-ttu-id="79d78-750">응용 프로그램이 큐에 쓰려고 시도 하면 때 <xref:System.Messaging.MessageQueue.CanWrite%2A> 은 `false`, 액세스가 거부 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-750">If your application tries to write to a queue when <xref:System.Messaging.MessageQueue.CanWrite%2A> is `false`, access is denied.</span></span>  
  
 <span data-ttu-id="79d78-751">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-751">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-752">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-752">Workgroup mode</span></span>|<span data-ttu-id="79d78-753">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-753">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-754">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-754">Local computer</span></span>|<span data-ttu-id="79d78-755">예</span><span class="sxs-lookup"><span data-stu-id="79d78-755">Yes</span></span>|  
|<span data-ttu-id="79d78-756">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-756">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-757">예</span><span class="sxs-lookup"><span data-stu-id="79d78-757">Yes</span></span>|  
|<span data-ttu-id="79d78-758">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-758">Remote computer</span></span>|<span data-ttu-id="79d78-759">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-759">No</span></span>|  
|<span data-ttu-id="79d78-760">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-760">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-761">예</span><span class="sxs-lookup"><span data-stu-id="79d78-761">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-762">다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.CanWrite%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-762">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.CanWrite%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-763">큐 범주를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-763">Gets or sets the queue category.</span></span></summary>
        <value><span data-ttu-id="79d78-764">큐 범주(메시지 큐 형식 식별자)를 나타내는 <see cref="T:System.Guid" />입니다. 여기서 응용 프로그램을 사용하여 큐를 분류할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-764">A <see cref="T:System.Guid" /> that represents the queue category (Message Queuing type identifier), which allows an application to categorize its queues.</span></span> <span data-ttu-id="79d78-765">기본값은 <see langword="Guid.empty" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-765">The default is <see langword="Guid.empty" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-766">큐 범주에 응용을 프로그램에서 큐를 분류할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-766">The queue category allows an application to categorize its queues.</span></span> <span data-ttu-id="79d78-767">예를 들어 하나의 범주 및 다른 모든 주문 큐에 모든 청구 큐를 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-767">For example, you can place all Billing queues in one category and all Order queues in another.</span></span>  
  
 <span data-ttu-id="79d78-768"><xref:System.Messaging.MessageQueue.Category%2A> 속성은 메시지 큐 형식 ID 속성 (즉, 읽기/쓰기)에 대 한 액세스를 제공을 통해 액세스할 수는 **큐 속성** 컴퓨터 관리 콘솔에서 대화 상자.</span><span class="sxs-lookup"><span data-stu-id="79d78-768">The <xref:System.Messaging.MessageQueue.Category%2A> property provides access to the Message Queuing Type ID property (which is read/write), accessible through the **Queue Properties** dialog box in the Computer Management Console.</span></span> <span data-ttu-id="79d78-769">새 범주를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-769">You can define a new category.</span></span> <span data-ttu-id="79d78-770">사용할 수 있지만 <xref:System.Guid.NewGuid%2A> 는 모든 고유 범주 값을 만들려면 <xref:System.Guid> 값, 이러한 작업이 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-770">Although you can use <xref:System.Guid.NewGuid%2A> to create a category value that is unique across all <xref:System.Guid> values, such an action is unnecessary.</span></span> <span data-ttu-id="79d78-771">범주 값이 다른 범주에서가 아니라 다른 모든 구별 되도록 <xref:System.Guid> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-771">The category value needs to be distinct only from other categories, not from all other <xref:System.Guid> values.</span></span> <span data-ttu-id="79d78-772">할당할 수는 예를 들어 {00000000-0000-0000-0000-000000000001} 로 <xref:System.Messaging.MessageQueue.Category%2A> 한 집합 큐에 대 한 및 {00000000-0000-0000-0000-000000000002} 로 <xref:System.Messaging.MessageQueue.Category%2A> 다른 집합에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-772">For example, you can assign {00000000-0000-0000-0000-000000000001} as the <xref:System.Messaging.MessageQueue.Category%2A> for one set of queues and {00000000-0000-0000-0000-000000000002} as the <xref:System.Messaging.MessageQueue.Category%2A> for another set.</span></span>  
  
 <span data-ttu-id="79d78-773">설정 하려면 필요 없는 <xref:System.Messaging.MessageQueue.Category%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-773">It is not necessary to set the <xref:System.Messaging.MessageQueue.Category%2A>.</span></span> <span data-ttu-id="79d78-774">값은 `null`이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-774">The value can be `null`.</span></span>  
  
 <span data-ttu-id="79d78-775">이 속성을 설정 하면 메시지 큐를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-775">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="79d78-776">따라서 다른 모든 <xref:System.Messaging.MessageQueue> 인스턴스 변경의 영향을 받는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-776">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.</span></span>  
  
 <span data-ttu-id="79d78-777">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-777">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-778">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-778">Workgroup mode</span></span>|<span data-ttu-id="79d78-779">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-779">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-780">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-780">Local computer</span></span>|<span data-ttu-id="79d78-781">예</span><span class="sxs-lookup"><span data-stu-id="79d78-781">Yes</span></span>|  
|<span data-ttu-id="79d78-782">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-782">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-783">예</span><span class="sxs-lookup"><span data-stu-id="79d78-783">Yes</span></span>|  
|<span data-ttu-id="79d78-784">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-784">Remote computer</span></span>|<span data-ttu-id="79d78-785">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-785">No</span></span>|  
|<span data-ttu-id="79d78-786">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-786">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-787">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-787">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-788">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.Category%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-788">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.Category%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-789">우선 순위 범주가 잘못된 값으로 설정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-789">The queue category was set to an invalid value.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-790">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-790">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-791">연결 캐시를 지웁니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-791">Clears the connection cache.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-792">호출 하는 경우 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, 캐시에 저장 되는 형식 이름을 제거 되 고 핸들이 열리고 캐시에 저장 된 닫혀 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-792">When you call <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, the format names stored in the cache are removed and handles opened and stored in the cache are closed.</span></span>  
  
 <span data-ttu-id="79d78-793">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-793">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-794">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-794">Workgroup mode</span></span>|<span data-ttu-id="79d78-795">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-795">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-796">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-796">Local computer</span></span>|<span data-ttu-id="79d78-797">예</span><span class="sxs-lookup"><span data-stu-id="79d78-797">Yes</span></span>|  
|<span data-ttu-id="79d78-798">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-798">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-799">예</span><span class="sxs-lookup"><span data-stu-id="79d78-799">Yes</span></span>|  
|<span data-ttu-id="79d78-800">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-800">Remote computer</span></span>|<span data-ttu-id="79d78-801">예</span><span class="sxs-lookup"><span data-stu-id="79d78-801">Yes</span></span>|  
|<span data-ttu-id="79d78-802">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-802">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-803">예</span><span class="sxs-lookup"><span data-stu-id="79d78-803">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-804">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-804">The following code example calls <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.</span></span>  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-805"><see cref="T:System.Messaging.MessageQueue" />가 할당한 리소스를 모두 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-805">Frees all resources allocated by the <see cref="T:System.Messaging.MessageQueue" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-806"><xref:System.Messaging.MessageQueue.Close%2A> 와 연결 된 모든 리소스를 해제 한 <xref:System.Messaging.MessageQueue>를 포함 하 여 공유 리소스에 해당 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-806"><xref:System.Messaging.MessageQueue.Close%2A> frees all resources associated with a <xref:System.Messaging.MessageQueue>, including shared resources if appropriate.</span></span> <span data-ttu-id="79d78-807">시스템 다시 이러한 리소스를 가져옵니다 자동으로 계속 사용할 수 있는, 예를 들어 호출 하는 경우는 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> 다음 C# 코드와 같이 메서드를 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-807">The system re-acquires these resources automatically if they are still available, for example when you call the <xref:System.Messaging.MessageQueue.Send%28System.Object%29> method, as in the following C# code.</span></span>  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 <span data-ttu-id="79d78-808">호출 하는 경우 <xref:System.Messaging.MessageQueue.Close%2A>모든 <xref:System.Messaging.MessageQueue> 메시지 큐를 직접 액세스 하는 속성이 지워집니다. <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, 및 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 모두 그대로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-808">When you call <xref:System.Messaging.MessageQueue.Close%2A>, all <xref:System.Messaging.MessageQueue> properties that directly access the Message Queuing queue are cleared out. The <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, and <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> all remain as they were.</span></span>  
  
 <span data-ttu-id="79d78-809"><xref:System.Messaging.MessageQueue.Close%2A> 읽기 및 공유 되어 때문에 큐에 쓰기 핸들 항상 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-809"><xref:System.Messaging.MessageQueue.Close%2A> does not always free the read and write handles to a queue, because they might be shared.</span></span> <span data-ttu-id="79d78-810">확인 하려면 다음 단계를 사용할 수 있는 <xref:System.Messaging.MessageQueue.Close%2A> 큐에 대 한 읽기 및 쓰기 핸들을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-810">You can take any of the following steps to ensure that <xref:System.Messaging.MessageQueue.Close%2A> frees the read and write handles to a queue:</span></span>  
  
-   <span data-ttu-id="79d78-811">만들기는 <xref:System.Messaging.MessageQueue> 단독 액세스 권한을 갖는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-811">Create the <xref:System.Messaging.MessageQueue> with exclusive access.</span></span> <span data-ttu-id="79d78-812">이렇게 하려면 호출는 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> 또는 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 생성자 및 집합은 `sharedModeDenyReceive` 매개 변수를 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-812">To do so, call the <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> or <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> constructor, and set the `sharedModeDenyReceive` parameter to `true`.</span></span>  
  
-   <span data-ttu-id="79d78-813">만들기는 <xref:System.Messaging.MessageQueue> 연결 캐싱을 사용 하지 않도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-813">Create the <xref:System.Messaging.MessageQueue> with connection caching disabled.</span></span> <span data-ttu-id="79d78-814">이렇게 하려면 호출는 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 집합과, 생성자는 `enableConnectionCache` 매개 변수를 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-814">To do so, call the <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> constructor and set the `enableConnectionCache` parameter to `false`.</span></span>  
  
-   <span data-ttu-id="79d78-815">연결 캐싱을 사용 하지 않도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-815">Disable connection caching.</span></span> <span data-ttu-id="79d78-816">이 위해 설정 된 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 속성을 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-816">To do so, set the <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> property to `false`.</span></span>  
  
 <span data-ttu-id="79d78-817">호출 해야 <xref:System.Messaging.MessageQueue.Close%2A> 메시지 큐 서버에 있는 큐를 삭제 하기 전에 큐에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-817">You should call <xref:System.Messaging.MessageQueue.Close%2A> for a queue before you delete the queue on the Message Queuing server.</span></span> <span data-ttu-id="79d78-818">그렇지 않은 경우 큐에 전송 된 메시지 예외를 throw 하거나 배달 못 한 편지 큐에 표시 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-818">Otherwise, messages sent to the queue could throw exceptions or appear in the dead-letter queue.</span></span>  
  
 <span data-ttu-id="79d78-819">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-819">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-820">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-820">Workgroup mode</span></span>|<span data-ttu-id="79d78-821">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-821">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-822">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-822">Local computer</span></span>|<span data-ttu-id="79d78-823">예</span><span class="sxs-lookup"><span data-stu-id="79d78-823">Yes</span></span>|  
|<span data-ttu-id="79d78-824">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-824">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-825">예</span><span class="sxs-lookup"><span data-stu-id="79d78-825">Yes</span></span>|  
|<span data-ttu-id="79d78-826">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-826">Remote computer</span></span>|<span data-ttu-id="79d78-827">예</span><span class="sxs-lookup"><span data-stu-id="79d78-827">Yes</span></span>|  
|<span data-ttu-id="79d78-828">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-828">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-829">예</span><span class="sxs-lookup"><span data-stu-id="79d78-829">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-830">다음 코드 예제에서는 메시지 큐를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-830">The following code example closes a Message Queuing queue.</span></span>  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-831">메시지 큐 서버의 지정된 경로에 새 큐를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-831">Creates a new queue at the specified path on a Message Queuing server.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="79d78-832">만들 큐의 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-832">The path of the queue to create.</span></span></param>
        <summary><span data-ttu-id="79d78-833">지정된 경로에 비트랜잭션 메시지 큐를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-833">Creates a non-transactional Message Queuing queue at the specified path.</span></span></summary>
        <returns><span data-ttu-id="79d78-834">새 큐를 나타내는 <see cref="T:System.Messaging.MessageQueue" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-834">A <see cref="T:System.Messaging.MessageQueue" /> that represents the new queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-835">이 오버 로드를 사용 하 여 메시지 큐 비트랜잭션 큐를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-835">Use this overload to create a non-transactional Message Queuing queue.</span></span>  
  
 <span data-ttu-id="79d78-836">새 인스턴스를 만드는 <xref:System.Messaging.MessageQueue> 응용 프로그램에서 클래스 및 기존 큐를 바인딩, 사용 하 여는 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-836">To create a new instance of the <xref:System.Messaging.MessageQueue> class in your application and bind it to an existing queue, use the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor.</span></span> <span data-ttu-id="79d78-837">메시지 큐에서 새 큐를 만들려면, <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-837">To create a new queue in Message Queuing, call <xref:System.Messaging.MessageQueue.Create%28System.String%29>.</span></span>  
  
 <span data-ttu-id="79d78-838">에 대 한 구문에서 `path` 매개 변수 유형에 따라 다릅니다 큐의 해당 참조는 다음 표에 나와 있는 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-838">The syntax for the `path` parameter depends on the type of queue it references, as shown in the following table.</span></span>  
  
|<span data-ttu-id="79d78-839">큐 유형</span><span class="sxs-lookup"><span data-stu-id="79d78-839">Queue type</span></span>|<span data-ttu-id="79d78-840">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-840">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="79d78-841">공개 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-841">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="79d78-842">개인 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-842">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
  
 <span data-ttu-id="79d78-843">사용 하 여 "." 로컬 컴퓨터에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-843">Use "." for the local computer.</span></span> <span data-ttu-id="79d78-844">자세한 구문에 대 한 참조는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-844">For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span>  
  
 <span data-ttu-id="79d78-845">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-845">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-846">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-846">Workgroup mode</span></span>|<span data-ttu-id="79d78-847">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-847">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-848">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-848">Local computer</span></span>|<span data-ttu-id="79d78-849">예</span><span class="sxs-lookup"><span data-stu-id="79d78-849">Yes</span></span>|  
|<span data-ttu-id="79d78-850">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-850">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-851">예</span><span class="sxs-lookup"><span data-stu-id="79d78-851">Yes</span></span>|  
|<span data-ttu-id="79d78-852">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-852">Remote computer</span></span>|<span data-ttu-id="79d78-853">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-853">No</span></span>|  
|<span data-ttu-id="79d78-854">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-854">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-855">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-855">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-856">다음 코드 예제에서는 공용 및 개인 큐를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-856">The following code example creates public and private queues.</span></span> <span data-ttu-id="79d78-857">선택한 큐에 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-857">It sends a message to selected queues.</span></span>  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-858"><paramref name="path" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-858">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-859">지정된 경로에 큐가 이미 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-859">A queue already exists at the specified path.</span></span>  
  
 <span data-ttu-id="79d78-860">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-860">-or-</span></span>  
  
 <span data-ttu-id="79d78-861">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-861">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="79d78-862">만들 큐의 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-862">The path of the queue to create.</span></span></param>
        <param name="transactional">
          <span data-ttu-id="79d78-863">트랜잭션 큐를 만들려면 <see langword="true" />이고, 비트랜잭션 큐를 만들려면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-863"><see langword="true" /> to create a transactional queue; <see langword="false" /> to create a non-transactional queue.</span></span></param>
        <summary><span data-ttu-id="79d78-864">지정된 경로에 트랜잭션 또는 비트랜잭션 메시지 큐를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-864">Creates a transactional or non-transactional Message Queuing queue at the specified path.</span></span></summary>
        <returns><span data-ttu-id="79d78-865">새 큐를 나타내는 <see cref="T:System.Messaging.MessageQueue" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-865">A <see cref="T:System.Messaging.MessageQueue" /> that represents the new queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-866">메시지 큐에서 트랜잭션 큐를 만들려면이 오버 로드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-866">You can use this overload to create a transactional queue in Message Queuing.</span></span> <span data-ttu-id="79d78-867">설정 하 여 비트랜잭션 큐를 만들 수는 `transactional` 매개 변수를 `false` 의 다른 오버 로드를 호출 하 여 <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-867">You can create a non-transactional queue, by setting the `transactional` parameter to `false` or by calling the other overload of <xref:System.Messaging.MessageQueue.Create%28System.String%29>.</span></span>  
  
 <span data-ttu-id="79d78-868">새 인스턴스를 만드는 <xref:System.Messaging.MessageQueue> 응용 프로그램에서 클래스 및 기존 큐를 바인딩, 사용 하 여는 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-868">To create a new instance of the <xref:System.Messaging.MessageQueue> class in your application and bind it to an existing queue, use the <xref:System.Messaging.MessageQueue.%23ctor%2A> constructor.</span></span> <span data-ttu-id="79d78-869">메시지 큐에서 새 큐를 만들려면, <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-869">To create a new queue in Message Queuing, call <xref:System.Messaging.MessageQueue.Create%28System.String%29>.</span></span>  
  
 <span data-ttu-id="79d78-870">에 대 한 구문에서 `path` 매개 변수 유형에 따라 다릅니다 큐의 해당 참조는 다음 표에 나와 있는 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-870">The syntax for the `path` parameter depends on the type of queue it references, as shown in the following table.</span></span>  
  
|<span data-ttu-id="79d78-871">큐 유형</span><span class="sxs-lookup"><span data-stu-id="79d78-871">Queue type</span></span>|<span data-ttu-id="79d78-872">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-872">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="79d78-873">공개 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-873">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="79d78-874">개인 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-874">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
  
 <span data-ttu-id="79d78-875">사용 하 여 "." 로컬 컴퓨터에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-875">Use "." for the local computer.</span></span> <span data-ttu-id="79d78-876">자세한 구문에 대 한 참조는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-876">For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span>  
  
 <span data-ttu-id="79d78-877">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-877">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-878">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-878">Workgroup mode</span></span>|<span data-ttu-id="79d78-879">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-879">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-880">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-880">Local computer</span></span>|<span data-ttu-id="79d78-881">예</span><span class="sxs-lookup"><span data-stu-id="79d78-881">Yes</span></span>|  
|<span data-ttu-id="79d78-882">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-882">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-883">예</span><span class="sxs-lookup"><span data-stu-id="79d78-883">Yes</span></span>|  
|<span data-ttu-id="79d78-884">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-884">Remote computer</span></span>|<span data-ttu-id="79d78-885">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-885">No</span></span>|  
|<span data-ttu-id="79d78-886">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-886">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-887">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-887">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-888">다음 코드 예제에서는 공용 및 개인 트랜잭션 큐를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-888">The following code example creates public and private transactional queues.</span></span> <span data-ttu-id="79d78-889">선택한 큐에 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-889">It sends a message to selected queues.</span></span>  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-890"><paramref name="path" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-890">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-891">지정된 경로에 큐가 이미 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-891">A queue already exists at the specified path.</span></span>  
  
 <span data-ttu-id="79d78-892">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-892">-or-</span></span>  
  
 <span data-ttu-id="79d78-893">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-893">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-894">현재 메시지 큐의 새 <see cref="T:System.Messaging.Cursor" />를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-894">Creates a new <see cref="T:System.Messaging.Cursor" /> for the current message queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-895">현재 메시지 큐의 새 <see cref="T:System.Messaging.Cursor" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-895">A new <see cref="T:System.Messaging.Cursor" /> for the current message queue.</span></span> <span data-ttu-id="79d78-896">이 커서는 큐의 메시지를 읽을 때 큐의 특정 위치를 유지하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-896">This cursor is used to maintain a specific location in the queue when reading the queue's messages.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-897">메시지 큐에서 큐가 만들어진 날짜와 시간을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-897">Gets the time and date that the queue was created in Message Queuing.</span></span></summary>
        <value><span data-ttu-id="79d78-898">큐가 만들어진 날짜와 시간을 나타내는 <see cref="T:System.DateTime" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-898">A <see cref="T:System.DateTime" /> that represents the date and time at which the queue was created.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-899"><xref:System.Messaging.MessageQueue.CreateTime%2A> 메시지 큐 서버에 있는 큐를으로 참조는 <xref:System.Messaging.MessageQueue> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="79d78-899"><xref:System.Messaging.MessageQueue.CreateTime%2A> refers to the queue on the Message Queuing server, not the <xref:System.Messaging.MessageQueue> instance.</span></span>  
  
 <span data-ttu-id="79d78-900">큐가 있으면이 속성은 큐가 있는 서버의 현지 시간으로 조정 큐를 만든 시간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-900">If the queue exists, this property represents the time the queue was created, adjusted to the local time of the server on which the queue exists.</span></span>  
  
 <span data-ttu-id="79d78-901">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-901">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-902">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-902">Workgroup mode</span></span>|<span data-ttu-id="79d78-903">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-903">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-904">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-904">Local computer</span></span>|<span data-ttu-id="79d78-905">예</span><span class="sxs-lookup"><span data-stu-id="79d78-905">Yes</span></span>|  
|<span data-ttu-id="79d78-906">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-906">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-907">예</span><span class="sxs-lookup"><span data-stu-id="79d78-907">Yes</span></span>|  
|<span data-ttu-id="79d78-908">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-908">Remote computer</span></span>|<span data-ttu-id="79d78-909">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-909">No</span></span>|  
|<span data-ttu-id="79d78-910">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-910">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-911">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-911">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-912">다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.CreateTime%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-912">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.CreateTime%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-913">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-913">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-914">응용 프로그램이 큐에 메시지를 보낼 때 기본적으로 사용되는 메시지 속성 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-914">Gets or sets the message property values to be used by default when the application sends messages to the queue.</span></span></summary>
        <value><span data-ttu-id="79d78-915">응용 프로그램에서 <see cref="T:System.Messaging.DefaultPropertiesToSend" /> 인스턴스 이외의 개체를 큐에 보낼 때 사용된 기본 메시지 큐 메시지 속성 값이 포함된 <see cref="T:System.Messaging.Message" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-915">A <see cref="T:System.Messaging.DefaultPropertiesToSend" /> that contains the default Message Queuing message property values used when the application sends objects other than <see cref="T:System.Messaging.Message" /> instances to the queue.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-916">다른 형식의 모든 개체를 보낼 때 <xref:System.Messaging.Message> 큐에는 <xref:System.Messaging.MessageQueue> 메시지 큐 메시지 개체를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-916">When you send any object that is not of type <xref:System.Messaging.Message> to the queue, the <xref:System.Messaging.MessageQueue> inserts the object into a Message Queuing message.</span></span> <span data-ttu-id="79d78-917">그 당시는 <xref:System.Messaging.MessageQueue> 속성 값을 지정할 때에 메시지에 적용 되는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-917">At that time, the <xref:System.Messaging.MessageQueue> applies to the message the property values you specify in the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property.</span></span> <span data-ttu-id="79d78-918">반대로, 보내는 경우는 <xref:System.Messaging.Message> 큐에 이러한 속성이 이미 지정 되어 인스턴스 자체에 대 한 하므로 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 에 대해 무시 됩니다는 <xref:System.Messaging.Message>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-918">Conversely, if you send a <xref:System.Messaging.Message> to the queue, these properties are already specified for the instance itself, so <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> is ignored for the <xref:System.Messaging.Message>.</span></span>  
  
 <span data-ttu-id="79d78-919">통해 속성을 설정할 수 있지만 <xref:System.Messaging.MessageQueue> 개체는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 큐 자체 큐로 전송 된 메시지의 속성을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-919">Although you set the properties through the <xref:System.Messaging.MessageQueue> object, the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> refers to the properties of the messages that are sent to the queue, not the queue itself.</span></span>  
  
 <span data-ttu-id="79d78-920">속성에 대 한 기본 값은 다음 표에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-920">The default values for the properties are shown in the following table.</span></span>  
  
|<span data-ttu-id="79d78-921">속성</span><span class="sxs-lookup"><span data-stu-id="79d78-921">Property</span></span>|<span data-ttu-id="79d78-922">기본값</span><span class="sxs-lookup"><span data-stu-id="79d78-922">Default value</span></span>|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|<span data-ttu-id="79d78-923">영 (0)</span><span class="sxs-lookup"><span data-stu-id="79d78-923">Zero (0)</span></span>|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|<span data-ttu-id="79d78-924">바이트 길이가 0 인 배열</span><span class="sxs-lookup"><span data-stu-id="79d78-924">A zero-length array of bytes</span></span>|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|<span data-ttu-id="79d78-925">빈 문자열 ("")</span><span class="sxs-lookup"><span data-stu-id="79d78-925">Empty string ("")</span></span>|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 <span data-ttu-id="79d78-926">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-926">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-927">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-927">Workgroup mode</span></span>|<span data-ttu-id="79d78-928">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-928">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-929">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-929">Local computer</span></span>|<span data-ttu-id="79d78-930">예</span><span class="sxs-lookup"><span data-stu-id="79d78-930">Yes</span></span>|  
|<span data-ttu-id="79d78-931">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-931">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-932">예</span><span class="sxs-lookup"><span data-stu-id="79d78-932">Yes</span></span>|  
|<span data-ttu-id="79d78-933">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-933">Remote computer</span></span>|<span data-ttu-id="79d78-934">예</span><span class="sxs-lookup"><span data-stu-id="79d78-934">Yes</span></span>|  
|<span data-ttu-id="79d78-935">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-935">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-936">예</span><span class="sxs-lookup"><span data-stu-id="79d78-936">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-937">다음 코드 예제에서는 보낼 메시지에 대 한 기본 속성을 확인 하는 메시지의 우선 순위를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-937">The following code example uses the priority of a message to determine default properties to send for the message.</span></span>  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-938">큐에 대한 기본 속성을 설정할 수 없습니다(예: 속성 중 하나가 잘못된 경우).</span><span class="sxs-lookup"><span data-stu-id="79d78-938">The default properties could not be set for the queue, possibly because one of the properties is not valid.</span></span></exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="79d78-939">삭제할 큐의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-939">The location of the queue to be deleted.</span></span></param>
        <summary><span data-ttu-id="79d78-940">메시지 큐 서버에 있는 큐를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-940">Deletes a queue on a Message Queuing server.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-941">에 대 한 구문에서 `path` 매개 변수는 큐의 형식에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-941">The syntax for the `path` parameter depends on the type of queue.</span></span>  
  
|<span data-ttu-id="79d78-942">큐 유형</span><span class="sxs-lookup"><span data-stu-id="79d78-942">Queue type</span></span>|<span data-ttu-id="79d78-943">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-943">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="79d78-944">공개 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-944">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="79d78-945">개인 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-945">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
  
 <span data-ttu-id="79d78-946">자세한 구문에 대 한 참조는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-946">For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span>  
  
 <span data-ttu-id="79d78-947">사용할 수 있습니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 또는 <xref:System.Messaging.MessageQueue.Label%2A> 큐 경로 설명 하기 위해.</span><span class="sxs-lookup"><span data-stu-id="79d78-947">Alternatively, you can use the <xref:System.Messaging.MessageQueue.FormatName%2A> or <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path.</span></span>  
  
|<span data-ttu-id="79d78-948">참조</span><span class="sxs-lookup"><span data-stu-id="79d78-948">Reference</span></span>|<span data-ttu-id="79d78-949">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-949">Syntax</span></span>|  
|---------------|------------|  
|<span data-ttu-id="79d78-950">형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-950">Format name</span></span>|<span data-ttu-id="79d78-951">FormatName: [ *형식 이름을* ]</span><span class="sxs-lookup"><span data-stu-id="79d78-951">FormatName:[ *format name* ]</span></span>|  
|<span data-ttu-id="79d78-952">레이블</span><span class="sxs-lookup"><span data-stu-id="79d78-952">Label</span></span>|<span data-ttu-id="79d78-953">레이블: [ *레이블* ]</span><span class="sxs-lookup"><span data-stu-id="79d78-953">Label:[ *label* ]</span></span>|  
  
 <span data-ttu-id="79d78-954">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-954">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-955">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-955">Workgroup mode</span></span>|<span data-ttu-id="79d78-956">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-956">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-957">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-957">Local computer</span></span>|<span data-ttu-id="79d78-958">예</span><span class="sxs-lookup"><span data-stu-id="79d78-958">Yes</span></span>|  
|<span data-ttu-id="79d78-959">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-959">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-960">예</span><span class="sxs-lookup"><span data-stu-id="79d78-960">Yes</span></span>|  
|<span data-ttu-id="79d78-961">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-961">Remote computer</span></span>|<span data-ttu-id="79d78-962">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-962">No</span></span>|  
|<span data-ttu-id="79d78-963">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-963">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-964">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-964">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-965">다음 코드 예제에서는 있는 경우는 메시지 큐의 큐를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-965">The following code example deletes a Message Queuing queue, if it exists.</span></span>  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-966"><paramref name="path" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-966">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-967"><paramref name="path" /> 매개 변수에 대한 구문이 잘못된 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-967">The syntax for the <paramref name="path" /> parameter is not valid.</span></span>  
  
 <span data-ttu-id="79d78-968">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-968">-or-</span></span>  
  
 <span data-ttu-id="79d78-969">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-969">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-970">이 <see cref="T:System.Messaging.MessageQueue" />가 메시지 큐에서 메시지를 받기 위한 단독 액세스 권한을 갖는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-970">Gets or sets a value that indicates whether this <see cref="T:System.Messaging.MessageQueue" /> has exclusive access to receive messages from the Message Queuing queue.</span></span></summary>
        <value>
          <span data-ttu-id="79d78-971">이 <see cref="T:System.Messaging.MessageQueue" />가 큐에서 메시지를 받기 위한 단독 권한을 갖는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-971"><see langword="true" /> if this <see cref="T:System.Messaging.MessageQueue" /> has exclusive rights to receive messages from the queue; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="79d78-972">기본값은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-972">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-973"><xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 이 참조 하는 큐의 공유 모드를 지정 <xref:System.Messaging.MessageQueue>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-973"><xref:System.Messaging.MessageQueue.DenySharedReceive%2A> specifies the shared mode of the queue referenced by this <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="79d78-974">설정 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 를 `true` 만 나타내기 위해이 <xref:System.Messaging.MessageQueue> 지정 된 큐에서 메시지를 받거나 피킹에 대해 액세스 권한이 <xref:System.Messaging.MessageQueue.Path%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-974">Set <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> to `true` to indicate that only this <xref:System.Messaging.MessageQueue> should have access to peek or receive messages from the queue with the specified <xref:System.Messaging.MessageQueue.Path%2A>.</span></span> <span data-ttu-id="79d78-975">다른 경우 <xref:System.Messaging.MessageQueue> 또는 해당 인스턴스는 동일한 큐 리소스와 연결 된 다른 응용 프로그램 또는 응용 프로그램 보기 또는 메시지를 받을 수는 없지만 보낼 여전히 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-975">If another <xref:System.Messaging.MessageQueue> or another application is associated with the same queue resource, that instance or application will not be able to peek or receive messages, but it can still send them.</span></span>  
  
 <span data-ttu-id="79d78-976">경우 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 은 `false`, 큐를 보내기, 보기, 또는 메시지를 받기 위해 여러 응용 프로그램에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-976">If <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> is `false`, the queue is available to multiple applications for sending, peeking, or receiving messages.</span></span>  
  
 <span data-ttu-id="79d78-977">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-977">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-978">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-978">Workgroup mode</span></span>|<span data-ttu-id="79d78-979">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-979">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-980">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-980">Local computer</span></span>|<span data-ttu-id="79d78-981">예</span><span class="sxs-lookup"><span data-stu-id="79d78-981">Yes</span></span>|  
|<span data-ttu-id="79d78-982">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-982">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-983">예</span><span class="sxs-lookup"><span data-stu-id="79d78-983">Yes</span></span>|  
|<span data-ttu-id="79d78-984">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-984">Remote computer</span></span>|<span data-ttu-id="79d78-985">예</span><span class="sxs-lookup"><span data-stu-id="79d78-985">Yes</span></span>|  
|<span data-ttu-id="79d78-986">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-986">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-987">예</span><span class="sxs-lookup"><span data-stu-id="79d78-987">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-988">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-988">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="79d78-989">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-989"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="79d78-990"><see cref="T:System.Messaging.MessageQueue" />에서 사용하는 리소스(메모리 제외)를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-990">Disposes of the resources (other than memory) used by the <see cref="T:System.Messaging.MessageQueue" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-991"><xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 사용을 마치면 <xref:System.Messaging.MessageQueue>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-991">Call <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> when you are finished using the <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="79d78-992"><xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 메서드를 사용하면 <xref:System.Messaging.MessageQueue>를 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-992">The <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> method leaves the <xref:System.Messaging.MessageQueue> in an unusable state.</span></span> <span data-ttu-id="79d78-993">호출한 후 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>에 대 한 모든 참조를 해제 해야는 <xref:System.Messaging.MessageQueue> 차지 했던 메모리를 가비지 수집에 의해 회수 될 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-993">After calling <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, you must release all references to the <xref:System.Messaging.MessageQueue> so the memory it was occupying can be reclaimed by garbage collection.</span></span>  
  
 <span data-ttu-id="79d78-994">호출 해야 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 에 대 한 마지막 참조를 해제 하기 전에 <xref:System.Messaging.MessageQueue>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-994">You should call <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> before you release your last reference to the <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="79d78-995">그렇지 않으면 리소스는 <xref:System.Messaging.MessageQueue> 는 사용 하 여 해제 되지 것입니다 가비지 컬렉션 호출할 때까지 <xref:System.Messaging.MessageQueue> 개체의 소멸자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-995">Otherwise, the resources the <xref:System.Messaging.MessageQueue> is using will not be freed until garbage collection calls the <xref:System.Messaging.MessageQueue> object's destructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-996">연결 캐시가 응용 프로그램에 의해 유지 관리될지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-996">Gets or sets a value that indicates whether a cache of connections will be maintained by the application.</span></span></summary>
        <value>
          <span data-ttu-id="79d78-997">연결 캐시를 만들어 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-997"><see langword="true" /> to create and use a connection cache; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-998">연결 캐시는 큐로 쓰기 핸들 또는 읽기를 포함 하는 구조에 대 한 참조의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-998">A connection cache is a list of references to structures that contain read or write handles to queues.</span></span> <span data-ttu-id="79d78-999">때 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 은 `true`, <xref:System.Messaging.MessageQueue> 호출할 때마다 캐시에서 처리를 빌리 기 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, 또는 <xref:System.Messaging.MessageQueue.Receive%2A>, 열려 있는 새 핸들이 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-999">When <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> is `true`, the <xref:System.Messaging.MessageQueue> borrows handles from the cache each time you call <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, or <xref:System.Messaging.MessageQueue.Receive%2A>, rather than open new handles.</span></span> <span data-ttu-id="79d78-1000">이 경우 성능을 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1000">This can improve performance.</span></span> <span data-ttu-id="79d78-1001">분리도 연결 캐시를 사용 하 여는 <xref:System.Messaging.MessageQueue> 네트워크 토폴로지에 변경 된 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1001">Using a connection cache also insulates the <xref:System.Messaging.MessageQueue> from changes in the network topology.</span></span>  
  
 <span data-ttu-id="79d78-1002">연결 캐시 꽉 큐에 새 연결을 만드는 경우는 <xref:System.Messaging.MessageQueue> 새 연결을 가장 최근에 액세스 된 구조를 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1002">If you create a new connection to a queue when the connection cache is full, the <xref:System.Messaging.MessageQueue> overwrites the least recently accessed structure with the new connection.</span></span> <span data-ttu-id="79d78-1003">호출 하 여 완전히 캐시를 지울 수 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, 예를 들어 이전 읽기 및 쓰기 핸들을 사용할 더 이상 사용 하는 큐의 형식 이름이 변경 된 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-1003">You can clear the cache entirely by calling <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, for example, if the format names of the queues you are working with have changed so that the previous read and write handles are no longer valid.</span></span>  
  
 <span data-ttu-id="79d78-1004">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1004">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1005">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1005">Workgroup mode</span></span>|<span data-ttu-id="79d78-1006">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1006">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1007">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1007">Local computer</span></span>|<span data-ttu-id="79d78-1008">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1008">Yes</span></span>|  
|<span data-ttu-id="79d78-1009">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1009">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1010">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1010">Yes</span></span>|  
|<span data-ttu-id="79d78-1011">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1011">Remote computer</span></span>|<span data-ttu-id="79d78-1012">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1012">Yes</span></span>|  
|<span data-ttu-id="79d78-1013">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1013">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1014">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1014">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1015">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1015">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1016">큐에서 비개인(암호화되지 않은) 메시지만 허용하는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1016">Gets or sets a value that indicates whether the queue accepts only non-private (non-encrypted) messages.</span></span></summary>
        <value><span data-ttu-id="79d78-1017"><see cref="T:System.Messaging.EncryptionRequired" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1017">One of the <see cref="T:System.Messaging.EncryptionRequired" /> values.</span></span> <span data-ttu-id="79d78-1018">기본값은 <see langword="None" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1018">The default is <see langword="None" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1019">큐로 전송 된 메시지에 해당 암호화가 필요한을 지정 하면 메시지 본문에만 암호화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1019">When you specify that encryption is required for the messages sent to a queue, only the message bodies are encrypted.</span></span> <span data-ttu-id="79d78-1020">다른 멤버 (예를 들어는 <xref:System.Messaging.Message.Label%2A> 및 <xref:System.Messaging.Message.SenderId%2A> 속성) 암호화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1020">The other members (for example, the <xref:System.Messaging.Message.Label%2A> and <xref:System.Messaging.Message.SenderId%2A> properties) cannot be encrypted.</span></span>  
  
 <span data-ttu-id="79d78-1021">이 속성을 설정 하면 메시지 큐를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1021">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="79d78-1022">따라서 다른 모든 <xref:System.Messaging.MessageQueue> 인스턴스 변경의 영향을 받는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1022">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.</span></span>  
  
 <span data-ttu-id="79d78-1023">메시지를 암호화 하면 메시지 개인 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1023">Encrypting a message makes the message private.</span></span> <span data-ttu-id="79d78-1024">큐의 암호화 요구 사항 수를 지정할 수 있습니다 `None`, `Body`, 또는 `Optional` 설정 하 여는 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> 속성 적절 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1024">You can specify the queue's encryption requirement to be `None`, `Body`, or `Optional` by setting the <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> property appropriately.</span></span> <span data-ttu-id="79d78-1025"><xref:System.Messaging.Message.UseEncryption%2A> 메시지의 설정을 큐의 암호화 요구 사항 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1025">The <xref:System.Messaging.Message.UseEncryption%2A> setting of the message must correspond to the encryption requirement of the queue.</span></span> <span data-ttu-id="79d78-1026">메시지가 암호화 되지 않았지만 큐를 지정 하는 경우 `Body`, 메시지를 암호화 하지만 큐를 지정 하는 경우 또는 `None`, 메시지 큐에서 거부 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1026">If the message is not encrypted but the queue specifies `Body`, or if the message is encrypted but the queue specifies `None`, the message is rejected by the queue.</span></span> <span data-ttu-id="79d78-1027">이 이벤트에서 부정 승인 메시지를 요청 하는 송신 응용 프로그램 메시지 큐는 보내는 응용 프로그램 메시지의 거부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1027">If the sending application requests a negative acknowledgment message in this event, Message Queuing indicates the message's rejection to the sending application.</span></span> <span data-ttu-id="79d78-1028">경우는 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성은 `true`, 암호화 실패 한 메시지는 배달 못 한 편지 큐로 보내집니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1028">If the <xref:System.Messaging.Message.UseDeadLetterQueue%2A> property is `true`, a message that fails encryption is sent to the dead-letter queue.</span></span> <span data-ttu-id="79d78-1029">그렇지 않은 경우 메시지가 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1029">Otherwise, the message is lost.</span></span>  
  
 <span data-ttu-id="79d78-1030">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1030">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1031">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1031">Workgroup mode</span></span>|<span data-ttu-id="79d78-1032">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1032">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1033">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1033">Local computer</span></span>|<span data-ttu-id="79d78-1034">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1034">Yes</span></span>|  
|<span data-ttu-id="79d78-1035">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1035">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1036">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1036">Yes</span></span>|  
|<span data-ttu-id="79d78-1037">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1037">Remote computer</span></span>|<span data-ttu-id="79d78-1038">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1038">No</span></span>|  
|<span data-ttu-id="79d78-1039">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1039">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1040">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1040">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1041">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1041">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1042">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1042">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="79d78-1043"><see cref="T:System.IAsyncResult" />는 종료한 후 최종 결과를 검색해 올 비동기 피킹(peeking) 작업을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1043">The <see cref="T:System.IAsyncResult" /> that identifies the asynchronous peek operation to finish and from which to retrieve an end result.</span></span></param>
        <summary><span data-ttu-id="79d78-1044">지정된 비동기 피킹(peeking) 작업을 완료합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1044">Completes the specified asynchronous peek operation.</span></span></summary>
        <returns><span data-ttu-id="79d78-1045">완료된 비동기 작업과 관련된 <see cref="T:System.Messaging.Message" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1045">The <see cref="T:System.Messaging.Message" /> associated with the completed asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1046">경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 의해 시작 된 작업이 완료 되는 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1046">When the <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> completes the operation that was initiated by the <xref:System.Messaging.MessageQueue.BeginPeek%2A> call.</span></span> <span data-ttu-id="79d78-1047">이렇게 하려면 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 메시지를 관찰 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1047">To do so, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> peeks the message.</span></span>  
  
 <span data-ttu-id="79d78-1048"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 로 인해 시간 초과 지정할 수는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 표시 되기 전에 제한 시간이 발생 하는 경우 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1048"><xref:System.Messaging.MessageQueue.BeginPeek%2A> can specify a time-out, which causes the <xref:System.Messaging.MessageQueue.PeekCompleted> event to be raised if the time-out occurs before a message appears in the queue.</span></span> <span data-ttu-id="79d78-1049">초과 된 경우 후속 호출을 큐에 도착 하는 메시지 없이 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1049">When a time-out occurs without a message arriving in the queue, a subsequent call to <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> throws an exception.</span></span>  
  
 <span data-ttu-id="79d78-1050"><xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 시킨 메시지를 읽는 데 사용 되는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1050"><xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is used to read the message that caused the <xref:System.Messaging.MessageQueue.PeekCompleted> event to be raised.</span></span>  
  
 <span data-ttu-id="79d78-1051">다시 호출 수를 비동기적으로 메시지를 피킹할 계속 하려면 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 호출한 후 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1051">If you want to continue to asynchronously peek messages, you can again call <xref:System.Messaging.MessageQueue.BeginPeek%2A> after calling <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="79d78-1052">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1052">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1053">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1053">Workgroup mode</span></span>|<span data-ttu-id="79d78-1054">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1054">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1055">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1055">Local computer</span></span>|<span data-ttu-id="79d78-1056">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1056">Yes</span></span>|  
|<span data-ttu-id="79d78-1057">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1057">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1058">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1058">Yes</span></span>|  
|<span data-ttu-id="79d78-1059">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1059">Remote computer</span></span>|<span data-ttu-id="79d78-1060">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1060">No</span></span>|  
|<span data-ttu-id="79d78-1061">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1061">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1062">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1062">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1063">다음 코드 예제에서는 라는 이벤트 처리기를 만들고 `MyPeekCompleted`에 연결는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자 및 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 경로에 있는 큐에서 비동기 작업을 시작 하려면 ". \myQueue"입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1063">The following code example creates an event handler named `MyPeekCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue".</span></span> <span data-ttu-id="79d78-1064">경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하면이 예에서는 메시지를 관찰 합니다. 한 화면으로 해당 본문을 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1064">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the example peeks the message and writes its body to the screen.</span></span> <span data-ttu-id="79d78-1065">이 예에서는 다음 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 새 비동기 작업을 시작 하려면 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1065">The example then calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> again to initiate a new asynchronous peek operation.</span></span>  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-1066"><paramref name="asyncResult" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1066">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1067"><paramref name="asyncResult" /> 매개 변수의 구문이 잘못된 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-1067">The syntax of the <paramref name="asyncResult" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1068">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1068">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="79d78-1069"><see cref="T:System.IAsyncResult" />는 종료한 후 최종 결과를 검색해 올 비동기 수신 작업을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1069">The <see cref="T:System.IAsyncResult" /> that identifies the asynchronous receive operation to finish and from which to retrieve an end result.</span></span></param>
        <summary><span data-ttu-id="79d78-1070">지정된 비동기 수신 작업을 완료합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1070">Completes the specified asynchronous receive operation.</span></span></summary>
        <returns><span data-ttu-id="79d78-1071">완료된 비동기 작업과 관련된 <see cref="T:System.Messaging.Message" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1071">The <see cref="T:System.Messaging.Message" /> associated with the completed asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1072">경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 의해 시작 된 작업이 완료 되는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1072">When the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> completes the operation that was initiated by the <xref:System.Messaging.MessageQueue.BeginReceive%2A> call.</span></span> <span data-ttu-id="79d78-1073">이렇게 하려면 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1073">To do so, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> receives the message.</span></span>  
  
 <span data-ttu-id="79d78-1074"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 로 인해 시간 초과 지정할 수는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 표시 되기 전에 제한 시간이 발생 하는 경우 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1074"><xref:System.Messaging.MessageQueue.BeginReceive%2A> can specify a time-out, which causes the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event to be raised if the time-out occurs before a message appears in the queue.</span></span> <span data-ttu-id="79d78-1075">초과 된 경우 후속 호출을 큐에 도착 하는 메시지 없이 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1075">When a time-out occurs without a message arriving in the queue, a subsequent call to <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> throws an exception.</span></span>  
  
 <span data-ttu-id="79d78-1076"><xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 메시지를 발생 시킨 (큐에서 제거 됨) 읽는 데 사용 되는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1076"><xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is used to read (removing from the queue) the message that caused the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event to be raised.</span></span>  
  
 <span data-ttu-id="79d78-1077">다시 호출 수를 비동기적으로 메시지를 받을 계속 하려면 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 호출한 후 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1077">If you want to continue to asynchronously receive messages, you can again call <xref:System.Messaging.MessageQueue.BeginReceive%2A> after calling <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.</span></span>  
  
 <span data-ttu-id="79d78-1078">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1078">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1079">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1079">Workgroup mode</span></span>|<span data-ttu-id="79d78-1080">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1080">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1081">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1081">Local computer</span></span>|<span data-ttu-id="79d78-1082">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1082">Yes</span></span>|  
|<span data-ttu-id="79d78-1083">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1083">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1084">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1084">Yes</span></span>|  
|<span data-ttu-id="79d78-1085">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1085">Remote computer</span></span>|<span data-ttu-id="79d78-1086">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1086">No</span></span>|  
|<span data-ttu-id="79d78-1087">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1087">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1088">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1088">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1089">다음 코드 예제에서는 비동기 요청을 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1089">The following code example chains asynchronous requests.</span></span> <span data-ttu-id="79d78-1090">"MyQueue" 라는 로컬 컴퓨터에는 큐가 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1090">It assumes there is a queue on the local computer called "myQueue".</span></span> <span data-ttu-id="79d78-1091">`Main` 에서 처리 하는 비동기 작업을 시작 하는 함수는 `MyReceiveCompleted` 루틴입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1091">The `Main` function begins the asynchronous operation that is handled by the `MyReceiveCompleted` routine.</span></span> <span data-ttu-id="79d78-1092">`MyReceiveCompleted` 현재 메시지를 처리 하 고 새 시작 비동기 수신 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1092">`MyReceiveCompleted` processes the current message and begins a new asynchronous receive operation.</span></span>  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-1093"><paramref name="asyncResult" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1093">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1094"><paramref name="asyncResult" /> 매개 변수의 구문이 잘못된 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-1094">The syntax of the <paramref name="asyncResult" /> parameter is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1095">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1095">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="79d78-1096">찾을 큐의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1096">The location of the queue to find.</span></span></param>
        <summary><span data-ttu-id="79d78-1097">지정된 경로에 메시지 큐가 있는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1097">Determines whether a Message Queuing queue exists at the specified path.</span></span></summary>
        <returns>
          <span data-ttu-id="79d78-1098">지정된 경로에 큐가 있으면 <see langword="true" />를 반환하고, 그렇지 않으면 <see langword="false" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1098"><see langword="true" /> if a queue with the specified path exists; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1099"><xref:System.Messaging.MessageQueue.Exists%28System.String%29> 메서드 메시지 큐가 지정된 된 경로에 있는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1099">The <xref:System.Messaging.MessageQueue.Exists%28System.String%29> method determines whether a Message Queuing queue exists at a specified path.</span></span> <span data-ttu-id="79d78-1100">지정 된 형식 이름 가진 큐가 있는지 여부를 확인 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1100">No method exists to determine whether a queue with a specified format name exists.</span></span> <span data-ttu-id="79d78-1101">형식 이름 구문 및 다른 경로 구문 형식에 대 한 자세한 내용은 참조는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.)</span><span class="sxs-lookup"><span data-stu-id="79d78-1101">For more information about the format name syntax and other path syntax forms, see the <xref:System.Messaging.MessageQueue.Path%2A> property.)</span></span>  
  
 <span data-ttu-id="79d78-1102"><xref:System.Messaging.MessageQueue.Exists%28System.String%29> 부담이 큰 작업이입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1102"><xref:System.Messaging.MessageQueue.Exists%28System.String%29> is an expensive operation.</span></span> <span data-ttu-id="79d78-1103">응용 프로그램 내에서 필요한 경우에 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1103">Use it only when it is necessary within the application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79d78-1104"><xref:System.Messaging.MessageQueue.Exists%28System.String%29> 방법은 지원 하지 않습니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1104">The <xref:System.Messaging.MessageQueue.Exists%28System.String%29> method does not support the <xref:System.Messaging.MessageQueue.FormatName%2A> prefix.</span></span>  
  
 <span data-ttu-id="79d78-1105">에 대 한 구문은 `path` 매개 변수는 다음 표에 나와 있는 것 처럼 큐의 형식에 의존 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1105">The syntax for the `path` parameter depends on the type of queue, as shown in the following table.</span></span>  
  
|<span data-ttu-id="79d78-1106">큐 유형</span><span class="sxs-lookup"><span data-stu-id="79d78-1106">Queue type</span></span>|<span data-ttu-id="79d78-1107">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-1107">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="79d78-1108">공개 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1108">Public queue</span></span>|`MachineName`\\`QueueName`|  
  
 <span data-ttu-id="79d78-1109"><xref:System.Messaging.MessageQueue.Exists%28System.String%29> 원격 개인 큐의 존재 여부를 확인 하려면 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1109"><xref:System.Messaging.MessageQueue.Exists%28System.String%29> cannot be called to verify the existence of a remote private queue.</span></span>  
  
 <span data-ttu-id="79d78-1110">자세한 구문에 대 한 참조는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1110">For more syntax, see the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span>  
  
 <span data-ttu-id="79d78-1111">사용할 수 있습니다는 <xref:System.Messaging.MessageQueue.Label%2A> 큐 경로 설명 하기 위해.</span><span class="sxs-lookup"><span data-stu-id="79d78-1111">Alternatively, you can use the <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path.</span></span>  
  
|<span data-ttu-id="79d78-1112">참조</span><span class="sxs-lookup"><span data-stu-id="79d78-1112">Reference</span></span>|<span data-ttu-id="79d78-1113">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-1113">Syntax</span></span>|  
|---------------|------------|  
|<span data-ttu-id="79d78-1114">레이블</span><span class="sxs-lookup"><span data-stu-id="79d78-1114">Label</span></span>|<span data-ttu-id="79d78-1115">레이블: [ `label` ]</span><span class="sxs-lookup"><span data-stu-id="79d78-1115">Label:[ `label` ]</span></span>|  
  
 <span data-ttu-id="79d78-1116">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1116">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1117">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1117">Workgroup mode</span></span>|<span data-ttu-id="79d78-1118">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1118">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1119">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1119">Local computer</span></span>|<span data-ttu-id="79d78-1120">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1120">Yes</span></span>|  
|<span data-ttu-id="79d78-1121">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1121">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1122">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1122">No</span></span>|  
|<span data-ttu-id="79d78-1123">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1123">Remote computer</span></span>|<span data-ttu-id="79d78-1124">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1124">No</span></span>|  
|<span data-ttu-id="79d78-1125">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1125">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1126">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1126">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1127">다음 코드 예제에서는 메시지 큐가 있는 경우 한 다음 삭제 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1127">The following code example verifies whether a Message Queuing queue exists, and then deletes it.</span></span>  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1128"><paramref name="path" /> 구문이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1128">The <paramref name="path" /> syntax is not valid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1129">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1129">An error occurred when accessing a Message Queuing method.</span></span>  
  
 <span data-ttu-id="79d78-1130">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-1130">-or-</span></span>  
  
 <span data-ttu-id="79d78-1131"><see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> 메서드가 원격 개인 큐에서 호출되는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1131">The <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> method is being called on a remote private queue</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-1132">큐가 있는지 여부를 확인할 때 응용 프로그램이 형식 이름 구문을 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1132">The application used format name syntax when verifying queue existence.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1133">큐를 작성할 때 메시지 큐가 발생시킨 고유한 큐 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1133">Gets the unique queue name that Message Queuing generated at the time of the queue's creation.</span></span></summary>
        <value><span data-ttu-id="79d78-1134">네트워크에서 고유한 큐 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1134">The name for the queue, which is unique on the network.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1135"><xref:System.Messaging.MessageQueue.FormatName%2A> 속성 큐의 형식 이름을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1135">The <xref:System.Messaging.MessageQueue.FormatName%2A> property contains the format name of the queue.</span></span> <span data-ttu-id="79d78-1136">메시지 큐 큐를 열려는 및 액세스 하는 방법을 식별 하는 형식 이름을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1136">Message Queuing uses the format name to identify which queue to open and how to access it.</span></span> <span data-ttu-id="79d78-1137">대부분의 큐의 특성에서는 달리 형식 이름을 하지 않으므로 메시지 큐 응용 프로그램 큐 속성을 메시지 큐 관리 도구를 통해 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1137">Unlike most of a queue's characteristics, the format name is not a Message Queuing application queue property, so you cannot access it through the Message Queuing management tool.</span></span> <span data-ttu-id="79d78-1138">형식 이름은 큐에 대 한 고유한 이름을 단순히 메시지 큐는 큐 또는 응용 프로그램을 나중에 생성 하는 메시지를 만들 때 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1138">The format name is simply a unique name for the queue, which Message Queuing generates when it creates the queue or which the application generates later.</span></span>  
  
 <span data-ttu-id="79d78-1139">경로 이름 구문을 사용 하 여 경로 지정 하는 경우 (같은 `myComputer\myQueue`) (사용 하 여 Active Directory)는 주 도메인 컨트롤러를 읽거나 큐에 쓸 때 형식 이름 구문을 사용 하는 대신 변환는 <xref:System.Messaging.MessageQueue.Path%2A> 관련된 에<xref:System.Messaging.MessageQueue.FormatName%2A> 큐에 액세스 하기 전에.</span><span class="sxs-lookup"><span data-stu-id="79d78-1139">If you specify a path using the path name syntax (such as `myComputer\myQueue`) rather than using the format name syntax when you read or write to the queue, the primary domain controller (which uses Active Directory) translates the <xref:System.Messaging.MessageQueue.Path%2A> into the associated <xref:System.Messaging.MessageQueue.FormatName%2A> before accessing the queue.</span></span> <span data-ttu-id="79d78-1140">형식 이름 구문을;를 사용 해야 응용 프로그램을 오프 라인으로 작업 하는 경우 그렇지 않으면 주 도메인 컨트롤러의 경로 변환 하는 데 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1140">If your application is working offline, you must use the format name syntax; otherwise, the primary domain controller will not be available to perform the path translation.</span></span>  
  
 <span data-ttu-id="79d78-1141">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1141">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1142">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1142">Workgroup mode</span></span>|<span data-ttu-id="79d78-1143">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1143">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1144">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1144">Local computer</span></span>|<span data-ttu-id="79d78-1145">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1145">Yes</span></span>|  
|<span data-ttu-id="79d78-1146">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1146">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1147">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1147">Yes</span></span>|  
|<span data-ttu-id="79d78-1148">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1148">Remote computer</span></span>|<span data-ttu-id="79d78-1149">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1149">Yes</span></span>|  
|<span data-ttu-id="79d78-1150">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1150">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1151">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1151">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1152">다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.FormatName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1152">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.FormatName%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1153"><see cref="P:System.Messaging.MessageQueue.Path" />이 설정되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1153">The <see cref="P:System.Messaging.MessageQueue.Path" /> is not set.</span></span>  
  
 <span data-ttu-id="79d78-1154">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-1154">-or-</span></span>  
  
 <span data-ttu-id="79d78-1155">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1155">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1156">큐에서 읽거나 쓴 메시지 본문으로 개체를 serialize하거나 그 메시지 본문에서 개체를 deserialize하는 데 사용되는 포맷터를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1156">Gets or sets the formatter used to serialize an object into or deserialize an object from the body of a message read from or written to the queue.</span></span></summary>
        <value><span data-ttu-id="79d78-1157">메시지 본문에서 쓰거나 읽는 스트림을 만드는 <see cref="T:System.Messaging.IMessageFormatter" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1157">The <see cref="T:System.Messaging.IMessageFormatter" /> that produces a stream to be written to or read from the message body.</span></span> <span data-ttu-id="79d78-1158">기본값은 <see cref="T:System.Messaging.XmlMessageFormatter" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1158">The default is <see cref="T:System.Messaging.XmlMessageFormatter" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1159"><xref:System.Messaging.MessageQueue.Formatter%2A> 속성 응용 프로그램을 읽거나 큐에 쓸 때 메시지를 변환 하는 포맷터 개체의 인스턴스를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1159">The <xref:System.Messaging.MessageQueue.Formatter%2A> property contains an instance of a formatter object, which transforms messages when your application reads or writes to the queue.</span></span>  
  
 <span data-ttu-id="79d78-1160">응용 프로그램 큐로 메시지를 보내면, 포맷터는 개체를 스트림으로 serialize 하 고 메시지 본문에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1160">When the application sends message to the queue, the formatter serializes the object into a stream and inserts it into the message body.</span></span> <span data-ttu-id="79d78-1161">큐에서 읽을 때 포맷터는 메시지 데이터에는 <xref:System.Messaging.Message.Body%2A> 속성은 <xref:System.Messaging.Message>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1161">When reading from a queue, the formatter deserializes the message data into the <xref:System.Messaging.Message.Body%2A> property of a <xref:System.Messaging.Message>.</span></span>  
  
 <span data-ttu-id="79d78-1162"><xref:System.Messaging.XmlMessageFormatter> 는 느슨하게 결합 되어 있으므로이 형식을 사용 하는 경우에 발신자와 수신자 입력 동일한 개체를 설정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1162">The <xref:System.Messaging.XmlMessageFormatter> is loosely coupled, so it is not necessary to have the same object type on the sender and receiver when using this format.</span></span> <span data-ttu-id="79d78-1163"><xref:System.Messaging.ActiveXMessageFormatter> 및 <xref:System.Messaging.BinaryMessageFormatter> 이진 표현으로 데이터를 직렬화 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1163">The <xref:System.Messaging.ActiveXMessageFormatter> and <xref:System.Messaging.BinaryMessageFormatter> serialize the data into binary representation.</span></span> <span data-ttu-id="79d78-1164"><xref:System.Messaging.ActiveXMessageFormatter> COM 구성 요소를 받거나 보낼 때 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1164">The <xref:System.Messaging.ActiveXMessageFormatter> is used when sending or receiving COM components.</span></span>  
  
 <span data-ttu-id="79d78-1165"><xref:System.Messaging.BinaryMessageFormatter> 및 <xref:System.Messaging.ActiveXMessageFormatter> 보다 더 빠르게 처리는 <xref:System.Messaging.XmlMessageFormatter>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1165"><xref:System.Messaging.BinaryMessageFormatter> and <xref:System.Messaging.ActiveXMessageFormatter> provide faster throughput than the <xref:System.Messaging.XmlMessageFormatter>.</span></span> <span data-ttu-id="79d78-1166"><xref:System.Messaging.ActiveXMessageFormatter> Visual Basic 6.0 메시지 큐 응용 프로그램과 상호 운용성을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1166">The <xref:System.Messaging.ActiveXMessageFormatter> allows interoperability with Visual Basic 6.0 Message Queuing applications.</span></span>  
  
 <span data-ttu-id="79d78-1167">응용 프로그램 큐에 메시지를 보낼 때의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 기본 메시지 속성을 사용 하는 해당 메시지에만 적용 됩니다 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1167">When your application sends messages to the queue, the <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> applies only to those messages that use the default message properties, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.</span></span> <span data-ttu-id="79d78-1168">보내는 경우는 <xref:System.Messaging.Message> 큐에 메시지 큐 사용 하 여에 정의 된 포맷터는 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 대신 본문을 serialize 할 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1168">If you send a <xref:System.Messaging.Message> to the queue, Message Queuing uses the formatter defined in the <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property to serialize the body instead.</span></span>  
  
 <span data-ttu-id="79d78-1169"><xref:System.Messaging.MessageQueue> 클래스는 항상 사용는 <xref:System.Messaging.Message> 받거나 큐에서 메시지를 피킹할 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1169">The <xref:System.Messaging.MessageQueue> class will always use a <xref:System.Messaging.Message> to receive or peek a message from the queue.</span></span> <span data-ttu-id="79d78-1170">메시지를 사용 하 여 deserialize 되는 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1170">The message is deserialized using the <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="79d78-1171">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1171">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1172">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1172">Workgroup mode</span></span>|<span data-ttu-id="79d78-1173">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1173">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1174">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1174">Local computer</span></span>|<span data-ttu-id="79d78-1175">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1175">Yes</span></span>|  
|<span data-ttu-id="79d78-1176">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1176">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1177">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1177">Yes</span></span>|  
|<span data-ttu-id="79d78-1178">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1178">Remote computer</span></span>|<span data-ttu-id="79d78-1179">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1179">No</span></span>|  
|<span data-ttu-id="79d78-1180">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1180">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1181">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1181">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1182">다음 코드 예제에서는 서식을 사용 하 여 메시지 본문을 보여 줍니다. <xref:System.Messaging.BinaryMessageFormatter>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1182">The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.</span></span>  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 <span data-ttu-id="79d78-1183">다음 코드 예제에서는 서식을 사용 하 여 메시지 본문을 보여 줍니다. <xref:System.Messaging.XmlMessageFormatter>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1183">The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-1184">큐에 있는 메시지를 모두 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1184">Returns all the messages that are in the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-1185">큐에 있는 모든 메시지를 메시지 큐에서 표시되는 것과 동일한 순서로 나타내는 <see cref="T:System.Messaging.Message" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1185">An array of type <see cref="T:System.Messaging.Message" /> that represents all the messages in the queue, in the same order as they appear in the Message Queuing queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1186"><xref:System.Messaging.MessageQueue.GetAllMessages%2A> 이러한 메시지를 큐에 메시지, 동적 아님 링크의 정적 스냅숏을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1186"><xref:System.Messaging.MessageQueue.GetAllMessages%2A> returns a static snapshot of the messages in the queue, not dynamic links to those messages.</span></span> <span data-ttu-id="79d78-1187">따라서 큐에서 메시지를 수정 하는 배열을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1187">Therefore, you cannot use the array to modify the messages in the queue.</span></span> <span data-ttu-id="79d78-1188">(예: 메시지를 삭제 하는 기능) 큐와 상호 작용을 실시간으로 동적 호출의 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 메서드를 큐에 있는 메시지의 동적 목록을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1188">If you want real-time, dynamic interaction with the queue (such as the ability to delete messages), call the <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> method, which returns a dynamic list of the messages in the queue.</span></span>  
  
 <span data-ttu-id="79d78-1189">때문에 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 메서드가 호출 된 시간에 큐에서 메시지의 복사본을 반환, 큐에 도착 하는 새로운 메시지 또는 메시지 큐에서 제거 된 배열을 반영 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1189">Because <xref:System.Messaging.MessageQueue.GetAllMessages%2A> returns a copy of the messages in the queue at the time the method was called, the array does not reflect new messages that arrive in the queue or messages that are removed from the queue.</span></span>  
  
 <span data-ttu-id="79d78-1190"><xref:System.Messaging.MessageQueue.GetAllMessages%2A> 에 의해 필터링 되지 속성만 검색는 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1190"><xref:System.Messaging.MessageQueue.GetAllMessages%2A> retrieves only those properties not filtered out by the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> property.</span></span>  
  
 <span data-ttu-id="79d78-1191">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1191">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1192">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1192">Workgroup mode</span></span>|<span data-ttu-id="79d78-1193">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1193">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1194">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1194">Local computer</span></span>|<span data-ttu-id="79d78-1195">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1195">Yes</span></span>|  
|<span data-ttu-id="79d78-1196">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1196">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1197">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1197">Yes</span></span>|  
|<span data-ttu-id="79d78-1198">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1198">Remote computer</span></span>|<span data-ttu-id="79d78-1199">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1199">No</span></span>|  
|<span data-ttu-id="79d78-1200">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1200">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1201">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1201">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1202">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1202">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.</span></span>  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1203">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1203">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-1204">큐의 메시지를 열거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1204">Enumerates the messages in a queue.</span></span> <span data-ttu-id="79d78-1205"><see cref="M:System.Messaging.MessageQueue.GetEnumerator" />은 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1205"><see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> is deprecated.</span></span> <span data-ttu-id="79d78-1206"><see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />를 대신 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1206"><see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> should be used instead.</span></span></summary>
        <returns><span data-ttu-id="79d78-1207">큐에 있는 메시지에 대한 동적 연결을 제공하는 <see cref="T:System.Collections.IEnumerator" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1207">A <see cref="T:System.Collections.IEnumerator" /> that provides a dynamic connection to the messages in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1208">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1208">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1209">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1209">Workgroup mode</span></span>|<span data-ttu-id="79d78-1210">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1210">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1211">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1211">Local computer</span></span>|<span data-ttu-id="79d78-1212">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1212">Yes</span></span>|  
|<span data-ttu-id="79d78-1213">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1213">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1214">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1214">Yes</span></span>|  
|<span data-ttu-id="79d78-1215">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1215">Remote computer</span></span>|<span data-ttu-id="79d78-1216">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1216">No</span></span>|  
|<span data-ttu-id="79d78-1217">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1217">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1218">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1218">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1219">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.GetEnumerator%2A>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1219">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.</span></span>  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName"><span data-ttu-id="79d78-1220">큐가 포함된 컴퓨터의 이름이며 앞에 백슬래시 두 개(\\\\)가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1220">The name of the computer that contains the queue, without the two preceding backslashes (\\\\).</span></span></param>
        <summary><span data-ttu-id="79d78-1221">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐가 있는 컴퓨터의 식별자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1221">Gets the identifier of the computer on which the queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> is located.</span></span></summary>
        <returns><span data-ttu-id="79d78-1222">큐가 있는 컴퓨터의 고유 식별자를 나타내는 <see cref="T:System.Guid" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1222">A <see cref="T:System.Guid" /> that represents a unique identifier for the computer on which the queue is located.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1223">컴퓨터의 식별자를 사용 하 여 다른 규칙 으로부터 다음 두 가지 목적: 보안 인증서를 설정 하 고 컴퓨터 저널을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1223">You can use a computer's identifier for two purposes, among others: to read the computer journal and to set security certificates.</span></span> <span data-ttu-id="79d78-1224">그러나 호출할 수 없습니다 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> 작업 하는 경우 오프 라인 도메인 컨트롤러에서 응용 프로그램 디렉터리 서비스에 액세스 해야 하기 때문에 원격 컴퓨터에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1224">However, you cannot call <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> for a remote computer when you are working offline because the application must have access to the directory service on the domain controller.</span></span>  
  
 <span data-ttu-id="79d78-1225">컴퓨터 식별자 (또는 컴퓨터 식별자)는 한 <xref:System.Guid> 메시지 큐 엔터프라이즈에 컴퓨터가 추가 될 때 만들어지는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1225">The computer identifier (or machine identifier) is a <xref:System.Guid> that Message Queuing creates when a computer is added to the enterprise.</span></span> <span data-ttu-id="79d78-1226">메시지 큐 컴퓨터 식별자와 결합 된 `Machine` 및 `Journal` 키워드 구문을 컴퓨터 저널 형식 이름을 만드는 데 `Machine=<computeridentifier>;Journal`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1226">Message Queuing combines the computer identifier with the `Machine` and `Journal` keywords to create the machine journal's format name, which has the syntax `Machine=<computeridentifier>;Journal`.</span></span> <span data-ttu-id="79d78-1227">라고도 하는 저널 큐로는의 복사본을 저장 하는 시스템 큐 응용 프로그램에서 생성 된 경우 컴퓨터 저널 경우 메시지는 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> 속성은 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1227">The machine journal, which is also known as the journal queue, is a system queue that stores copies of application-generated messages when the <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> property is `true`.</span></span>  
  
 <span data-ttu-id="79d78-1228">이 구문은 업무 일지 큐에 대 한 형식 이름을 생성 하는 경우에 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1228">This syntax for the journal is only valid when constructing the format name for the queue.</span></span> <span data-ttu-id="79d78-1229">경로 이름 구문은 `MachineName` \\ `Journal$`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1229">The path name syntax is `MachineName`\\`Journal$`.</span></span>  
  
 <span data-ttu-id="79d78-1230">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1230">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1231">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1231">Workgroup mode</span></span>|<span data-ttu-id="79d78-1232">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1232">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1233">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1233">Local computer</span></span>|<span data-ttu-id="79d78-1234">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1234">No</span></span>|  
|<span data-ttu-id="79d78-1235">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1235">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1236">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1236">No</span></span>|  
|<span data-ttu-id="79d78-1237">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1237">Remote computer</span></span>|<span data-ttu-id="79d78-1238">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1238">No</span></span>|  
|<span data-ttu-id="79d78-1239">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1239">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1240">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1240">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1241">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1241">The following code example calls <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.</span></span>  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1242">오프라인으로 작업하는 경우와 같이 디렉터리 서비스를 사용할 수 없기 때문에 컴퓨터 식별자를 검색할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1242">The computer identifier could not be retrieved, possibly because the directory service is not available; for example, if you are working offline.</span></span>  
  
 <span data-ttu-id="79d78-1243">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-1243">-or-</span></span>  
  
 <span data-ttu-id="79d78-1244">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1244">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-1245">큐에 있는 모든 메시지에 대해 열거자 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1245">Creates an enumerator object for all the messages in the queue.</span></span> <span data-ttu-id="79d78-1246"><see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />은 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1246"><see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> is deprecated.</span></span> <span data-ttu-id="79d78-1247"><see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />를 대신 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1247"><see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> should be used instead.</span></span></summary>
        <returns><span data-ttu-id="79d78-1248">큐에 있는 메시지를 보유하는 <see cref="T:System.Messaging.MessageEnumerator" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1248">The <see cref="T:System.Messaging.MessageEnumerator" /> holding the messages that are contained in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1249"><xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 큐에 있는 모든 메시지의 동적 목록을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1249"><xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> creates a dynamic list of all the messages in a queue.</span></span> <span data-ttu-id="79d78-1250">제거할 수 있습니다는 큐에서 열거자의 현재 위치에서 메시지를 호출 하 여 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 에 대 한는 <xref:System.Messaging.MessageEnumerator> 하 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1250">You can remove from the queue the message at the enumerator's current position by calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> for the <xref:System.Messaging.MessageEnumerator> that <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> returns.</span></span>  
  
 <span data-ttu-id="79d78-1251">커서가 연결 된 큐에 메시지의 동적 목록과 있으므로 열거형 메시지는 현재 커서 위치 초과 하는 경우 큐의 메시지에 대 한 수정 내용을 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1251">Because the cursor is associated with the dynamic list of messages in the queue, the enumeration reflects any modification you make to the messages in the queue, if the message is beyond the current cursor position.</span></span> <span data-ttu-id="79d78-1252">예를 들어 열거자 커서의 현재 위치를 넘어 배치 된 우선 순위가 낮은 메시지 있지만 해당 위치 앞에 삽입 하는 우선 순위가 높은 메시지가 아니라에 자동으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1252">For example, the enumerator can automatically access a lower-priority message placed beyond the cursor's current position, but not a higher-priority message inserted before that position.</span></span> <span data-ttu-id="79d78-1253">그러나 다시 설정할 수 있습니다는 열거 되므로 커서 다시 목록 맨 앞으로 호출 하 여 이동 <xref:System.Messaging.MessageEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageEnumerator>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1253">However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageEnumerator.Reset%2A> for the <xref:System.Messaging.MessageEnumerator>.</span></span>  
  
 <span data-ttu-id="79d78-1254">열거형에 있는 메시지의 순서는 우선 순위가 낮은 것 하기 전에 우선 순위가 높은 메시지가 표시 되므로 큐에서의 순서를 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1254">The order of the messages in the enumeration reflects their order in the queue, so higher-priority messages will appear before lower-priority ones.</span></span>  
  
 <span data-ttu-id="79d78-1255">동적 연결 하지 않고 큐의 메시지를 정적 스냅숏을 호출 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1255">If you want a static snapshot of the messages in the queue rather than a dynamic connection to them, call <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.</span></span> <span data-ttu-id="79d78-1256">이 메서드는 배열을 반환 <xref:System.Messaging.Message> 개체를 메서드가 호출 된 시간에 메시지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1256">This method returns an array of <xref:System.Messaging.Message> objects, which represent the messages at the time the method was called.</span></span>  
  
 <span data-ttu-id="79d78-1257">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1257">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1258">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1258">Workgroup mode</span></span>|<span data-ttu-id="79d78-1259">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1259">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1260">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1260">Local computer</span></span>|<span data-ttu-id="79d78-1261">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1261">Yes</span></span>|  
|<span data-ttu-id="79d78-1262">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1262">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1263">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1263">Yes</span></span>|  
|<span data-ttu-id="79d78-1264">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1264">Remote computer</span></span>|<span data-ttu-id="79d78-1265">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1265">Yes</span></span>|  
|<span data-ttu-id="79d78-1266">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1266">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1267">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1267">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1268">다음 코드 예제에서는 큐에 있는 메시지의 동적 목록을 가져오고 있는 모든 메시지가 계산 된 <xref:System.Messaging.Message.Priority%2A> 속성이로 설정 <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1268">The following code example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-1269">큐에 있는 모든 메시지에 대해 열거자 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1269">Creates an enumerator object for all the messages in the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-1270">큐에 있는 메시지를 보유하는 <see cref="T:System.Messaging.MessageEnumerator" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1270">The <see cref="T:System.Messaging.MessageEnumerator" /> holding the messages that are contained in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1271"><xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 큐에 있는 모든 메시지의 동적 목록을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1271"><xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> creates a dynamic list of all the messages in a queue.</span></span> <span data-ttu-id="79d78-1272">제거할 수 있습니다는 큐에서 열거자의 현재 위치에서 메시지를 호출 하 여 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 에 대 한는 <xref:System.Messaging.MessageEnumerator> 하 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1272">You can remove from the queue the message at the enumerator's current position by calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> for the <xref:System.Messaging.MessageEnumerator> that <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> returns.</span></span>  
  
 <span data-ttu-id="79d78-1273">커서가 연결 된 큐에 메시지의 동적 목록과 있으므로 열거형 메시지는 현재 커서 위치 초과 하는 경우 큐의 메시지에 대 한 수정 내용을 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1273">Because the cursor is associated with the dynamic list of messages in the queue, the enumeration reflects any modification you make to the messages in the queue, if the message is beyond the current cursor position.</span></span> <span data-ttu-id="79d78-1274">예를 들어 열거자 커서의 현재 위치를 넘어 배치 된 우선 순위가 낮은 메시지 있지만 해당 위치 앞에 삽입 하는 우선 순위가 높은 메시지가 아니라에 자동으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1274">For example, the enumerator can automatically access a lower-priority message placed beyond the cursor's current position, but not a higher-priority message inserted before that position.</span></span> <span data-ttu-id="79d78-1275">그러나 다시 설정할 수 있습니다는 열거 되므로 커서 다시 목록 맨 앞으로 호출 하 여 이동 <xref:System.Messaging.MessageEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageEnumerator>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1275">However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageEnumerator.Reset%2A> for the <xref:System.Messaging.MessageEnumerator>.</span></span>  
  
 <span data-ttu-id="79d78-1276">열거형에 있는 메시지의 순서는 우선 순위가 낮은 것 하기 전에 우선 순위가 높은 메시지가 표시 되므로 큐에서의 순서를 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1276">The order of the messages in the enumeration reflects their order in the queue, so higher-priority messages will appear before lower-priority ones.</span></span>  
  
 <span data-ttu-id="79d78-1277">동적 연결 하지 않고 큐의 메시지를 정적 스냅숏을 호출 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1277">If you want a static snapshot of the messages in the queue rather than a dynamic connection to them, call <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.</span></span> <span data-ttu-id="79d78-1278">이 메서드는 배열을 반환 <xref:System.Messaging.Message> 개체를 메서드가 호출 된 시간에 메시지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1278">This method returns an array of <xref:System.Messaging.Message> objects, which represent the messages at the time the method was called.</span></span>  
  
 <span data-ttu-id="79d78-1279">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1279">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1280">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1280">Workgroup mode</span></span>|<span data-ttu-id="79d78-1281">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1281">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1282">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1282">Local computer</span></span>|<span data-ttu-id="79d78-1283">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1283">Yes</span></span>|  
|<span data-ttu-id="79d78-1284">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1284">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1285">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1285">Yes</span></span>|  
|<span data-ttu-id="79d78-1286">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1286">Remote computer</span></span>|<span data-ttu-id="79d78-1287">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1287">Yes</span></span>|  
|<span data-ttu-id="79d78-1288">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1288">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1289">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1289">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-1290">네트워크에 있는 공개 큐의 동적 목록에 대한 열거자 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1290">Creates an enumerator object for a dynamic listing of the public queues on the network.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-1291">앞으로만 이동 가능한 커서 의미 체계 기능을 제공하여 네트워크에 있는 모든 공개 큐를 열거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1291">Provides forward-only cursor semantics to enumerate through all public queues on the network.</span></span></summary>
        <returns><span data-ttu-id="79d78-1292">네트워크에 있는 모든 공개 메시지 큐의 동적 목록을 제공하는 <see cref="T:System.Messaging.MessageQueueEnumerator" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1292">A <see cref="T:System.Messaging.MessageQueueEnumerator" /> that provides a dynamic listing of all the public message queues on the network.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1293">이 오버 로드의 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 네트워크에 있는 모든 공개 큐의 열거형을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1293">This overload of <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> returns an enumeration of all the public queues that are on the network.</span></span>  
  
 <span data-ttu-id="79d78-1294">커서가 동적 목록과 관련 되어 있으므로 열거형에는 삭제 또는 커서의 현재 위치를 벗어나서 추가 큐에 대 한 큐 목록에 대 한 수정 내용을 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1294">Because the cursor is associated with a dynamic listing, the enumeration reflects any modification you make to a queue list for queues deleted or added beyond the cursor's current position.</span></span> <span data-ttu-id="79d78-1295">추가 또는 삭제는 커서의 현재 위치 보다 앞에 있는 큐의 반영 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1295">Additions or deletion of queues located before the cursor's current position are not reflected.</span></span> <span data-ttu-id="79d78-1296">예를 들어 열거자의 커서 위치 뒤에 추가 하는 큐 이지만 아닌 해당 위치 앞에 삽입에 자동으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1296">For example, the enumerator can automatically access a queue appended beyond the cursor position but not one inserted before that position.</span></span> <span data-ttu-id="79d78-1297">그러나 다시 설정할 수 있습니다는 열거 되므로 커서 다시 목록 맨 앞으로 호출 하 여 이동 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageQueueEnumerator>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1297">However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> for the <xref:System.Messaging.MessageQueueEnumerator>.</span></span>  
  
 <span data-ttu-id="79d78-1298">큐는 네트워크에 정의 된 순서가 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1298">There is no defined ordering of queues in a network.</span></span> <span data-ttu-id="79d78-1299">열거자 정렬 되지 않은, 예를 들어 컴퓨터, 레이블, 공개 또는 개인 상태 또는 다른 액세스할 수 있는 기준으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1299">An enumerator does not order them, for example, by computer, label, public or private status, or any other accessible criteria.</span></span>  
  
 <span data-ttu-id="79d78-1300">동적 연결 하지 않고 네트워크에 있는 큐의 정적 스냅샷 호출 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 또는 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1300">If you want a static snapshot of the queues on the network rather than a dynamic connection to them, call <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> or <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>.</span></span> <span data-ttu-id="79d78-1301">이러한 두 메서드는 각각의 배열을 반환 <xref:System.Messaging.MessageQueue> 개체를 메서드가 호출 된 시간에 큐를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1301">Each of these two methods returns an array of <xref:System.Messaging.MessageQueue> objects, which represent the queues at the time the method was called.</span></span>  
  
 <span data-ttu-id="79d78-1302">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1302">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1303">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1303">Workgroup mode</span></span>|<span data-ttu-id="79d78-1304">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1304">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1305">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1305">Local computer</span></span>|<span data-ttu-id="79d78-1306">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1306">No</span></span>|  
|<span data-ttu-id="79d78-1307">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1307">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1308">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1308">No</span></span>|  
|<span data-ttu-id="79d78-1309">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1309">Remote computer</span></span>|<span data-ttu-id="79d78-1310">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1310">No</span></span>|  
|<span data-ttu-id="79d78-1311">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1311">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1312">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1312">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1313">다음 코드 예제에서는 네트워크의 모든 메시지 큐에서 반복 되며 각 큐에 대 한 경로 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1313">The following code example iterates through all the message queues in the network, and examines the path for each queue.</span></span> <span data-ttu-id="79d78-1314">마지막으로, 네트워크에 공개 큐의 수를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1314">Finally, it displays the number of public queues on the network.</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria"><span data-ttu-id="79d78-1315">사용 가능한 메시지 큐를 필터링하는 데 사용되는 기준이 포함된 <see cref="T:System.Messaging.MessageQueueCriteria" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1315">A <see cref="T:System.Messaging.MessageQueueCriteria" /> that contains the criteria used to filter the available message queues.</span></span></param>
        <summary><span data-ttu-id="79d78-1316">앞으로만 이동 가능한 커서 의미 체계 기능 제공하여 네트워크에 있는 공개 큐 중 지정된 기준을 만족하는 큐를 모두 열거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1316">Provides forward-only cursor semantics to enumerate through all public queues on the network that meet the specified criteria.</span></span></summary>
        <returns><span data-ttu-id="79d78-1317">네트워크에 있는 공개 메시지 큐 중 <paramref name="criteria" /> 매개 변수가 지정한 제한 사항을 만족시키는 큐에 대한 동적 목록을 제공하는 <see cref="T:System.Messaging.MessageQueueEnumerator" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1317">A <see cref="T:System.Messaging.MessageQueueEnumerator" /> that provides a dynamic listing of the public message queues on the network that satisfy the restrictions specified by the <paramref name="criteria" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1318">이 오버 로드의 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 응용 프로그램 조건에 정의 된 조건을 충족 하는 네트워크에 있는 모든 공개 큐의 목록을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1318">This overload of <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> returns a listing of all the public queues on the network that satisfy criteria defined in the application criteria.</span></span> <span data-ttu-id="79d78-1319">를 포함 하는 조건을 작성 또는 수정 시간, 컴퓨터 이름, 레이블, 범주 또는 이러한 조건의 조합을 예를 들어 큐를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1319">You can specify the criteria to include, for example, queue creation or modification time, computer name, label, category, or any combination of these.</span></span>  
  
 <span data-ttu-id="79d78-1320">커서가 동적 목록과 관련 되어 있으므로 열거형에는 커서의 현재 위치 뒤에 발생 하는 큐에 대 한 수정 내용을 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1320">Because the cursor is associated with a dynamic listing, the enumeration reflects any modification you make to a queue that occurs beyond the cursor's current position.</span></span> <span data-ttu-id="79d78-1321">커서의 현재 위치 보다 앞에 있는 큐에 변경 내용이 반영 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1321">Changes to queues located before the cursor's current position are not reflected.</span></span> <span data-ttu-id="79d78-1322">예를 들어 열거자의 커서 위치 뒤에 추가 하는 큐 이지만 아닌 해당 위치 앞에 삽입에 자동으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1322">For example, the enumerator can automatically access a queue appended beyond the cursor position but not one inserted before that position.</span></span> <span data-ttu-id="79d78-1323">그러나 다시 설정할 수 있습니다는 열거 되므로 커서 다시 목록 맨 앞으로 호출 하 여 이동 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageQueueEnumerator>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1323">However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> for the <xref:System.Messaging.MessageQueueEnumerator>.</span></span>  
  
 <span data-ttu-id="79d78-1324">큐는 네트워크에 정의 된 순서가 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1324">There is no defined ordering of queues in a network.</span></span> <span data-ttu-id="79d78-1325">열거자 정렬 되지 않은, 예를 들어 컴퓨터, 레이블, 공개 또는 개인 상태 또는 다른 액세스할 수 있는 기준으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1325">An enumerator does not order them, for example, by computer, label, public or private status, or any other accessible criteria.</span></span>  
  
 <span data-ttu-id="79d78-1326">동적 연결 하지 않고 네트워크에 있는 큐의 정적 스냅샷 하려는 경우에 대 한 조건을 지정 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 호출 또는 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1326">If you want a static snapshot of the queues on the network rather than a dynamic connection to them, specify criteria for <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> or call <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>.</span></span> <span data-ttu-id="79d78-1327">이러한 두 메서드는 각각의 배열을 반환 <xref:System.Messaging.MessageQueue> 개체를 메서드가 호출 된 시간에 큐를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1327">Each of these two methods returns an array of <xref:System.Messaging.MessageQueue> objects, which represent the queues at the time the method was called.</span></span> <span data-ttu-id="79d78-1328">호출 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, 또는 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 호출할 때와 같은 결과 얻을 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 의 필터링 기준을 사용 하 여 <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, 및 <xref:System.Messaging.MessageQueue.MachineName%2A>각각.</span><span class="sxs-lookup"><span data-stu-id="79d78-1328">Calling <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, or <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> provides the same results as calling <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> with the filtering criteria of <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, and <xref:System.Messaging.MessageQueue.MachineName%2A>, respectively.</span></span>  
  
 <span data-ttu-id="79d78-1329">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1329">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1330">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1330">Workgroup mode</span></span>|<span data-ttu-id="79d78-1331">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1331">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1332">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1332">Local computer</span></span>|<span data-ttu-id="79d78-1333">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1333">No</span></span>|  
|<span data-ttu-id="79d78-1334">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1334">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1335">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1335">No</span></span>|  
|<span data-ttu-id="79d78-1336">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1336">Remote computer</span></span>|<span data-ttu-id="79d78-1337">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1337">No</span></span>|  
|<span data-ttu-id="79d78-1338">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1338">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1339">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1339">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1340">다음 코드 예제에서는 메시지 큐를 통해 반복 하 고 "MyComputer" 컴퓨터에 같고 마지막 날에 만들어진 각 큐의 경로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1340">The following code example iterates through message queues and displays the path of each queue that was created in the last day and that exists on the computer "MyComputer".</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName"><span data-ttu-id="79d78-1341">개인 큐를 검색할 컴퓨터입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1341">The computer from which to retrieve the private queues.</span></span></param>
        <summary><span data-ttu-id="79d78-1342">지정된 컴퓨터에 있는 개인 큐를 모두 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1342">Retrieves all the private queues on the specified computer.</span></span></summary>
        <returns><span data-ttu-id="79d78-1343">검색된 개인 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1343">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved private queues.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1344"><xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 지정된 된 컴퓨터에 있는 큐의 정적 스냅숏을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1344"><xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> retrieves a static snapshot of the queues on a specified computer.</span></span>  
  
 <span data-ttu-id="79d78-1345">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1345">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1346">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1346">Workgroup mode</span></span>|<span data-ttu-id="79d78-1347">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1347">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1348">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1348">Local computer</span></span>|<span data-ttu-id="79d78-1349">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1349">Yes</span></span>|  
|<span data-ttu-id="79d78-1350">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1350">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1351">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1351">Yes</span></span>|  
|<span data-ttu-id="79d78-1352">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1352">Remote computer</span></span>|<span data-ttu-id="79d78-1353">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1353">Yes</span></span>|  
|<span data-ttu-id="79d78-1354">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1354">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1355">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1355">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1356">다음 코드 예제에서는 큐 목록을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1356">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1357"><paramref name="machineName" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1357">The <paramref name="machineName" /> parameter is <see langword="null" /> or an empty string ("").</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1358">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1358">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-1359">네트워크에 있는 공개 큐를 모두 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1359">Retrieves all the public queues on the network.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-1360">네트워크에 있는 공개 큐를 모두 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1360">Retrieves all the public queues on the network.</span></span></summary>
        <returns><span data-ttu-id="79d78-1361">검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1361">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1362">네트워크에 있는 모든 공개 큐의 전체 목록을 원하는 경우이 오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1362">Use this overload if you want a complete list of all the public queues on the network.</span></span> <span data-ttu-id="79d78-1363">와 같은 특정 조건을 기준으로 목록을 제한 하려는 경우 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, 또는이 메서드의 다른 오버 로드를 사용 하는 마지막으로 수정한 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1363">If you want to restrict the list by certain criteria, such as <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, or last modified time use another overload of this method.</span></span> <span data-ttu-id="79d78-1364">(사용할 수 있습니다 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, 또는 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)</span><span class="sxs-lookup"><span data-stu-id="79d78-1364">(Alternatively, you can use <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, or <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)</span></span>  
  
 <span data-ttu-id="79d78-1365"><xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 큐의 정적 스냅숏을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1365"><xref:System.Messaging.MessageQueue.GetPublicQueues%2A> retrieves a static snapshot of the queues.</span></span> <span data-ttu-id="79d78-1366">큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1366">To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.</span></span>  
  
 <span data-ttu-id="79d78-1367">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1367">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1368">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1368">Workgroup mode</span></span>|<span data-ttu-id="79d78-1369">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1369">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1370">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1370">Local computer</span></span>|<span data-ttu-id="79d78-1371">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1371">No</span></span>|  
|<span data-ttu-id="79d78-1372">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1372">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1373">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1373">No</span></span>|  
|<span data-ttu-id="79d78-1374">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1374">Remote computer</span></span>|<span data-ttu-id="79d78-1375">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1375">No</span></span>|  
|<span data-ttu-id="79d78-1376">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1376">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1377">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1377">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1378">다음 코드 예제에서는 큐 목록을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1378">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1379">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1379">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria"><span data-ttu-id="79d78-1380">큐를 필터링하는 데 사용되는 기준이 포함된 <see cref="T:System.Messaging.MessageQueueCriteria" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1380">A <see cref="T:System.Messaging.MessageQueueCriteria" /> that contains the criteria used to filter the queues.</span></span></param>
        <summary><span data-ttu-id="79d78-1381">네트워크에 있는 공개 큐 중 지정된 기준을 만족시키는 큐를 모두 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1381">Retrieves all the public queues on the network that meet the specified criteria.</span></span></summary>
        <returns><span data-ttu-id="79d78-1382">검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1382">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1383">레이블, 범주 또는 컴퓨터 이름으로 네트워크에 있는 모든 공개 큐를 필터링 하려는 경우는 <xref:System.Messaging.MessageQueue> 해당 기능을 제공 하는 특정 메서드를 포함 하는 클래스 (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, 및 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>각각).</span><span class="sxs-lookup"><span data-stu-id="79d78-1383">If you want to filter all the public queues on the network by label, category, or computer name, the <xref:System.Messaging.MessageQueue> class contains specific methods that provide that functionality (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, and <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, respectively).</span></span> <span data-ttu-id="79d78-1384">이 오버 로드를 사용 하 여 (예를 들어 경우 레이블과 범주 둘 다 지정 하려는) 이러한 조건 중 하나 이상 만족 하는 네트워크에서 공개 큐를 모든 목록을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1384">Use this overload to get a list of all the public queues on the network that meet more than one of these criteria (for example, if you want to specify both a label and a category).</span></span> <span data-ttu-id="79d78-1385">필터링 할 수도 있습니다 메시지 조건으로 이외의 <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, 및 <xref:System.Messaging.MessageQueue.MachineName%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1385">You can also filter by message criteria other than <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, and <xref:System.Messaging.MessageQueue.MachineName%2A>.</span></span> <span data-ttu-id="79d78-1386">예를 들어 큐의 마지막 수정 시간을 기준으로이 오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1386">For example, you use this overload to filter by a queue's last-modified time.</span></span> <span data-ttu-id="79d78-1387">새 인스턴스를 만들기만 <xref:System.Messaging.MessageQueueCriteria> 클래스 인스턴스의 적절 한 속성을 설정 하 고 해당 인스턴스를 전달는 `criteria` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1387">Simply create a new instance of the <xref:System.Messaging.MessageQueueCriteria> class, set the appropriate properties in the instance, and pass the instance as the `criteria` parameter.</span></span>  
  
 <span data-ttu-id="79d78-1388"><xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 큐의 정적 스냅숏을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1388"><xref:System.Messaging.MessageQueue.GetPublicQueues%2A> retrieves a static snapshot of the queues.</span></span> <span data-ttu-id="79d78-1389">큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1389">To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.</span></span>  
  
 <span data-ttu-id="79d78-1390">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1390">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1391">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1391">Workgroup mode</span></span>|<span data-ttu-id="79d78-1392">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1392">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1393">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1393">Local computer</span></span>|<span data-ttu-id="79d78-1394">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1394">No</span></span>|  
|<span data-ttu-id="79d78-1395">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1395">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1396">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1396">No</span></span>|  
|<span data-ttu-id="79d78-1397">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1397">Remote computer</span></span>|<span data-ttu-id="79d78-1398">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1398">No</span></span>|  
|<span data-ttu-id="79d78-1399">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1399">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1400">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1400">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1401">다음 코드 예제에서는 큐 목록을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1401">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1402">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1402">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category"><span data-ttu-id="79d78-1403">검색할 큐 집합을 그룹화하는 <see cref="T:System.Guid" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1403">A <see cref="T:System.Guid" /> that groups the set of queues to be retrieved.</span></span></param>
        <summary><span data-ttu-id="79d78-1404">네트워크에 있는 공개 큐 중 지정된 범주에 속한 큐를 모두 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1404">Retrieves all the public queues on the network that belong to the specified category.</span></span></summary>
        <returns><span data-ttu-id="79d78-1405">검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1405">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1406">공개 큐를 범주별으로 필터링 하려면이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1406">Use this method to filter the public queues by category.</span></span> <span data-ttu-id="79d78-1407"><xref:System.Messaging.MessageQueue.Category%2A> 속성은 메시지 큐 유형의 ID 속성 (즉, 읽기/쓰기) 특정 큐에 대 한 액세스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1407">The <xref:System.Messaging.MessageQueue.Category%2A> property provides access to the Message Queuing type ID property (which is read/write) of a particular queue.</span></span> <span data-ttu-id="79d78-1408">사용할 수 있지만 <xref:System.Guid.NewGuid%2A> 는 모든 고유 범주 값을 만들려면 <xref:System.Guid> 값 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1408">Although you can use <xref:System.Guid.NewGuid%2A> to create a category value that is unique across all <xref:System.Guid> values, it is not necessary.</span></span> <span data-ttu-id="79d78-1409">범주 값이 다른 범주에서가 아니라 다른 모든 구별 되도록 <xref:System.Guid> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1409">The category value needs to be distinct only from other categories, not from all other <xref:System.Guid> values.</span></span> <span data-ttu-id="79d78-1410">할당할 수는 예를 들어 {00000000-0000-0000-0000-000000000001} 로 <xref:System.Messaging.MessageQueue.Category%2A> 한 집합 큐에 대 한 및 {00000000-0000-0000-0000-000000000002} 로 <xref:System.Messaging.MessageQueue.Category%2A> 다른 집합에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1410">For example, you can assign {00000000-0000-0000-0000-000000000001} as the <xref:System.Messaging.MessageQueue.Category%2A> for one set of queues and {00000000-0000-0000-0000-000000000002} as the <xref:System.Messaging.MessageQueue.Category%2A> for another set.</span></span>  
  
 <span data-ttu-id="79d78-1411"><xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 큐의 정적 스냅숏을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1411"><xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> retrieves a static snapshot of the queues.</span></span> <span data-ttu-id="79d78-1412">큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1412">To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.</span></span> <span data-ttu-id="79d78-1413">일부로 범주를 지정할 수는 <xref:System.Messaging.MessageQueueCriteria> 메서드에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1413">You can specify the category as part of the <xref:System.Messaging.MessageQueueCriteria> you pass into the method.</span></span>  
  
 <span data-ttu-id="79d78-1414">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1414">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1415">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1415">Workgroup mode</span></span>|<span data-ttu-id="79d78-1416">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1416">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1417">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1417">Local computer</span></span>|<span data-ttu-id="79d78-1418">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1418">No</span></span>|  
|<span data-ttu-id="79d78-1419">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1419">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1420">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1420">No</span></span>|  
|<span data-ttu-id="79d78-1421">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1421">Remote computer</span></span>|<span data-ttu-id="79d78-1422">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1422">No</span></span>|  
|<span data-ttu-id="79d78-1423">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1423">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1424">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1424">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1425">다음 코드 예제에서는 큐 목록을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1425">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1426">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1426">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label"><span data-ttu-id="79d78-1427">검색할 큐 집합을 그룹화하는 레이블입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1427">A label that groups the set of queues to be retrieved.</span></span></param>
        <summary><span data-ttu-id="79d78-1428">네트워크에 있는 공개 큐 중 지정된 레이블이 있는 큐를 모두 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1428">Retrieves all the public queues on the network that carry the specified label.</span></span></summary>
        <returns><span data-ttu-id="79d78-1429">검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1429">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1430">이 메서드를 사용 하 여 레이블에 의해 공개 큐를 필터링 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1430">Use this method to filter the public queues by label.</span></span>  
  
 <span data-ttu-id="79d78-1431"><xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 큐의 정적 스냅숏을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1431"><xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> retrieves a static snapshot of the queues.</span></span> <span data-ttu-id="79d78-1432">큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1432">To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.</span></span> <span data-ttu-id="79d78-1433">일부분으로 레이블을 지정할 수는 <xref:System.Messaging.MessageQueueCriteria> 메서드에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1433">You can specify the label as part of the <xref:System.Messaging.MessageQueueCriteria> you pass into the method.</span></span>  
  
 <span data-ttu-id="79d78-1434">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1434">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1435">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1435">Workgroup mode</span></span>|<span data-ttu-id="79d78-1436">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1436">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1437">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1437">Local computer</span></span>|<span data-ttu-id="79d78-1438">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1438">No</span></span>|  
|<span data-ttu-id="79d78-1439">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1439">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1440">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1440">No</span></span>|  
|<span data-ttu-id="79d78-1441">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1441">Remote computer</span></span>|<span data-ttu-id="79d78-1442">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1442">No</span></span>|  
|<span data-ttu-id="79d78-1443">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1443">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1444">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1444">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1445">다음 코드 예제에서는 큐 목록을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1445">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1446">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1446">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-1447"><paramref name="label" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1447">The <paramref name="label" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName"><span data-ttu-id="79d78-1448">검색할 공개 큐 집합을 포함하는 컴퓨터의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1448">The name of the computer that contains the set of public queues to be retrieved.</span></span></param>
        <summary><span data-ttu-id="79d78-1449">지정된 컴퓨터에 있는 공개 큐를 모두 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1449">Retrieves all the public queues that reside on the specified computer.</span></span></summary>
        <returns><span data-ttu-id="79d78-1450">컴퓨터에 있는 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1450">An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the public queues on the computer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1451">컴퓨터별 공개 큐를 필터링 하려면이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1451">Use this method to filter the public queues by computer.</span></span>  
  
 <span data-ttu-id="79d78-1452"><xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 큐의 정적 스냅숏을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1452"><xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> retrieves a static snapshot of the queues.</span></span> <span data-ttu-id="79d78-1453">큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1453">To interact with a dynamic list of the queues, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.</span></span> <span data-ttu-id="79d78-1454">일부분으로 컴퓨터 이름을 지정할 수 있습니다는 <xref:System.Messaging.MessageQueueCriteria> 메서드에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1454">You can specify the computer name as part of the <xref:System.Messaging.MessageQueueCriteria> you pass into the method.</span></span>  
  
 <span data-ttu-id="79d78-1455">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1455">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1456">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1456">Workgroup mode</span></span>|<span data-ttu-id="79d78-1457">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1457">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1458">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1458">Local computer</span></span>|<span data-ttu-id="79d78-1459">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1459">No</span></span>|  
|<span data-ttu-id="79d78-1460">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1460">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1461">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1461">No</span></span>|  
|<span data-ttu-id="79d78-1462">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1462">Remote computer</span></span>|<span data-ttu-id="79d78-1463">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1463">No</span></span>|  
|<span data-ttu-id="79d78-1464">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1464">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1465">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1465">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1466">다음 코드 예제에서는 큐 목록을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1466">The following code example retrieves lists of queues.</span></span>  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1467"><paramref name="machineName" /> 매개 변수의 구문이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1467">The <paramref name="machineName" /> parameter has incorrect syntax.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1468">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1468">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-1469">이 호출 시 MSMQ가 현재 사용자(스레드 ID)와 연결된 보안 컨텍스트를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1469">Retrieves the security context that MSMQ associates with the current user (thread identity) at the time of this call.</span></span></summary>
        <returns><span data-ttu-id="79d78-1470">보안 컨텍스트를 포함하는 <see cref="T:System.Messaging.SecurityContext" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1470">A <see cref="T:System.Messaging.SecurityContext" /> object that contains the security context.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1471">큐의 고유한 메시지 큐 식별자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1471">Gets the unique Message Queuing identifier of the queue.</span></span></summary>
        <value><span data-ttu-id="79d78-1472">메시지 큐 응용 프로그램에 의해 생성된 메시지 식별자를 나타내는 <see cref="P:System.Messaging.MessageQueue.Id" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1472">A <see cref="P:System.Messaging.MessageQueue.Id" /> that represents the message identifier generated by the Message Queuing application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1473">메시지 큐는 <xref:System.Messaging.MessageQueue.Id%2A> 속성 큐를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1473">Message Queuing sets the <xref:System.Messaging.MessageQueue.Id%2A> property when it creates the queue.</span></span> <span data-ttu-id="79d78-1474">이 속성은 공개 큐에 사용할 수만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1474">This property is only available for public queues.</span></span>  
  
 <span data-ttu-id="79d78-1475">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1475">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1476">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1476">Workgroup mode</span></span>|<span data-ttu-id="79d78-1477">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1477">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1478">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1478">Local computer</span></span>|<span data-ttu-id="79d78-1479">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1479">Yes</span></span>|  
|<span data-ttu-id="79d78-1480">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1480">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1481">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1481">Yes</span></span>|  
|<span data-ttu-id="79d78-1482">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1482">Remote computer</span></span>|<span data-ttu-id="79d78-1483">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1483">No</span></span>|  
|<span data-ttu-id="79d78-1484">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1484">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1485">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1485">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1486">다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.Id%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1486">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.Id%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1487">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1487">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1488">큐에 크기 제한이 없도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1488">Specifies that no size restriction exists for a queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1489">이 멤버는 설정할 때 사용할 자주 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 또는 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1489">This member is frequently used when setting <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> or <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1490">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.InfiniteQueueSize> 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1490">The following code example demonstrates the use of the <xref:System.Messaging.MessageQueue.InfiniteQueueSize> member.</span></span>  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1491">메시지를 피킹하거나 받는 메서드에 시간 제한이 없도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1491">Specifies that no time-out exists for methods that peek or receive messages.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1492"><xref:System.Messaging.MessageQueue> 두 가지 유형의 메시지 검색 지원: 동기 및 비동기입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1492"><xref:System.Messaging.MessageQueue> supports two types of message retrieval: synchronous and asynchronous.</span></span> <span data-ttu-id="79d78-1493">동기 메서드 <xref:System.Messaging.MessageQueue.Peek%2A> 및 <xref:System.Messaging.MessageQueue.Receive%2A>, 프로세스 스레드가 지정된 된 시간 간격을 큐에 도착할 때까지 새 메시지에 대해 기다려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1493">The synchronous methods, <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.Receive%2A>, cause the process thread to wait a specified time interval for a new message to arrive in the queue.</span></span> <span data-ttu-id="79d78-1494">지정 된 시간 간격이 <xref:System.Messaging.MessageQueue.InfiniteTimeout>, 새 메시지가 있을 때까지 프로세스 스레드가 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1494">If the specified time interval is <xref:System.Messaging.MessageQueue.InfiniteTimeout>, the process thread remains blocked until a new message is available.</span></span> <span data-ttu-id="79d78-1495">반면에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 및 <xref:System.Messaging.MessageQueue.BeginReceive%2A> (비동기 메서드), 주 응용 프로그램 작업을 큐에 메시지가 도착할 때까지 별도의 스레드에서 계속 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1495">On the other hand, <xref:System.Messaging.MessageQueue.BeginPeek%2A> and <xref:System.Messaging.MessageQueue.BeginReceive%2A> (the asynchronous methods), allow the main application tasks to continue in a separate thread until a message arrives in the queue.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1496">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1496">The following code example demonstrates the use of the <xref:System.Messaging.MessageQueue.InfiniteTimeout> member.</span></span>  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1497">큐 설명을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1497">Gets or sets the queue description.</span></span></summary>
        <value><span data-ttu-id="79d78-1498">메시지 큐의 레이블입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1498">The label for the message queue.</span></span> <span data-ttu-id="79d78-1499">기본값은 빈 문자열("")입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1499">The default is an empty string ("").</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1500">메시지 큐 레이블의 최대 길이 124 자입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1500">The maximum length of a message queue label is 124 characters.</span></span>  
  
 <span data-ttu-id="79d78-1501"><xref:System.Messaging.MessageQueue.Label%2A> 속성이 모든 큐에서 고유할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1501">The <xref:System.Messaging.MessageQueue.Label%2A> property does not need to be unique across all queues.</span></span> <span data-ttu-id="79d78-1502">그러나 동일한 여러 큐를 공유 하는 경우 <xref:System.Messaging.MessageQueue.Label%2A>를 사용할 수 없습니다는 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> 모든 사람이 메시지를 브로드캐스팅하려면 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-1502">However, if multiple queues share the same <xref:System.Messaging.MessageQueue.Label%2A>, you cannot use the <xref:System.Messaging.MessageQueue.Send%28System.Object%29> method to broadcast a message to all of them.</span></span> <span data-ttu-id="79d78-1503">에 대 한 레이블 구문을 사용 하는 경우는 <xref:System.Messaging.MessageQueue.Path%2A> 메시지를 보낼 때 속성에는 예외가 발생 하는 경우는 <xref:System.Messaging.MessageQueue.Label%2A> 고유 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1503">If you use the label syntax for the <xref:System.Messaging.MessageQueue.Path%2A> property when you send the message, an exception will be thrown if the <xref:System.Messaging.MessageQueue.Label%2A> is not unique.</span></span>  
  
 <span data-ttu-id="79d78-1504">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1504">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1505">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1505">Workgroup mode</span></span>|<span data-ttu-id="79d78-1506">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1506">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1507">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1507">Local computer</span></span>|<span data-ttu-id="79d78-1508">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1508">Yes</span></span>|  
|<span data-ttu-id="79d78-1509">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1509">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1510">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1510">Yes</span></span>|  
|<span data-ttu-id="79d78-1511">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1511">Remote computer</span></span>|<span data-ttu-id="79d78-1512">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1512">No</span></span>|  
|<span data-ttu-id="79d78-1513">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1513">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1514">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1514">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1515">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.Label%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1515">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.Label%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1516">레이블이 잘못된 값으로 설정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1516">The label was set to an invalid value.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1517">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1517">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1518">큐의 속성이 마지막으로 수정된 시간을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1518">Gets the last time the properties of a queue were modified.</span></span></summary>
        <value><span data-ttu-id="79d78-1519">큐의 속성이 마지막으로 수정된 시간을 알려주는 <see cref="T:System.DateTime" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1519">A <see cref="T:System.DateTime" /> that indicates when the queue properties were last modified.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1520">큐를 만들 때 마지막으로 수정한 시간 포함 및 모든 <xref:System.Messaging.MessageQueue> 와 같은 메시지 큐 큐를 수정 하는 속성 <xref:System.Messaging.MessageQueue.BasePriority%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1520">The last modification time includes when the queue was created and any <xref:System.Messaging.MessageQueue> property that modifies the Message Queuing queue, such as <xref:System.Messaging.MessageQueue.BasePriority%2A>.</span></span> <span data-ttu-id="79d78-1521">값은 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성은 로컬 컴퓨터의 시스템 시간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1521">The value of the <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property represents the system time of the local computer.</span></span>  
  
 <span data-ttu-id="79d78-1522">호출 해야 <xref:System.Messaging.MessageQueue.Refresh%2A> 을 가져오기 전에 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성; 연결 된이 수정 시간, <xref:System.Messaging.MessageQueue> 최신 상태가 아닐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1522">You must call <xref:System.Messaging.MessageQueue.Refresh%2A> before getting the <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property; otherwise, the modification time associated with this <xref:System.Messaging.MessageQueue> might not be current.</span></span>  
  
 <span data-ttu-id="79d78-1523">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1523">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1524">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1524">Workgroup mode</span></span>|<span data-ttu-id="79d78-1525">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1525">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1526">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1526">Local computer</span></span>|<span data-ttu-id="79d78-1527">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1527">Yes</span></span>|  
|<span data-ttu-id="79d78-1528">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1528">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1529">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1529">Yes</span></span>|  
|<span data-ttu-id="79d78-1530">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1530">Remote computer</span></span>|<span data-ttu-id="79d78-1531">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1531">No</span></span>|  
|<span data-ttu-id="79d78-1532">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1532">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1533">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1533">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1534">다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1534">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1535">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1535">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1536">메시지 큐가 있는 컴퓨터의 이름을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1536">Gets or sets the name of the computer where the Message Queuing queue is located.</span></span></summary>
        <value><span data-ttu-id="79d78-1537">큐가 있는 컴퓨터의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1537">The name of the computer where the queue is located.</span></span> <span data-ttu-id="79d78-1538">메시지 큐의 기본값은 "."이며, 이는 로컬 컴퓨터를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1538">The Message Queuing default is ".", the local computer.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1539"><xref:System.Messaging.MessageQueue.MachineName%2A> 큐의 약식 이름 구문이의 필수 구성 요소인 <xref:System.Messaging.MessageQueue.Path%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1539">The <xref:System.Messaging.MessageQueue.MachineName%2A> is an integral component of the friendly name syntax of the queue <xref:System.Messaging.MessageQueue.Path%2A>.</span></span> <span data-ttu-id="79d78-1540">다음 표에서 해당 이름을 사용 하 여 큐 경로 식별 하려는 경우 형식이 지정 된 큐에 대 한 사용 해야 하는 구문을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1540">The following table shows the syntax you should use for a queue of a specified type when you want to identify the queue path using its friendly name.</span></span>  
  
|<span data-ttu-id="79d78-1541">큐 유형</span><span class="sxs-lookup"><span data-stu-id="79d78-1541">Queue type</span></span>|<span data-ttu-id="79d78-1542">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-1542">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="79d78-1543">공개 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1543">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="79d78-1544">개인 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1544">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
|<span data-ttu-id="79d78-1545">저널 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1545">Journal queue</span></span>|`MachineName`\\`QueueName`\\`Journal$`|  
|<span data-ttu-id="79d78-1546">컴퓨터 저널 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1546">Machine journal queue</span></span>|`MachineName`\\`Journal$`|  
|<span data-ttu-id="79d78-1547">컴퓨터 배달 못 한 편지 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1547">Machine dead-letter queue</span></span>|`MachineName`\\`Deadletter$`|  
|<span data-ttu-id="79d78-1548">컴퓨터 트랜잭션 배달 못 한 편지 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1548">Machine transactional dead-letter queue</span></span>|`MachineName`\\`XactDeadletter$`|  
  
 <span data-ttu-id="79d78-1549">사용 하 여 "."를 지정할 때 로컬 컴퓨터에 대 한는 <xref:System.Messaging.MessageQueue.MachineName%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1549">Use "." for the local computer when specifying the <xref:System.Messaging.MessageQueue.MachineName%2A>.</span></span> <span data-ttu-id="79d78-1550">컴퓨터 이름에만이 속성에 대 한 예를 들어 인식 `Server0`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1550">Only the computer name is recognized for this property, for example, `Server0`.</span></span> <span data-ttu-id="79d78-1551"><xref:System.Messaging.MessageQueue.MachineName%2A> 속성 IP 주소 형식은 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1551">The <xref:System.Messaging.MessageQueue.MachineName%2A> property does not support the IP address format.</span></span>  
  
 <span data-ttu-id="79d78-1552">정의 하는 경우는 <xref:System.Messaging.MessageQueue.Path%2A> 의 측면에서 <xref:System.Messaging.MessageQueue.MachineName%2A>, 도메인 컨트롤러에 대 한 경로 변환 필요 하기 때문에 오프 라인으로 작업 하는 경우 응용 프로그램 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1552">If you define the <xref:System.Messaging.MessageQueue.Path%2A> in terms of the <xref:System.Messaging.MessageQueue.MachineName%2A>, the application throws an exception when working offline because the domain controller is required for path translation.</span></span> <span data-ttu-id="79d78-1553">따라서 사용 해야 합니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 에 대 한는 <xref:System.Messaging.MessageQueue.Path%2A> 구문 오프 라인으로 작업 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-1553">Therefore, you must use the <xref:System.Messaging.MessageQueue.FormatName%2A> for the <xref:System.Messaging.MessageQueue.Path%2A> syntax when working offline.</span></span>  
  
 <span data-ttu-id="79d78-1554"><xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성은 서로 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1554">The <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, and <xref:System.Messaging.MessageQueue.QueueName%2A> properties are related.</span></span> <span data-ttu-id="79d78-1555">변경 된 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성 원인을 <xref:System.Messaging.MessageQueue.Path%2A> 변경할 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1555">Changing the <xref:System.Messaging.MessageQueue.MachineName%2A> property causes the <xref:System.Messaging.MessageQueue.Path%2A> property to change.</span></span> <span data-ttu-id="79d78-1556">새 구성 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1556">It is built from the new <xref:System.Messaging.MessageQueue.MachineName%2A> and the <xref:System.Messaging.MessageQueue.QueueName%2A>.</span></span> <span data-ttu-id="79d78-1557">변경 된 <xref:System.Messaging.MessageQueue.Path%2A> (예: 형식 이름 구문 사용) 다시 설정는 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 새 큐를 참조 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1557">Changing the <xref:System.Messaging.MessageQueue.Path%2A> (for example, to use the format name syntax) resets the <xref:System.Messaging.MessageQueue.MachineName%2A> and <xref:System.Messaging.MessageQueue.QueueName%2A> properties to refer to the new queue.</span></span> <span data-ttu-id="79d78-1558">경우는 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성이 비어는 <xref:System.Messaging.MessageQueue.Path%2A> 지정한 컴퓨터의 업무 일지 큐에 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1558">If the <xref:System.Messaging.MessageQueue.QueueName%2A> property is empty, the <xref:System.Messaging.MessageQueue.Path%2A> is set to the Journal queue of the computer you specify.</span></span>  
  
 <span data-ttu-id="79d78-1559">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1559">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1560">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1560">Workgroup mode</span></span>|<span data-ttu-id="79d78-1561">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1561">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1562">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1562">Local computer</span></span>|<span data-ttu-id="79d78-1563">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1563">Yes</span></span>|  
|<span data-ttu-id="79d78-1564">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1564">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1565">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1565">Yes</span></span>|  
|<span data-ttu-id="79d78-1566">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1566">Remote computer</span></span>|<span data-ttu-id="79d78-1567">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1567">Yes</span></span>|  
|<span data-ttu-id="79d78-1568">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1568">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1569">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1569">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1570">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1570">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.MachineName%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1571">컴퓨터 이름이 잘못되었습니다(예: 구문이 잘못된 경우).</span><span class="sxs-lookup"><span data-stu-id="79d78-1571">The name of the computer is not valid, possibly because the syntax is incorrect.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1572">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1572">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1573">업무 일지 큐의 최대 크기를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1573">Gets or sets the maximum size of the journal queue.</span></span></summary>
        <value><span data-ttu-id="79d78-1574">업무 일지 큐의 최대 크기입니다(단위: KB).</span><span class="sxs-lookup"><span data-stu-id="79d78-1574">The maximum size, in kilobytes, of the journal queue.</span></span> <span data-ttu-id="79d78-1575">메시지 큐에서는 기본적으로 제한이 없도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1575">The Message Queuing default specifies that no limit exists.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1576"><xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 저널 메시지 큐 저장 용량 제한에 대 한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1576"><xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> provides access to the Message Queuing journal storage limit.</span></span> <span data-ttu-id="79d78-1577">인 경우에만 관련 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> 은 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1577">It is relevant only when <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> is `true`.</span></span> <span data-ttu-id="79d78-1578">이 속성을 설정 하면 메시지 큐를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1578">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="79d78-1579">따라서 다른 모든 <xref:System.Messaging.MessageQueue> 는 변경의 영향을 받는 인스턴스</span><span class="sxs-lookup"><span data-stu-id="79d78-1579">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change</span></span>  
  
 <span data-ttu-id="79d78-1580">업무 일지 나 배달 못 한 편지 큐에 메시지를 저장 하는 경우 주기적으로 더 이상 필요 없는 메시지를 제거 하려면 큐를 지워야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1580">If you store messages in a journal or dead-letter queue, you should periodically clear the queue to remove messages that are no longer needed.</span></span> <span data-ttu-id="79d78-1581">이러한 큐에서 메시지 큐가 있는 컴퓨터에 대 한 메시지 할당량을 차지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1581">Messages in such a queue count toward the message quota for the computer where the queue resides.</span></span> <span data-ttu-id="79d78-1582">(관리자 컴퓨터 할당량을 설정 합니다.)</span><span class="sxs-lookup"><span data-stu-id="79d78-1582">(The administrator sets the computer quota.)</span></span>  
  
 <span data-ttu-id="79d78-1583">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1583">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1584">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1584">Workgroup mode</span></span>|<span data-ttu-id="79d78-1585">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1585">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1586">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1586">Local computer</span></span>|<span data-ttu-id="79d78-1587">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1587">Yes</span></span>|  
|<span data-ttu-id="79d78-1588">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1588">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1589">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1589">Yes</span></span>|  
|<span data-ttu-id="79d78-1590">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1590">Remote computer</span></span>|<span data-ttu-id="79d78-1591">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1591">No</span></span>|  
|<span data-ttu-id="79d78-1592">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1592">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1593">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1593">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1594">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1594">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1595">업무 일지 큐의 최대 크기가 잘못된 값으로 설정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1595">The maximum journal queue size was set to an invalid value.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1596">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1596">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1597">큐의 최대 크기를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1597">Gets or sets the maximum size of the queue.</span></span></summary>
        <value><span data-ttu-id="79d78-1598">큐의 최대 크기입니다(단위: KB).</span><span class="sxs-lookup"><span data-stu-id="79d78-1598">The maximum size, in kilobytes, of the queue.</span></span> <span data-ttu-id="79d78-1599">메시지 큐에서는 기본적으로 제한이 없도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1599">The Message Queuing default specifies that no limit exists.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1600"><xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> 는 메시지 큐 메시지 저장소 용량 한도 관리자가 정의 하는 컴퓨터의 메시지 할당량와에서 구분 됨에 대 한 액세스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1600">The <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> provides access to the Message Queuing message storage limit, which is separate from the computer's message quota that the administrator defines.</span></span> <span data-ttu-id="79d78-1601">메시지 할당량에 대 한 자세한 내용은 참조 하십시오. <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1601">For more information about the message quota, see <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.</span></span>  
  
 <span data-ttu-id="79d78-1602">이 속성을 설정 하면 메시지 큐를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1602">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="79d78-1603">따라서 다른 모든 <xref:System.Messaging.MessageQueue> 는 변경의 영향을 받는 인스턴스</span><span class="sxs-lookup"><span data-stu-id="79d78-1603">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change</span></span>  
  
 <span data-ttu-id="79d78-1604">최대 큐 크기 또는 컴퓨터 메시지 할당량을 초과 하려고 하는 경우 메시지가 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1604">If an attempt is made to exceed either the maximum queue size or the computer message quota, messages might be lost.</span></span> <span data-ttu-id="79d78-1605">큐 할당량에 도달 하면 메시지 큐는 부정 승인 메시지를 반환 하 여 큐가 꽉 차면를 보내는 응용 프로그램의 관리 큐를 알립니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1605">When the queue quota is reached, Message Queuing notifies the administration queue of the sending application to indicate that the queue is full, by returning a negative acknowledgment message.</span></span> <span data-ttu-id="79d78-1606">메시지 큐 큐에 메시지의 총 크기 제한 아래로 떨어질 때까지 부정 승인을 보내도록 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1606">Message Queuing continues to send negative acknowledgments until the total size of the messages in the queue drops below the limit.</span></span>  
  
 <span data-ttu-id="79d78-1607">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1607">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1608">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1608">Workgroup mode</span></span>|<span data-ttu-id="79d78-1609">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1609">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1610">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1610">Local computer</span></span>|<span data-ttu-id="79d78-1611">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1611">Yes</span></span>|  
|<span data-ttu-id="79d78-1612">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1612">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1613">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1613">Yes</span></span>|  
|<span data-ttu-id="79d78-1614">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1614">Remote computer</span></span>|<span data-ttu-id="79d78-1615">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1615">No</span></span>|  
|<span data-ttu-id="79d78-1616">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1616">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1617">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1617">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1618">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1618">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1619">큐의 최대 크기에 음수 값이 포함된 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1619">The maximum queue size contains a negative value.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1620">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1620">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1621">메시지를 받거나 또는 피킹하는 데 필요한 속성 필터를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1621">Gets or sets the property filter for receiving or peeking messages.</span></span></summary>
        <value><span data-ttu-id="79d78-1622">큐가 각각의 메시지에 대해 받거나 피킹하는 속성 집합을 필터링하는 데 사용되는 <see cref="T:System.Messaging.MessagePropertyFilter" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1622">The <see cref="T:System.Messaging.MessagePropertyFilter" /> used by the queue to filter the set of properties it receives or peeks for each message.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1623">이 필터는 메시지 속성을 제한 하는 부울 값의 집합입니다는 <xref:System.Messaging.MessageQueue> 받거나를 관찰 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1623">This filter is a set of Boolean values restricting the message properties that the <xref:System.Messaging.MessageQueue> receives or peeks.</span></span> <span data-ttu-id="79d78-1624">경우는 <xref:System.Messaging.MessageQueue> 를 수신 하거나 메시지를 관찰 합니다. 서버 큐에서를 해당 속성만 검색는 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 값은 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1624">When the <xref:System.Messaging.MessageQueue> receives or peeks a message from the server queue, it retrieves only those properties for which the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> value is `true`.</span></span>  
  
 <span data-ttu-id="79d78-1625">다음에 대 한 초기 속성 값이 표시는 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1625">The following shows initial property values for the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> property.</span></span> <span data-ttu-id="79d78-1626">이러한 설정은 호출 동일 <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> 에 <xref:System.Messaging.MessagePropertyFilter>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1626">These settings are identical to calling <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> on a <xref:System.Messaging.MessagePropertyFilter>.</span></span>  
  
|<span data-ttu-id="79d78-1627">속성</span><span class="sxs-lookup"><span data-stu-id="79d78-1627">Property</span></span>|<span data-ttu-id="79d78-1628">기본값</span><span class="sxs-lookup"><span data-stu-id="79d78-1628">Default value</span></span>|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|<span data-ttu-id="79d78-1629">1024 바이트</span><span class="sxs-lookup"><span data-stu-id="79d78-1629">1024 bytes</span></span>|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|<span data-ttu-id="79d78-1630">255 바이트</span><span class="sxs-lookup"><span data-stu-id="79d78-1630">255 bytes</span></span>|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|<span data-ttu-id="79d78-1631">255 바이트</span><span class="sxs-lookup"><span data-stu-id="79d78-1631">255 bytes</span></span>|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 <span data-ttu-id="79d78-1632">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1632">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1633">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1633">Workgroup mode</span></span>|<span data-ttu-id="79d78-1634">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1634">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1635">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1635">Local computer</span></span>|<span data-ttu-id="79d78-1636">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1636">Yes</span></span>|  
|<span data-ttu-id="79d78-1637">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1637">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1638">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1638">Yes</span></span>|  
|<span data-ttu-id="79d78-1639">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1639">Remote computer</span></span>|<span data-ttu-id="79d78-1640">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1640">Yes</span></span>|  
|<span data-ttu-id="79d78-1641">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1641">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1642">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1642">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1643">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 받은 메시지 속성을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1643">The following code example uses the <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> to restrict the message properties received.</span></span>  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1644">필터가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1644">The filter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1645">MSMQ 3.0에서 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1645">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="79d78-1646">큐에 연결된 멀티캐스트 주소를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1646">Gets or sets the multicast address associated with the queue.</span></span></summary>
        <value><span data-ttu-id="79d78-1647">아래 형식으로 된 올바른 멀티캐스트 주소가 들어 있는 <see cref="T:System.String" />이거나, 큐가 멀티캐스트 주소에 연결되지 않았음을 나타내는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1647">A <see cref="T:System.String" /> that contains a valid multicast address (in the form shown below) or <see langword="null" />, which indicates that the queue is not associated with a multicast address.</span></span>  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1648"><xref:System.Messaging.MessageQueue.MulticastAddress%2A> 속성은 비트랜잭션 큐 메시지를 보낼 때 사용할 수 있는 멀티 캐스트 주소와 연결 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1648">The <xref:System.Messaging.MessageQueue.MulticastAddress%2A> property is used to associate a non-transactional queue with a multicast address that can be used when sending messages.</span></span> <span data-ttu-id="79d78-1649">멀티 캐스트 주소와 트랜잭션 큐를 연결할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1649">You cannot associate a transactional queue with a multicast address.</span></span> <span data-ttu-id="79d78-1650">해당 주소와 연결 된 모든 큐에 보내는 응용 프로그램 메시지를 보내면 멀티 캐스트 주소를, 메시지 큐 메시지의 사본을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1650">When the sending application sends messages to a multicast address, Message Queuing sends a copy of the message to every queue associated with that address.</span></span>  
  
 <span data-ttu-id="79d78-1651">IP 멀티 캐스트 주소 224.0.0.0에서 239.255.255.255 처음 네 개의 상위 비트를 1110 설정에 해당 하는 클래스 D 범위에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1651">IP multicast addresses must be in the class D range from 224.0.0.0 to 239.255.255.255, which corresponds to setting the first four high-order bits equal to 1110.</span></span> <span data-ttu-id="79d78-1652">그러나 특정 범위의이 범위에는 주소는 예약 되지 않은 및 멀티 캐스트 메시지를 보내는 데 사용할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1652">However, only certain ranges of addresses in this range are unreserved and available for sending multicast messages.</span></span> <span data-ttu-id="79d78-1653">예약 된 멀티 캐스트 주소 목록이 최신에 대 한 참조는 [번호 기관 IANA (Internet Assigned) 인터넷 멀티 캐스트 주소](http://go.microsoft.com/fwlink/?linkid=3859) 웹 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1653">For the latest list of reserved multicast addresses, see the [Internet Assigned Number Authority (IANA) Internet Multicast Addresses](http://go.microsoft.com/fwlink/?linkid=3859) Web page.</span></span> <span data-ttu-id="79d78-1654">포트 번호에서 제한은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1654">There are no restrictions on the port number.</span></span>  
  
 <span data-ttu-id="79d78-1655">여러 소스 컴퓨터 멀티 캐스트 메시지를 보내는 경우 메시지를 받는 하나의 원본 컴퓨터에서 특정 큐 각 원본 컴퓨터 IP 주소와 포트 번호의 다른 조합에 메시지를 전송 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1655">If several source computers are sending multicast messages and you want a specific queue to receive messages from only one source computer, each source computer must send messages to a different combination of IP address and port number.</span></span>  
  
 <span data-ttu-id="79d78-1656">멀티 캐스트 주소에서 큐를 분리 하려면 설정는 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> 속성을 빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1656">To dissociate a queue from a multicast address, set the <xref:System.Messaging.MessageQueue.MulticastAddress%2A> property to a zero-length string.</span></span> <span data-ttu-id="79d78-1657">설정 하지 마십시오 `null`에서 발생 하므로, 한 <xref:System.ArgumentNullException>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1657">Do not set it to `null`, as this will result in a <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="79d78-1658">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1658">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1659">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1659">Workgroup mode</span></span>|<span data-ttu-id="79d78-1660">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1660">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1661">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1661">Local computer</span></span>|<span data-ttu-id="79d78-1662">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1662">Yes</span></span>|  
|<span data-ttu-id="79d78-1663">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1663">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1664">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1664">Yes</span></span>|  
|<span data-ttu-id="79d78-1665">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1665">Remote computer</span></span>|<span data-ttu-id="79d78-1666">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1666">No</span></span>|  
|<span data-ttu-id="79d78-1667">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1667">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1668">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1668">No</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="79d78-1669">MSMQ 3.0이 설치되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1669">MSMQ 3.0 is not installed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1670">큐의 경로를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1670">Gets or sets the queue's path.</span></span> <span data-ttu-id="79d78-1671"><see cref="P:System.Messaging.MessageQueue.Path" />를 설정하면 <see cref="T:System.Messaging.MessageQueue" />가 새 큐를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1671">Setting the <see cref="P:System.Messaging.MessageQueue.Path" /> causes the <see cref="T:System.Messaging.MessageQueue" /> to point to a new queue.</span></span></summary>
        <value><span data-ttu-id="79d78-1672"><see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1672">The queue that is referenced by the <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="79d78-1673">기본값은 사용하는 <see cref="M:System.Messaging.MessageQueue.#ctor" /> 생성자에 따라 달라지는데, <see langword="null" />이거나 생성자의 <paramref name="path" /> 매개 변수에 의해 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1673">The default depends on which <see cref="M:System.Messaging.MessageQueue.#ctor" /> constructor you use; it is either <see langword="null" /> or is specified by the constructor's <paramref name="path" /> parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1674">에 대 한 구문에서 <xref:System.Messaging.MessageQueue.Path%2A> 속성 유형에 따라 다릅니다 큐의 해당 지점에는 다음 표에 나와 있는 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1674">The syntax for the <xref:System.Messaging.MessageQueue.Path%2A> property depends on the type of queue it points to, as shown in the following table.</span></span>  
  
|<span data-ttu-id="79d78-1675">큐 유형</span><span class="sxs-lookup"><span data-stu-id="79d78-1675">Queue type</span></span>|<span data-ttu-id="79d78-1676">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-1676">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="79d78-1677">공개 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1677">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="79d78-1678">개인 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1678">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
|<span data-ttu-id="79d78-1679">저널 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1679">Journal queue</span></span>|`MachineName`\\`QueueName`\\`Journal$`|  
|<span data-ttu-id="79d78-1680">컴퓨터 저널 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1680">Machine journal queue</span></span>|`MachineName`\\`Journal$`|  
|<span data-ttu-id="79d78-1681">컴퓨터 배달 못 한 편지 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1681">Machine dead-letter queue</span></span>|`MachineName`\\`Deadletter$`|  
|<span data-ttu-id="79d78-1682">컴퓨터 트랜잭션 배달 못 한 편지 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-1682">Machine transactional dead-letter queue</span></span>|`MachineName`\\`XactDeadletter$`|  
  
 <span data-ttu-id="79d78-1683">사용 하 여 "." 로컬 컴퓨터를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1683">Use "." to represent the local computer.</span></span>  
  
 <span data-ttu-id="79d78-1684"><xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성은 서로 관련 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1684">The <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, and <xref:System.Messaging.MessageQueue.QueueName%2A> properties are related.</span></span> <span data-ttu-id="79d78-1685">변경 된 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성 원인을 <xref:System.Messaging.MessageQueue.Path%2A> 변경할 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1685">Changing the <xref:System.Messaging.MessageQueue.MachineName%2A> property causes the <xref:System.Messaging.MessageQueue.Path%2A> property to change.</span></span> <span data-ttu-id="79d78-1686">새 구성 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1686">It is built from the new <xref:System.Messaging.MessageQueue.MachineName%2A> and the <xref:System.Messaging.MessageQueue.QueueName%2A>.</span></span> <span data-ttu-id="79d78-1687">변경 된 <xref:System.Messaging.MessageQueue.Path%2A> (예: 형식 이름 구문 사용) 다시 설정는 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 새 큐를 참조 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1687">Changing the <xref:System.Messaging.MessageQueue.Path%2A> (for example, to use the format name syntax) resets the <xref:System.Messaging.MessageQueue.MachineName%2A> and <xref:System.Messaging.MessageQueue.QueueName%2A> properties to refer to the new queue.</span></span>  
  
 <span data-ttu-id="79d78-1688">사용할 수 있습니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 또는 <xref:System.Messaging.MessageQueue.Label%2A> 다음 표에 나와 있는 것 처럼 큐 경로 설명 하기 위해 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1688">Alternatively, you can use the <xref:System.Messaging.MessageQueue.FormatName%2A> or <xref:System.Messaging.MessageQueue.Label%2A> to describe the queue path, as shown in the following table.</span></span>  
  
|<span data-ttu-id="79d78-1689">참조</span><span class="sxs-lookup"><span data-stu-id="79d78-1689">Reference</span></span>|<span data-ttu-id="79d78-1690">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-1690">Syntax</span></span>|<span data-ttu-id="79d78-1691">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1691">Example</span></span>|  
|---------------|------------|-------------|  
|<span data-ttu-id="79d78-1692">형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1692">Format name</span></span>|<span data-ttu-id="79d78-1693">`FormatName:` [ *형식 이름을* ]</span><span class="sxs-lookup"><span data-stu-id="79d78-1693">`FormatName:` [ *format name* ]</span></span>|<span data-ttu-id="79d78-1694">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span><span class="sxs-lookup"><span data-stu-id="79d78-1694">`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112</span></span>|  
|<span data-ttu-id="79d78-1695">레이블</span><span class="sxs-lookup"><span data-stu-id="79d78-1695">Label</span></span>|<span data-ttu-id="79d78-1696">`Label:` [ *레이블* ]</span><span class="sxs-lookup"><span data-stu-id="79d78-1696">`Label:` [ *label* ]</span></span>|<span data-ttu-id="79d78-1697">`Label:` TheLabel</span><span class="sxs-lookup"><span data-stu-id="79d78-1697">`Label:` TheLabel</span></span>|  
  
 <span data-ttu-id="79d78-1698">에 대 한 레이블 구문을 사용 하는 경우는 <xref:System.Messaging.MessageQueue.Path%2A> 메시지를 보낼 때 속성에는 예외가 발생 하는 경우는 <xref:System.Messaging.MessageQueue.Label%2A> 고유 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1698">If you use the label syntax for the <xref:System.Messaging.MessageQueue.Path%2A> property when you send the message, an exception will be thrown if the <xref:System.Messaging.MessageQueue.Label%2A> is not unique.</span></span>  
  
 <span data-ttu-id="79d78-1699">오프 라인으로 작업 하려면 첫 번째 테이블의 이름 구문이 아닌 형식 이름 구문을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1699">To work offline, you must use the format name syntax, rather than the friendly name syntax in the first table.</span></span> <span data-ttu-id="79d78-1700">그렇지 않으면 주 도메인 컨트롤러 (Active Directory 상주 하는) 형식 이름에 경로 확인할 수 없기 때문에 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1700">Otherwise, an exception is thrown because the primary domain controller (on which Active Directory resides) is not available to resolve the path to the format name.</span></span>  
  
 <span data-ttu-id="79d78-1701">새 경로 설정 하면 메시지 큐 닫고 모든 핸들을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1701">Setting a new path closes the message queue and releases all handles.</span></span>  
  
 <span data-ttu-id="79d78-1702">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1702">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1703">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1703">Workgroup mode</span></span>|<span data-ttu-id="79d78-1704">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1704">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1705">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1705">Local computer</span></span>|<span data-ttu-id="79d78-1706">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1706">Yes</span></span>|  
|<span data-ttu-id="79d78-1707">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1707">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1708">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1708">Yes</span></span>|  
|<span data-ttu-id="79d78-1709">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1709">Remote computer</span></span>|<span data-ttu-id="79d78-1710">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1710">Yes</span></span>|  
|<span data-ttu-id="79d78-1711">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1711">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1712">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1712">Yes</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="79d78-1713">작업 그룹 모드에서 개인 큐의 경우에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1713">In workgroup mode you can only use private queues.</span></span> <span data-ttu-id="79d78-1714">개인 큐 구문을 사용 하 여 경로 지정 `MachineName` \\ `Private$` \\ `QueueName`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1714">You specify the path using the private queue syntax `MachineName`\\`Private$`\\`QueueName`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1715">다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 다양 한 경로 이름 구문 형식을 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1715">The following code example creates new <xref:System.Messaging.MessageQueue> objects using various path name syntax types.</span></span> <span data-ttu-id="79d78-1716">각각의 경우에서 경로가 생성자에 정의 된 큐로 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1716">In each case, it sends a message to the queue whose path is defined in the constructor.</span></span>  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1717">경로가 잘못되었습니다(예: 구문이 잘못된 경우)</span><span class="sxs-lookup"><span data-stu-id="79d78-1717">The path is not valid, possibly because the syntax is not valid.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe><span data-ttu-id="79d78-1718">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1718">The method is not thread safe.</span></span></threadsafe>
        <summary><span data-ttu-id="79d78-1719">큐에 있는 첫 번째 메시지의 복사본을 반환하지만 큐에서 메시지를 제거하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1719">Returns a copy of the first message in the queue without removing the message from the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-1720">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 첫 번째 메시지를 반환하지만 제거(피킹)하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1720">Returns without removing (peeks) the first message in the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="79d78-1721"><see cref="M:System.Messaging.MessageQueue.Peek" /> 메서드는 동기적이므로 메시지를 사용할 수 있을 때까지 현재 스레드를 차단시킵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1721">The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available.</span></span></summary>
        <returns><span data-ttu-id="79d78-1722">큐에 있는 첫 번째 메시지를 나타내는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1722">The <see cref="T:System.Messaging.Message" /> that represents the first message in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1723">이 오버 로드를 사용 하는 큐를 피킹할 수 하거나 메시지가 큐에 있는 될 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1723">Use this overload to peek a queue, or to wait until a message exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-1724"><xref:System.Messaging.MessageQueue.Peek%2A> 메서드 읽지만 첫 번째 메시지 큐에서 제거 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1724">The <xref:System.Messaging.MessageQueue.Peek%2A> method reads, but does not remove, the first message from the queue.</span></span> <span data-ttu-id="79d78-1725">따라서 반복 호출을 <xref:System.Messaging.MessageQueue.Peek%2A> 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1725">Therefore, repeated calls to <xref:System.Messaging.MessageQueue.Peek%2A> return the same message, unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-1726"><xref:System.Messaging.MessageQueue.Receive%2A> 메서드 반면에 모두를 읽는 첫 번째 메시지를 큐에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1726">The <xref:System.Messaging.MessageQueue.Receive%2A> method, on the other hand, both reads and removes the first message from the queue.</span></span> <span data-ttu-id="79d78-1727">반복 호출을 <xref:System.Messaging.MessageQueue.Receive%2A>, 따라서 다양 한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1727">Repeated calls to <xref:System.Messaging.MessageQueue.Receive%2A>, therefore, return different messages.</span></span>  
  
 <span data-ttu-id="79d78-1728">메시지 큐는 우선 순위와 도착 시간에 따라 큐에 메시지를 정리 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1728">Message Queuing orders messages in the queue according to priority and arrival time.</span></span> <span data-ttu-id="79d78-1729">새 메시지는 우선 순위가 높을 경우에 이전 앞에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1729">A newer message is placed before an older one only if it is of a higher priority.</span></span>  
  
 <span data-ttu-id="79d78-1730">큐에 메시지가 도착할 때까지 대기하는 동안 현재 스레드를 차단하는 것이 허용되는 경우에만 <xref:System.Messaging.MessageQueue.Peek%2A>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1730">Use <xref:System.Messaging.MessageQueue.Peek%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="79d78-1731">이 오버 로드는 제한 시간을 지정 하지 않으므로, 응용 프로그램이 무기한 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1731">Because this overload does not specify a time-out, the application might wait indefinitely.</span></span> <span data-ttu-id="79d78-1732">대기하지 않고 응용 프로그램 처리를 계속하려면 비동기 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1732">If you need the application processing to continue without waiting, use the asynchronous <xref:System.Messaging.MessageQueue.BeginPeek%2A> method.</span></span> <span data-ttu-id="79d78-1733">또는의 오버 로드를 사용 하 여 큐에 도착 하는 메시지에 대 한 제한 시간을 지정할 수 <xref:System.Messaging.MessageQueue.Peek%2A> 하는 제한 시간을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1733">Alternatively, you can specify a time-out for a message to arrive in the queue by using the overload of <xref:System.Messaging.MessageQueue.Peek%2A> that specifies a time-out.</span></span>  
  
 <span data-ttu-id="79d78-1734">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1734">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1735">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1735">Workgroup mode</span></span>|<span data-ttu-id="79d78-1736">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1736">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1737">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1737">Local computer</span></span>|<span data-ttu-id="79d78-1738">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1738">Yes</span></span>|  
|<span data-ttu-id="79d78-1739">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1739">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1740">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1740">Yes</span></span>|  
|<span data-ttu-id="79d78-1741">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1741">Remote computer</span></span>|<span data-ttu-id="79d78-1742">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1742">No</span></span>|  
|<span data-ttu-id="79d78-1743">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1743">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1744">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1744">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1745">다음 예에서는 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-1745">The following examples use the <xref:System.Messaging.MessageQueue.Peek%2A> method on a queue.</span></span>  
  
 <span data-ttu-id="79d78-1746">첫 번째 예제에서 응용 프로그램 메시지 큐에서 사용할 수 있게 될 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1746">In the first example, the application waits until a message becomes available in the queue.</span></span> <span data-ttu-id="79d78-1747">첫 번째 예에서는; 도착 하는 메시지에 액세스 하지 않는 참고 단지 메시지가 도착할 때까지 처리 일시 중지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1747">Note that the first example does not access the message that arrives; it merely pauses processing until a message arrives.</span></span> <span data-ttu-id="79d78-1748">경우 메시지가 큐에 이미 있는 즉시 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1748">If a message already exists in the queue, it will return immediately.</span></span>  
  
 <span data-ttu-id="79d78-1749">두 번째 예제에서는 응용 프로그램 정의 포함 하는 메시지 `Order` 클래스는 큐로 전송 되 고 다음 큐에서 피킹 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1749">In the second example, a message that contains an application-defined `Order` class is sent to the queue, and then peeked from the queue.</span></span>  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1750">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1750">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-1751">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1751">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-1752">큐가 메시지를 포함하도록 대기하는 최대 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1752">A <see cref="T:System.TimeSpan" /> that indicates the maximum time to wait for the queue to contain a message.</span></span></param>
        <summary><span data-ttu-id="79d78-1753">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 첫 번째 메시지를 반환하지만 제거(피킹)하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1753">Returns without removing (peeks) the first message in the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="79d78-1754"><see cref="M:System.Messaging.MessageQueue.Peek" /> 메서드는 동기적이므로 메시지를 사용할 수 있거나 지정된 시간이 초과될 때까지 현재 실행 스레드를 차단시킵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1754">The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available or the specified time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="79d78-1755">큐에 있는 첫 번째 메시지를 나타내는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1755">The <see cref="T:System.Messaging.Message" /> that represents the first message in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1756">이 오버 로드를 사용 하 여 큐를 피킹할 수 또는 지정된 된 시간까지 메시지가 큐에 있는 동안 기다려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1756">Use this overload to peek a queue, or to wait a specified period of time until a message exists in the queue.</span></span> <span data-ttu-id="79d78-1757">메시지가 큐에 이미 있는 경우 메서드가 즉시 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1757">The method returns immediately if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-1758"><xref:System.Messaging.MessageQueue.Peek%2A> 메서드 읽지만 첫 번째 메시지 큐에서 제거 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1758">The <xref:System.Messaging.MessageQueue.Peek%2A> method reads, but does not remove, the first message from the queue.</span></span> <span data-ttu-id="79d78-1759">따라서 반복 호출을 <xref:System.Messaging.MessageQueue.Peek%2A> 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1759">Therefore, repeated calls to <xref:System.Messaging.MessageQueue.Peek%2A> return the same message, unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-1760"><xref:System.Messaging.MessageQueue.Receive%2A> 메서드 반면에 모두를 읽는 첫 번째 메시지를 큐에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1760">The <xref:System.Messaging.MessageQueue.Receive%2A> method, on the other hand, both reads and removes the first message from the queue.</span></span> <span data-ttu-id="79d78-1761">반복 호출을 <xref:System.Messaging.MessageQueue.Receive%2A>, 따라서 다양 한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1761">Repeated calls to <xref:System.Messaging.MessageQueue.Receive%2A>, therefore, return different messages.</span></span>  
  
 <span data-ttu-id="79d78-1762">메시지 큐는 우선 순위와 도착 시간에 따라 큐에 메시지를 정리 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1762">Message Queuing orders messages in the queue according to priority and arrival time.</span></span> <span data-ttu-id="79d78-1763">새 메시지는 우선 순위가 높을 경우에 이전 앞에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1763">A newer message is placed before an older one only if it is of a higher priority.</span></span>  
  
 <span data-ttu-id="79d78-1764">큐에 메시지가 도착할 때까지 대기하는 동안 현재 스레드를 차단하는 것이 허용되는 경우에만 <xref:System.Messaging.MessageQueue.Peek%2A>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1764">Use <xref:System.Messaging.MessageQueue.Peek%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="79d78-1765">스레드는 지정 된 시간을 무기한으로 차단 될 다른 사람이 <xref:System.Messaging.MessageQueue.InfiniteTimeout>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1765">The thread will be blocked up to the specified period of time, or indefinitely if you indicated <xref:System.Messaging.MessageQueue.InfiniteTimeout>.</span></span> <span data-ttu-id="79d78-1766">대기하지 않고 응용 프로그램 처리를 계속하려면 비동기 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1766">If you need the application processing to continue without waiting, use the asynchronous <xref:System.Messaging.MessageQueue.BeginPeek%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-1767">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1767">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1768">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1768">Workgroup mode</span></span>|<span data-ttu-id="79d78-1769">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1769">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1770">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1770">Local computer</span></span>|<span data-ttu-id="79d78-1771">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1771">Yes</span></span>|  
|<span data-ttu-id="79d78-1772">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1772">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1773">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1773">Yes</span></span>|  
|<span data-ttu-id="79d78-1774">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1774">Remote computer</span></span>|<span data-ttu-id="79d78-1775">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1775">No</span></span>|  
|<span data-ttu-id="79d78-1776">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1776">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1777">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1777">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1778">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드 큐가 비어 있는지 여부를 확인 하려면 0 시간 제한 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1778">The following code example uses the <xref:System.Messaging.MessageQueue.Peek%2A> method with a time-out of zero to check whether the queue is empty.</span></span>  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1779"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1779">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1780">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1780">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-1781">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1781">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-1782">큐가 메시지를 포함하도록 대기하는 최대 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1782">A <see cref="T:System.TimeSpan" /> that indicates the maximum time to wait for the queue to contain a message.</span></span></param>
        <param name="cursor"><span data-ttu-id="79d78-1783">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1783">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <param name="action"><span data-ttu-id="79d78-1784"><see cref="T:System.Messaging.PeekAction" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1784">One of the <see cref="T:System.Messaging.PeekAction" /> values.</span></span> <span data-ttu-id="79d78-1785">이 값은 큐의 현재 메시지를 피킹할지 또는 다음 메시지를 피킹할지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1785">Indicates whether to peek at the current message in the queue, or the next message.</span></span></param>
        <summary><span data-ttu-id="79d78-1786">지정된 커서를 사용하여 큐에 있는 현재 또는 다음 메시지를 제거하지 않고 반환(피킹)합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1786">Returns without removing (peeks) the current or next message in the queue, using the specified cursor.</span></span> <span data-ttu-id="79d78-1787"><see cref="M:System.Messaging.MessageQueue.Peek" /> 메서드는 동기적이므로 메시지를 사용할 수 있거나 지정된 시간이 초과될 때까지 현재 실행 스레드를 차단시킵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1787">The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available or the specified time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="79d78-1788">큐에 있는 메시지를 나타내는 <see cref="T:System.Messaging.Message" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1788">A <see cref="T:System.Messaging.Message" /> that represents a message in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1789">이 오버 로드를 사용 하 여 큐를 피킹할 수 또는 지정된 된 시간까지 메시지가 큐에 있는 동안 기다려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1789">Use this overload to peek a queue, or to wait a specified period of time until a message exists in the queue.</span></span> <span data-ttu-id="79d78-1790">메시지가 큐에 이미 있는 경우 메서드가 즉시 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1790">The method returns immediately if a message already exists in the queue.</span></span>  
  
 <span data-ttu-id="79d78-1791"><xref:System.Messaging.MessageQueue.Peek%2A> 메서드 읽지만 큐에서 메시지 제거 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1791">The <xref:System.Messaging.MessageQueue.Peek%2A> method reads, but does not remove, a message from the queue.</span></span> <span data-ttu-id="79d78-1792"><xref:System.Messaging.MessageQueue.Receive%2A> 메서드 반면에 모두를 읽는 큐에서 메시지를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1792">The <xref:System.Messaging.MessageQueue.Receive%2A> method, on the other hand, both reads and removes a message from the queue.</span></span>  
  
 <span data-ttu-id="79d78-1793">큐에 메시지가 도착할 때까지 대기하는 동안 현재 스레드를 차단하는 것이 허용되는 경우에만 <xref:System.Messaging.MessageQueue.Peek%2A>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1793">Use <xref:System.Messaging.MessageQueue.Peek%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="79d78-1794">스레드는 지정 된 시간을 무기한으로 차단 하면 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1794">The thread is blocked up to the specified period of time, or indefinitely if you indicated <xref:System.Messaging.MessageQueue.InfiniteTimeout>.</span></span> <span data-ttu-id="79d78-1795">대기하지 않고 응용 프로그램 처리를 계속하려면 비동기 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1795">If you need the application processing to continue without waiting, use the asynchronous <xref:System.Messaging.MessageQueue.BeginPeek%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-1796">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1796">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1797">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1797">Workgroup mode</span></span>|<span data-ttu-id="79d78-1798">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1798">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1799">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1799">Local computer</span></span>|<span data-ttu-id="79d78-1800">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1800">Yes</span></span>|  
|<span data-ttu-id="79d78-1801">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1801">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1802">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1802">Yes</span></span>|  
|<span data-ttu-id="79d78-1803">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1803">Remote computer</span></span>|<span data-ttu-id="79d78-1804">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1804">No</span></span>|  
|<span data-ttu-id="79d78-1805">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1805">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1806">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1806">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79d78-1807"><paramref name="action" /> 매개 변수에 대해 <see langword="PeekAction.Current" /> 또는 <see langword="PeekAction.Next" /> 이외의 값을 지정했습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1807">A value other than <see langword="PeekAction.Current" /> or <see langword="PeekAction.Next" /> was specified for the <paramref name="action" /> parameter.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-1808"><paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1808">The <paramref name="cursor" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1809"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1809">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span> <span data-ttu-id="79d78-1810"><paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1810">Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1811">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1811">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-1812">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1812">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-1813">주어진 상관 관계 식별자를 갖는 메시지를 피킹합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1813">Peeks a message that matches a given correlation identifier.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="79d78-1814">피킹할 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1814">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to peek.</span></span></param>
        <summary><span data-ttu-id="79d78-1815">주어진 상관 관계 식별자를 갖는 메시지를 피킹합니다. 지정된 상관 관계 식별자가 포함된 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1815">Peeks the message that matches the given correlation identifier and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-1816">전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1816">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1817">참조 하는 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1817">This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="79d78-1818">메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수를 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1818">If no message is found that matches the `correlationID` parameter, an exception is thrown.</span></span>  
  
 <span data-ttu-id="79d78-1819"><xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1819">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="79d78-1820">다른 두 메서드를 사용 하면 큐에서 피킹 메시지를 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1820">Two other methods allow you to peek messages in a queue.</span></span> <span data-ttu-id="79d78-1821"><xref:System.Messaging.MessageQueue.Peek%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1821">The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="79d78-1822">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1822">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1823">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1823">Workgroup mode</span></span>|<span data-ttu-id="79d78-1824">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1824">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1825">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1825">Local computer</span></span>|<span data-ttu-id="79d78-1826">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1826">Yes</span></span>|  
|<span data-ttu-id="79d78-1827">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1827">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1828">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1828">Yes</span></span>|  
|<span data-ttu-id="79d78-1829">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1829">Remote computer</span></span>|<span data-ttu-id="79d78-1830">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1830">No</span></span>|  
|<span data-ttu-id="79d78-1831">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1831">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1832">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1832">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1833">다음 코드 예제는 큐에서 주문에 포함 된 메시지 송수신 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1833">The following code example sends and receives a message that contains an order to and from a queue.</span></span> <span data-ttu-id="79d78-1834">원본 메시지가 도달 하거나이 긍정 승인을 특별히 요청 큐에서 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1834">It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.</span></span>  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-1835"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1835">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-1836">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1836">The message with the specified <paramref name="correlationId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1837">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1837">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="79d78-1838">피킹할 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1838">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to peek.</span></span></param>
        <param name="timeout"><span data-ttu-id="79d78-1839">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1839">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <summary><span data-ttu-id="79d78-1840">주어진 상관 관계 식별자를 갖는 메시지를 피킹하며, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1840">Peeks the message that matches the given correlation identifier and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-1841">전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1841">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1842">참조 하는 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1842">This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="79d78-1843">메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수를 새 메시지에 지정 된 기간 내에서 큐에 도착할는 `timeout` 매개 변수를 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1843">If no message is found that matches the `correlationID` parameter, and no new message arrives in the queue within the period specified by the `timeout` parameter, an exception is thrown.</span></span>  
  
 <span data-ttu-id="79d78-1844">`timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1844">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="79d78-1845">새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1845">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="79d78-1846">될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하는 새 메시지는 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1846">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter.</span></span> <span data-ttu-id="79d78-1847">그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1847">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="79d78-1848">따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.CorrelationId%2A> 일치는 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1848">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter.</span></span>  
  
 <span data-ttu-id="79d78-1849"><xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1849">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="79d78-1850">다른 두 메서드를 사용 하면 큐에서 피킹 메시지를 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1850">Two other methods allow you to peek messages in a queue.</span></span> <span data-ttu-id="79d78-1851"><xref:System.Messaging.MessageQueue.Peek%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1851">The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="79d78-1852">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1852">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1853">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1853">Workgroup mode</span></span>|<span data-ttu-id="79d78-1854">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1854">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1855">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1855">Local computer</span></span>|<span data-ttu-id="79d78-1856">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1856">Yes</span></span>|  
|<span data-ttu-id="79d78-1857">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1857">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1858">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1858">Yes</span></span>|  
|<span data-ttu-id="79d78-1859">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1859">Remote computer</span></span>|<span data-ttu-id="79d78-1860">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1860">No</span></span>|  
|<span data-ttu-id="79d78-1861">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1861">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1862">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1862">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1863">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1863">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-1864"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1864">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1865"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1865">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-1866">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1866">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1867">제한 시간이 만료되기 전에 메시지가 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1867">A message did not arrive before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-1868">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-1868">-or-</span></span>  
  
 <span data-ttu-id="79d78-1869">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1869">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-1870">지정된 메시지 식별자가 포함된 메시지의 복사본을 반환하지만 큐에서 해당 메시지를 제거하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1870">Returns a copy of the message that has the specified message identifier without removing the message from the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="79d78-1871">피킹할 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1871">The <see cref="P:System.Messaging.Message.Id" /> of the message to peek.</span></span></param>
        <summary><span data-ttu-id="79d78-1872">메시지 식별자가 <paramref name="id" /> 매개 변수와 일치하는 메시지를 피킹합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1872">Peeks the message whose message identifier matches the <paramref name="id" /> parameter.</span></span></summary>
        <returns><span data-ttu-id="79d78-1873"><see cref="T:System.Messaging.Message" /> 속성이 <paramref name="id" /> 매개 변수와 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1873">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1874">사용 하 여 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 큐에서 제거 하지 않고 읽이 알려진된 메시지 식별자를 가진 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1874">Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> to read, without removing from the queue, a message that has a known message identifier.</span></span> <span data-ttu-id="79d78-1875">메시지의 식별자가 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1875">The identifier of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span> <span data-ttu-id="79d78-1876">이 오버 로드 큐 메시지 포함 하지 않는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1876">This overload throws an exception if the queue does not currently contain the message.</span></span>  
  
 <span data-ttu-id="79d78-1877">두 개의 추가 메서드를 사용 하면 메시지를 피킹할 큐에 있는: <xref:System.Messaging.MessageQueue.Peek%2A> 및 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1877">Two additional methods allow you to peek messages in a queue: <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="79d78-1878"><xref:System.Messaging.MessageQueue.Peek%2A> 메서드; 큐에 있는 첫 번째 메시지를 반환 합니다. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1878">The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> returns an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="79d78-1879">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1879">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1880">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1880">Workgroup mode</span></span>|<span data-ttu-id="79d78-1881">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1881">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1882">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1882">Local computer</span></span>|<span data-ttu-id="79d78-1883">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1883">Yes</span></span>|  
|<span data-ttu-id="79d78-1884">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1884">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1885">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1885">Yes</span></span>|  
|<span data-ttu-id="79d78-1886">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1886">Remote computer</span></span>|<span data-ttu-id="79d78-1887">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1887">No</span></span>|  
|<span data-ttu-id="79d78-1888">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1888">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1889">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1889">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1890">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1890">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-1891"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1891">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-1892">지정된 <paramref name="id" />의 메시지가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1892">No message with the specified <paramref name="id" /> exists.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1893">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1893">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="79d78-1894">피킹할 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1894">The <see cref="P:System.Messaging.Message.Id" /> of the message to peek.</span></span></param>
        <param name="timeout"><span data-ttu-id="79d78-1895">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1895">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <summary><span data-ttu-id="79d78-1896">메시지 식별자가 <paramref name="id" /> 매개 변수와 일치하는 메시지를 피킹합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1896">Peeks the message whose message identifier matches the <paramref name="id" /> parameter.</span></span> <span data-ttu-id="79d78-1897">큐에 메시지가 표시되거나 제한 시간이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1897">Waits until the message appears in the queue or a time-out occurs.</span></span></summary>
        <returns><span data-ttu-id="79d78-1898"><see cref="T:System.Messaging.Message" /> 속성이 <paramref name="id" /> 매개 변수와 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1898">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1899">사용 하 여 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 큐에서 제거 하지 않고 읽이 알려진된 메시지 식별자를 가진 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1899">Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> to read, without removing from the queue, a message that has a known message identifier.</span></span> <span data-ttu-id="79d78-1900">메시지의 식별자가 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1900">The identifier of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span> <span data-ttu-id="79d78-1901">이 오버 로드 큐 메시지 포함 하지 않는 경우 제한 시간이 발생 하기 전에 새 메시지가 도착 하지 않으면 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1901">This overload throws an exception if the queue does not currently contain the message and a new message does not arrive before the time-out occurs.</span></span>  
  
 <span data-ttu-id="79d78-1902">`timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1902">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="79d78-1903">새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1903">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="79d78-1904">될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하는 새 메시지는 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1904">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter.</span></span> <span data-ttu-id="79d78-1905">그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1905">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="79d78-1906">따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.Id%2A> 일치는 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1906">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.</span></span>  
  
 <span data-ttu-id="79d78-1907">두 개의 추가 메서드를 사용 하면 메시지를 피킹할 큐에 있는: <xref:System.Messaging.MessageQueue.Peek%2A> 및 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1907">Two additional methods allow you to peek messages in a queue: <xref:System.Messaging.MessageQueue.Peek%2A> and <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="79d78-1908"><xref:System.Messaging.MessageQueue.Peek%2A> 메서드; 큐에 있는 첫 번째 메시지를 반환 합니다. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1908">The <xref:System.Messaging.MessageQueue.Peek%2A> method returns the first message in the queue; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> returns an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="79d78-1909">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1909">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1910">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1910">Workgroup mode</span></span>|<span data-ttu-id="79d78-1911">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1911">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1912">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1912">Local computer</span></span>|<span data-ttu-id="79d78-1913">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1913">Yes</span></span>|  
|<span data-ttu-id="79d78-1914">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1914">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1915">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1915">Yes</span></span>|  
|<span data-ttu-id="79d78-1916">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1916">Remote computer</span></span>|<span data-ttu-id="79d78-1917">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1917">No</span></span>|  
|<span data-ttu-id="79d78-1918">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1918">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1919">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1919">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1920">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1920">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-1921"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1921">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-1922"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1922">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-1923">지정된 <paramref name="id" />가 들어 있는 메시지가 큐에 없고 <paramref name="timeout" /> 매개 변수가 지정한 기간이 만료되기 전에 메시지가 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1923">The message with the specified <paramref name="id" /> does not exist in the queue and did not arrive before the period specified by the <paramref name="timeout" /> parameter expired.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1924">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1924">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-1925">MSMQ 3.0에서 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1925">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="79d78-1926">큐의 특정 메시지를 피킹합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1926">Peeks at a specific message from the queue.</span></span> <span data-ttu-id="79d78-1927">메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1927">The message can be specified by a lookup identifier or by its position at the front or end of the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId"><span data-ttu-id="79d78-1928">피킹할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1928">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to peek at.</span></span></param>
        <summary><span data-ttu-id="79d78-1929">MSMQ 3.0에서 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1929">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="79d78-1930">비트랜잭션 큐에서 지정된 조회 식별자를 갖는 메시지를 피킹합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1930">Peeks at the message that matches the given lookup identifier from a non-transactional queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-1931">전달된 <paramref name="lookupId" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.LookupId" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1931">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.LookupId" /> property matches the <paramref name="lookupId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1932">이 메서드를 사용 하 여 큐에서 제거 하지 않고 알려진된 조회 식별자를 가진 메시지를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1932">Use this method to read a message with a known lookup identifier without removing it from the queue.</span></span> <span data-ttu-id="79d78-1933">이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1933">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="79d78-1934"><xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 해당 메시지가 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 주어진 `lookupId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1934">The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.</span></span>  
  
 <span data-ttu-id="79d78-1935">지정한 lookup 식별자와 메시지를 읽고 큐에서 제거를 사용 하 여는 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-1935">To read a message with a specified lookup identifier and remove it from the queue, use the <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-1936">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1936">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1937">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1937">Workgroup mode</span></span>|<span data-ttu-id="79d78-1938">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1938">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1939">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1939">Local computer</span></span>|<span data-ttu-id="79d78-1940">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1940">Yes</span></span>|  
|<span data-ttu-id="79d78-1941">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1941">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1942">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1942">Yes</span></span>|  
|<span data-ttu-id="79d78-1943">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1943">Remote computer</span></span>|<span data-ttu-id="79d78-1944">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1944">No</span></span>|  
|<span data-ttu-id="79d78-1945">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1945">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1946">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1946">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="79d78-1947">MSMQ 3.0이 설치되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1947">MSMQ 3.0 is not installed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-1948">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1948">The message with the specified <paramref name="lookupId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1949">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1949">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="79d78-1950">큐에서 메시지를 읽는 방법을 지정하는 <see cref="T:System.Messaging.MessageLookupAction" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1950">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue.</span></span> <span data-ttu-id="79d78-1951">다음 중 하나를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1951">Specify one of the following:</span></span>  
  
 <span data-ttu-id="79d78-1952"><see langword="MessageLookupAction.Current" />: <c>lookupId</c>로 지정된 메시지를 피킹합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1952"><see langword="MessageLookupAction.Current" />: Peeks at the message specified by <c>lookupId</c>.</span></span>  
  
 <span data-ttu-id="79d78-1953"><see langword="MessageLookupAction.Next" />: <c>lookupId</c>로 지정된 메시지의 뒤에 있는 메시지를 피킹합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1953"><see langword="MessageLookupAction.Next" />: Peeks at the message following the message specified by <c>lookupId</c>.</span></span>  
  
 <span data-ttu-id="79d78-1954"><see langword="MessageLookupAction.Previous" />: <c>lookupId</c>로 지정된 메시지의 앞에 있는 메시지를 피킹합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1954"><see langword="MessageLookupAction.Previous" />: Peeks at the message preceding the message specified by <c>lookupId</c>.</span></span>  
  
 <span data-ttu-id="79d78-1955"><see langword="MessageLookupAction.First" />: 큐에 있는 첫 번째 메시지를 피킹합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1955"><see langword="MessageLookupAction.First" />: Peeks at the first message in the queue.</span></span> <span data-ttu-id="79d78-1956"><c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1956">The <c>lookupId</c> parameter must be set to 0.</span></span>  
  
 <span data-ttu-id="79d78-1957"><see langword="MessageLookupAction.Last" />: 큐에 있는 마지막 메시지를 피킹합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1957"><see langword="MessageLookupAction.Last" />: Peeks at the last message in the queue.</span></span> <span data-ttu-id="79d78-1958"><c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1958">The <c>lookupId</c> parameter must be set to 0.</span></span></param>
        <param name="lookupId"><span data-ttu-id="79d78-1959">0에서 피킹할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1959">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to peek at, or 0.</span></span> <span data-ttu-id="79d78-1960">0은 큐에 있는 첫 번째 또는 마지막 메시지에 액세스할 때 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1960">0 is used when accessing the first or last message in the queue.</span></span></param>
        <summary><span data-ttu-id="79d78-1961">MSMQ 3.0에서 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1961">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="79d78-1962">큐의 특정 메시지를 피킹합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1962">Peeks at a specific message from the queue.</span></span> <span data-ttu-id="79d78-1963">메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1963">The message can be specified by a lookup identifier or by its position at the front or end of the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-1964">전달된 <paramref name="action" /> 및 <paramref name="lookupId" /> 매개 변수로 지정된 <see cref="T:System.Messaging.Message" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1964">The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="action" /> and <paramref name="lookupId" /> parameters passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1965">이 메서드를 사용 하 여 큐에서 제거 하지 않고 알려진된 조회 식별자를 가진 메시지를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1965">Use this method to read a message with a known lookup identifier without removing it from the queue.</span></span> <span data-ttu-id="79d78-1966">이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1966">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="79d78-1967"><xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 해당 메시지가 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 주어진 `lookupId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1967">The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.</span></span>  
  
 <span data-ttu-id="79d78-1968">사용 하 여 지정 된 식별자를 갖는 메시지를 큐에서 제거할는 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-1968">To read a message with a specified identifier and remove it from the queue, use the <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-1969">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1969">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1970">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1970">Workgroup mode</span></span>|<span data-ttu-id="79d78-1971">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-1971">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-1972">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1972">Local computer</span></span>|<span data-ttu-id="79d78-1973">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1973">Yes</span></span>|  
|<span data-ttu-id="79d78-1974">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1974">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-1975">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1975">Yes</span></span>|  
|<span data-ttu-id="79d78-1976">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-1976">Remote computer</span></span>|<span data-ttu-id="79d78-1977">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-1977">No</span></span>|  
|<span data-ttu-id="79d78-1978">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-1978">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-1979">예</span><span class="sxs-lookup"><span data-stu-id="79d78-1979">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="79d78-1980">MSMQ 3.0이 설치되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1980">MSMQ 3.0 is not installed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-1981">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1981">The message with the specified <paramref name="lookupId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-1982">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1982">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-1983"><paramref name="action" /> 매개 변수가 <see cref="T:System.Messaging.MessageLookupAction" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-1983">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-1984">큐에서 메시지를 제거하지 않고 메시지를 읽는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1984">Occurs when a message is read without being removed from the queue.</span></span> <span data-ttu-id="79d78-1985">이는 비동기 작업인 <see cref="M:System.Messaging.MessageQueue.BeginPeek" />의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1985">This is a result of the asynchronous operation, <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1986"><xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 처리에서 발생 하는 데 사용 되는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 메시지가 큐에서 사용할 수 있는 때입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1986"><xref:System.Messaging.MessageQueue.BeginPeek%2A> is used in asynchronous processing to raise the <xref:System.Messaging.MessageQueue.PeekCompleted> event when a message is available in the queue.</span></span>  
  
 <span data-ttu-id="79d78-1987"><xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 하 여 시작 된 작업을 완료 하는 데는 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 및 메시지 피킹 때는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1987"><xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> is used to complete the operation initiated by a call to <xref:System.Messaging.MessageQueue.BeginPeek%2A> and peek the message when the <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised.</span></span>  
  
 <span data-ttu-id="79d78-1988"><xref:System.Messaging.PeekCompletedEventHandler> 대리자를 만들 때, 이벤트를 처리할 메서드를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1988">When you create a <xref:System.Messaging.PeekCompletedEventHandler> delegate, you identify the method that will handle the event.</span></span> <span data-ttu-id="79d78-1989">이벤트를 이벤트 처리기와 연결하려면 대리자의 인스턴스를 해당 이벤트에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1989">To associate the event with your event handler, add an instance of the delegate to the event.</span></span> <span data-ttu-id="79d78-1990">대리자를 제거하지 않는 경우 이벤트가 발생할 때마다 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1990">The event handler is called whenever the event occurs, unless you remove the delegate.</span></span> <span data-ttu-id="79d78-1991">이벤트 처리기 대리자에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1991">For more information about event handler delegates, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79d78-1992">다음 코드 예제에서는 라는 이벤트 처리기를 만들고 `MyPeekCompleted`에 연결는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자 및 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 경로에 있는 큐에서 비동기 작업을 시작 하려면 ". \myQueue"입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1992">The following code example creates an event handler named `MyPeekCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.PeekCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue".</span></span> <span data-ttu-id="79d78-1993">경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하면이 예에서는 메시지를 관찰 합니다. 한 화면으로 해당 본문을 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1993">When a <xref:System.Messaging.MessageQueue.PeekCompleted> event is raised, the example peeks the message and writes its body to the screen.</span></span> <span data-ttu-id="79d78-1994">이 예에서는 다음 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 다시 새 비동기 작업을 시작 하려면</span><span class="sxs-lookup"><span data-stu-id="79d78-1994">The example then calls <xref:System.Messaging.MessageQueue.BeginPeek%2A> again to initiate a new asynchronous peek operation</span></span>  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-1995">큐에 포함된 모든 메시지를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1995">Deletes all the messages contained in the queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-1996">큐를 제거로 인해 메시지 큐에 영향을 주는 큐 수정 플래그를 설정 하는 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1996">Purging the queue causes Message Queuing to set the queue modification flag, which affects the <xref:System.Messaging.MessageQueue.LastModifyTime%2A> property.</span></span> <span data-ttu-id="79d78-1997">메시지 큐에서 제거 하는 손실 됩니다. 배달 못 한 편지 큐 또는 저널 큐에 전송 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1997">Messages that are purged from the queue are lost; they are not sent to the dead-letter queue or the journal queue.</span></span>  
  
 <span data-ttu-id="79d78-1998">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-1998">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-1999">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-1999">Workgroup mode</span></span>|<span data-ttu-id="79d78-2000">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2000">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2001">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2001">Local computer</span></span>|<span data-ttu-id="79d78-2002">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2002">Yes</span></span>|  
|<span data-ttu-id="79d78-2003">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2003">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2004">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2004">Yes</span></span>|  
|<span data-ttu-id="79d78-2005">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2005">Remote computer</span></span>|<span data-ttu-id="79d78-2006">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2006">No</span></span>|  
|<span data-ttu-id="79d78-2007">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2007">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2008">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2008">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2009">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Purge%2A>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2009">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Purge%2A>.</span></span>  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2010">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2010">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-2011">큐를 식별하는 이름을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2011">Gets or sets the friendly name that identifies the queue.</span></span></summary>
        <value><span data-ttu-id="79d78-2012">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐를 식별하는 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2012">The name that identifies the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="79d78-2013">이 값은 <see langword="null" />일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2013">The value cannot be <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2014">결합할 수는 <xref:System.Messaging.MessageQueue.QueueName%2A> 와 <xref:System.Messaging.MessageQueue.MachineName%2A> 친숙 한 만들려는 <xref:System.Messaging.MessageQueue.Path%2A> 큐에 대 한 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2014">You can combine the <xref:System.Messaging.MessageQueue.QueueName%2A> with the <xref:System.Messaging.MessageQueue.MachineName%2A> to create a friendly <xref:System.Messaging.MessageQueue.Path%2A> name for the queue.</span></span> <span data-ttu-id="79d78-2015">이름 변형에 대 한 구문에서 <xref:System.Messaging.MessageQueue.Path%2A> 다음 표에 나와 있는 것 처럼 속성 큐의 형식에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2015">The syntax for the friendly name variation of the <xref:System.Messaging.MessageQueue.Path%2A> property depends on the type of queue, as shown in the following table.</span></span>  
  
|<span data-ttu-id="79d78-2016">큐 유형</span><span class="sxs-lookup"><span data-stu-id="79d78-2016">Queue type</span></span>|<span data-ttu-id="79d78-2017">구문</span><span class="sxs-lookup"><span data-stu-id="79d78-2017">Syntax</span></span>|  
|----------------|------------|  
|<span data-ttu-id="79d78-2018">공개 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-2018">Public queue</span></span>|`MachineName`\\`QueueName`|  
|<span data-ttu-id="79d78-2019">개인 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-2019">Private queue</span></span>|`MachineName`\\`Private$`\\`QueueName`|  
|<span data-ttu-id="79d78-2020">저널 큐</span><span class="sxs-lookup"><span data-stu-id="79d78-2020">Journal queue</span></span>|`MachineName`\\`QueueName`\\`Journal$`|  
  
 <span data-ttu-id="79d78-2021">사용 하 여 "." 로컬 컴퓨터를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2021">Use "." to represent the local computer.</span></span>  
  
 <span data-ttu-id="79d78-2022">변경 된 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성에 영향을 미칩니다는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2022">Changing the <xref:System.Messaging.MessageQueue.QueueName%2A> property affects the <xref:System.Messaging.MessageQueue.Path%2A> property.</span></span> <span data-ttu-id="79d78-2023">설정 하는 경우는 <xref:System.Messaging.MessageQueue.QueueName%2A> 설정 하지 않고는 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성에는 <xref:System.Messaging.MessageQueue.Path%2A> 속성은.\\ `QueueName`.</span><span class="sxs-lookup"><span data-stu-id="79d78-2023">If you set the <xref:System.Messaging.MessageQueue.QueueName%2A> without setting the <xref:System.Messaging.MessageQueue.MachineName%2A> property, the <xref:System.Messaging.MessageQueue.Path%2A> property becomes .\\`QueueName`.</span></span> <span data-ttu-id="79d78-2024">그렇지 않은 경우는 <xref:System.Messaging.MessageQueue.Path%2A> 됩니다 `MachineName` \\ `QueueName`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2024">Otherwise, the <xref:System.Messaging.MessageQueue.Path%2A> becomes `MachineName`\\`QueueName`.</span></span>  
  
 <span data-ttu-id="79d78-2025">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2025">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2026">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2026">Workgroup mode</span></span>|<span data-ttu-id="79d78-2027">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2027">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2028">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2028">Local computer</span></span>|<span data-ttu-id="79d78-2029">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2029">Yes</span></span>|  
|<span data-ttu-id="79d78-2030">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2030">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2031">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2031">Yes</span></span>|  
|<span data-ttu-id="79d78-2032">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2032">Remote computer</span></span>|<span data-ttu-id="79d78-2033">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2033">Yes</span></span>|  
|<span data-ttu-id="79d78-2034">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2034">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2035">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2035">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2036">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2036">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.QueueName%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2037">큐 이름이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2037">The queue name is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-2038">메시지 큐에서 메시지를 읽는 데 사용되는 기본 핸들을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2038">Gets the native handle used to read messages from the message queue.</span></span></summary>
        <value><span data-ttu-id="79d78-2039">큐에서 메시지를 피킹하거나 받는 데 사용하는 네이티브 큐 개체에 대한 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2039">A handle to the native queue object that you use for peeking and receiving messages from the queue.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2040"><xref:System.Messaging.MessageQueue.ReadHandle%2A> 관찰 하 고 큐에서 메시지 수신에 사용 되는 메시지 큐 개체에 대 한 기본 창 핸들을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2040">The <xref:System.Messaging.MessageQueue.ReadHandle%2A> provides a native Windows handle to the message queue object that is used for peeking and receiving messages from the queue.</span></span> <span data-ttu-id="79d78-2041">큐의 경로 변경 하면 핸들을 닫고 다시 새 값으로.</span><span class="sxs-lookup"><span data-stu-id="79d78-2041">If you change the path of the queue, the handle is closed and reopened with a new value.</span></span>  
  
 <span data-ttu-id="79d78-2042">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2042">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2043">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2043">Workgroup mode</span></span>|<span data-ttu-id="79d78-2044">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2044">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2045">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2045">Local computer</span></span>|<span data-ttu-id="79d78-2046">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2046">Yes</span></span>|  
|<span data-ttu-id="79d78-2047">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2047">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2048">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2048">Yes</span></span>|  
|<span data-ttu-id="79d78-2049">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2049">Remote computer</span></span>|<span data-ttu-id="79d78-2050">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2050">No</span></span>|  
|<span data-ttu-id="79d78-2051">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2051">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2052">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2052">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2053">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2053">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe><span data-ttu-id="79d78-2054">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2054">The method is not thread safe.</span></span></threadsafe>
        <summary><span data-ttu-id="79d78-2055">큐에 있는 첫 번째 메시지를 받고, 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2055">Receives the first message in the queue, removing it from the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-2056"><see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2056">Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="79d78-2057">이 호출은 동기적이므로 메시지를 사용할 수 있을 때까지 현재 실행 스레드를 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2057">This call is synchronous, and blocks the current thread of execution until a message is available.</span></span></summary>
        <returns><span data-ttu-id="79d78-2058">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2058">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2059">이 오버 로드를 사용 하 여 큐에서 메시지를 받거나 큐에 메시지가 도착할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2059">Use this overload to receive a message from a queue, or wait until there are messages in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2060"><xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2060">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="79d78-2061">에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 있는 높은 우선 순위의 메시지가 새로운, 또는 큐에서 다음 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2061">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue, or new, higher priority messages.</span></span>  
  
 <span data-ttu-id="79d78-2062">사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2062">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="79d78-2063"><xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2063">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2064">에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2064">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2065">이 오버 로드 때문에 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 시간 제한이 없음을 지정, 응용 프로그램이 무기한 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2065">Because this overload of the <xref:System.Messaging.MessageQueue.Receive%2A> method specifies an infinite time-out, the application might wait indefinitely.</span></span> <span data-ttu-id="79d78-2066">비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2066">If the application processing should continue without waiting for the message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2067">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2067">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2068">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2068">Workgroup mode</span></span>|<span data-ttu-id="79d78-2069">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2069">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2070">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2070">Local computer</span></span>|<span data-ttu-id="79d78-2071">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2071">Yes</span></span>|  
|<span data-ttu-id="79d78-2072">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2072">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2073">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2073">Yes</span></span>|  
|<span data-ttu-id="79d78-2074">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2074">Remote computer</span></span>|<span data-ttu-id="79d78-2075">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2075">No</span></span>|  
|<span data-ttu-id="79d78-2076">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2076">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2077">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2077">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2078">다음 코드 예제에서는 큐에서 메시지를 받은 및 화면으로 해당 메시지에 대 한 정보를 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2078">The following code example receives a message from a queue and outputs information about that message to the screen.</span></span>  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2079">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2079">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction"><span data-ttu-id="79d78-2080"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</span><span class="sxs-lookup"><span data-stu-id="79d78-2080">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="79d78-2081"><see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2081">Receives the first message available in the transactional queue referenced by the <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="79d78-2082">이 호출은 동기적이므로 메시지를 사용할 수 있을 때까지 현재 실행 스레드를 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2082">This call is synchronous, and blocks the current thread of execution until a message is available.</span></span></summary>
        <returns><span data-ttu-id="79d78-2083">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2083">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2084">이 오버 로드를 사용 하 여 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 트랜잭션 큐에서 메시지를 수신 하기는 `transaction` 매개 변수 또는 큐에 메시지가 도착할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2084">Use this overload to receive a message from a transactional queue using the internal transaction context defined by the `transaction` parameter, or wait until there are messages in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2085"><xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2085">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="79d78-2086">에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2086">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2087">트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2087">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2088">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2088">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2089">사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2089">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="79d78-2090"><xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2090">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2091">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2091">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="79d78-2092">때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 에서는 큐의 메시지를 제거 하지 않으며, 호출 하 여 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2092">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2093">에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2093">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2094">이 오버 로드 때문에 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 시간 제한이 없음을 지정, 응용 프로그램이 무기한 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2094">Because this overload of the <xref:System.Messaging.MessageQueue.Receive%2A> method specifies an infinite time-out, the application might wait indefinitely.</span></span> <span data-ttu-id="79d78-2095">비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2095">If the application processing should continue without waiting for the message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2096">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2096">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2097">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2097">Workgroup mode</span></span>|<span data-ttu-id="79d78-2098">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2098">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2099">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2099">Local computer</span></span>|<span data-ttu-id="79d78-2100">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2100">Yes</span></span>|  
|<span data-ttu-id="79d78-2101">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2101">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2102">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2102">Yes</span></span>|  
|<span data-ttu-id="79d78-2103">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2103">Remote computer</span></span>|<span data-ttu-id="79d78-2104">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2104">No</span></span>|  
|<span data-ttu-id="79d78-2105">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2105">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2106">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2106">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2107">다음 코드 예제에서는 로컬 컴퓨터에는 트랜잭션 큐에 연결 하 고 큐에 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2107">The following code example connects to a transactional queue on the local computer and sends a message to the queue.</span></span> <span data-ttu-id="79d78-2108">그런 다음 주문이 포함 된 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2108">It then receives the message that contains an order.</span></span> <span data-ttu-id="79d78-2109">Throw 비트랜잭션 큐를 발생 하는 경우 예외 및 트랜잭션 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2109">If it encounters a non-transactional queue, it will throw and exception and rollback the transaction.</span></span>  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2110">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2110">An error occurred when accessing a Message Queuing method.</span></span>  
  
 <span data-ttu-id="79d78-2111">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2111">-or-</span></span>  
  
 <span data-ttu-id="79d78-2112">비트랜잭션 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2112">The queue is non-transactional.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-2113">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2113">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType"><span data-ttu-id="79d78-2114"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2114">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="79d78-2115"><see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2115">Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="79d78-2116">이 호출은 동기적이므로 메시지를 사용할 수 있을 때까지 현재 실행 스레드를 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2116">This call is synchronous, and blocks the current thread of execution until a message is available.</span></span></summary>
        <returns><span data-ttu-id="79d78-2117">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2117">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2118">이 오버 로드를 사용 하 여 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에서 메시지를 수신 하기는 `transactionType` 매개 변수 또는 큐에 메시지가 도착할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2118">Use this overload to receive a message from a queue using a transaction context defined by the `transactionType` parameter, or wait until there are messages in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2119">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2119">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="79d78-2120">지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2120">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="79d78-2121">지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2121">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="79d78-2122"><xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2122">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="79d78-2123">에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2123">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2124">이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2124">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2125">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2125">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2126">사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2126">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="79d78-2127"><xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2127">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2128">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2128">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="79d78-2129">때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 에서는 큐의 메시지를 제거 하지 않으며, 호출 하 여 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2129">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2130">에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2130">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2131">이 오버 로드 때문에 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드 시간 제한이 없음을 지정, 응용 프로그램이 무기한 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2131">Because this overload of the <xref:System.Messaging.MessageQueue.Receive%2A> method specifies an infinite time-out, the application might wait indefinitely.</span></span> <span data-ttu-id="79d78-2132">비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2132">If the application processing should continue without waiting for the message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2133">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2133">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2134">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2134">Workgroup mode</span></span>|<span data-ttu-id="79d78-2135">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2135">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2136">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2136">Local computer</span></span>|<span data-ttu-id="79d78-2137">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2137">Yes</span></span>|  
|<span data-ttu-id="79d78-2138">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2138">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2139">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2139">Yes</span></span>|  
|<span data-ttu-id="79d78-2140">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2140">Remote computer</span></span>|<span data-ttu-id="79d78-2141">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2141">No</span></span>|  
|<span data-ttu-id="79d78-2142">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2142">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2143">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2143">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2144">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2144">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2145">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2145">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-2146"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2146">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-2147">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2147">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-2148">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2148">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <summary><span data-ttu-id="79d78-2149"><see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 첫 번째 메시지를 받고, 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2149">Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" /> and waits until either a message is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2150">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2150">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2151">이 오버로드를 사용하여 메시지를 받고, 큐에 메시지가 없는 경우에는 지정된 시간 내에 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2151">Use this overload to receive a message and return in a specified period of time if there are no messages in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2152"><xref:System.Messaging.MessageQueue.Receive%2A> 동기적으로 메시지를 읽고에 대 한 메서드를 사용 하면 큐에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2152">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, removing it from the queue.</span></span> <span data-ttu-id="79d78-2153">에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 있는 높은 우선 순위의 메시지가 새로운, 또는 큐에서 다음 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2153">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue, or new, higher priority messages.</span></span>  
  
 <span data-ttu-id="79d78-2154">사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2154">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="79d78-2155"><xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2155">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2156">에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2156">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2157">스레드, 또는 무한정 지정된 된 기간에 대 한 차단 될 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2157">The thread will be blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter.</span></span> <span data-ttu-id="79d78-2158">비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2158">If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2159">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2159">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2160">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2160">Workgroup mode</span></span>|<span data-ttu-id="79d78-2161">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2161">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2162">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2162">Local computer</span></span>|<span data-ttu-id="79d78-2163">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2163">Yes</span></span>|  
|<span data-ttu-id="79d78-2164">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2164">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2165">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2165">Yes</span></span>|  
|<span data-ttu-id="79d78-2166">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2166">Remote computer</span></span>|<span data-ttu-id="79d78-2167">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2167">No</span></span>|  
|<span data-ttu-id="79d78-2168">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2168">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2169">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2169">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2170">다음 코드 예제에서는 큐에서 메시지를 받은 및 화면으로 해당 메시지에 대 한 정보를 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2170">The following code example receives a message from a queue and outputs information about that message to the screen.</span></span> <span data-ttu-id="79d78-2171">이 예제에서는 메시지가 큐에 도착할 때까지 기다리는 동안 최대 5 초 동안 실행이 일시 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2171">The example pauses execution for up to five seconds while waiting for a message to arrive in the queue.</span></span>  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2172"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2172">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2173">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2173">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2174">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2174">-or-</span></span>  
  
 <span data-ttu-id="79d78-2175">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2175">An error occurred when accessing a Message Queuing method</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-2176">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2176">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-2177">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2177">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="cursor"><span data-ttu-id="79d78-2178">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2178">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <summary><span data-ttu-id="79d78-2179">지정된 커서를 사용하여 큐에 있는 현재 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2179">Receives the current message in the queue, using a specified cursor.</span></span> <span data-ttu-id="79d78-2180">사용할 수 있는 메시지가 없는 경우 이 메서드는 메시지를 사용할 수 있거나 시간 제한이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2180">If no message is available, this method waits until either a message is available, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2181">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2181">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2182"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2182">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2183">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2183">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2184">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2184">-or-</span></span>  
  
 <span data-ttu-id="79d78-2185">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2185">An error occurred when accessing a Message Queuing method</span></span>  
  
 <span data-ttu-id="79d78-2186">이 오버로드를 사용하여 메시지를 받고, 큐에 메시지가 없는 경우에는 지정된 시간 내에 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2186">Use this overload to receive a message and return in a specified period of time if there are no messages in the queue.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-2187">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2187">The method is not thread safe.</span></span></threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-2188">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2188">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transaction"><span data-ttu-id="79d78-2189"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</span><span class="sxs-lookup"><span data-stu-id="79d78-2189">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="79d78-2190"><see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐의 첫 번째 메시지를 받으며, 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2190">Receives the first message available in the transactional queue referenced by the <see cref="T:System.Messaging.MessageQueue" /> and waits until either a message is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2191">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2191">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2192">이 오버 로드를 사용 하 여 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 트랜잭션 큐에서 메시지를 수신 하기는 `transaction` 매개 변수 및 큐에 메시지가 없는 경우 시간을 지정 된 기간에 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2192">Use this overload to receive a message from a transactional queue using the internal transaction context defined by the `transaction` parameter, and return within a specified period of time if there are no messages in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2193"><xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2193">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="79d78-2194">에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2194">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2195">트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2195">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2196">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2196">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2197">사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2197">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="79d78-2198"><xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2198">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2199">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2199">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="79d78-2200">때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 에서는 큐의 메시지를 제거 하지 않으며, 호출 하 여 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2200">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2201">에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2201">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2202">스레드, 또는 무한정 지정된 된 기간에 대 한 차단 될 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2202">The thread will be blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter.</span></span> <span data-ttu-id="79d78-2203">비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2203">If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2204">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2204">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2205">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2205">Workgroup mode</span></span>|<span data-ttu-id="79d78-2206">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2206">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2207">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2207">Local computer</span></span>|<span data-ttu-id="79d78-2208">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2208">Yes</span></span>|  
|<span data-ttu-id="79d78-2209">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2209">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2210">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2210">Yes</span></span>|  
|<span data-ttu-id="79d78-2211">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2211">Remote computer</span></span>|<span data-ttu-id="79d78-2212">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2212">No</span></span>|  
|<span data-ttu-id="79d78-2213">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2213">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2214">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2214">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2215">다음 코드 예제에서는이 방법 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2215">The following code example demonstrates the use of this method.</span></span>  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2216"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2216">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2217">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2217">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2218">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2218">-or-</span></span>  
  
 <span data-ttu-id="79d78-2219">비트랜잭션 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2219">The queue is non-transactional.</span></span>  
  
 <span data-ttu-id="79d78-2220">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2220">-or-</span></span>  
  
 <span data-ttu-id="79d78-2221">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2221">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-2222">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2222">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-2223">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2223">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transactionType"><span data-ttu-id="79d78-2224"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2224">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="79d78-2225"><see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2225">Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />.</span></span> <span data-ttu-id="79d78-2226">이 호출은 동기적이므로 큐에 메시지를 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2226">This call is synchronous, and waits until either a message is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2227">큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2227">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2228">이 오버 로드를 사용 하 여 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에서 메시지를 수신 하기는 `transactionType` 매개 변수, 및 지정 된 기간 동안 큐에 메시지가 없는 경우 시간을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2228">Use this overload to receive a message from a queue using a transaction context defined by the `transactionType` parameter, and return in a specified period of time if there are no messages in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2229">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2229">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="79d78-2230">지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2230">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="79d78-2231">지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2231">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="79d78-2232"><xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2232">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="79d78-2233">에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2233">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> will return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2234">이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2234">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2235">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2235">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2236">사용 하 여 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2236">To read the first message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="79d78-2237"><xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2237">The <xref:System.Messaging.MessageQueue.Peek%2A> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2238">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2238">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="79d78-2239">때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 에서는 큐의 메시지를 제거 하지 않으며, 호출 하 여 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2239">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there would be nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2240">에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2240">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2241">스레드, 또는 무한정 지정된 된 기간에 대 한 차단 될 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2241">The thread will be blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter.</span></span> <span data-ttu-id="79d78-2242">비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2242">If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2243">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2243">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2244">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2244">Workgroup mode</span></span>|<span data-ttu-id="79d78-2245">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2245">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2246">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2246">Local computer</span></span>|<span data-ttu-id="79d78-2247">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2247">Yes</span></span>|  
|<span data-ttu-id="79d78-2248">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2248">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2249">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2249">Yes</span></span>|  
|<span data-ttu-id="79d78-2250">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2250">Remote computer</span></span>|<span data-ttu-id="79d78-2251">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2251">No</span></span>|  
|<span data-ttu-id="79d78-2252">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2252">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2253">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2253">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2254">다음 코드 예제에서는이 방법 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2254">The following code example demonstrates the use of this method.</span></span>  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2255"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2255">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-2256"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2256">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2257">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2257">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2258">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2258">-or-</span></span>  
  
 <span data-ttu-id="79d78-2259">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2259">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-2260">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2260">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-2261">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2261">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="cursor"><span data-ttu-id="79d78-2262">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2262">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <param name="transaction"><span data-ttu-id="79d78-2263"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</span><span class="sxs-lookup"><span data-stu-id="79d78-2263">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="79d78-2264">지정된 커서를 사용하여 큐에 있는 현재 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2264">Receives the current message in the queue, using a specified cursor.</span></span> <span data-ttu-id="79d78-2265">사용할 수 있는 메시지가 없는 경우 이 메서드는 메시지를 사용할 수 있거나 시간 제한이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2265">If no message is available, this method waits until either a message is available, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2266">큐에 있는 메시지를 참조하는 <see cref="T:System.Messaging.Message" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2266">A <see cref="T:System.Messaging.Message" /> that references a message in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2267">이 오버 로드를 사용 하 여 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 트랜잭션 큐에서 메시지를 수신 하기는 `transaction` 매개 변수 및 큐에 메시지가 없는 경우 시간을 지정 된 기간에 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2267">Use this overload to receive a message from a transactional queue using the internal transaction context defined by the `transaction` parameter, and return within a specified period of time if there are no messages in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2268"><xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2268">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="79d78-2269">에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2269">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2270">트랜잭션 큐에서이 메서드는, 때문에 트랜잭션이 중단 되 면 받은 메시지를 큐로 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2270">Because this method is called on a transactional queue, the message that is received is returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2271">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2271">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2272">사용 하 여 큐에서 제거 하지 않고 큐의 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2272">To read a message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="79d78-2273">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2273">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="79d78-2274">때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메시지를 제거 하지 않습니다, 호출 하 여 롤백하지 즉 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2274">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there is nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2275">에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2275">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2276">또는 무한정 지정된 된 기간에 대 한 스레드가 차단 되는 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2276">The thread is blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter.</span></span> <span data-ttu-id="79d78-2277">비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2277">If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2278">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2278">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2279">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2279">Workgroup mode</span></span>|<span data-ttu-id="79d78-2280">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2280">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2281">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2281">Local computer</span></span>|<span data-ttu-id="79d78-2282">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2282">Yes</span></span>|  
|<span data-ttu-id="79d78-2283">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2283">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2284">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2284">Yes</span></span>|  
|<span data-ttu-id="79d78-2285">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2285">Remote computer</span></span>|<span data-ttu-id="79d78-2286">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2286">No</span></span>|  
|<span data-ttu-id="79d78-2287">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2287">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2288">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2288">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2289"><paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2289">The <paramref name="cursor" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="79d78-2290">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2290">-or-</span></span>  
  
 <span data-ttu-id="79d78-2291"><paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2291">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2292"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2292">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span> <span data-ttu-id="79d78-2293"><paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2293">Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2294">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2294">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2295">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2295">-or-</span></span>  
  
 <span data-ttu-id="79d78-2296">비트랜잭션 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2296">The queue is non-transactional.</span></span>  
  
 <span data-ttu-id="79d78-2297">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2297">-or-</span></span>  
  
 <span data-ttu-id="79d78-2298">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2298">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-2299">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2299">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="79d78-2300">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2300">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="cursor"><span data-ttu-id="79d78-2301">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2301">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</span></span></param>
        <param name="transactionType"><span data-ttu-id="79d78-2302">메시지와 연결할 트랜잭션 컨텍스트 형식을 설명하는 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2302">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values that describes the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="79d78-2303">지정된 커서를 사용하여 큐에 있는 현재 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2303">Receives the current message in the queue, using a specified cursor.</span></span> <span data-ttu-id="79d78-2304">사용할 수 있는 메시지가 없는 경우 이 메서드는 메시지를 사용할 수 있거나 시간 제한이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2304">If no message is available, this method waits until either a message is available, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2305">큐에 있는 메시지를 참조하는 <see cref="T:System.Messaging.Message" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2305">A <see cref="T:System.Messaging.Message" /> that references a message in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2306">이 오버 로드를 사용 하 여 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에서 메시지를 수신 하기는 `transactionType` 매개 변수, 및 지정 된 기간 동안 큐에 메시지가 없는 경우 시간을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2306">Use this overload to receive a message from a queue using a transaction context defined by the `transactionType` parameter, and return in a specified period of time if there are no messages in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2307">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2307">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="79d78-2308">지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2308">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="79d78-2309">지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2309">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="79d78-2310"><xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거할 동기적으로 메시지를 읽고에 대 한 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2310">The <xref:System.Messaging.MessageQueue.Receive%2A> method allows for the synchronous reading of a message, thereby removing it from the queue.</span></span> <span data-ttu-id="79d78-2311">에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에 있는 다음 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2311">Subsequent calls to <xref:System.Messaging.MessageQueue.Receive%2A> return the messages that follow in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2312">이 메서드는 트랜잭션 큐에서 메시지를 수신 하기, 트랜잭션이 중단 되는 경우 수신 되는 메시지 큐로 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2312">If this method is called to receive a message from a transactional queue, the message that is received is returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2313">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2313">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2314">사용 하 여 큐에서 제거 하지 않고 큐의 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2314">To read a message in a queue without removing it from the queue, use the <xref:System.Messaging.MessageQueue.Peek%2A> method.</span></span> <span data-ttu-id="79d78-2315">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2315">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.Peek%2A>.</span></span> <span data-ttu-id="79d78-2316">때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메시지를 제거 하지 않습니다, 호출 하 여 롤백하지 즉 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2316">Because <xref:System.Messaging.MessageQueue.Peek%2A> does not remove any messages in the queue, there is nothing to roll back by a call to <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2317">에 대 한 호출을 사용 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것은 현재 스레드를 메시지가 큐에 도착 하기를 기다리는 동안 차단 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2317">Use a call to <xref:System.Messaging.MessageQueue.Receive%2A> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2318">또는 무한정 지정된 된 기간에 대 한 스레드가 차단 되는 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2318">The thread is blocked for the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter.</span></span> <span data-ttu-id="79d78-2319">비동기 메서드를 사용 하 여 응용 프로그램 처리를 메시지를 기다리지 않고 계속, 고려 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2319">If the application processing should continue without waiting for a message, consider using the asynchronous method, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="79d78-2320">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2320">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2321">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2321">Workgroup mode</span></span>|<span data-ttu-id="79d78-2322">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2322">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2323">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2323">Local computer</span></span>|<span data-ttu-id="79d78-2324">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2324">Yes</span></span>|  
|<span data-ttu-id="79d78-2325">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2325">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2326">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2326">Yes</span></span>|  
|<span data-ttu-id="79d78-2327">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2327">Remote computer</span></span>|<span data-ttu-id="79d78-2328">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2328">No</span></span>|  
|<span data-ttu-id="79d78-2329">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2329">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2330">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2330">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2331"><paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2331">The <paramref name="cursor" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2332"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2332">The value specified for the <paramref name="timeout" /> parameter is not valid.</span></span> <span data-ttu-id="79d78-2333"><paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2333">Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-2334"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2334">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2335">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2335">A message did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2336">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2336">-or-</span></span>  
  
 <span data-ttu-id="79d78-2337">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2337">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <threadsafe><span data-ttu-id="79d78-2338">메서드는 스레드로부터 안전 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2338">The method is not thread safe.</span></span></threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-2339">주어진 상관 관계 식별자를 갖는 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2339">Receives a message that matches a given correlation identifier.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="79d78-2340">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2340">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <summary><span data-ttu-id="79d78-2341">주어진 상관 관계 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받습니다. 지정된 상관 관계 식별자가 포함된 메시지가 큐에 현재 존재하지 않는 경우에는 바로 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2341">Receives the message that matches the given correlation identifier (from a non-transactional queue) and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-2342">전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2342">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2343">가 참조 비트랜잭션 큐에서이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2343">This method looks in the non-transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="79d78-2344">메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수를 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2344">If no message is found that matches the `correlationID` parameter, an exception is thrown.</span></span> <span data-ttu-id="79d78-2345">그렇지 않으면 메시지 큐에서 제거 되 고 응용 프로그램에 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2345">Otherwise, the message is removed from the queue and returned to the application.</span></span>  
  
 <span data-ttu-id="79d78-2346"><xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2346">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="79d78-2347">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2347">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2348"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 메서드의 고유 식별자를 지정 하 여 메시지를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2348">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method retrieves a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="79d78-2349">사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2349">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2350"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2350">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2351">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2351">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2352">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2352">Workgroup mode</span></span>|<span data-ttu-id="79d78-2353">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2353">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2354">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2354">Local computer</span></span>|<span data-ttu-id="79d78-2355">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2355">Yes</span></span>|  
|<span data-ttu-id="79d78-2356">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2356">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2357">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2357">Yes</span></span>|  
|<span data-ttu-id="79d78-2358">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2358">Remote computer</span></span>|<span data-ttu-id="79d78-2359">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2359">No</span></span>|  
|<span data-ttu-id="79d78-2360">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2360">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2361">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2361">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2362">다음 코드 예제는 큐에서 주문에 포함 된 메시지 송수신 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2362">The following code example sends and receives a message that contains an order to and from a queue.</span></span> <span data-ttu-id="79d78-2363">원본 메시지가 도달 하거나이 긍정 승인을 특별히 요청 큐에서 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2363">It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.</span></span>  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2364"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2364">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-2365">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2365">The message with the specified <paramref name="correlationId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2366">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2366">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="79d78-2367">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2367">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <param name="transaction"><span data-ttu-id="79d78-2368"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</span><span class="sxs-lookup"><span data-stu-id="79d78-2368">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="79d78-2369">주어진 상관 관계 식별자를 갖는 메시지를 트랜잭션 큐로부터 받습니다. 지정된 상관 관계 식별자가 포함된 메시지가 큐에 현재 존재하지 않는 경우에는 바로 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2369">Receives the message that matches the given correlation identifier (from a transactional queue) and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-2370">전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2370">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2371">참조 하는 트랜잭션 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2371">This method looks in the transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="79d78-2372">메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수를 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2372">If no message is found that matches the `correlationID` parameter, an exception is thrown.</span></span> <span data-ttu-id="79d78-2373">그렇지 않으면, 메시지 큐에서 제거 고 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 응용 프로그램에 반환 된 `transaction` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2373">Otherwise, the message is removed from the queue and returned to the application using the internal transaction context defined by the `transaction` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2374">트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2374">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2375">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2375">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2376"><xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2376">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="79d78-2377">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2377">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2378"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2378">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="79d78-2379">사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2379">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2380"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2380">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2381">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2381">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="79d78-2382">때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2382">Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="79d78-2383">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2383">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2384">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2384">Workgroup mode</span></span>|<span data-ttu-id="79d78-2385">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2385">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2386">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2386">Local computer</span></span>|<span data-ttu-id="79d78-2387">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2387">Yes</span></span>|  
|<span data-ttu-id="79d78-2388">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2388">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2389">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2389">Yes</span></span>|  
|<span data-ttu-id="79d78-2390">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2390">Remote computer</span></span>|<span data-ttu-id="79d78-2391">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2391">No</span></span>|  
|<span data-ttu-id="79d78-2392">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2392">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2393">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2393">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2394">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2394">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2395"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2395">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="79d78-2396">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2396">-or-</span></span>  
  
 <span data-ttu-id="79d78-2397"><paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2397">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-2398">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2398">The message with the specified <paramref name="correlationId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2399">비트랜잭션 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2399">The queue is non-transactional.</span></span>  
  
 <span data-ttu-id="79d78-2400">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2400">-or-</span></span>  
  
 <span data-ttu-id="79d78-2401">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2401">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="79d78-2402">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2402">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <param name="transactionType"><span data-ttu-id="79d78-2403"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2403">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="79d78-2404">주어진 상관 관계 식별자를 갖는 메시지를 받습니다. 지정된 상관 관계 식별자가 들어 있는 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2404">Receives the message that matches the given correlation identifier and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-2405">전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2405">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2406">참조 하는 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2406">This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="79d78-2407">메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수를 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2407">If no message is found that matches the `correlationID` parameter, an exception is thrown.</span></span> <span data-ttu-id="79d78-2408">메시지 큐에서 제거 되 고 정의 된 트랜잭션 컨텍스트를 사용 하 여 응용 프로그램에 반환 되는 그렇지 않은 경우는 `transactionType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2408">Otherwise, the message is removed from the queue and returned to the application using a transaction context defined by the `transactionType` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2409">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2409">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="79d78-2410">지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2410">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="79d78-2411">지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2411">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="79d78-2412">이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2412">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2413">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2413">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2414"><xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2414">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="79d78-2415">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2415">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2416"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2416">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="79d78-2417">사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2417">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2418"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2418">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2419">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2419">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="79d78-2420">때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2420">Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="79d78-2421">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2421">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2422">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2422">Workgroup mode</span></span>|<span data-ttu-id="79d78-2423">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2423">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2424">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2424">Local computer</span></span>|<span data-ttu-id="79d78-2425">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2425">Yes</span></span>|  
|<span data-ttu-id="79d78-2426">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2426">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2427">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2427">Yes</span></span>|  
|<span data-ttu-id="79d78-2428">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2428">Remote computer</span></span>|<span data-ttu-id="79d78-2429">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2429">No</span></span>|  
|<span data-ttu-id="79d78-2430">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2430">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2431">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2431">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2432">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2432">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2433"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2433">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-2434">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2434">The message with the specified <paramref name="correlationId" /> could not be found.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-2435"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2435">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2436">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2436">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="79d78-2437">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2437">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="79d78-2438">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2438">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <summary><span data-ttu-id="79d78-2439">주어진 상관 관계 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받고, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2439">Receives the message that matches the given correlation identifier (from a non-transactional queue) and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2440">전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2440">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2441">가 참조 비트랜잭션 큐에서이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2441">This method looks in the non-transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="79d78-2442">이 메서드는 상관 관계 식별자를 가진 메시지에 지정 된 즉시 반환는 `correlationId` 매개 변수는 큐에 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2442">This method returns immediately if the message with the correlation identifier specified by the `correlationId` parameter is in the queue.</span></span> <span data-ttu-id="79d78-2443">그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2443">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="79d78-2444">제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2444">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="79d78-2445">`timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2445">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="79d78-2446">새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2446">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2447">될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하는 새 메시지는 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2447">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter.</span></span> <span data-ttu-id="79d78-2448">그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2448">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="79d78-2449">따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.CorrelationId%2A> 일치는 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2449">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2450"><xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2450">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="79d78-2451">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2451">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2452"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2452">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="79d78-2453">사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2453">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2454"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2454">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2455">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2455">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2456">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2456">Workgroup mode</span></span>|<span data-ttu-id="79d78-2457">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2457">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2458">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2458">Local computer</span></span>|<span data-ttu-id="79d78-2459">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2459">Yes</span></span>|  
|<span data-ttu-id="79d78-2460">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2460">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2461">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2461">Yes</span></span>|  
|<span data-ttu-id="79d78-2462">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2462">Remote computer</span></span>|<span data-ttu-id="79d78-2463">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2463">No</span></span>|  
|<span data-ttu-id="79d78-2464">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2464">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2465">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2465">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2466">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2466">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2467"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2467">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2468"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2468">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2469">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2469">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2470">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2470">-or-</span></span>  
  
 <span data-ttu-id="79d78-2471">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2471">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="79d78-2472">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2472">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="79d78-2473">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2473">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transaction"><span data-ttu-id="79d78-2474"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</span><span class="sxs-lookup"><span data-stu-id="79d78-2474">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="79d78-2475">주어진 상관 관계 식별자를 갖는 메시지를 트랜잭션 큐로부터 받고, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2475">Receives the message that matches the given correlation identifier (from a transactional queue) and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2476">전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2476">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2477">참조 하는 트랜잭션 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2477">This method looks in the transactional queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="79d78-2478">이 메서드는 상관 관계 식별자를 가진 메시지에 지정 된 즉시 반환는 `correlationId` 매개 변수는 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 큐에는 `transaction` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2478">This method returns immediately if the message with the correlation identifier specified by the `correlationId` parameter is in the queue, using the internal transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="79d78-2479">그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2479">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="79d78-2480">제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2480">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="79d78-2481">`timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2481">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="79d78-2482">새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2482">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2483">될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하는 새 메시지는 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2483">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter.</span></span> <span data-ttu-id="79d78-2484">그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2484">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="79d78-2485">따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.CorrelationId%2A> 일치는 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2485">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2486">트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2486">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2487">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2487">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2488"><xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2488">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="79d78-2489">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2489">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2490"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2490">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="79d78-2491">사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2491">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2492"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2492">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2493">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2493">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="79d78-2494">때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2494">Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="79d78-2495">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2495">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2496">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2496">Workgroup mode</span></span>|<span data-ttu-id="79d78-2497">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2497">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2498">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2498">Local computer</span></span>|<span data-ttu-id="79d78-2499">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2499">Yes</span></span>|  
|<span data-ttu-id="79d78-2500">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2500">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2501">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2501">Yes</span></span>|  
|<span data-ttu-id="79d78-2502">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2502">Remote computer</span></span>|<span data-ttu-id="79d78-2503">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2503">No</span></span>|  
|<span data-ttu-id="79d78-2504">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2504">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2505">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2505">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2506">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2506">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2507"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2507">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="79d78-2508">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2508">-or-</span></span>  
  
 <span data-ttu-id="79d78-2509"><paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2509">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2510"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2510">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2511">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2511">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2512">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2512">-or-</span></span>  
  
 <span data-ttu-id="79d78-2513">비트랜잭션 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2513">The queue is non-transactional.</span></span>  
  
 <span data-ttu-id="79d78-2514">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2514">-or-</span></span>  
  
 <span data-ttu-id="79d78-2515">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2515">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId"><span data-ttu-id="79d78-2516">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2516">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="79d78-2517">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2517">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transactionType"><span data-ttu-id="79d78-2518"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2518">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="79d78-2519">주어진 상관 관계 식별자를 갖는 메시지를 받고, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2519">Receives the message that matches the given correlation identifier and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2520">전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2520">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2521">참조 하는 큐에이 메서드를 찾습니다는 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2521">This method looks in the queue referenced by the <xref:System.Messaging.MessageQueue> for a message whose <xref:System.Messaging.Message.CorrelationId%2A> matches the specified `correlationId` parameter.</span></span> <span data-ttu-id="79d78-2522">이 메서드는 상관 관계 식별자를 가진 메시지에 지정 된 즉시 반환는 `correlationId` 매개 변수는 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에는 `transactionType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2522">This method returns immediately if the message with the correlation identifier specified by the `correlationId` parameter is in the queue, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="79d78-2523">그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2523">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="79d78-2524">제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2524">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="79d78-2525">`timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2525">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="79d78-2526">새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2526">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2527">될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하는 새 메시지는 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2527">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.CorrelationId%2A> of the new message to see if it matches the `correlationId` parameter.</span></span> <span data-ttu-id="79d78-2528">그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2528">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="79d78-2529">따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.CorrelationId%2A> 일치는 `correlationId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2529">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.CorrelationId%2A> matches the `correlationId` parameter.</span></span> <span data-ttu-id="79d78-2530">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2530">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="79d78-2531">지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2531">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="79d78-2532">지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2532">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="79d78-2533">이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2533">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2534">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2534">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2535"><xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐에 전송 된 메시지를 연결 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2535">The <xref:System.Messaging.Message.CorrelationId%2A> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</span></span>  
  
 <span data-ttu-id="79d78-2536">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2536">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2537"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 의 고유 식별자를 지정 하 여 메시지를 검색할 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2537">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> method is used to retrieve a message by specifying its unique identifier.</span></span>  
  
 <span data-ttu-id="79d78-2538">사용 하 여 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 가진 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2538">To read a message with a specified correlation identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2539"><xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2539">The <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2540">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2540">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>.</span></span> <span data-ttu-id="79d78-2541">때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2541">Because <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="79d78-2542">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2542">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2543">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2543">Workgroup mode</span></span>|<span data-ttu-id="79d78-2544">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2544">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2545">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2545">Local computer</span></span>|<span data-ttu-id="79d78-2546">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2546">Yes</span></span>|  
|<span data-ttu-id="79d78-2547">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2547">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2548">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2548">Yes</span></span>|  
|<span data-ttu-id="79d78-2549">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2549">Remote computer</span></span>|<span data-ttu-id="79d78-2550">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2550">No</span></span>|  
|<span data-ttu-id="79d78-2551">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2551">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2552">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2552">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2553">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2553">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2554"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2554">The <paramref name="correlationId" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-2555">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2555">The message with the specified <paramref name="correlationId" /> could not be found.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2556"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2556">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-2557"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2557">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2558">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2558">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2559">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2559">-or-</span></span>  
  
 <span data-ttu-id="79d78-2560">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2560">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-2561">주어진 식별자를 갖는 메시지를 받고, 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2561">Receives the message that matches the given identifier, removing it from the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="79d78-2562">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2562">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <summary><span data-ttu-id="79d78-2563">주어진 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받습니다. 지정된 식별자가 들어 있는 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2563">Receives the message that matches the given identifier from a non-transactional queue and immediately raises an exception if no message with the specified identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-2564">전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2564">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2565">이 메서드를 사용 하 여 알려진된 식별자를 갖는 메시지를 읽고 큐에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2565">Use this method to read a message with a known identifier and remove it from the queue.</span></span> <span data-ttu-id="79d78-2566">이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2566">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2567"><xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2567">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2568">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2568">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2569"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2569">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="79d78-2570">사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2570">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2571"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2571">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2572">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2572">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2573">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2573">Workgroup mode</span></span>|<span data-ttu-id="79d78-2574">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2574">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2575">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2575">Local computer</span></span>|<span data-ttu-id="79d78-2576">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2576">Yes</span></span>|  
|<span data-ttu-id="79d78-2577">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2577">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2578">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2578">Yes</span></span>|  
|<span data-ttu-id="79d78-2579">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2579">Remote computer</span></span>|<span data-ttu-id="79d78-2580">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2580">No</span></span>|  
|<span data-ttu-id="79d78-2581">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2581">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2582">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2582">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2583">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2583">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2584"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2584">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-2585">지정된 <paramref name="id" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2585">The message with the specified <paramref name="id" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2586">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2586">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="79d78-2587">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2587">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <param name="transaction"><span data-ttu-id="79d78-2588"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</span><span class="sxs-lookup"><span data-stu-id="79d78-2588">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="79d78-2589">주어진 식별자를 갖는 메시지를 트랜잭션 큐로부터 받습니다. 지정된 식별자가 포함된 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2589">Receives the message that matches the given identifier (from a transactional queue) and immediately raises an exception if no message with the specified identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-2590">전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2590">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2591">이 메서드를 사용 하 여 알려진된 식별자를 가진 포함 된 메시지에 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 하는 `transaction` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2591">Use this method to read a message with a known identifier and remove it from the queue, using the internal transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="79d78-2592">이 메서드에서 예외가 throw 즉시 메시지 큐에 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2592">This method throws an exception immediately if the message is not in the queue</span></span>  
  
 <span data-ttu-id="79d78-2593"><xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2593">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2594">트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2594">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2595">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2595">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2596">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2596">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2597"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2597">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="79d78-2598">사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2598">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2599"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2599">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2600">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2600">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.</span></span> <span data-ttu-id="79d78-2601">때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2601">Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="79d78-2602">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2602">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2603">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2603">Workgroup mode</span></span>|<span data-ttu-id="79d78-2604">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2604">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2605">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2605">Local computer</span></span>|<span data-ttu-id="79d78-2606">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2606">Yes</span></span>|  
|<span data-ttu-id="79d78-2607">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2607">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2608">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2608">Yes</span></span>|  
|<span data-ttu-id="79d78-2609">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2609">Remote computer</span></span>|<span data-ttu-id="79d78-2610">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2610">No</span></span>|  
|<span data-ttu-id="79d78-2611">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2611">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2612">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2612">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2613">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2613">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2614"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2614">The <paramref name="id" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="79d78-2615">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2615">-or-</span></span>  
  
 <span data-ttu-id="79d78-2616"><paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2616">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-2617">지정된 <paramref name="id" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2617">The message with the specified <paramref name="id" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2618">비트랜잭션 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2618">The queue is non-transactional.</span></span>  
  
 <span data-ttu-id="79d78-2619">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2619">-or-</span></span>  
  
 <span data-ttu-id="79d78-2620">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2620">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="79d78-2621">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2621">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <param name="transactionType"><span data-ttu-id="79d78-2622"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2622">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="79d78-2623">주어진 식별자를 갖는 메시지를 받습니다. 지정된 식별자가 포함된 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2623">Receives the message that matches the given identifier and immediately raises an exception if no message with the specified identifier currently exists in the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-2624">전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2624">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2625">이 메서드를 사용 하 여 알려진된 식별자를 갖는 메시지를 읽고 큐에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2625">Use this method to read a message with a known identifier and remove it from the queue.</span></span> <span data-ttu-id="79d78-2626">이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2626">This method throws an exception immediately if the message is not in the queue.</span></span> <span data-ttu-id="79d78-2627">메시지 큐에서 제거 되 고 정의 된 트랜잭션 컨텍스트를 사용 하 여 응용 프로그램에 반환 되는 그렇지 않은 경우는 `transactionType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2627">Otherwise, the message is removed from the queue and returned to the application using a transaction context defined by the `transactionType` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2628">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2628">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="79d78-2629">지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2629">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="79d78-2630">지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2630">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="79d78-2631"><xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2631">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span> <span data-ttu-id="79d78-2632">지정한 식별자를 가진 메시지는 큐와 연결 된 것과 다른 경우 <xref:System.Messaging.MessageQueue> 인스턴스 메시지를 찾을 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2632">If the message with the specified identifier is in a queue other than the one associated with this <xref:System.Messaging.MessageQueue> instance, the message will not be found.</span></span>  
  
 <span data-ttu-id="79d78-2633">이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2633">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2634">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2634">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2635">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2635">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2636"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2636">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="79d78-2637">사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2637">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2638"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2638">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2639">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2639">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.</span></span> <span data-ttu-id="79d78-2640">때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2640">Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="79d78-2641">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2641">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2642">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2642">Workgroup mode</span></span>|<span data-ttu-id="79d78-2643">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2643">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2644">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2644">Local computer</span></span>|<span data-ttu-id="79d78-2645">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2645">Yes</span></span>|  
|<span data-ttu-id="79d78-2646">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2646">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2647">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2647">Yes</span></span>|  
|<span data-ttu-id="79d78-2648">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2648">Remote computer</span></span>|<span data-ttu-id="79d78-2649">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2649">No</span></span>|  
|<span data-ttu-id="79d78-2650">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2650">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2651">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2651">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2652">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2652">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2653"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2653">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-2654">지정된 <paramref name="id" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2654">The message with the specified <paramref name="id" /> could not be found.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-2655"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2655">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2656">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2656">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="79d78-2657">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2657">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="79d78-2658">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2658">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <summary><span data-ttu-id="79d78-2659">주어진 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받고, 지정된 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2659">Receives the message that matches the given identifier (from a non-transactional queue) and waits until either a message with the specified identifier is available in the queue or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2660">전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2660">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2661">이 메서드를 사용 하 여 알려진된 식별자를 갖는 메시지를 읽고 큐에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2661">Use this method to read a message with a known identifier and remove it from the queue.</span></span> <span data-ttu-id="79d78-2662">이 메서드는 식별자를 가진 메시지에 지정 된 즉시 반환는 `id` 매개 변수는 큐에 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2662">This method returns immediately if the message with the identifier specified by the `id` parameter is in the queue.</span></span> <span data-ttu-id="79d78-2663">그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2663">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="79d78-2664">제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2664">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="79d78-2665">`timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2665">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="79d78-2666">새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2666">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2667">될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하는 새 메시지는 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2667">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter.</span></span> <span data-ttu-id="79d78-2668">그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2668">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="79d78-2669">따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.Id%2A> 일치는 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2669">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2670"><xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2670">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2671">이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 것이 현재 스레드를 차단 하 여 새 메시지에 지정한 제한 시간 내에 큐에 도착 계속으로 허용 되는 `timeout` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2671">Use this overload of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.</span></span> <span data-ttu-id="79d78-2672">스레드가 차단 됩니다 이상, 또는 무한정 지정된 된 기간 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수를 새 메시지가 계속 하 여 지정 된 제한 시간 내에 큐에 도착 하는 경우 또는 `timeout` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2672">The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter, or if new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2673">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2673">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2674"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2674">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="79d78-2675">사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2675">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2676"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2676">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2677">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2677">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2678">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2678">Workgroup mode</span></span>|<span data-ttu-id="79d78-2679">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2679">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2680">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2680">Local computer</span></span>|<span data-ttu-id="79d78-2681">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2681">Yes</span></span>|  
|<span data-ttu-id="79d78-2682">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2682">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2683">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2683">Yes</span></span>|  
|<span data-ttu-id="79d78-2684">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2684">Remote computer</span></span>|<span data-ttu-id="79d78-2685">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2685">No</span></span>|  
|<span data-ttu-id="79d78-2686">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2686">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2687">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2687">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2688">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2688">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2689"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2689">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2690"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2690">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2691">제한 시간이 만료되기 전에 <paramref name="id" />가 지정된 메시지가 큐에 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2691">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2692">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2692">-or-</span></span>  
  
 <span data-ttu-id="79d78-2693">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2693">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="79d78-2694">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2694">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="79d78-2695">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2695">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transaction"><span data-ttu-id="79d78-2696"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</span><span class="sxs-lookup"><span data-stu-id="79d78-2696">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="79d78-2697">주어진 식별자를 갖는 메시지를 트랜잭션 큐로부터 받고, 지정된 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2697">Receives the message that matches the given identifier (from a transactional queue) and waits until either a message with the specified identifier is available in the queue or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2698">전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2698">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2699">이 메서드를 사용 하 여 알려진된 식별자를 가진 포함 된 메시지에 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 하는 `transaction` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2699">Use this method to read a message with a known identifier and remove it from the queue, using the internal transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="79d78-2700">이 메서드는 식별자를 가진 메시지에 지정 된 즉시 반환는 `id` 매개 변수는 큐에 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2700">This method returns immediately if the message with the identifier specified by the `id` parameter is in the queue.</span></span> <span data-ttu-id="79d78-2701">그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2701">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="79d78-2702">제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2702">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="79d78-2703">`timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2703">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="79d78-2704">새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2704">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2705">될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하는 새 메시지는 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2705">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter.</span></span> <span data-ttu-id="79d78-2706">그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2706">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="79d78-2707">따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.Id%2A> 일치는 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2707">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2708"><xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2708">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2709">이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 것이 현재 스레드를 차단 하 여 새 메시지에 지정한 제한 시간 내에 큐에 도착 계속으로 허용 되는 `timeout` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2709">Use this overload of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.</span></span> <span data-ttu-id="79d78-2710">스레드가 차단 됩니다 이상, 또는 무한정 지정된 된 기간 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수를 새 메시지에 지정 된 시간 제한 기간 내에 큐에 도착 계속 되 면 또는 `timeout` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2710">The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter, or if new messages continue to arrive in the queue within the timeout period specified by the `timeout` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2711">트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2711">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2712">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2712">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2713">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2713">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2714"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2714">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="79d78-2715">사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2715">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2716"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2716">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message, unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2717">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2717">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.</span></span> <span data-ttu-id="79d78-2718">때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2718">Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="79d78-2719">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2719">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2720">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2720">Workgroup mode</span></span>|<span data-ttu-id="79d78-2721">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2721">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2722">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2722">Local computer</span></span>|<span data-ttu-id="79d78-2723">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2723">Yes</span></span>|  
|<span data-ttu-id="79d78-2724">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2724">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2725">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2725">Yes</span></span>|  
|<span data-ttu-id="79d78-2726">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2726">Remote computer</span></span>|<span data-ttu-id="79d78-2727">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2727">No</span></span>|  
|<span data-ttu-id="79d78-2728">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2728">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2729">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2729">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2730">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2730">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2731"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2731">The <paramref name="id" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="79d78-2732">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2732">-or-</span></span>  
  
 <span data-ttu-id="79d78-2733"><paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2733">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2734"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2734">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2735">제한 시간이 만료되기 전에 <paramref name="id" />가 지정된 메시지가 큐에 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2735">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2736">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2736">-or-</span></span>  
  
 <span data-ttu-id="79d78-2737">비트랜잭션 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2737">The queue is non-transactional.</span></span>  
  
 <span data-ttu-id="79d78-2738">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2738">-or-</span></span>  
  
 <span data-ttu-id="79d78-2739">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2739">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="79d78-2740">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2740">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</span></span></param>
        <param name="timeout"><span data-ttu-id="79d78-2741">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2741">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</span></span></param>
        <param name="transactionType"><span data-ttu-id="79d78-2742"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2742">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="79d78-2743">주어진 식별자를 갖는 메시지를 받고, 지정된 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2743">Receives the message that matches the given identifier and waits until either a message with the specified identifier is available in the queue or the time-out expires.</span></span></summary>
        <returns><span data-ttu-id="79d78-2744">전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2744">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2745">이 메서드를 사용 하 여 알려진된 식별자를 갖는 메시지를 읽고 큐에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2745">Use this method to read a message with a known identifier and remove it from the queue.</span></span> <span data-ttu-id="79d78-2746">이 메서드는 식별자를 가진 메시지에 지정 된 즉시 반환는 `id` 매개 변수는 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에는 `transactionType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2746">This method returns immediately if the message with the identifier specified by the `id` parameter is in the queue, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="79d78-2747">그렇지 않으면 메서드는 도착 하는 데 새 메시지에 대해 지정 된 기간을 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2747">Otherwise, the method waits the given period of time for a new message to arrive.</span></span> <span data-ttu-id="79d78-2748">제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2748">If a new message does not arrive before the time-out expires, an exception is thrown.</span></span>  
  
 <span data-ttu-id="79d78-2749">`timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2749">The `timeout` parameter does not specify the total running time for this method.</span></span> <span data-ttu-id="79d78-2750">새 메시지가 큐에 도착할 때까지 대기 하는 시간을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2750">Rather, it specifies the time to wait for a new message to arrive in the queue.</span></span> <span data-ttu-id="79d78-2751">될 때마다 새 메시지가 도착 하면이 메서드는 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하는 새 메시지는 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2751">Each time a new message arrives, this method examines the <xref:System.Messaging.Message.Id%2A> of the new message to see if it matches the `id` parameter.</span></span> <span data-ttu-id="79d78-2752">그렇지 않으면이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2752">If not, this method starts the time-out period over and waits for another new message to arrive.</span></span> <span data-ttu-id="79d78-2753">따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것이 제한 된 시간까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드 <xref:System.Messaging.Message.Id%2A> 일치는 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2753">Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <xref:System.Messaging.Message.Id%2A> matches the `id` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2754">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2754">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="79d78-2755">지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2755">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="79d78-2756">지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2756">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="79d78-2757"><xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유는 주어진 `id` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2757">The <xref:System.Messaging.Message.Id%2A> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given `id` parameter.</span></span> <span data-ttu-id="79d78-2758">지정한 식별자를 가진 메시지는 큐와 연결 된 것과 다른 경우 <xref:System.Messaging.MessageQueue> 인스턴스 메시지를 찾을 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2758">If the message with the specified identifier is in a queue other than the one associated with this <xref:System.Messaging.MessageQueue> instance, the message will not be found.</span></span>  
  
 <span data-ttu-id="79d78-2759">이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 것이 현재 스레드를 차단 하 여 새 메시지에 지정한 제한 시간 내에 큐에 도착 계속으로 허용 되는 `timeout` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2759">Use this overload of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.</span></span> <span data-ttu-id="79d78-2760">스레드가 차단 됩니다 이상, 또는 무한정 지정된 된 기간 값을 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수를 새 메시지가 계속 하 여 지정 된 제한 시간 내에 큐에 도착 하는 경우 또는 `timeout` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2760">The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <xref:System.Messaging.MessageQueue.InfiniteTimeout> for the `timeout` parameter, or if new messages continue to arrive in the queue within the time-out period specified by the `timeout` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2761">이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2761">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2762">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2762">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2763">다른 두 메서드를 사용 하는 큐에서 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2763">Two other methods allow you to receive messages from a queue.</span></span> <span data-ttu-id="79d78-2764"><xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드를 사용 하는 승인, 보고서 또는 큐로 보낸 메시지 결과로 생성 된 응용 프로그램 생성 응답 메시지를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2764">The <xref:System.Messaging.MessageQueue.Receive%2A> method returns the first message in the queue, and the <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</span></span>  
  
 <span data-ttu-id="79d78-2765">사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2765">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method.</span></span> <span data-ttu-id="79d78-2766"><xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지는 큐에서 우선 순위가 높은 메시지가 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출 동일한 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2766">The <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</span></span> <span data-ttu-id="79d78-2767">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2767">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.</span></span> <span data-ttu-id="79d78-2768">때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우 롤백될 수, 큐에 메시지를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2768">Because <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="79d78-2769">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2769">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2770">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2770">Workgroup mode</span></span>|<span data-ttu-id="79d78-2771">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2771">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2772">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2772">Local computer</span></span>|<span data-ttu-id="79d78-2773">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2773">Yes</span></span>|  
|<span data-ttu-id="79d78-2774">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2774">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2775">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2775">Yes</span></span>|  
|<span data-ttu-id="79d78-2776">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2776">Remote computer</span></span>|<span data-ttu-id="79d78-2777">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2777">No</span></span>|  
|<span data-ttu-id="79d78-2778">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2778">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2779">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2779">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2780">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2780">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2781"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2781">The <paramref name="id" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-2782"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2782">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2783">제한 시간이 만료되기 전에 <paramref name="id" />가 지정된 메시지가 큐에 도착하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2783">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.</span></span>  
  
 <span data-ttu-id="79d78-2784">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2784">-or-</span></span>  
  
 <span data-ttu-id="79d78-2785">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2785">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-2786"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2786">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-2787">MSMQ 3.0에서 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2787">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="79d78-2788">큐에서 특정 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2788">Receives a specific message from the queue.</span></span> <span data-ttu-id="79d78-2789">메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2789">The message can be specified by a lookup identifier or by its position at the front or end of the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId"><span data-ttu-id="79d78-2790">받을 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2790">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive.</span></span></param>
        <summary><span data-ttu-id="79d78-2791">MSMQ 3.0에서 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2791">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="79d78-2792">비트랜잭션 큐에서 지정된 조회 식별자를 갖는 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2792">Receives the message that matches the given lookup identifier from a non-transactional queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-2793">전달된 <paramref name="lookupId" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.LookupId" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2793">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.LookupId" /> property matches the <paramref name="lookupId" /> parameter passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2794">이 메서드를 사용 하 여 알려진된 조회 식별자를 갖는 메시지를 큐에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2794">Use this method to read a message with a known lookup identifier and remove it from the queue.</span></span> <span data-ttu-id="79d78-2795">이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2795">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2796"><xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 해당 메시지가 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 주어진 `lookupId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2796">The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2797">지정한 lookup 식별자와 메시지를 읽으려면 큐에서 제거 하지 않고, 사용 된 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2797">To read a message with a specified lookup identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> method.</span></span>  
  
 <span data-ttu-id="79d78-2798">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2798">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2799">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2799">Workgroup mode</span></span>|<span data-ttu-id="79d78-2800">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2800">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2801">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2801">Local computer</span></span>|<span data-ttu-id="79d78-2802">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2802">Yes</span></span>|  
|<span data-ttu-id="79d78-2803">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2803">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2804">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2804">Yes</span></span>|  
|<span data-ttu-id="79d78-2805">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2805">Remote computer</span></span>|<span data-ttu-id="79d78-2806">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2806">No</span></span>|  
|<span data-ttu-id="79d78-2807">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2807">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2808">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2808">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="79d78-2809">MSMQ 3.0이 설치되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2809">MSMQ 3.0 is not installed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-2810">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2810">The message with the specified <paramref name="lookupId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2811">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2811">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="79d78-2812">큐에서 메시지를 읽는 방법을 지정하는 <see cref="T:System.Messaging.MessageLookupAction" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2812">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue.</span></span> <span data-ttu-id="79d78-2813">다음 중 하나를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2813">Specify one of the following:</span></span>  
  
 <span data-ttu-id="79d78-2814"><see langword="MessageLookupAction.Current" />: <c>lookupId</c>로 지정된 메시지를 받고 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2814"><see langword="MessageLookupAction.Current" />: Receives the message specified by <c>lookupId</c> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="79d78-2815"><see langword="MessageLookupAction.Next" />: <c>lookupId</c>로 지정된 메시지의 뒤에 있는 메시지를 받고 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2815"><see langword="MessageLookupAction.Next" />: Receives the message following the message specified by <c>lookupId</c> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="79d78-2816"><see langword="MessageLookupAction.Previous" />: <c>lookupId</c>로 지정된 메시지의 앞에 있는 메시지를 받고 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2816"><see langword="MessageLookupAction.Previous" />: Receives the message preceding the message specified by <c>lookupId</c> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="79d78-2817"><see langword="MessageLookupAction.First" />: 큐에 있는 첫 번째 메시지를 받고 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2817"><see langword="MessageLookupAction.First" />: Receives the first message in the queue and removes it from the queue.</span></span> <span data-ttu-id="79d78-2818"><c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2818">The <c>lookupId</c> parameter must be set to 0.</span></span>  
  
 <span data-ttu-id="79d78-2819"><see langword="MessageLookupAction.Last" />: 큐에 있는 마지막 메시지를 받고 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2819"><see langword="MessageLookupAction.Last" />: Receives the last message in the queue and removes it from the queue.</span></span> <span data-ttu-id="79d78-2820"><c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2820">The <c>lookupId</c> parameter must be set to 0.</span></span></param>
        <param name="lookupId"><span data-ttu-id="79d78-2821">0을 수신할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2821">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive, or 0.</span></span> <span data-ttu-id="79d78-2822">0은 큐에 있는 첫 번째 또는 마지막 메시지에 액세스할 때 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2822">0 is used when accessing the first or last message in the queue.</span></span></param>
        <param name="transaction"><span data-ttu-id="79d78-2823"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</span><span class="sxs-lookup"><span data-stu-id="79d78-2823">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="79d78-2824">MSMQ 3.0에서 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2824">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="79d78-2825">트랜잭션 큐에서 특정 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2825">Receives a specific message from a transactional queue.</span></span> <span data-ttu-id="79d78-2826">메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2826">The message can be specified by a lookup identifier or by its position at the front or end of the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-2827">전달된 <paramref name="lookupId" /> 및 <paramref name="action" /> 매개 변수로 지정된 <see cref="T:System.Messaging.Message" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2827">The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="lookupId" /> and <paramref name="action" /> parameters passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2828">이 메서드를 사용 하 여 알려진된 조회 식별자를 갖는 메시지 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 하는 `transaction` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2828">Use this method to read a message with a known lookup identifier and remove it from the queue, using a transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="79d78-2829">이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2829">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2830"><xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 해당 메시지가 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 주어진 `lookupId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2830">The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2831">트랜잭션 큐에서이 메서드는, 때문에 받은 메시지가 반환 됩니다 큐에 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2831">Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2832">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2832">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2833">사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2833">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> method.</span></span> <span data-ttu-id="79d78-2834">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2834">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>.</span></span> <span data-ttu-id="79d78-2835">때문에 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 트랜잭션이 중단 된 경우 롤백될 수, 큐에서 메시지를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2835">Because <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> does not remove any messages from the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="79d78-2836">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2836">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2837">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2837">Workgroup mode</span></span>|<span data-ttu-id="79d78-2838">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2838">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2839">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2839">Local computer</span></span>|<span data-ttu-id="79d78-2840">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2840">Yes</span></span>|  
|<span data-ttu-id="79d78-2841">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2841">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2842">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2842">Yes</span></span>|  
|<span data-ttu-id="79d78-2843">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2843">Remote computer</span></span>|<span data-ttu-id="79d78-2844">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2844">No</span></span>|  
|<span data-ttu-id="79d78-2845">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2845">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2846">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2846">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="79d78-2847">MSMQ 3.0이 설치되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2847">MSMQ 3.0 is not installed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-2848">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2848">The message with the specified <paramref name="lookupId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2849">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2849">An error occurred when accessing a Message Queuing method.</span></span>  
  
 <span data-ttu-id="79d78-2850">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2850">-or-</span></span>  
  
 <span data-ttu-id="79d78-2851">비트랜잭션 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2851">The queue is non-transactional.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-2852"><paramref name="action" /> 매개 변수가 <see cref="T:System.Messaging.MessageLookupAction" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2852">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="79d78-2853">큐에서 메시지를 읽는 방법을 지정하는 <see cref="T:System.Messaging.MessageLookupAction" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2853">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue.</span></span> <span data-ttu-id="79d78-2854">다음 중 하나를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2854">Specify one of the following:</span></span>  
  
 <span data-ttu-id="79d78-2855"><see langword="MessageLookupAction.Current" />: <c>lookupId</c>로 지정된 메시지를 받고 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2855"><see langword="MessageLookupAction.Current" />: Receives the message specified by <c>lookupId</c> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="79d78-2856"><see langword="MessageLookupAction.Next" />: <c>lookupId</c>로 지정된 메시지의 뒤에 있는 메시지를 받고 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2856"><see langword="MessageLookupAction.Next" />: Receives the message following the message specified by <c>lookupId</c> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="79d78-2857"><see langword="MessageLookupAction.Previous" />: <c>lookupId</c>로 지정된 메시지의 앞에 있는 메시지를 받고 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2857"><see langword="MessageLookupAction.Previous" />: Receives the message preceding the message specified by <c>lookupId</c> and removes it from the queue.</span></span>  
  
 <span data-ttu-id="79d78-2858"><see langword="MessageLookupAction.First" />: 큐에 있는 첫 번째 메시지를 받고 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2858"><see langword="MessageLookupAction.First" />: Receives the first message in the queue and removes it from the queue.</span></span> <span data-ttu-id="79d78-2859"><c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2859">The <c>lookupId</c> parameter must be set to 0.</span></span>  
  
 <span data-ttu-id="79d78-2860"><see langword="MessageLookupAction.Last" />: 큐에 있는 마지막 메시지를 받고 큐에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2860"><see langword="MessageLookupAction.Last" />: Receives the last message in the queue and removes it from the queue.</span></span> <span data-ttu-id="79d78-2861"><c>lookupId</c> 매개 변수를 0으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2861">The <c>lookupId</c> parameter must be set to 0.</span></span></param>
        <param name="lookupId"><span data-ttu-id="79d78-2862">0을 수신할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2862">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive, or 0.</span></span> <span data-ttu-id="79d78-2863">0은 큐에 있는 첫 번째 또는 마지막 메시지에 액세스할 때 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2863">0 is used when accessing the first or last message in the queue.</span></span></param>
        <param name="transactionType"><span data-ttu-id="79d78-2864"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2864">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="79d78-2865">MSMQ 3.0에서 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2865">Introduced in MSMQ 3.0.</span></span> <span data-ttu-id="79d78-2866">지정된 트랜잭션 컨텍스트를 사용하여 큐에서 특정 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2866">Receives a specific message from the queue, using the specified transaction context.</span></span> <span data-ttu-id="79d78-2867">메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2867">The message can be specified by a lookup identifier or by its position at the front or end of the queue.</span></span></summary>
        <returns><span data-ttu-id="79d78-2868">전달된 <paramref name="action" /> 및 <paramref name="lookupId" /> 매개 변수로 지정된 <see cref="T:System.Messaging.Message" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2868">The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="action" /> and <paramref name="lookupId" /> parameters passed in.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2869">이 메서드를 사용 하 여 알려진된 조회 식별자를 갖는 메시지 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 하는 `transactionType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2869">Use this method to read a message with a known lookup identifier and remove it from the queue, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="79d78-2870">이 메서드는 메시지 큐에 없는 경우 예외가 즉시 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2870">This method throws an exception immediately if the message is not in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2871"><xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 해당 메시지가 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 주어진 `lookupId` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2871">The <xref:System.Messaging.Message.LookupId%2A> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given `lookupId` parameter.</span></span>  
  
 <span data-ttu-id="79d78-2872">사용 하 여 큐에서 제거 하지 않고 지정 된 식별자를 갖는 메시지를 읽으려면는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="79d78-2872">To read a message with a specified identifier without removing it from the queue, use the <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> method.</span></span> <span data-ttu-id="79d78-2873">에 대 한 호출에서 반환 된 메시지와 관련 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2873">There is no transaction context associated with a message returned by a call to <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>.</span></span> <span data-ttu-id="79d78-2874">때문에 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 트랜잭션이 중단 된 경우 롤백될 수, 큐에서 메시지를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2874">Because <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> does not remove any messages from the queue, there would be nothing to roll back if the transaction were aborted.</span></span>  
  
 <span data-ttu-id="79d78-2875">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수를 사용 하는 메시지를 받을 원하는 스레드에 연결 된입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2875">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="79d78-2876">지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2876">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="79d78-2877">지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐에서 메시지를 수신 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-2877">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="79d78-2878">이 메서드를 호출 하 여 트랜잭션 큐에서 메시지를 수신 하기, 받은 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2878">If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</span></span> <span data-ttu-id="79d78-2879">메시지는 영구적으로 제거 되지 큐에서 트랜잭션이 커밋될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2879">The message is not permanently removed from the queue until the transaction is committed.</span></span>  
  
 <span data-ttu-id="79d78-2880">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2880">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2881">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2881">Workgroup mode</span></span>|<span data-ttu-id="79d78-2882">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2882">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2883">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2883">Local computer</span></span>|<span data-ttu-id="79d78-2884">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2884">Yes</span></span>|  
|<span data-ttu-id="79d78-2885">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2885">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2886">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2886">Yes</span></span>|  
|<span data-ttu-id="79d78-2887">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2887">Remote computer</span></span>|<span data-ttu-id="79d78-2888">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2888">No</span></span>|  
|<span data-ttu-id="79d78-2889">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2889">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2890">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2890">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="79d78-2891">MSMQ 3.0이 설치되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2891">MSMQ 3.0 is not installed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79d78-2892">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2892">The message with the specified <paramref name="lookupId" /> could not be found.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2893">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2893">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-2894"><paramref name="action" /> 매개 변수가 <see cref="T:System.Messaging.MessageLookupAction" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2894">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.</span></span>  
  
 <span data-ttu-id="79d78-2895">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2895">-or-</span></span>  
  
 <span data-ttu-id="79d78-2896"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2896">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-2897">큐에서 메시지가 제거된 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2897">Occurs when a message has been removed from the queue.</span></span> <span data-ttu-id="79d78-2898">이 이벤트는 비동기 작업인 <see cref="M:System.Messaging.MessageQueue.BeginReceive" />에 의해 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2898">This event is raised by the asynchronous operation, <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2899"><xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 처리에서 발생 하는 데 사용 되는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 메시지가 큐에서 사용할 수 있는 때입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2899"><xref:System.Messaging.MessageQueue.BeginReceive%2A> is used in asynchronous processing to raise the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event when a message is available in the queue.</span></span>  
  
 <span data-ttu-id="79d78-2900"><xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 하 여 시작 된 작업을 완료 하는 데는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 및 메시지 피킹 때는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2900"><xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> is used to complete the operation initiated by a call to <xref:System.Messaging.MessageQueue.BeginReceive%2A> and peek the message when the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised.</span></span>  
  
 <span data-ttu-id="79d78-2901"><xref:System.Messaging.ReceiveCompletedEventHandler> 대리자를 만들 때, 이벤트를 처리할 메서드를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2901">When you create a <xref:System.Messaging.ReceiveCompletedEventHandler> delegate, you identify the method that will handle the event.</span></span> <span data-ttu-id="79d78-2902">이벤트를 이벤트 처리기와 연결하려면 대리자의 인스턴스를 해당 이벤트에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2902">To associate the event with your event handler, add an instance of the delegate to the event.</span></span> <span data-ttu-id="79d78-2903">대리자를 제거하지 않는 경우 이벤트가 발생할 때마다 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2903">The event handler is called whenever the event occurs, unless you remove the delegate.</span></span> <span data-ttu-id="79d78-2904">이벤트 처리기 대리자에 대 한 자세한 내용은 참조 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2904">For more information about event handler delegates, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2905">다음 코드 예제에서는 라는 이벤트 처리기를 만들고 `MyReceiveCompleted`에 연결는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 처리기 대리자 및 호출 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시작 하는 비동기 수신 작업의 경로에 있는 큐에 ". \myQueue"입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2905">The following code example creates an event handler named `MyReceiveCompleted`, attaches it to the <xref:System.Messaging.MessageQueue.ReceiveCompleted> event handler delegate, and calls <xref:System.Messaging.MessageQueue.BeginReceive%2A> to initiate an asynchronous receive operation on the queue that is located at the path ".\myQueue".</span></span> <span data-ttu-id="79d78-2906">경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면이 예제는 메시지를 받고 화면으로 해당 본문을 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2906">When a <xref:System.Messaging.MessageQueue.ReceiveCompleted> event is raised, the example receives the message and writes its body to the screen.</span></span> <span data-ttu-id="79d78-2907">이 예에서는 다음 호출 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 새 시작을 다시 비동기 수신 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2907">The example then calls <xref:System.Messaging.MessageQueue.BeginReceive%2A> again to initiate a new asynchronous receive operation.</span></span>  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-2908"><see cref="T:System.Messaging.MessageQueue" />가 제공하는 속성을 새로 고쳐 리소스의 현재 상태를 반영합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2908">Refreshes the properties presented by the <see cref="T:System.Messaging.MessageQueue" /> to reflect the current state of the resource.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2909"><xref:System.Messaging.MessageQueue.Refresh%2A> 속성을 동기화 하는 <xref:System.Messaging.MessageQueue> 리소스가 있는 해당 연결 된 메시지 큐 서버입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2909"><xref:System.Messaging.MessageQueue.Refresh%2A> synchronizes the properties of a <xref:System.Messaging.MessageQueue> with its associated Message Queuing server resource.</span></span> <span data-ttu-id="79d78-2910">경우 속성을 같은 <xref:System.Messaging.MessageQueue.Label%2A> 또는 <xref:System.Messaging.MessageQueue.Category%2A>, 시간 이후 서버에서 변경 되었습니다는 <xref:System.Messaging.MessageQueue> 만들어진 <xref:System.Messaging.MessageQueue.Refresh%2A> 업데이트는 <xref:System.Messaging.MessageQueue> 새 정보로 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2910">If any property, such as <xref:System.Messaging.MessageQueue.Label%2A> or <xref:System.Messaging.MessageQueue.Category%2A>, has changed on the server since the time the <xref:System.Messaging.MessageQueue> was created, <xref:System.Messaging.MessageQueue.Refresh%2A> updates the <xref:System.Messaging.MessageQueue> with the new information.</span></span>  
  
 <span data-ttu-id="79d78-2911">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2911">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2912">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2912">Workgroup mode</span></span>|<span data-ttu-id="79d78-2913">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2913">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2914">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2914">Local computer</span></span>|<span data-ttu-id="79d78-2915">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2915">Yes</span></span>|  
|<span data-ttu-id="79d78-2916">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2916">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2917">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2917">Yes</span></span>|  
|<span data-ttu-id="79d78-2918">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2918">Remote computer</span></span>|<span data-ttu-id="79d78-2919">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2919">No</span></span>|  
|<span data-ttu-id="79d78-2920">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2920">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2921">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2921">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2922">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Refresh%2A>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2922">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Refresh%2A>.</span></span>  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79d78-2923">사용 권한 목록을 운영 체제의 기본값으로 다시 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2923">Resets the permission list to the operating system's default values.</span></span> <span data-ttu-id="79d78-2924">기본 목록에 추가한 큐 권한을 모두 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2924">Removes any queue permissions you have appended to the default list.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2925">호출 하는 경우 <xref:System.Messaging.MessageQueue.ResetPermissions%2A>를 기본값으로 사용 권한 목록을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2925">When you call <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, you return the permission list to its default values.</span></span> <span data-ttu-id="79d78-2926">일반적으로이 큐 작성자 모든 사용 권한을 부여 하 고 Everyone 그룹에 게 다음 권한을:</span><span class="sxs-lookup"><span data-stu-id="79d78-2926">Generally, this grants the queue creator all permissions, and gives the group Everyone the following rights:</span></span>  
  
-   <span data-ttu-id="79d78-2927">큐의 속성을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2927">Get the properties of the queue.</span></span>  
  
-   <span data-ttu-id="79d78-2928">큐 권한을 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2928">Get queue permissions.</span></span>  
  
-   <span data-ttu-id="79d78-2929">큐에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2929">Write to the queue.</span></span>  
  
 <span data-ttu-id="79d78-2930">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2930">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2931">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2931">Workgroup mode</span></span>|<span data-ttu-id="79d78-2932">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2932">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2933">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2933">Local computer</span></span>|<span data-ttu-id="79d78-2934">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2934">Yes</span></span>|  
|<span data-ttu-id="79d78-2935">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2935">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2936">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2936">Yes</span></span>|  
|<span data-ttu-id="79d78-2937">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2937">Remote computer</span></span>|<span data-ttu-id="79d78-2938">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2938">No</span></span>|  
|<span data-ttu-id="79d78-2939">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2939">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2940">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2940">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2941">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ResetPermissions%2A>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2941">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.</span></span>  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2942">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2942">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-2943">큐에 개체를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2943">Sends an object to a queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="79d78-2944">큐에 보낼 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2944">The object to send to the queue.</span></span></param>
        <summary><span data-ttu-id="79d78-2945">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 비트랜잭션 큐에 개체를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2945">Sends an object to non-transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2946">이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2946">Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="79d78-2947">큐에 보내는 개체 수는 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2947">The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object.</span></span> <span data-ttu-id="79d78-2948">이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2948">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span>  
  
 <span data-ttu-id="79d78-2949">이 오버 로드를 사용 하 여 트랜잭션 큐로 메시지를 보내려고 하면 메시지가 배달 못 한 편지 큐로 보내집니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2949">If you use this overload to send a message to a transactional queue, the message will be sent to the dead-letter queue.</span></span> <span data-ttu-id="79d78-2950">사용 하는 오버 로드를 사용 하 여 메시지가 다른 메시지를 포함 하는 트랜잭션의 일부가 되도록 하려는 경우는 <xref:System.Messaging.MessageQueueTransaction> 또는 <xref:System.Messaging.MessageQueueTransactionType> 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2950">If you want the message to be part of a transaction that contains other messages, use an overload that takes a <xref:System.Messaging.MessageQueueTransaction> or <xref:System.Messaging.MessageQueueTransactionType> as a parameter.</span></span>  
  
 <span data-ttu-id="79d78-2951">설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2951">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="79d78-2952"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2952">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="79d78-2953">지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2953">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="79d78-2954">보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2954">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="79d78-2955">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2955">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2956">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2956">Workgroup mode</span></span>|<span data-ttu-id="79d78-2957">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2957">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2958">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2958">Local computer</span></span>|<span data-ttu-id="79d78-2959">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2959">Yes</span></span>|  
|<span data-ttu-id="79d78-2960">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2960">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2961">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2961">Yes</span></span>|  
|<span data-ttu-id="79d78-2962">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2962">Remote computer</span></span>|<span data-ttu-id="79d78-2963">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2963">No</span></span>|  
|<span data-ttu-id="79d78-2964">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2964">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2965">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2965">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2966">다음 코드 예제에서는 메시지 큐에 연결 하 고 큐에 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2966">The following code example connects to a message queue and sends a message to the queue.</span></span>  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 <span data-ttu-id="79d78-2967">다음 코드 예제에서는 응용 프로그램 정의 보냅니다 `Order` 큐에 클래스 및 해당 큐에서 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2967">The following code example sends an application-defined `Order` class to a queue and then receives a message from that queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2968"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2968">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
 <span data-ttu-id="79d78-2969">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-2969">-or-</span></span>  
  
 <span data-ttu-id="79d78-2970">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2970">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="79d78-2971">큐에 보낼 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2971">The object to send to the queue.</span></span></param>
        <param name="transaction"><span data-ttu-id="79d78-2972"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</span><span class="sxs-lookup"><span data-stu-id="79d78-2972">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="79d78-2973">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐에 개체를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2973">Sends an object to the transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-2974">이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 트랜잭션 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>에 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여는 `transaction` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2974">Use this overload to send a message that contains the `obj` parameter to the transactional queue referenced by the <xref:System.Messaging.MessageQueue>, using an internal transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="79d78-2975">큐에 보내는 개체 수는 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2975">The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object.</span></span> <span data-ttu-id="79d78-2976">이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2976">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span>  
  
 <span data-ttu-id="79d78-2977">비트랜잭션 큐로 메시지를 보내려고이 오버 로드를 사용 하는 경우 예외를 throw 하지 않고 배달 못 한 편지 큐로 메시지를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2977">If you use this overload to send a message to a non-transactional queue, the message might be sent to the dead-letter queue without throwing an exception.</span></span>  
  
 <span data-ttu-id="79d78-2978">설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2978">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="79d78-2979"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2979">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="79d78-2980">지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2980">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="79d78-2981">보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2981">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="79d78-2982"><xref:System.Messaging.MessageQueueTransaction> 스레딩 아파트를 인식 아파트 상태가 따라서 `STA`, 트랜잭션이 여러 스레드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2982"><xref:System.Messaging.MessageQueueTransaction> is threading apartment aware, so if your apartment state is `STA`, you cannot use the transaction in multiple threads.</span></span> <span data-ttu-id="79d78-2983">에 주 스레드의 상태를 설정 하는 Visual Basic `STA`적용 해야 하므로 <xref:System.MTAThreadAttribute> 에 `Main` 서브루틴 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2983">Visual Basic sets the state of the main thread to `STA`, so you must apply the <xref:System.MTAThreadAttribute> in the `Main` subroutine.</span></span> <span data-ttu-id="79d78-2984">그렇지 않으면 다른 스레드를 사용하여 트랜잭션 메시지를 전달할 때 <xref:System.Messaging.MessageQueueException> 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2984">Otherwise, sending a transactional message using another thread throws a <xref:System.Messaging.MessageQueueException> exception.</span></span> <span data-ttu-id="79d78-2985">적용 된 <xref:System.MTAThreadAttribute> 다음 부분을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2985">You apply the <xref:System.MTAThreadAttribute> by using the following fragment.</span></span>  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 <span data-ttu-id="79d78-2986">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2986">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-2987">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-2987">Workgroup mode</span></span>|<span data-ttu-id="79d78-2988">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-2988">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-2989">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2989">Local computer</span></span>|<span data-ttu-id="79d78-2990">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2990">Yes</span></span>|  
|<span data-ttu-id="79d78-2991">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2991">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-2992">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2992">Yes</span></span>|  
|<span data-ttu-id="79d78-2993">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-2993">Remote computer</span></span>|<span data-ttu-id="79d78-2994">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-2994">No</span></span>|  
|<span data-ttu-id="79d78-2995">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-2995">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-2996">예</span><span class="sxs-lookup"><span data-stu-id="79d78-2996">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-2997">다음 코드 예제에서는 문자열은 트랜잭션 큐로 보내고 해당 큐에서 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-2997">The following code example sends a string to a transactional queue and then receives a message from that queue.</span></span>  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-2998"><paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2998">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-2999"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-2999">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
 <span data-ttu-id="79d78-3000">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-3000">-or-</span></span>  
  
 <span data-ttu-id="79d78-3001">메시지 큐 응용 프로그램에서 트랜잭션을 잘못 사용했음을 나타냈습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3001">The Message Queuing application indicated an incorrect transaction use.</span></span>  
  
 <span data-ttu-id="79d78-3002">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-3002">-or-</span></span>  
  
 <span data-ttu-id="79d78-3003">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3003">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="79d78-3004">큐에 보낼 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3004">The object to send to the queue.</span></span></param>
        <param name="transactionType"><span data-ttu-id="79d78-3005"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3005">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="79d78-3006">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에 개체를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3006">Sends an object to the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3007">이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>, 정의 된 트랜잭션 컨텍스트를 사용 하 여는 `transactionType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3007">Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="79d78-3008">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수는 메시지를 보내는 데 사용할 스레드에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3008">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to send the message.</span></span> <span data-ttu-id="79d78-3009">지정 `Single` 내부 단일 트랜잭션으로 메시지를 전송 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-3009">Specify `Single` if you want to send the message as a single internal transaction.</span></span> <span data-ttu-id="79d78-3010">지정할 수 있습니다 `None` 비트랜잭션 스레드에 트랜잭션 메시지를 전송 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-3010">You can specify `None` if you want to send a transactional message to a non-transactional thread.</span></span>  
  
 <span data-ttu-id="79d78-3011">큐에 보내는 개체 수는 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3011">The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object.</span></span> <span data-ttu-id="79d78-3012">이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3012">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span>  
  
 <span data-ttu-id="79d78-3013">설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3013">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="79d78-3014"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3014">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="79d78-3015">지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3015">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="79d78-3016">보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3016">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="79d78-3017">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3017">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-3018">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-3018">Workgroup mode</span></span>|<span data-ttu-id="79d78-3019">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-3019">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-3020">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3020">Local computer</span></span>|<span data-ttu-id="79d78-3021">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3021">Yes</span></span>|  
|<span data-ttu-id="79d78-3022">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3022">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-3023">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3023">Yes</span></span>|  
|<span data-ttu-id="79d78-3024">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3024">Remote computer</span></span>|<span data-ttu-id="79d78-3025">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3025">No</span></span>|  
|<span data-ttu-id="79d78-3026">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3026">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-3027">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3027">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-3028">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3028">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-3029"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3029">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-3030"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3030">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
 <span data-ttu-id="79d78-3031">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-3031">-or-</span></span>  
  
 <span data-ttu-id="79d78-3032">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3032">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="79d78-3033">큐에 보낼 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3033">The object to send to the queue.</span></span></param>
        <param name="label"><span data-ttu-id="79d78-3034">메시지의 레이블입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3034">The label of the message.</span></span></param>
        <summary><span data-ttu-id="79d78-3035">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 비트랜잭션 큐에 개체를 보내고 메시지에 레이블을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3035">Sends an object to the non-transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3036">이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3036">Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>.</span></span> <span data-ttu-id="79d78-3037">이 오버 로드를 가진 메시지를 식별 하는 문자열 레이블을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3037">With this overload, you can specify the string label that identifies the message.</span></span> <span data-ttu-id="79d78-3038">큐에 보내는 개체 수는 <xref:System.Messaging.Message>, 구조체, 데이터 개체 또는 관리 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3038">The object you send to the queue can be a <xref:System.Messaging.Message>, a structure, a data object, or any managed object.</span></span> <span data-ttu-id="79d78-3039">이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3039">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span>  
  
 <span data-ttu-id="79d78-3040">메시지 레이블에 메시지 큐 레이블 다릅니다 되지만 둘 다 응용 프로그램에 따라 되어 상속 메시지 큐에 의미가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3040">The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.</span></span>  
  
 <span data-ttu-id="79d78-3041">이 오버 로드를 사용 하 여 트랜잭션 큐로 메시지를 보내려고 하면 메시지가 배달 못 한 편지 큐로 보내집니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3041">If you use this overload to send a message to a transactional queue, the message will be sent to the dead-letter queue.</span></span> <span data-ttu-id="79d78-3042">사용 하는 오버 로드를 사용 하 여 메시지가 다른 메시지를 포함 하는 트랜잭션의 일부가 되도록 하려는 경우는 <xref:System.Messaging.MessageQueueTransaction> 또는 <xref:System.Messaging.MessageQueueTransactionType> 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3042">If you want the message to be part of a transaction that contains other messages, use an overload that takes a <xref:System.Messaging.MessageQueueTransaction> or <xref:System.Messaging.MessageQueueTransactionType> as a parameter.</span></span>  
  
 <span data-ttu-id="79d78-3043"><xref:System.Messaging.MessageQueue.Path%2A> 이 대 한 속성 <xref:System.Messaging.MessageQueue> 메시지를 보내기 전에 인스턴스를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3043">The <xref:System.Messaging.MessageQueue.Path%2A> property for this <xref:System.Messaging.MessageQueue> instance must be specified before you send the message.</span></span> <span data-ttu-id="79d78-3044">설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3044">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="79d78-3045"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3045">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="79d78-3046">지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3046">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="79d78-3047">보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3047">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="79d78-3048">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3048">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-3049">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-3049">Workgroup mode</span></span>|<span data-ttu-id="79d78-3050">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-3050">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-3051">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3051">Local computer</span></span>|<span data-ttu-id="79d78-3052">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3052">Yes</span></span>|  
|<span data-ttu-id="79d78-3053">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3053">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-3054">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3054">Yes</span></span>|  
|<span data-ttu-id="79d78-3055">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3055">Remote computer</span></span>|<span data-ttu-id="79d78-3056">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3056">No</span></span>|  
|<span data-ttu-id="79d78-3057">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3057">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-3058">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3058">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-3059">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3059">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-3060"><paramref name="label" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3060">The <paramref name="label" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-3061"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3061">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
 <span data-ttu-id="79d78-3062">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-3062">-or-</span></span>  
  
 <span data-ttu-id="79d78-3063">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3063">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="79d78-3064">큐에 보낼 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3064">The object to send to the queue.</span></span></param>
        <param name="label"><span data-ttu-id="79d78-3065">메시지의 레이블입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3065">The label of the message.</span></span></param>
        <param name="transaction"><span data-ttu-id="79d78-3066"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</span><span class="sxs-lookup"><span data-stu-id="79d78-3066">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</span></span></param>
        <summary><span data-ttu-id="79d78-3067">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐에 개체를 보내고 메시지에 레이블을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3067">Sends an object to the transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3068">이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 트랜잭션 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>에 정의 된 내부 트랜잭션 컨텍스트를 사용 하 여는 `transaction` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3068">Use this overload to send a message that contains the `obj` parameter to the transactional queue referenced by the <xref:System.Messaging.MessageQueue>, using an internal transaction context defined by the `transaction` parameter.</span></span> <span data-ttu-id="79d78-3069">이 오버 로드를 가진 메시지를 식별 하는 문자열 레이블을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3069">With this overload, you can specify the string label that identifies the message.</span></span> <span data-ttu-id="79d78-3070">큐에 보내는 개체 수는 <xref:System.Messaging.Message>, 구조체, 데이터 개체 또는 관리 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3070">The object you send to the queue can be a <xref:System.Messaging.Message>, a structure, a data object, or any managed object.</span></span> <span data-ttu-id="79d78-3071">이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3071">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span>  
  
 <span data-ttu-id="79d78-3072">메시지 레이블에 메시지 큐 레이블 다릅니다 되지만 둘 다 응용 프로그램에 따라 되어 상속 메시지 큐에 의미가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3072">The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.</span></span>  
  
 <span data-ttu-id="79d78-3073">비트랜잭션 큐로 메시지를 보내려고이 오버 로드를 사용 하는 경우 예외를 throw 하지 않고 배달 못 한 편지 큐로 메시지를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3073">If you use this overload to send a message to a non-transactional queue, the message might be sent to the dead-letter queue without throwing an exception.</span></span>  
  
 <span data-ttu-id="79d78-3074">설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3074">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="79d78-3075"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3075">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="79d78-3076">지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3076">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="79d78-3077">보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성</span><span class="sxs-lookup"><span data-stu-id="79d78-3077">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property</span></span>  
  
 <span data-ttu-id="79d78-3078"><xref:System.Messaging.MessageQueueTransaction> 스레딩 아파트를 인식 아파트 상태가 따라서 `STA`, 트랜잭션이 여러 스레드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3078"><xref:System.Messaging.MessageQueueTransaction> is threading apartment aware, so if your apartment state is `STA`, you cannot use the transaction in multiple threads.</span></span> <span data-ttu-id="79d78-3079">에 주 스레드의 상태를 설정 하는 Visual Basic `STA`적용 해야 하므로 <xref:System.MTAThreadAttribute> 에 `Main` 서브루틴 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3079">Visual Basic sets the state of the main thread to `STA`, so you must apply the <xref:System.MTAThreadAttribute> in the `Main` subroutine.</span></span> <span data-ttu-id="79d78-3080">그렇지 않으면 다른 스레드를 사용하여 트랜잭션 메시지를 전달할 때 <xref:System.Messaging.MessageQueueException> 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3080">Otherwise, sending a transactional message using another thread throws a <xref:System.Messaging.MessageQueueException> exception.</span></span> <span data-ttu-id="79d78-3081">적용 된 <xref:System.MTAThreadAttribute> 다음 부분을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3081">You apply the <xref:System.MTAThreadAttribute> by using the following fragment.</span></span>  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 <span data-ttu-id="79d78-3082">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3082">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-3083">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-3083">Workgroup mode</span></span>|<span data-ttu-id="79d78-3084">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-3084">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-3085">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3085">Local computer</span></span>|<span data-ttu-id="79d78-3086">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3086">Yes</span></span>|  
|<span data-ttu-id="79d78-3087">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3087">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-3088">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3088">Yes</span></span>|  
|<span data-ttu-id="79d78-3089">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3089">Remote computer</span></span>|<span data-ttu-id="79d78-3090">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3090">No</span></span>|  
|<span data-ttu-id="79d78-3091">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3091">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-3092">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3092">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-3093">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3093">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-3094"><paramref name="label" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3094">The <paramref name="label" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="79d78-3095">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-3095">-or-</span></span>  
  
 <span data-ttu-id="79d78-3096"><paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3096">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-3097"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3097">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
 <span data-ttu-id="79d78-3098">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-3098">-or-</span></span>  
  
 <span data-ttu-id="79d78-3099">메시지 큐 응용 프로그램에서 트랜잭션을 잘못 사용했음을 나타냈습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3099">The Message Queuing application indicated an incorrect transaction usage.</span></span>  
  
 <span data-ttu-id="79d78-3100">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-3100">-or-</span></span>  
  
 <span data-ttu-id="79d78-3101">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3101">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="79d78-3102">큐에 보낼 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3102">The object to send to the queue.</span></span></param>
        <param name="label"><span data-ttu-id="79d78-3103">메시지의 레이블입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3103">The label of the message.</span></span></param>
        <param name="transactionType"><span data-ttu-id="79d78-3104"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3104">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="79d78-3105">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에 개체를 보내고 메시지에 레이블을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3105">Sends an object to the queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3106">이 오버 로드를 사용 하 여 포함 된 메시지를 보낼는 `obj` 가 참조 하는 큐에 대 한 매개 변수는 <xref:System.Messaging.MessageQueue>, 정의 된 트랜잭션 컨텍스트를 사용 하 여는 `transactionType` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3106">Use this overload to send a message that contains the `obj` parameter to the queue referenced by the <xref:System.Messaging.MessageQueue>, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="79d78-3107">지정 `Automatic` 에 대 한는 `transactionType` 이미 있는 경우 외부 트랜잭션 컨텍스트 매개 변수는 메시지를 보내는 데 사용할 스레드에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3107">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to send the message.</span></span> <span data-ttu-id="79d78-3108">지정 `Single` 내부 단일 트랜잭션으로 메시지를 전송 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-3108">Specify `Single` if you want to send the message as a single internal transaction.</span></span> <span data-ttu-id="79d78-3109">지정할 수 있습니다 `None` 비트랜잭션 스레드에 트랜잭션 메시지를 전송 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-3109">You can specify `None` if you want to send a transactional message to a non-transactional thread.</span></span>  
  
 <span data-ttu-id="79d78-3110">큐에 보내는 개체 수는 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3110">The object you send to the queue can be a <xref:System.Messaging.Message> or any managed object.</span></span> <span data-ttu-id="79d78-3111">이외의 다른 모든 개체를 보낼 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3111">If you send any object other than a <xref:System.Messaging.Message>, the object is serialized and inserted into the body of the message.</span></span> <span data-ttu-id="79d78-3112">이 오버 로드를 가진 메시지를 식별 하는 문자열 레이블을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3112">With this overload, you can specify the string label that identifies the message.</span></span>  
  
 <span data-ttu-id="79d78-3113">메시지 레이블에 메시지 큐 레이블 다릅니다 되지만 둘 다 응용 프로그램에 따라 되어 상속 메시지 큐에 의미가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3113">The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.</span></span>  
  
 <span data-ttu-id="79d78-3114">설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 기본적으로 포맷터는 <xref:System.Messaging.XmlMessageFormatter>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3114">If you do not set the <xref:System.Messaging.MessageQueue.Formatter%2A> property before calling <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, the formatter defaults to the <xref:System.Messaging.XmlMessageFormatter>.</span></span>  
  
 <span data-ttu-id="79d78-3115"><xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성이 아닌 다른 모든 개체에 적용 한 <xref:System.Messaging.Message>합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3115">The <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> property applies to any object other than a <xref:System.Messaging.Message>.</span></span> <span data-ttu-id="79d78-3116">지정 하면, 예를 들어, 레이블 또는 사용 하 여 우선 순위는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 다른 형식의 개체가 포함 된 모든 메시지에 적용 <xref:System.Messaging.Message> 때 응용 프로그램 큐로 보냅니다는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3116">If you specify, for example, a label or a priority using the <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> member, these values apply to any message that contains an object that is not of type <xref:System.Messaging.Message> when your application sends it to the queue.</span></span> <span data-ttu-id="79d78-3117">보낼 때는 <xref:System.Messaging.Message>, 속성 값이 설정에 대 한는 <xref:System.Messaging.Message> 우선 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3117">When sending a <xref:System.Messaging.Message>, the property values set for the <xref:System.Messaging.Message> take precedence over <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, and the message's <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> property takes precedence over the queue's <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="79d78-3118">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3118">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-3119">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-3119">Workgroup mode</span></span>|<span data-ttu-id="79d78-3120">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-3120">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-3121">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3121">Local computer</span></span>|<span data-ttu-id="79d78-3122">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3122">Yes</span></span>|  
|<span data-ttu-id="79d78-3123">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3123">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-3124">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3124">Yes</span></span>|  
|<span data-ttu-id="79d78-3125">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3125">Remote computer</span></span>|<span data-ttu-id="79d78-3126">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3126">No</span></span>|  
|<span data-ttu-id="79d78-3127">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3127">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-3128">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3128">Yes</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-3129">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3129">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79d78-3130"><paramref name="label" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3130">The <paramref name="label" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction"><span data-ttu-id="79d78-3131">메시지 큐 응용 프로그램에서 트랜잭션을 잘못 사용했음을 나타냈습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3131">The Message Queuing application indicated an incorrect transaction usage.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="79d78-3132"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3132">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-3133"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3133">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.</span></span>  
  
 <span data-ttu-id="79d78-3134">또는</span><span class="sxs-lookup"><span data-stu-id="79d78-3134">-or-</span></span>  
  
 <span data-ttu-id="79d78-3135">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3135">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79d78-3136">현재 집합에 사용 권한을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3136">Adds permissions to the current set.</span></span> <span data-ttu-id="79d78-3137">큐 속성 및 큐에 있는 메시지에 대해 액세스 권한이 있는 사용자를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3137">This controls who has access rights to queue properties and messages in the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl"><span data-ttu-id="79d78-3138">부여할 사용 권한 및 트러스티를 지정하는 액세스 제어 항목이 하나 이상 포함된 <see cref="T:System.Messaging.AccessControlList" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3138">A <see cref="T:System.Messaging.AccessControlList" /> that contains one or more access control entries that specify the trustees and the permissions to grant.</span></span></param>
        <summary><span data-ttu-id="79d78-3139">액세스 제어 목록의 내용을 기준으로 큐에 액세스 권한을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3139">Assigns access rights to the queue based on the contents of an access control list.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3140">이 오버 로드를 사용 하 여 권한을 부여, 거부 또는 트러스티 및 사용 권한 정보를 지정 하려면 액세스 제어 항목의 컬렉션을 사용 하 여 권한을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3140">Use this overload to grant, deny, or revoke rights by using a collection of access control entries to specify trustee and permissions information.</span></span> <span data-ttu-id="79d78-3141">이 데, 예를 들어 동시에 여러 사용자에 게 권한을 부여 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3141">This is used, for example, to grant permissions to multiple users at the same time.</span></span>  
  
 <span data-ttu-id="79d78-3142">생성할 때 지정 하는 트러스티는 `ace` 매개 변수는 개별 사용자, 사용자, 그룹 또는 컴퓨터 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3142">The trustee you specify when you construct the `ace` parameter can be an individual user, a group of users, or a computer.</span></span> <span data-ttu-id="79d78-3143">트러스티 개별 이면 형식을 사용 `DOMAIN` \\ `user`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3143">If the trustee is an individual, use the format `DOMAIN`\\`user`.</span></span> <span data-ttu-id="79d78-3144">지정할 수 있습니다 "." 트러스티 로컬 컴퓨터에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3144">You can specify "." for the trustee to indicate the local computer.</span></span>  
  
 <span data-ttu-id="79d78-3145">통해 할당 한 권한은 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3145">The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list.</span></span> <span data-ttu-id="79d78-3146">기본적으로 공용 또는 개인 큐의 작성자에 게 모든 권한을 큐 속성, 사용 권한, 가져오고, 큐에 쓸 수 있는 권한이 모든 사용자는 도메인 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3146">By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</span></span> <span data-ttu-id="79d78-3147">호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보가 기존 목록 맨 아래에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3147">When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.</span></span>  
  
 <span data-ttu-id="79d78-3148">각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:</span><span class="sxs-lookup"><span data-stu-id="79d78-3148">The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:</span></span>  
  
-   <span data-ttu-id="79d78-3149">액세스 거부 됨 <xref:System.Messaging.AccessControlEntry> 는 스레드의 액세스 토큰에 표시 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3149">An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</span></span>  
  
-   <span data-ttu-id="79d78-3150">하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티는 스레드의 액세스 토큰에 명시적으로 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3150">One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</span></span>  
  
-   <span data-ttu-id="79d78-3151">모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로,이 경우 암시적으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3151">All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</span></span>  
  
 <span data-ttu-id="79d78-3152">생성할 때는 `dacl` 추가 매개 변수를 <xref:System.Messaging.AccessControlEntry> 인스턴스 여 <xref:System.Messaging.AccessControlList> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3152">When you construct the `dacl` parameter, you add <xref:System.Messaging.AccessControlEntry> instances to your <xref:System.Messaging.AccessControlList> collection.</span></span> <span data-ttu-id="79d78-3153">각 액세스 제어 항목을 생성할 때 일반 또는 표준 액세스 권한을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3153">When you construct each access control entry, you can specify generic or standard access rights.</span></span> <span data-ttu-id="79d78-3154">큐에 대 한 권한은 다음의 조합이 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3154">The rights to a queue can be any combination of the following:</span></span>  
  
-   <span data-ttu-id="79d78-3155">삭제</span><span class="sxs-lookup"><span data-stu-id="79d78-3155">Delete</span></span>  
  
-   <span data-ttu-id="79d78-3156">보안 읽기</span><span class="sxs-lookup"><span data-stu-id="79d78-3156">Read Security</span></span>  
  
-   <span data-ttu-id="79d78-3157">보안 쓰기</span><span class="sxs-lookup"><span data-stu-id="79d78-3157">Write Security</span></span>  
  
-   <span data-ttu-id="79d78-3158">동기화</span><span class="sxs-lookup"><span data-stu-id="79d78-3158">Synchronize</span></span>  
  
-   <span data-ttu-id="79d78-3159">소유자 수정</span><span class="sxs-lookup"><span data-stu-id="79d78-3159">Modify Owner</span></span>  
  
-   <span data-ttu-id="79d78-3160">읽기</span><span class="sxs-lookup"><span data-stu-id="79d78-3160">Read</span></span>  
  
-   <span data-ttu-id="79d78-3161">Write</span><span class="sxs-lookup"><span data-stu-id="79d78-3161">Write</span></span>  
  
-   <span data-ttu-id="79d78-3162">실행</span><span class="sxs-lookup"><span data-stu-id="79d78-3162">Execute</span></span>  
  
-   <span data-ttu-id="79d78-3163">필수</span><span class="sxs-lookup"><span data-stu-id="79d78-3163">Required</span></span>  
  
-   <span data-ttu-id="79d78-3164">모두</span><span class="sxs-lookup"><span data-stu-id="79d78-3164">All</span></span>  
  
-   <span data-ttu-id="79d78-3165">없음</span><span class="sxs-lookup"><span data-stu-id="79d78-3165">None</span></span>  
  
 <span data-ttu-id="79d78-3166">이러한 권한은 비트 OR 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합으로 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3166">These rights are a set of bit flags that you can combine using the OR bitwise operator.</span></span>  
  
-   <span data-ttu-id="79d78-3167">모든 권한</span><span class="sxs-lookup"><span data-stu-id="79d78-3167">Full Control</span></span>  
  
-   <span data-ttu-id="79d78-3168">메시지를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3168">Delete Message</span></span>  
  
-   <span data-ttu-id="79d78-3169">메시지를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3169">Receive Message</span></span>  
  
-   <span data-ttu-id="79d78-3170">메시지 엿보기</span><span class="sxs-lookup"><span data-stu-id="79d78-3170">Peek Message</span></span>  
  
-   <span data-ttu-id="79d78-3171">저널 메시지 받기</span><span class="sxs-lookup"><span data-stu-id="79d78-3171">Receive Journal Message</span></span>  
  
-   <span data-ttu-id="79d78-3172">큐 속성</span><span class="sxs-lookup"><span data-stu-id="79d78-3172">Get Queue Properties</span></span>  
  
-   <span data-ttu-id="79d78-3173">큐 속성 설정</span><span class="sxs-lookup"><span data-stu-id="79d78-3173">Set Queue Properties</span></span>  
  
-   <span data-ttu-id="79d78-3174">사용 권한 가져오기</span><span class="sxs-lookup"><span data-stu-id="79d78-3174">Get Permissions</span></span>  
  
-   <span data-ttu-id="79d78-3175">사용 권한 설정</span><span class="sxs-lookup"><span data-stu-id="79d78-3175">Set Permissions</span></span>  
  
-   <span data-ttu-id="79d78-3176">큐 소유권 가져오기</span><span class="sxs-lookup"><span data-stu-id="79d78-3176">Take Queue Ownership</span></span>  
  
-   <span data-ttu-id="79d78-3177">메시지 작성</span><span class="sxs-lookup"><span data-stu-id="79d78-3177">Write Message</span></span>  
  
 <span data-ttu-id="79d78-3178">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3178">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-3179">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-3179">Workgroup mode</span></span>|<span data-ttu-id="79d78-3180">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-3180">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-3181">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3181">Local computer</span></span>|<span data-ttu-id="79d78-3182">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3182">Yes</span></span>|  
|<span data-ttu-id="79d78-3183">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3183">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-3184">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3184">Yes</span></span>|  
|<span data-ttu-id="79d78-3185">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3185">Remote computer</span></span>|<span data-ttu-id="79d78-3186">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3186">No</span></span>|  
|<span data-ttu-id="79d78-3187">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3187">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-3188">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3188">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-3189">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3189">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.</span></span>      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-3190">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3190">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace"><span data-ttu-id="79d78-3191">사용자, 액세스 형식 및 사용 권한 형식을 지정하는 <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3191">A <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> that specifies a user, an access type, and a permission type.</span></span></param>
        <summary><span data-ttu-id="79d78-3192">액세스 제어 항목의 내용을 기준으로 큐에 액세스 권한을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3192">Assigns access rights to the queue based on the contents of an access control entry.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3193">이 오버 로드를 사용 하 여 권한을 부여, 거부 또는 트러스티 및 권한 정보를 지정 하는 액세스 제어 항목을 사용 하 여 권한을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3193">Use this overload to grant, deny, or revoke rights by using an access control entry to specify trustee and rights information.</span></span>  
  
 <span data-ttu-id="79d78-3194">생성할 때 지정 하는 트러스티는 `ace` 매개 변수는 개별 사용자, 사용자, 그룹 또는 컴퓨터 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3194">The trustee you specify when you construct the `ace` parameter can be an individual user, a group of users, or a computer.</span></span> <span data-ttu-id="79d78-3195">트러스티 개별 이면 형식을 사용 `DOMAIN` \\ `user`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3195">If the trustee is an individual, use the format `DOMAIN`\\`user`.</span></span> <span data-ttu-id="79d78-3196">지정할 수 있습니다 "." 트러스티 로컬 컴퓨터에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3196">You can specify "." for the trustee to indicate the local computer.</span></span>  
  
 <span data-ttu-id="79d78-3197">통해 할당 한 권한은 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3197">The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list.</span></span> <span data-ttu-id="79d78-3198">기본적으로 공용 또는 개인 큐의 작성자에 게 모든 권한을 큐 속성, 사용 권한, 가져오고, 큐에 쓸 수 있는 권한이 모든 사용자는 도메인 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3198">By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</span></span> <span data-ttu-id="79d78-3199">호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보가 기존 목록 맨 아래에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3199">When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.</span></span>  
  
 <span data-ttu-id="79d78-3200">각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:</span><span class="sxs-lookup"><span data-stu-id="79d78-3200">The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:</span></span>  
  
-   <span data-ttu-id="79d78-3201">액세스 거부 됨 <xref:System.Messaging.AccessControlEntry> 는 스레드의 액세스 토큰에 표시 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3201">An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</span></span>  
  
-   <span data-ttu-id="79d78-3202">하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티는 스레드의 액세스 토큰에 명시적으로 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3202">One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</span></span>  
  
-   <span data-ttu-id="79d78-3203">모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로,이 경우 암시적으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3203">All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</span></span>  
  
 <span data-ttu-id="79d78-3204">지정 하는 큐에 대 한 권한을 `rights` 매개 변수를 생성할 때 프로그램 <xref:System.Messaging.MessageQueueAccessControlEntry>, 다음의 조합일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3204">The rights to a queue, which you specify in the `rights` parameter when you construct your <xref:System.Messaging.MessageQueueAccessControlEntry>, can be any combination of the following:</span></span>  
  
-   <span data-ttu-id="79d78-3205">모든 권한</span><span class="sxs-lookup"><span data-stu-id="79d78-3205">Full Control</span></span>  
  
-   <span data-ttu-id="79d78-3206">메시지를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3206">Delete Message</span></span>  
  
-   <span data-ttu-id="79d78-3207">메시지를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3207">Receive Message</span></span>  
  
-   <span data-ttu-id="79d78-3208">메시지 엿보기</span><span class="sxs-lookup"><span data-stu-id="79d78-3208">Peek Message</span></span>  
  
-   <span data-ttu-id="79d78-3209">저널 메시지 받기</span><span class="sxs-lookup"><span data-stu-id="79d78-3209">Receive Journal Message</span></span>  
  
-   <span data-ttu-id="79d78-3210">큐 속성</span><span class="sxs-lookup"><span data-stu-id="79d78-3210">Get Queue Properties</span></span>  
  
-   <span data-ttu-id="79d78-3211">큐 속성 설정</span><span class="sxs-lookup"><span data-stu-id="79d78-3211">Set Queue Properties</span></span>  
  
-   <span data-ttu-id="79d78-3212">사용 권한 가져오기</span><span class="sxs-lookup"><span data-stu-id="79d78-3212">Get Permissions</span></span>  
  
-   <span data-ttu-id="79d78-3213">사용 권한 설정</span><span class="sxs-lookup"><span data-stu-id="79d78-3213">Set Permissions</span></span>  
  
-   <span data-ttu-id="79d78-3214">큐 소유권 가져오기</span><span class="sxs-lookup"><span data-stu-id="79d78-3214">Take Queue Ownership</span></span>  
  
-   <span data-ttu-id="79d78-3215">메시지 작성</span><span class="sxs-lookup"><span data-stu-id="79d78-3215">Write Message</span></span>  
  
 <span data-ttu-id="79d78-3216">`rights` 에 대 한 생성자에서 지정한 매개 변수는 `ace` 매개 변수는의 플래그는 <xref:System.Messaging.MessageQueueAccessRights> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3216">The `rights` parameter you specify in the constructor for the `ace` parameter is a flag of the <xref:System.Messaging.MessageQueueAccessRights> enumeration.</span></span> <span data-ttu-id="79d78-3217">비트 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합을 나타냅니다를 빌드할 때는 `rights` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3217">It represents a set of bit flags that you can combine using the bitwise operator OR when you build the `rights` parameter.</span></span>  
  
 <span data-ttu-id="79d78-3218">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3218">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-3219">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-3219">Workgroup mode</span></span>|<span data-ttu-id="79d78-3220">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-3220">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-3221">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3221">Local computer</span></span>|<span data-ttu-id="79d78-3222">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3222">Yes</span></span>|  
|<span data-ttu-id="79d78-3223">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3223">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-3224">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3224">Yes</span></span>|  
|<span data-ttu-id="79d78-3225">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3225">Remote computer</span></span>|<span data-ttu-id="79d78-3226">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3226">No</span></span>|  
|<span data-ttu-id="79d78-3227">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3227">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-3228">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3228">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-3229">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3229">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-3230">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3230">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user"><span data-ttu-id="79d78-3231">큐에 대한 추가 권한을 가져오는 개인, 그룹 또는 컴퓨터입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3231">The individual, group, or computer that gets additional rights to the queue.</span></span></param>
        <param name="rights"><span data-ttu-id="79d78-3232">전달된 <c>사용자</c>에 메시지 큐 서비스가 할당하는 큐에 대한 권한 집합을 나타내는 <see cref="T:System.Messaging.MessageQueueAccessRights" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3232">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> that indicates the set of rights to the queue that Message Queuing assigns to the <c>user</c> passed in.</span></span></param>
        <summary><span data-ttu-id="79d78-3233">지정된 액세스 권한을 컴퓨터, 그룹, 또는 사용자에게 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3233">Gives a computer, group, or user the specified access rights.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3234">이 오버 로드를 사용 하 여 개별 사용자에 지정 된 권한을 부여 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3234">Use this overload to grant specified rights to an individual user.</span></span> <span data-ttu-id="79d78-3235">사용자는 개별 사용자에 게, 사용자, 그룹 또는 컴퓨터를 포함 하는 모든 유효한 트러스티를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3235">The user can be any valid trustee, which includes individual users, groups of users, or a computer.</span></span> <span data-ttu-id="79d78-3236">사용자가 개인을 사용 하 여 형식을 `DOMAIN` \\ `user` 에 대 한는 `user` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3236">If the user is an individual, use the format `DOMAIN`\\`user` for the `user` parameter.</span></span> <span data-ttu-id="79d78-3237">지정할 수 있습니다 "."에 대 한는 `user` 로컬 컴퓨터를 나타내기 위해 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3237">You can specify "." for the `user` parameter to indicate the local computer.</span></span>  
  
 <span data-ttu-id="79d78-3238">통해 할당 한 권한은 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3238">The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list.</span></span> <span data-ttu-id="79d78-3239">기본적으로 공용 또는 개인 큐의 작성자에 게 모든 권한을 큐 속성, 사용 권한, 가져오고, 큐에 쓸 수 있는 권한이 모든 사용자는 도메인 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3239">By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</span></span> <span data-ttu-id="79d78-3240">호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보가 기존 목록 맨 아래에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3240">When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.</span></span>  
  
 <span data-ttu-id="79d78-3241">각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:</span><span class="sxs-lookup"><span data-stu-id="79d78-3241">The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:</span></span>  
  
-   <span data-ttu-id="79d78-3242">액세스 거부 됨 <xref:System.Messaging.AccessControlEntry> 는 스레드의 액세스 토큰에 표시 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3242">An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</span></span>  
  
-   <span data-ttu-id="79d78-3243">하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티는 스레드의 액세스 토큰에 명시적으로 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3243">One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</span></span>  
  
-   <span data-ttu-id="79d78-3244">모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로,이 경우 암시적으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3244">All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</span></span>  
  
 <span data-ttu-id="79d78-3245">에 지정 된 큐에 대 한 권한을 `rights` 매개 변수를 다음의 조합일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3245">The rights to a queue, specified in the `rights` parameter, can be any combination of the following:</span></span>  
  
-   <span data-ttu-id="79d78-3246">모든 권한</span><span class="sxs-lookup"><span data-stu-id="79d78-3246">Full Control</span></span>  
  
-   <span data-ttu-id="79d78-3247">메시지를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3247">Delete Message</span></span>  
  
-   <span data-ttu-id="79d78-3248">메시지를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3248">Receive Message</span></span>  
  
-   <span data-ttu-id="79d78-3249">메시지 엿보기</span><span class="sxs-lookup"><span data-stu-id="79d78-3249">Peek Message</span></span>  
  
-   <span data-ttu-id="79d78-3250">저널 메시지 받기</span><span class="sxs-lookup"><span data-stu-id="79d78-3250">Receive Journal Message</span></span>  
  
-   <span data-ttu-id="79d78-3251">큐 속성</span><span class="sxs-lookup"><span data-stu-id="79d78-3251">Get Queue Properties</span></span>  
  
-   <span data-ttu-id="79d78-3252">큐 속성 설정</span><span class="sxs-lookup"><span data-stu-id="79d78-3252">Set Queue Properties</span></span>  
  
-   <span data-ttu-id="79d78-3253">사용 권한 가져오기</span><span class="sxs-lookup"><span data-stu-id="79d78-3253">Get Permissions</span></span>  
  
-   <span data-ttu-id="79d78-3254">사용 권한 설정</span><span class="sxs-lookup"><span data-stu-id="79d78-3254">Set Permissions</span></span>  
  
-   <span data-ttu-id="79d78-3255">큐 소유권 가져오기</span><span class="sxs-lookup"><span data-stu-id="79d78-3255">Take Queue Ownership</span></span>  
  
-   <span data-ttu-id="79d78-3256">메시지 작성</span><span class="sxs-lookup"><span data-stu-id="79d78-3256">Write Message</span></span>  
  
 <span data-ttu-id="79d78-3257"><xref:System.Messaging.MessageQueueAccessRights> 열거형은 빌드 또는 비트 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합 나타냅니다는 `rights` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3257">The <xref:System.Messaging.MessageQueueAccessRights> enumeration represents a set of bit flags that you can combine using the bitwise operator OR to build the `rights` parameter.</span></span>  
  
 <span data-ttu-id="79d78-3258">이 오버 로드를 가진만 권한을 부여할 수 있습니다. 취소 하거나 거부할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3258">With this overload, you can only grant permissions; you cannot revoke or deny them.</span></span> <span data-ttu-id="79d78-3259">명시적으로 부여 된 다른 오버 로드를 사용 해야 <xref:System.Messaging.AccessControlEntryType> 이외의 `Allow`합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3259">You must use a different overload to explicitly grant any <xref:System.Messaging.AccessControlEntryType> other than `Allow`.</span></span>  
  
 <span data-ttu-id="79d78-3260">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3260">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-3261">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-3261">Workgroup mode</span></span>|<span data-ttu-id="79d78-3262">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-3262">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-3263">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3263">Local computer</span></span>|<span data-ttu-id="79d78-3264">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3264">Yes</span></span>|  
|<span data-ttu-id="79d78-3265">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3265">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-3266">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3266">Yes</span></span>|  
|<span data-ttu-id="79d78-3267">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3267">Remote computer</span></span>|<span data-ttu-id="79d78-3268">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3268">No</span></span>|  
|<span data-ttu-id="79d78-3269">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3269">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-3270">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3270">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-3271">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3271">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79d78-3272"><paramref name="user" />이 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3272">The <paramref name="user" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-3273">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3273">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user"><span data-ttu-id="79d78-3274">큐에 대한 추가 권한을 가져오는 개인, 그룹 또는 컴퓨터입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3274">The individual, group, or computer that gets additional rights to the queue.</span></span></param>
        <param name="rights"><span data-ttu-id="79d78-3275">전달된 <c>사용자</c>에 메시지 큐 서비스가 할당하는 큐에 대한 권한 집합을 나타내는 <see cref="T:System.Messaging.MessageQueueAccessRights" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3275">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> that indicates the set of rights to the queue that Message Queuing assigns to the <c>user</c> passed in.</span></span></param>
        <param name="entryType"><span data-ttu-id="79d78-3276"><c>rights</c> 매개 변수로 지정된 사용 권한을 부여할지 거부할지 또는 해지할지를 지정하는 <see cref="T:System.Messaging.AccessControlEntryType" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3276">A <see cref="T:System.Messaging.AccessControlEntryType" /> that specifies whether to grant, deny, or revoke the permissions specified by the <c>rights</c> parameter.</span></span></param>
        <summary><span data-ttu-id="79d78-3277">지정된 액세스 제어 형식(예: 허용, 거부, 해지, 또는 설정)을 포함하여, 지정된 액세스 권한을 컴퓨터, 그룹 또는 사용자에게 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3277">Gives a computer, group, or user the specified access rights, with the specified access control type (allow, deny, revoke, or set).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3278">이 오버 로드를 사용 하 여 권한을 부여, 거부 또는 개별 사용자에 대 한 지정 된 권한을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3278">Use this overload to grant, deny, or revoke specified rights for an individual user.</span></span> <span data-ttu-id="79d78-3279">사용자는 개별 사용자에 게, 사용자, 그룹 또는 컴퓨터를 포함 하는 모든 유효한 트러스티를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3279">The user can be any valid trustee, which includes individual users, groups of users, or a computer.</span></span> <span data-ttu-id="79d78-3280">사용자가 개인을 사용 하 여 형식을 `DOMAIN` \\ `user` 에 대 한는 `user` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3280">If the user is an individual, use the format `DOMAIN`\\`user` for the `user` parameter.</span></span> <span data-ttu-id="79d78-3281">지정할 수 있습니다 "."에 대 한는 `user` 로컬 컴퓨터를 나타내기 위해 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3281">You can specify "." for the `user` parameter to indicate the local computer.</span></span>  
  
 <span data-ttu-id="79d78-3282">통해 할당 한 권한은 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3282">The permissions you assign through <xref:System.Messaging.MessageQueue.SetPermissions%2A> add rights to the existing list.</span></span> <span data-ttu-id="79d78-3283">기본적으로 공용 또는 개인 큐의 작성자에 게 모든 권한을 큐 속성, 사용 권한, 가져오고, 큐에 쓸 수 있는 권한이 모든 사용자는 도메인 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3283">By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</span></span> <span data-ttu-id="79d78-3284">호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보가 기존 목록 맨 아래에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3284">When you call <xref:System.Messaging.MessageQueue.SetPermissions%2A>, the user and permissions information is appended to the bottom of the existing list.</span></span>  
  
 <span data-ttu-id="79d78-3285">각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:</span><span class="sxs-lookup"><span data-stu-id="79d78-3285">The system examines each <xref:System.Messaging.AccessControlEntry> in sequence until one of the following events occurs:</span></span>  
  
-   <span data-ttu-id="79d78-3286">액세스 거부 됨 <xref:System.Messaging.AccessControlEntry> 는 스레드의 액세스 토큰에 표시 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3286">An access-denied <xref:System.Messaging.AccessControlEntry> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</span></span>  
  
-   <span data-ttu-id="79d78-3287">하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티는 스레드의 액세스 토큰에 명시적으로 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3287">One or more access-allowed <xref:System.Messaging.AccessControlEntry> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</span></span>  
  
-   <span data-ttu-id="79d78-3288">모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로,이 경우 암시적으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3288">All <xref:System.Messaging.AccessControlEntry> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</span></span>  
  
 <span data-ttu-id="79d78-3289">에 지정 된 큐에 대 한 권한을 `rights` 매개 변수를 다음의 조합일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3289">The rights to a queue, specified in the `rights` parameter, can be any combination of the following:</span></span>  
  
-   <span data-ttu-id="79d78-3290">모든 권한</span><span class="sxs-lookup"><span data-stu-id="79d78-3290">Full Control</span></span>  
  
-   <span data-ttu-id="79d78-3291">메시지를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3291">Delete Message</span></span>  
  
-   <span data-ttu-id="79d78-3292">메시지를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3292">Receive Message</span></span>  
  
-   <span data-ttu-id="79d78-3293">메시지 엿보기</span><span class="sxs-lookup"><span data-stu-id="79d78-3293">Peek Message</span></span>  
  
-   <span data-ttu-id="79d78-3294">저널 메시지 받기</span><span class="sxs-lookup"><span data-stu-id="79d78-3294">Receive Journal Message</span></span>  
  
-   <span data-ttu-id="79d78-3295">큐 속성</span><span class="sxs-lookup"><span data-stu-id="79d78-3295">Get Queue Properties</span></span>  
  
-   <span data-ttu-id="79d78-3296">큐 속성 설정</span><span class="sxs-lookup"><span data-stu-id="79d78-3296">Set Queue Properties</span></span>  
  
-   <span data-ttu-id="79d78-3297">사용 권한 가져오기</span><span class="sxs-lookup"><span data-stu-id="79d78-3297">Get Permissions</span></span>  
  
-   <span data-ttu-id="79d78-3298">사용 권한 설정</span><span class="sxs-lookup"><span data-stu-id="79d78-3298">Set Permissions</span></span>  
  
-   <span data-ttu-id="79d78-3299">큐 소유권 가져오기</span><span class="sxs-lookup"><span data-stu-id="79d78-3299">Take Queue Ownership</span></span>  
  
-   <span data-ttu-id="79d78-3300">메시지 작성</span><span class="sxs-lookup"><span data-stu-id="79d78-3300">Write Message</span></span>  
  
 <span data-ttu-id="79d78-3301"><xref:System.Messaging.MessageQueueAccessRights> 열거형은 빌드 또는 비트 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합 나타냅니다는 `rights` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3301">The <xref:System.Messaging.MessageQueueAccessRights> enumeration represents a set of bit flags that you can combine using the bitwise operator OR to build the `rights` parameter.</span></span>  
  
 <span data-ttu-id="79d78-3302">다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3302">The following table shows whether this method is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-3303">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-3303">Workgroup mode</span></span>|<span data-ttu-id="79d78-3304">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-3304">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-3305">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3305">Local computer</span></span>|<span data-ttu-id="79d78-3306">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3306">Yes</span></span>|  
|<span data-ttu-id="79d78-3307">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3307">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-3308">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3308">Yes</span></span>|  
|<span data-ttu-id="79d78-3309">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3309">Remote computer</span></span>|<span data-ttu-id="79d78-3310">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3310">No</span></span>|  
|<span data-ttu-id="79d78-3311">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3311">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-3312">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3312">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-3313">다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>의 사용법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3313">The following code example demonstrates the use of <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.</span></span>  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-3314">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3314">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-3315"><see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 또는 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 이벤트의 결과로 생성된 이벤트 처리기의 호출을 마샬링하는 개체를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3315">Gets or sets the object that marshals the event-handler call resulting from a <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> or <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> event.</span></span></summary>
        <value><span data-ttu-id="79d78-3316"><see cref="T:System.ComponentModel.ISynchronizeInvoke" /> 또는 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 이벤트의 결과로 생성된 이벤트 처리기의 호출을 마샬링하는 개체를 나타내는 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3316">A <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, which represents the object that marshals the event-handler call resulting from a <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> or <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> event.</span></span> <span data-ttu-id="79d78-3317">기본값은 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3317">The default is <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3318">A <xref:System.Messaging.MessageQueue.ReceiveCompleted> 또는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트에서 결과 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 또는 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 각각 특정 스레드를 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3318">A <xref:System.Messaging.MessageQueue.ReceiveCompleted> or <xref:System.Messaging.MessageQueue.PeekCompleted> event results from a <xref:System.Messaging.MessageQueue.BeginReceive%2A> or <xref:System.Messaging.MessageQueue.BeginPeek%2A> request, respectively, to a specific thread.</span></span> <span data-ttu-id="79d78-3319">일반적으로 <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> 해당 구성 요소에 지정 된 스레드에 바인딩되므로 관련된 구성 요소 컨트롤 또는 폼에 배치 된 경우 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3319">Typically, the <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> is set when its related component is placed inside a control or a form, because those components are bound to a specific thread.</span></span>  
  
 <span data-ttu-id="79d78-3320">일반적으로 동기화 개체는 메서드 호출을을 단일 스레드를 마샬링합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3320">Typically, the synchronizing object marshals a method call into a single thread.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-3321">큐가 트랜잭션만 허용하는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3321">Gets a value that indicates whether the queue accepts only transactions.</span></span></summary>
        <value>
          <span data-ttu-id="79d78-3322">큐가 트랜잭션의 일부로서 전달된 메시지만 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3322"><see langword="true" /> if the queue accepts only messages sent as part of a transaction; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3323">트랜잭션 메시지를 단일 트랜잭션에 관련 된 여러 메시지의 결합을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3323">Transactional messaging refers to the coupling of several related messages into a single transaction.</span></span> <span data-ttu-id="79d78-3324">트랜잭션의 일부는 메시지가 순서 대로 배달 보장 메시지를 보내는 한 번만 배달 되 고 대상 큐에서 성공적으로 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3324">Sending messages as part of a transaction ensures that the messages are delivered in order, delivered only once, and successfully retrieved from their destination queue.</span></span>  
  
 <span data-ttu-id="79d78-3325">트랜잭션 대기열의 경우에 트랜잭션의 일부로 전송 되는 메시지에만 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3325">If a queue is transactional, it accepts only messages that are sent as part of a transaction.</span></span> <span data-ttu-id="79d78-3326">하지만 비트랜잭션 메시지가 수 전송 되거나 명시적으로 트랜잭션를 사용 하지 않고 로컬 트랜잭션 큐에서 수신 <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, 및 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3326">However, a non-transactional message can be sent or received from a local transaction queue without explicitly using transactional <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, and <xref:System.Messaging.MessageQueueTransaction.Abort%2A> syntax.</span></span> <span data-ttu-id="79d78-3327">비트랜잭션 메시지가 트랜잭션 큐로 전송 되,이 구성 요소는 단일 메시지 트랜잭션을 만듭니다,에 대 한 제외 하 고 직접 형식 이름을 사용 하 여 원격 컴퓨터에 있는 큐를 참조 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="79d78-3327">If a non-transactional message is sent to a transactional queue, this component creates a single-message transaction for it, except in the case of referencing a queue on a remote computer using a direct format name.</span></span> <span data-ttu-id="79d78-3328">이 상황에서 메시지를 보낼 때 트랜잭션 컨텍스트를 지정 하지 않으면 하나 드립니다 만들어지지 않습니다 및 메시지 배달 못 한 편지 큐로 보내집니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3328">In this situation, if you do not specify a transaction context when sending a message, one is not created for you and the message will be sent to the dead-letter queue.</span></span>  
  
 <span data-ttu-id="79d78-3329">비트랜잭션 메시지가 트랜잭션 큐 보내기에서 예외가 발생할 경우 메시지를 롤백할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3329">If you send a non-transactional message to a transactional queue, you will not be able to roll back the message in the event of an exception.</span></span>  
  
 <span data-ttu-id="79d78-3330"><xref:System.Messaging.MessageQueueTransaction> 스레딩 아파트를 인식 아파트 상태가 따라서 `STA`, 트랜잭션이 여러 스레드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3330"><xref:System.Messaging.MessageQueueTransaction> is threading apartment aware, so if your apartment state is `STA`, you cannot use the transaction in multiple threads.</span></span> <span data-ttu-id="79d78-3331">에 주 스레드의 상태를 설정 하는 Visual Basic `STA`적용 해야 하므로 <xref:System.MTAThreadAttribute> 에 `Main` 서브루틴 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3331">Visual Basic sets the state of the main thread to `STA`, so you must apply the <xref:System.MTAThreadAttribute> in the `Main` subroutine.</span></span> <span data-ttu-id="79d78-3332">그렇지 않으면 다른 스레드를 사용하여 트랜잭션 메시지를 전달할 때 <xref:System.Messaging.MessageQueueException> 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3332">Otherwise, sending a transactional message using another thread throws a <xref:System.Messaging.MessageQueueException> exception.</span></span> <span data-ttu-id="79d78-3333">적용 된 <xref:System.MTAThreadAttribute> 다음 부분을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3333">You apply the <xref:System.MTAThreadAttribute> by using the following fragment.</span></span>  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 <span data-ttu-id="79d78-3334">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3334">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-3335">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-3335">Workgroup mode</span></span>|<span data-ttu-id="79d78-3336">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-3336">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-3337">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3337">Local computer</span></span>|<span data-ttu-id="79d78-3338">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3338">Yes</span></span>|  
|<span data-ttu-id="79d78-3339">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3339">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-3340">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3340">Yes</span></span>|  
|<span data-ttu-id="79d78-3341">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3341">Remote computer</span></span>|<span data-ttu-id="79d78-3342">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3342">No</span></span>|  
|<span data-ttu-id="79d78-3343">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3343">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-3344">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3344">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-3345">다음 코드 예제에서는 메시지 큐의의 값을 표시 <xref:System.Messaging.MessageQueue.Transactional%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3345">The following code example displays the value of a message queue's <xref:System.Messaging.MessageQueue.Transactional%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-3346">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3346">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-3347">받은 메시지가 업무 일지 큐로 복사되는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3347">Gets or sets a value that indicates whether received messages are copied to the journal queue.</span></span></summary>
        <value>
          <span data-ttu-id="79d78-3348">큐에서 받은 메시지가 해당 업무 일지 큐로 복사되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3348"><see langword="true" /> if messages received from the queue are copied to its journal queue; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3349">메시지 큐 응용 프로그램에서 새 응용 프로그램 큐를 동일한 위치에 자동으로 연결 된 저널 큐를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3349">When the Message Queuing application creates a new application queue, it automatically creates an associated journal queue in the same location.</span></span> <span data-ttu-id="79d78-3350">큐에서 제거 된 메시지를 추적 하는 저널 큐 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3350">The journal queue is used to track the messages removed from a queue.</span></span> <span data-ttu-id="79d78-3351">이 속성을 설정 하면 메시지 큐를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3351">Setting this property modifies the Message Queuing queue.</span></span> <span data-ttu-id="79d78-3352">따라서 다른 모든 <xref:System.Messaging.MessageQueue> 인스턴스 변경의 영향을 받는 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3352">Therefore, any other <xref:System.Messaging.MessageQueue> instances are affected by the change.</span></span>  
  
 <span data-ttu-id="79d78-3353">저널 큐의 받는 시간이 타이머가 만료 되었습니다 (Information Store 또는 Active Directory)는 메시지 큐 디렉터리 서비스를 사용 하 여 큐에서 제거 된 메시지 추적 때문에 큐에서 제거 된 메시지를 추적 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3353">The journal queue does not track messages removed from the queue because their time-to-be-received timer expired, nor does it track messages purged from the queue by using a Message Queuing directory service (Information Store or Active Directory).</span></span>  
  
 <span data-ttu-id="79d78-3354">응용 프로그램; 업무 일지 큐에 메시지를 보낼 수 없습니다. 이러한 큐의 읽기 전용 액세스로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3354">Applications cannot send messages to journal queues; they are limited to read-only access of these queues.</span></span> <span data-ttu-id="79d78-3355">또한 메시지 큐는 저널 큐에서 메시지를 제거 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3355">Furthermore, Message Queuing never removes messages from journal queues.</span></span> <span data-ttu-id="79d78-3356">큐를 사용 하 여 응용 프로그램 받는 하거나 큐를 제거 하 여 이러한 메시지를 지워야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3356">The application using the queue must clear these messages either by receiving them or by purging the queue.</span></span>  
  
 <span data-ttu-id="79d78-3357">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3357">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-3358">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-3358">Workgroup mode</span></span>|<span data-ttu-id="79d78-3359">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-3359">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-3360">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3360">Local computer</span></span>|<span data-ttu-id="79d78-3361">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3361">Yes</span></span>|  
|<span data-ttu-id="79d78-3362">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3362">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-3363">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3363">Yes</span></span>|  
|<span data-ttu-id="79d78-3364">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3364">Remote computer</span></span>|<span data-ttu-id="79d78-3365">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3365">No</span></span>|  
|<span data-ttu-id="79d78-3366">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3366">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-3367">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3367">No</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79d78-3368">다음 코드 예제에서는 메시지 큐의 값을 설정 가져오고 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3368">The following code example gets and sets the value of a message queue's <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> property.</span></span>  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-3369">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="79d78-3369">An error occurred when accessing a Message Queuing method.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79d78-3370">메시지 큐에 메시지를 보내는 데 사용되는 기본 핸들을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3370">Gets the native handle used to send messages to the message queue.</span></span></summary>
        <value><span data-ttu-id="79d78-3371">큐에 메시지를 보내는 데 사용하는 네이티브 큐 개체에 대한 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3371">A handle to the native queue object that you use for sending messages to the queue.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79d78-3372"><xref:System.Messaging.MessageQueue.WriteHandle%2A> 큐에 메시지를 보내는 데 사용 되는 메시지 큐 개체에 대 한 기본 창 핸들을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3372">The <xref:System.Messaging.MessageQueue.WriteHandle%2A> provides a native Windows handle to the message queue object that is used for sending messages to the queue.</span></span> <span data-ttu-id="79d78-3373">큐의 경로 변경 하면 핸들을 닫고 다시 새 값으로.</span><span class="sxs-lookup"><span data-stu-id="79d78-3373">If you change the path of the queue, the handle is closed and reopened with a new value.</span></span>  
  
 <span data-ttu-id="79d78-3374">다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3374">The following table shows whether this property is available in various Workgroup modes.</span></span>  
  
|<span data-ttu-id="79d78-3375">작업 그룹 모드</span><span class="sxs-lookup"><span data-stu-id="79d78-3375">Workgroup mode</span></span>|<span data-ttu-id="79d78-3376">사용 가능</span><span class="sxs-lookup"><span data-stu-id="79d78-3376">Available</span></span>|  
|--------------------|---------------|  
|<span data-ttu-id="79d78-3377">로컬 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3377">Local computer</span></span>|<span data-ttu-id="79d78-3378">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3378">Yes</span></span>|  
|<span data-ttu-id="79d78-3379">로컬 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3379">Local computer and direct format name</span></span>|<span data-ttu-id="79d78-3380">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3380">Yes</span></span>|  
|<span data-ttu-id="79d78-3381">원격 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="79d78-3381">Remote computer</span></span>|<span data-ttu-id="79d78-3382">아니요</span><span class="sxs-lookup"><span data-stu-id="79d78-3382">No</span></span>|  
|<span data-ttu-id="79d78-3383">원격 컴퓨터와 직접 형식 이름</span><span class="sxs-lookup"><span data-stu-id="79d78-3383">Remote computer and direct format name</span></span>|<span data-ttu-id="79d78-3384">예</span><span class="sxs-lookup"><span data-stu-id="79d78-3384">Yes</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="79d78-3385">메시지 큐를 쓰기 작업에 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79d78-3385">The message queue is not available for writing.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>