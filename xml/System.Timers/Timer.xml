<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="618b69c9a4d91151391fe5e2c79054e0441f4aec" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530807" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>반복 이벤트를 생성하는 옵션으로 설정된 간격 후 이벤트를 생성합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Timers.Timer> 구성 요소는 발생 하는 서버 기반 타이머는 <xref:System.Timers.Timer.Elapsed> 수에서 1/1000 후 응용 프로그램에서 이벤트는 <xref:System.Timers.Timer.Interval%2A> 속성 경과 합니다. 구성할 수는 <xref:System.Timers.Timer> 를 한 번 또는 반복적으로 사용 하 여 이벤트를 발생 시키는 개체는 <xref:System.Timers.Timer.AutoReset%2A> 속성입니다. 일반적으로 <xref:System.Timers.Timer> 필요할 때 범위 내에 유지 되도록 클래스 수준에서 개체를 선언 합니다. 그런 다음 처리할 수는 <xref:System.Timers.Timer.Elapsed> 정상적인 처리를 제공 하는 이벤트입니다. 예를 들어 가정해 유지 해야 하는 중요 한 서버가 주 7 일, 하루 24 시간을 실행 합니다. 사용 하는 서비스를 만들 수는 <xref:System.Timers.Timer> 개체를 정기적으로 서버를 확인 하 고 실행 되 고 시스템 인지 확인 합니다. 시스템이 응답 하지 않는 경우 서비스는 서버를 다시 시작 하거나 관리자에 게 알릴를 시도할 수 있습니다.  
  
> [!IMPORTANT]
> <xref:System.Timers.Timer> 클래스는 모든.NET 구현 및.NET 표준 1.6 및 더 낮은 버전 등 버전을 사용할 수 없습니다.
> 이러한 경우에 사용할 수 있습니다는 <xref:System.Threading.Timer?displayProperty=nameWithType> 클래스를 대신 합니다.
  
 이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다. 직접 형식의 dispose를 호출 해당 <xref:System.IDisposable.Dispose%2A> 에서 메서드는 `try` / `catch` 블록입니다. 작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다. 자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
 서버 기반 <xref:System.Timers.Timer?displayProperty=nameWithType> 클래스는 다중 스레드 환경에서 작업자 스레드와 함께 사용 하기 위해 설계 되었습니다. 서버 타이머 올려진 처리 스레드 간에 이동할 수 <xref:System.Timers.Timer.Elapsed> Windows 타이머 이벤트를 발생 시키는 시간에에서 이벤트입니다.  
  
 <xref:System.Timers.Timer?displayProperty=nameWithType> 구성 요소는 <xref:System.Timers.Timer.Elapsed> 값 (밀리초)에 따른 이벤트는 <xref:System.Timers.Timer.Interval%2A> 속성입니다. 필요한 처리를 수행 하도록이 이벤트를 처리할 수 있습니다. 예를 들어 지속적으로 데이터베이스에 판매 주문을 게시 하는 온라인 판매 응용 프로그램이 있다고 가정 합니다. 배송에 대 한 지침을 컴파일하는 서비스는 주문을 각 주문을 개별적으로 처리 하지 않고 일괄 처리에서 작동 합니다. 사용할 수는 <xref:System.Timers.Timer> 를 30 분 마다 일괄 처리를 시작 합니다.  
  
> [!IMPORTANT]
>  System.Timers.Timer 클래스에는 시스템 클록의 해상도입니다. 즉는 <xref:System.Timers.Timer.Elapsed> 이벤트는 시스템 시계의 정밀도 의해 정의 된 간격으로 발생 하는 <xref:System.Timers.Timer.Interval%2A> 시스템 클록의 해상도 보다 작아야 합니다. 자세한 내용은 <xref:System.Timers.Timer.Interval%2A> 속성을 참조하세요.  
  
 때 <xref:System.Timers.Timer.AutoReset%2A> 로 설정 된 `false`, <xref:System.Timers.Timer?displayProperty=nameWithType> 발생 시키는 개체는 <xref:System.Timers.Timer.Elapsed> 이벤트 한 번만 첫 번째 후 <xref:System.Timers.Timer.Interval%2A> 경과 합니다. 올리기 유지는 <xref:System.Timers.Timer.Elapsed> 가 정의한 간격에서 정기적으로 이벤트는 <xref:System.Timers.Timer.Interval%2A>설정, <xref:System.Timers.Timer.AutoReset%2A> 를 `true`은 기본 값입니다.  
  
 <xref:System.Timers.Timer> 구성 요소의 catch 하 여 억제에 대 한 이벤트 처리기에서 발생 한 모든 예외는 <xref:System.Timers.Timer.Elapsed> 이벤트입니다. 이 동작은.NET Framework의 이후 릴리스에서 변경 될 수 있습니다. 단,이 아닌지 포함할를 비동기적으로 실행 하는 이벤트 처리기의 경우에 `await` 연산자 (C#) 또는 `Await` 연산자 (Visual Basic의 경우). 다음 예제와 같이 이러한 이벤트 처리기에서 throw 된 예외를 호출 스레드로 다시 전파 됩니다. 비동기 메서드에서 throw 된 예외에 대 한 자세한 내용은 참조 하십시오. [예외 처리](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)합니다.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 경우는 <xref:System.Timers.Timer.SynchronizingObject%2A> 속성은 `null`, <xref:System.Timers.Timer.Elapsed> 에서 이벤트가 발생 한 <xref:System.Threading.ThreadPool> 스레드입니다. 처리 하는 경우는 <xref:System.Timers.Timer.Elapsed> 보다 오래 지속 되는 이벤트 <xref:System.Timers.Timer.Interval%2A>, 다른 이벤트를 다시 발생할 수 있습니다 <xref:System.Threading.ThreadPool> 스레드입니다. 이 경우 이벤트 처리기 재진입 되어야 합니다.  
  
> [!NOTE]
>  이벤트 처리 메서드는 한 스레드에서 다른 스레드에서 호출 하는 동시에 실행 될 수 있습니다는 <xref:System.Timers.Timer.Stop%2A> 메서드 또는 집합은 <xref:System.Timers.Timer.Enabled%2A> 속성을 `false`합니다. 이 될 수 있습니다는 <xref:System.Timers.Timer.Elapsed> 타이머가 중지 된 후 발생 하는 이벤트입니다. 에 대 한 예제 코드는 <xref:System.Timers.Timer.Stop%2A> 메서드가 경합 상태를 방지 하는 방법을 보여 줍니다.  
  
 경우에 <xref:System.Timers.Timer.SynchronizingObject%2A> 않습니다 `null`, <xref:System.Timers.Timer.Elapsed> 이벤트 후에 발생할 수 있습니다는 <xref:System.Timers.Timer.Dispose%2A> 또는 <xref:System.Timers.Timer.Stop%2A> 메서드가 호출 된 후 또는 <xref:System.Timers.Timer.Enabled%2A> 속성이로 설정 된 `false`때문에 발생시키는신호<xref:System.Timers.Timer.Elapsed> 스레드 풀 스레드에서 실행 이벤트는 항상 대기 합니다. 이 경합 상태에 대 한 이벤트 처리기를 알려주는 플래그를 설정 하는 것을 해결할 수는 <xref:System.Timers.Timer.Elapsed> 후속 이벤트를 무시 하는 이벤트입니다.  
  
 사용 하는 경우는 <xref:System.Timers.Timer?displayProperty=nameWithType> 폼 이나 컨트롤 해당 사용자 인터페이스 요소에 사용 되는 타이머를 배치 하지 않고 같은 사용자 인터페이스 요소를 사용 하 여 클래스 할당 폼 이나 컨트롤 포함 하는 <xref:System.Timers.Timer> 에 <xref:System.Timers.Timer.SynchronizingObject%2A> 속성, 이벤트는 않도록 사용자 인터페이스 스레드 마샬링됩니다.  
  
 인스턴스에 대 한 기본 속성 값 목록은 <xref:System.Timers.Timer>, 참조는 <xref:System.Timers.Timer.%23ctor%2A> 생성자입니다.  
  
> [!TIP]
>  .NET 라는 4 개의 클래스가 포함 되어 있는지 알아야 `Timer`각각 서로 다른 기능을 제공 하는 중:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (이 항목): 정기적으로 이벤트를 발생 시킵니다. 클래스는 서버 기반으로 사용 또는 되며 다중 스레드 환경에서 서비스 구성 요소를 위한 사용자 인터페이스가 없는 하 고 런타임 시 표시 되지 않습니다.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: 정기적으로 스레드 풀 스레드에서 단일 콜백 메서드를 실행 합니다. 콜백 메서드는 사용 되는 타이머 인스턴스화되고 변경할 수 없는 때 정의 됩니다. 마찬가지로 <xref:System.Timers.Timer?displayProperty=nameWithType> 클래스,이 클래스는 다중 스레드 환경에서 서버 기반 또는 서비스 구성 요소로 사용 하기 위한 사용자 인터페이스가 없는 하 고을 런타임 시 표시 되지 않습니다.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (.NET framework에만 해당): Windows Forms 구성 요소를 일정 한 간격 이벤트를 발생 시킵니다. 구성 요소 사용자 인터페이스가 없는 및 단일 스레드 환경에서 사용 하도록 설계 되었습니다.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (.NET framework에만 해당): 일정 한 간격으로 비동기 또는 동기 웹 페이지 포스트백을 수행 하는 ASP.NET 구성 요소입니다.  

## Examples  
 다음 예제는 `System.Timers.Timer` 발생 하는 개체의 <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> 이벤트 2 초 마다 (2, 000 밀리초)는 이벤트에 대 한 이벤트 처리기를 설정 하 고 타이머를 시작 합니다. 값을 표시 하는 이벤트 처리기는 <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> 속성 될 때마다 발생 합니다.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>모든 공용 <see langword="static" /> 이 형식의 멤버는 스레드로부터 안전 합니다. 인터페이스 멤버는 스레드로부터 안전하지 않습니다.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Timers.Timer" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Timers.Timer" /> 클래스의 새 인스턴스를 초기화하고 모든 속성을 각각의 초기 값으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 표에서의 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Timers.Timer>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 밀리초|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|null 참조(Visual Basic의 경우 `Nothing`)|  
  
   
  
## Examples  
 다음 예제는 <xref:System.Timers.Timer> 발생 하는 개체의 <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> 이벤트 2 초 마다 (2000 밀리초)는 이벤트에 대 한 이벤트 처리기를 설정 하 고 타이머를 시작 합니다. 값을 표시 하는 이벤트 처리기는 <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> 속성 될 때마다 발생 합니다.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">이벤트 간의 시간(밀리초 단위)입니다. 값은 0보다 크고 <see cref="F:System.Int32.MaxValue" />보다 작거나 같아야 합니다.</param>
        <summary>
          <see cref="T:System.Timers.Timer" /> 클래스의 새 인스턴스를 초기화하고 <see cref="P:System.Timers.Timer.Interval" /> 속성을 지정된 시간(밀리초)으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 설정의 <xref:System.Timers.Timer.Interval%2A> 새 타이머 인스턴스의 속성 하지만 사용 되는 타이머를 사용 하지 않습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Timers.Timer> 발생 하는 개체의 <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> 이벤트 2 초 마다 (2000 밀리초)는 이벤트에 대 한 이벤트 처리기를 설정 하 고 타이머를 시작 합니다. 값을 표시 하는 이벤트 처리기는 <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> 속성 될 때마다 발생 합니다.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interval" /> 매개 변수 값이 0보다 작거나 같거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Timers.Timer" />에서 <see cref="E:System.Timers.Timer.Elapsed" /> 이벤트를 한 번만(<see langword="false" />) 발생시켜야 하는지 반복해서(<see langword="true" />) 발생시켜야 하는지 나타내는 부울을 가져오거나 설정합니다.</summary>
        <value>
          간격이 경과할 때마다 <see cref="T:System.Timers.Timer" />에서 <see cref="E:System.Timers.Timer.Elapsed" /> 이벤트를 발생시켜야 하면 <see langword="true" />이고, 첫 번째 간격이 경과한 후 한 번만 <see cref="E:System.Timers.Timer.Elapsed" /> 이벤트를 발생시켜야 하면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Timers.Timer> 이미 때 사용할 수는 <xref:System.Timers.Timer.Start%2A> 메서드가 호출 되 면 재설정 됩니다. 경우 <xref:System.Timers.Timer.AutoReset%2A> 은 `false`, <xref:System.Timers.Timer.Start%2A> 개수를 다시 시작 하기 위해 메서드를 호출 해야 합니다.  
  
 간격을 다시 설정에 영향을 줍니다 시기는 <xref:System.Timers.Timer.Elapsed> 이벤트가 발생 합니다. 예를 들어 간격을 5 초로 설정 하 고 다음을 설정 하는 경우는 <xref:System.Timers.Timer.Enabled%2A> 속성을 `true`, 수 시간에 시작 <xref:System.Timers.Timer.Enabled%2A> 설정 됩니다. 지났을 때 3 초, 10 초 간격을 다시 설정 하는 경우는 <xref:System.Timers.Timer.Elapsed> 13 초 후 처음으로 이벤트는 <xref:System.Timers.Timer.Enabled%2A> 속성이로 설정 된 `true`합니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Timers.Timer> 인 <xref:System.Timers.Timer.Elapsed> 1.5 초 후에 이벤트가 발생 합니다. 해당 이벤트 처리기는 "Hello World!"를 표시 합니다. 콘솔.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>폼에 사용되거나 다른 구성 요소에서 사용하는 <see cref="T:System.Timers.Timer" />의 런타임 초기화를 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 디자인 환경에서이 메서드를 사용 하 여 폼에 또는 다른 구성 요소에서 사용 되는 구성 요소 초기화를 시작 합니다. <xref:System.Timers.Timer.EndInit%2A> 메서드 초기화를 끝냅니다. 사용 하는 <xref:System.Timers.Timer.BeginInit%2A> 및 <xref:System.Timers.Timer.EndInit%2A> 메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Timers.Timer" />에서 사용하는 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Timers.Timer.Close%2A> 메서드 호출에서 `Dispose` 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary>현재 <see cref="T:System.Timers.Timer" />에서 사용하는 모든 리소스를 해제합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>간격이 경과하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Timers.Timer.Elapsed> 이벤트는 <xref:System.Timers.Timer.Enabled%2A> 속성은 `true` 에 정의 된 시간 간격 (밀리초)는 <xref:System.Timers.Timer.Interval%2A> 속성 간격이 경과 합니다. 경우는 <xref:System.Timers.Timer.AutoReset%2A> 속성은 `true`에 정의 된 간격으로 이벤트를 반복적으로 발생는 <xref:System.Timers.Timer.Interval%2A> 속성;는 이벤트가 그렇지 않으면 처음으로 한 번만 <xref:System.Timers.Timer.Interval%2A> 간격이 경과 값입니다.  
  
 경우 <xref:System.Timers.Timer.Interval%2A> 후 설정 됩니다는 <xref:System.Timers.Timer> 가 시작 된 횟수가 재설정 됩니다. 예를 들어 간격을 5 초로 설정 하 고 다음 설정 <xref:System.Timers.Timer.Enabled%2A> 를 `true`, 수 시간에 시작 <xref:System.Timers.Timer.Enabled%2A> 설정 됩니다. 때 3 초, 10 초 간격을 다시 설정 하는 경우는 <xref:System.Timers.Timer.Elapsed> 13 초 후 처음으로 이벤트는 <xref:System.Timers.Timer.Enabled%2A> 로 설정 된 `true`합니다.  
  
 경우는 <xref:System.Timers.Timer.SynchronizingObject%2A> 속성은 `null`, <xref:System.Timers.Timer.Elapsed> 에서 이벤트가 발생 한 <xref:System.Threading.ThreadPool> 스레드입니다. 하는 경우의 처리는 <xref:System.Timers.Timer.Elapsed> 보다 오래 지속 되는 이벤트 <xref:System.Timers.Timer.Interval%2A>, 다른 이벤트를 다시 발생할 수 있습니다 <xref:System.Threading.ThreadPool> 스레드입니다. 이 경우 이벤트 처리기 재진입 되어야 합니다.  
  
> [!NOTE]
>  이벤트 처리 메서드는 한 스레드에서 다른 스레드에서 호출 하는 동시에 실행 될 수 있습니다는 <xref:System.Timers.Timer.Stop%2A> 메서드 또는 집합은 <xref:System.Timers.Timer.Enabled%2A> 속성을 `false`합니다. 이 될 수 있습니다는 <xref:System.Timers.Timer.Elapsed> 타이머가 중지 된 후 발생 하는 이벤트입니다. 에 대 한 예제 코드는 <xref:System.Timers.Timer.Stop%2A> 메서드가 경합 상태를 방지 하는 방법을 보여 줍니다.  
  
 경우에 <xref:System.Timers.Timer.SynchronizingObject%2A> 않습니다 `null`, <xref:System.Timers.Timer.Elapsed> 이벤트 후에 발생할 수 있습니다는 <xref:System.Timers.Timer.Dispose%2A> 또는 <xref:System.Timers.Timer.Stop%2A> 메서드가 호출 된 후 또는 <xref:System.Timers.Timer.Enabled%2A> 속성이로 설정 된 `false`때문에 발생시키는신호<xref:System.Timers.Timer.Elapsed> 스레드 풀 스레드에서 실행 이벤트는 항상 대기 합니다. 이 경합 상태에 대 한 이벤트 처리기를 알려주는 플래그를 설정 하는 것을 해결할 수는 <xref:System.Timers.Timer.Elapsed> 후속 이벤트를 무시 하는 이벤트입니다.  
  
 <xref:System.Timers.Timer> 구성 요소의 catch 하 여 억제에 대 한 이벤트 처리기에서 발생 한 모든 예외는 <xref:System.Timers.Timer.Elapsed> 이벤트입니다. 이 동작은.NET Framework의 이후 릴리스에서 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Timers.Timer> 발생 하는 개체의 <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> 이벤트 2 초 마다 (2000 밀리초)는 이벤트에 대 한 이벤트 처리기를 설정 하 고 타이머를 시작 합니다. 값을 표시 하는 이벤트 처리기는 <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> 속성 될 때마다 발생 합니다.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Timers.Timer" />에서 <see cref="E:System.Timers.Timer.Elapsed" /> 이벤트를 발생시켜야 하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Timers.Timer" />에서 <see cref="E:System.Timers.Timer.Elapsed" /> 이벤트를 발생시켜야 하면 <see langword="true" />이고 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 <xref:System.Timers.Timer.Enabled%2A> 를 `true` 호출할 때와 동일 하 게 <xref:System.Timers.Timer.Start%2A>, 설정 <xref:System.Timers.Timer.Enabled%2A> 를 `false` 호출할 때와 동일 <xref:System.Timers.Timer.Stop%2A>합니다.  
  
> [!NOTE]
>  발생 시키는 신호는 <xref:System.Timers.Timer.Elapsed> 에 실행 이벤트는 항상 대기는 <xref:System.Threading.ThreadPool> 스레드입니다. 이 될 수 있습니다는 <xref:System.Timers.Timer.Elapsed> 후 발생 하는 이벤트는 <xref:System.Timers.Timer.Enabled%2A> 속성이 `false`합니다. 에 대 한 코드 예제는 <xref:System.Timers.Timer.Stop%2A> 메서드가 경합 상태를 해결 하는 방법을 보여 줍니다.  
  
 경우 <xref:System.Timers.Timer.Enabled%2A> 로 설정 된 `true` 및 <xref:System.Timers.Timer.AutoReset%2A> 로 설정 된 `false`, <xref:System.Timers.Timer> 를 발생 시킵니다는 <xref:System.Timers.Timer.Elapsed> 이벤트는 처음에는 간격으로 한 번만 경과 합니다.  
  
 다음은 간격을 설정 하는 경우는 <xref:System.Timers.Timer> 가 시작 된 횟수가 재설정 됩니다. 예를 들어 간격을 5 초로 설정 하 고 다음을 설정 하는 경우는 <xref:System.Timers.Timer.Enabled%2A> 속성을 `true`, 수 시간에 시작 <xref:System.Timers.Timer.Enabled%2A> 설정 됩니다. 때 3 초, 10 초 간격을 다시 설정 하는 경우는 <xref:System.Timers.Timer.Elapsed> 13 초 후 처음으로 이벤트는 <xref:System.Timers.Timer.Enabled%2A> 로 설정 된 `true`합니다.  
  
> [!NOTE]
>  예: Microsoft Visual Studio의 일부 비주얼 디자이너에서 설정 된 <xref:System.Timers.Timer.Enabled%2A> 속성을 `true` 새 삽입할 때 <xref:System.Timers.Timer>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Timers.Timer> 발생 하는 개체의 <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> 이벤트 2 초 마다 (2000 밀리초)는 이벤트에 대 한 이벤트 처리기를 설정 하 고 타이머를 시작 합니다. 값을 표시 하는 이벤트 처리기는 <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> 속성 될 때마다 발생 합니다.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">타이머가 삭제되어 이 속성을 설정할 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException">타이머를 사용하기 전에 <see cref="P:System.Timers.Timer.Interval" /> 속성은 <see cref="F:System.Int32.MaxValue" /> 보다 큰 값으로 설정되었습니다.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>폼에 사용되거나 다른 구성 요소에서 사용하는 <see cref="T:System.Timers.Timer" />의 런타임 초기화를 마칩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 디자인 환경에서이 메서드를 사용 하 여 폼에 또는 다른 구성 요소에서 사용 되는 구성 요소 초기화를 끝냅니다. <xref:System.Timers.Timer.BeginInit%2A> 메서드 초기화를 시작 합니다. 사용 하는 <xref:System.Timers.Timer.BeginInit%2A> 및 <xref:System.Timers.Timer.EndInit%2A> 메서드는 컨트롤이 완전히 초기화 되기 전에 사용 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="E:System.Timers.Timer.Elapsed" /> 이벤트를 발생시킬 간격(밀리초)을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="E:System.Timers.Timer.Elapsed" /> 이벤트 간의 시간(밀리초)입니다. 값은 0보다 크고 <see cref="F:System.Int32.MaxValue" />보다 작거나 같아야 합니다. 기본값은 100밀리초입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하면는 <xref:System.Timers.Timer.Interval%2A> 속성은 빈도 확인 하는 <xref:System.Timers.Timer.Elapsed> 이벤트가 발생 합니다. 때문에 <xref:System.Timers.Timer> 시스템 클록에 따라 달라 집니다 클래스, 시스템 클록의 해상도 있습니다. 즉는 <xref:System.Timers.Timer.Elapsed> 이벤트는 시스템 시계의 정밀도 의해 정의 된 간격으로 발생 하는 <xref:System.Timers.Timer.Interval%2A> 시스템 클록의 해상도 보다 작아야 합니다. 다음 예에서는 <xref:System.Timers.Timer.Interval%2A> 속성을 5 밀리초입니다. 실행할 때는 [!INCLUDE[win7](~/includes/win7-md.md)] 시스템 클럭의 5 밀리초 마다 보다는 약 15 밀리초 마다 약 15 밀리초, 이벤트 발생의 해상도가 하는 시스템입니다.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 현재 시스템에서 시스템 클록의 해상도 확인 하려면 다음 코드를 사용할 수 있습니다.  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 응용 프로그램에서 제공 하는 보다 큰 해상도 필요로 하는 경우는 <xref:System.Timers.Timer> 클래스 또는 고해상도 멀티미디어 타이머를 사용 하 여; 참조 시스템 클록 [하는 방법: High-Resolution 타이머를 사용 하 여](http://msdn.microsoft.com/library/aa964692.aspx)합니다.  
  
 다음은 간격을 설정 하는 경우는 <xref:System.Timers.Timer> 가 시작 된 횟수가 재설정 됩니다. 예를 들어 간격을 5 초로 설정 하 고 다음을 설정 하는 경우는 <xref:System.Timers.Timer.Enabled%2A> 속성을 `true`, 수 시간에 시작 <xref:System.Timers.Timer.Enabled%2A> 설정 됩니다. 때 3 초, 10 초 간격을 다시 설정 하는 경우는 <xref:System.Timers.Timer.Elapsed> 13 초 후 처음으로 이벤트는 <xref:System.Timers.Timer.Enabled%2A> 로 설정 된 `true`합니다.  
  
 경우 <xref:System.Timers.Timer.Enabled%2A> 로 설정 된 `true` 및 <xref:System.Timers.Timer.AutoReset%2A> 로 설정 된 `false`, <xref:System.Timers.Timer> 를 발생 시킵니다는 <xref:System.Timers.Timer.Elapsed> 이벤트는 처음에는 간격으로 한 번만 경과 합니다. <xref:System.Timers.Timer.Enabled%2A> 으로 설정 됩니다 `false`합니다.  
  
> [!NOTE]
>  경우 <xref:System.Timers.Timer.Enabled%2A> 및 <xref:System.Timers.Timer.AutoReset%2A> 으로 설정 됩니다 `false`, 및 타이머 이전에 활성화 되어 있는 설정의 <xref:System.Timers.Timer.Interval%2A> 속성 원인을 <xref:System.Timers.Timer.Elapsed> 이벤트를 한 번 발생 처럼는 <xref:System.Timers.Timer.Enabled%2A> 에설정된속성`true`. 간격 이벤트를 생성 하지 않고을 설정 하려면 일시적으로 설정한는 <xref:System.Timers.Timer.Enabled%2A> 속성을 `true`설정는 <xref:System.Timers.Timer.Interval%2A> 속성을 원하는 시간 간격을 즉시 설정 하 고는 <xref:System.Timers.Timer.Enabled%2A> 속성을 다시 `false`합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Timers.Timer> 발생 하는 개체의 <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> 이벤트 2 초 마다 (2000 밀리초)는 이벤트에 대 한 이벤트 처리기를 설정 하 고 타이머를 시작 합니다. 값을 표시 하는 이벤트 처리기는 <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> 속성 될 때마다 발생 합니다.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">간격이 0 이하인 경우  
  
 또는  
  
 간격은 <see cref="F:System.Int32.MaxValue" /> 보다 크며, 타이머는 현재 사용 가능합니다. 타이머를 현재 사용할 수 없는 경우, 사용 가능하게 될 때까지 예외가 throw되지 않습니다.</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디자인 모드에서 <see cref="T:System.Timers.Timer" />를 컨테이너에 바인딩하는 사이트를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Timers.Timer" /> 개체를 컨테이너에 바인딩하는 사이트를 나타내는 <see cref="T:System.ComponentModel.ISite" /> 인터페이스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사이트 바인딩는 <xref:System.ComponentModel.Component> 에 <xref:System.ComponentModel.Container> 서로 통신할 수 있도록 할 뿐만 아니라 해당 구성 요소를 관리 하는 컨테이너에 대 한 방법을 제공 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Timers.Timer.Enabled" />를 <see langword="true" />로 설정하여 <see cref="E:System.Timers.Timer.Elapsed" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 <xref:System.Timers.Timer.Start%2A> 라고 하 고 <xref:System.Timers.Timer.AutoReset%2A> 로 설정 된 `false`, <xref:System.Timers.Timer> 를 발생 시킵니다는 <xref:System.Timers.Timer.Elapsed> 이벤트는 처음에는 간격으로 한 번만 경과 합니다. 경우 <xref:System.Timers.Timer.Start%2A> 라고 하 고 <xref:System.Timers.Timer.AutoReset%2A> 은 `true`, <xref:System.Timers.Timer> 를 발생 시킵니다는 <xref:System.Timers.Timer.Elapsed> 첫 번째 이벤트 시간 간격이 경과 하 고 계속 지정된 된 간격에 이벤트를 발생 시킵니다.  
  
 설정 하 여 타이밍을 시작할 수도 <xref:System.Timers.Timer.Enabled%2A> 를 `true`합니다.  
  
> [!NOTE]
>  경우 <xref:System.Timers.Timer.AutoReset%2A> 은 `false`, <xref:System.Timers.Timer.Start%2A> 개수를 다시 시작 하기 위해 메서드를 호출 해야 합니다.  
  
 에 대 한 호출에서 <xref:System.Timers.Timer.Start%2A> 메서드를 사용 되는 타이머를 사용 하도록 설정 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="T:System.Timers.Timer" />를 만들 때 간격을 <see cref="F:System.Int32.MaxValue" /> + 1보다 크거나 같은 값으로 설정했거나 0보다 작은 값으로 설정한 경우</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="P:System.Timers.Timer.Enabled" />를 <see langword="false" />로 설정하여 <see cref="E:System.Timers.Timer.Elapsed" /> 이벤트 발생을 중지합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 하 여 타이밍을 중지할 수도 <xref:System.Timers.Timer.Enabled%2A> 를 `false`합니다.  
  
> [!NOTE]
>  발생 시키는 신호는 <xref:System.Timers.Timer.Elapsed> 이벤트는 항상 실행 대기에 <xref:System.Threading.ThreadPool> 스레드, 이벤트 처리 메서드는 동일한 하나의 스레드에서 실행 되므로 시간에 대 한 호출은 <xref:System.Timers.Timer.Stop%2A> 다른 스레드에서 메서드를 실행 합니다. 이 될 수 있습니다는 <xref:System.Timers.Timer.Elapsed> 후 발생 하는 이벤트는 <xref:System.Timers.Timer.Stop%2A> 메서드를 호출 합니다. 다음 섹션의 코드 예제에서는이 경합 상태를 해결 하는 방법을 보여 줍니다.  
  
   
  
## Examples  
 다음 예제는 `System.Timers.Timer` 발생 하는 개체의 <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> 이벤트 2 초 마다 (2, 000 밀리초)는 이벤트에 대 한 이벤트 처리기를 설정 하 고 타이머를 시작 합니다. 값을 표시 하는 이벤트 처리기는 <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> 속성 될 때마다 발생 합니다. 사용자가 Enter 키를 누르면 응용 프로그램 호출에서 <xref:System.Timers.Timer.Stop%2A> 응용 프로그램을 종료 하기 전에 메서드.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 다음 코드 예제에서는 호출 하는 스레드를 방지 하는 방법을 보여 줍니다.는 <xref:System.Timers.Timer.Stop%2A> 메서드를 현재 실행 될 때까지 계속할 <xref:System.Timers.Timer.Elapsed> 이벤트 끝 두 것을 방지 하려면 또한 <xref:System.Timers.Timer.Elapsed> 이벤트는 동일한 이벤트 처리기를 실행 합니다. 시간 (재진입 라고도 함)입니다.  
  
 이 예제에서는 100 테스트 실행을 실행합니다. 에 테스트가 실행 될 때마다 타이머가 150 시간 (밀리초) 간격으로 시작 됩니다. 이벤트 처리기에서 사용 된 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 다양 한 길이는 50 200 밀리초를 하는 작업을 시뮬레이션 하는 메서드. 테스트 메서드는 또한 잠시 동안 기다린 다음 타이머를 중지 하는 제어 스레드를 시작 합니다. 컨트롤 스레드 타이머를 중지 하는 경우 이벤트를 처리 되 고, 컨트롤 스레드 이벤트가 계속 진행 하기 전에 완료 될 때까지 기다려야 합니다.  
  
 <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 재진입을 방지 하 고 제어 스레드 실행 중인 이벤트가 종료 될 때까지 계속 하지 않게 하려면 메서드 오버 로드를 사용 합니다. 이벤트 처리기에서 사용 된 <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> 변수를 1로 되지만 현재 값이 0 인 경우에 컨트롤을 설정 하려면 메서드. 이 작업은 원자성 작업입니다. 반환 값 0 이면 제어 변수를 1로 설정 하 고 이벤트 처리기에 진행 됩니다. 반환 값 0이 아닌 경우 재진입을 방지 하는 이벤트가 취소 됩니다. (모든 이벤트를 실행 하는 데 필요한 것은 <xref:System.Threading.Monitor> 클래스에 더 좋은 방법은 이벤트를 동기화 하는 것입니다.) 이벤트 처리기가 종료 때 제어 변수를 다시 0으로 설정. 이 예제에서는 기록 하 고 실행 된 재진입으로 인해 삭제 된 후에 발생 한 이벤트의 총 수는 <xref:System.Timers.Timer.Stop%2A> 메서드를 호출 했습니다.  
  
 컨트롤 스레드가 사용 하는 <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> 변수 (-1),-1로 되지만 현재 값이 0 인 경우에 컨트롤을 설정 하는 메서드. 원자 단위 작업에서 반환 하는 0이 아닌 이벤트 진행 중입니다. 컨트롤 스레드 잠시 기다린 후 다시 시도 합니다. 이 예제에서는 컨트롤 스레드 이벤트가 완료 될 때까지 기다려야 했던 횟수를 기록 합니다.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>시간 간격이 경과할 때 발행되는 이벤트 처리기 호출을 마샬링하는 데 사용되는 개체를 가져오거나 설정합니다.</summary>
        <value>시간 간격이 경과할 때 발행되는 이벤트 처리기 호출을 마샬링하는 데 사용되는 개체를 나타내는 <see cref="T:System.ComponentModel.ISynchronizeInvoke" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Timers.Timer.SynchronizingObject%2A> 은 `null`를 처리 하는 메서드는 <xref:System.Timers.Timer.Elapsed> 이벤트 시스템 스레드 풀의 스레드라도에서 호출 됩니다. 시스템 스레드 풀에 대 한 자세한 내용은 참조 하십시오. <xref:System.Threading.ThreadPool>합니다.  
  
 경우는 <xref:System.Timers.Timer.Elapsed> 수 결과 예외가 하거나 작동 하지 않을 수 시스템 스레드 풀을 통해 구성 요소에 액세스 하는 단추와 같은 한 시각적 Windows Forms 구성 요소 이벤트를 처리 합니다. 이 효과 설정 하 여 방지할 <xref:System.Timers.Timer.SynchronizingObject%2A> 처리 하는 메서드 때문에 Windows Forms 구성 요소에는 <xref:System.Timers.Timer.Elapsed> 구성 요소에 만들어진 스레드와 동일한 스레드에서 호출 이벤트입니다.  
  
> [!NOTE]
>  경우에는 <xref:System.Timers.Timer.SynchronizingObject%2A> 속성은 `null`, <xref:System.Timers.Timer.Elapsed> 이벤트 후에 발생할 수 있습니다는 <xref:System.Timers.Timer.Dispose%2A> 또는 <xref:System.Timers.Timer.Stop%2A> 메서드가 호출 된 후 또는 <xref:System.Timers.Timer.Enabled%2A> 속성이로 설정 된 `false`때문에 발생 시키는 신호 <xref:System.Timers.Timer.Elapsed> 스레드 풀 스레드에서 실행 이벤트는 항상 대기 합니다. 이 경합 상태에 대 한 이벤트 처리기를 알려주는 플래그를 설정 하는 것을 해결할 수는 <xref:System.Timers.Timer.Elapsed> 후속 이벤트를 무시 하는 이벤트입니다.  
  
 경우는 <xref:System.Timers.Timer> Windows Forms 디자이너에서 Visual Studio 내에서 사용 되 <xref:System.Timers.Timer.SynchronizingObject%2A> 포함 하는 컨트롤에 자동으로 설정 됩니다는 <xref:System.Timers.Timer>합니다. 예를 들어, 배치 하는 경우는 <xref:System.Timers.Timer> 에 대 한 디자이너에서 `Form1` (에서 상속 되 <xref:System.Windows.Forms.Form>), <xref:System.Timers.Timer.SynchronizingObject%2A> 속성 <xref:System.Timers.Timer> 인스턴스의로 설정 된 `Form1`합니다.  
  
   
  
## Examples  
 다음 예제는 매우 간단한 텍스트 파일 편집기로 사용 되는 Windows Forms 응용 프로그램입니다. 텍스트 상자에 텍스트 저장 되지 않은 경우 응용 프로그램 사용자에 게 요청 1 분 간격으로 하는지 여부를 보려는 입력란의 내용을 저장 하 합니다.  이렇게 하려면는 <xref:System.Timers.Timer.Interval%2A> 속성을 1 분 (60, 000 밀리초)로 설정 및 <xref:System.Timers.Timer.SynchronizingObject%2A> 속성이로 설정 되는 <xref:System.Windows.Forms.Form> 개체입니다.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 이 예제에서는 폼에는 다음과 같은 컨트롤을 추가 합니다.  
  
-   A <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `TextBox1` (기본 이름).  
  
-   A <xref:System.Windows.Forms.Button> 라는 컨트롤 `Button1` (기본 이름).  
  
-   A <xref:System.Windows.Forms.SaveFileDialog> 라는 컨트롤 `SaveSaveFileDialog1` (기본 이름).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>