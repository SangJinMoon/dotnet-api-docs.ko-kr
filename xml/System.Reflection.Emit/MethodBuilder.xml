<Type Name="MethodBuilder" FullName="System.Reflection.Emit.MethodBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c93c1a358d5c177a5835b41cbeaeae252a6af730" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30470777" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MethodBuilder : System.Reflection.MethodInfo, System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo implements class System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.MethodBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodBuilder&#xA;Inherits MethodInfo&#xA;Implements _MethodBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder sealed : System::Reflection::MethodInfo, System::Runtime::InteropServices::_MethodBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>동적 클래스에 메서드(또는 생성자)를 정의하고 표시합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder> 클래스는 완전 하 게 Microsoft MSIL (intermediate language), 이름, 특성, 서명 및 메서드 본문을 포함 하는 메서드를 설명 하는 데 사용 합니다. 와 함께에서 사용 되는 <xref:System.Reflection.Emit.TypeBuilder> 런타임으로 클래스를 생성 하는 클래스입니다.  
  
## <a name="global-methods-and-methods-as-type-members"></a>전역 메서드 및 형식 멤버와 메서드  
 리플렉션을 사용 하 여 전역 메서드를 정의 하 고 형식 멤버와 메서드를 정의를 내보냅니다. 메서드를 정의 하는 Api 반환 <xref:System.Reflection.Emit.MethodBuilder> 개체입니다.  
  
### <a name="global-methods"></a>전역 메서드  
 전역 메서드를 사용 하 여 정의 된 <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType> 반환 하는 **MethodBuilder** 개체입니다.  
  
 전역 메서드는 정적 이어야 합니다. 동적 모듈에는 전역 메서드를 포함 하는 경우는 <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType> 공용 언어 런타임에서 동적 모듈을 수정 하는 모든 전역 함수가 될 때까지 연기 하기 때문에 동적 모듈 또는 포함 하는 동적 어셈블리를 유지 하기 전에 메서드를 호출 해야 합니다 정의 되어 있습니다.  
  
 전역 기본 메서드를 사용 하 여 정의 된 <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType> 메서드. 플랫폼 호출 (PInvoke) 추상 또는 가상 메서드를 선언 되어야 합니다. 런타임 설정은 <xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType> 플랫폼에 대 한 특성 메서드를 호출 합니다.  
  
### <a name="methods-as-members-of-types"></a>형식의 멤버와 메서드  
 메서드를 사용 하 여 형식 멤버로 정의 된 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 반환 하는 <xref:System.Reflection.Emit.MethodBuilder> 개체입니다.  
  
 <xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A> 메서드를 사용 하는 매개 변수 또는 반환 값의 이름 및 매개 변수 특성을 설정 합니다. <xref:System.Reflection.Emit.ParameterBuilder> 이 메서드에서 반환 된 개체는 매개 변수 또는 반환 값을 나타냅니다. <xref:System.Reflection.Emit.ParameterBuilder> 마샬링을 설정 상수 값을 설정 하 고 사용자 지정 특성을 적용 하는 개체를 사용할 수 있습니다.  
  
## <a name="attributes"></a>특성  
 멤버는 <xref:System.Reflection.MethodAttributes> 열거형 동적 메서드의 정확한 문자를 정의 합니다.  
  
-   정적 메서드를 사용 하 여 지정 된는 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType> 특성입니다.  
  
-   최종 메서드 (재정의할 수 없는 메서드)를 사용 하 여 지정 된는 <xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType> 특성입니다.  
  
-   가상 메서드를 사용 하 여 지정 된는 <xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType> 특성입니다.  
  
-   추상 메서드를 사용 하 여 지정 된는 <xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType> 특성입니다.  
  
-   몇 가지 특성에는 메서드 표시 유형을 결정 합니다. 에 대 한 설명을 참조는 <xref:System.Reflection.MethodAttributes> 열거형입니다.  
  
-   오버 로드 된 연산자를 구현 하는 메서드를 설정 해야 합니다는 <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> 특성입니다.  
  
-   종료자 설정 해야 합니다는 <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> 특성입니다.  
  
## <a name="known-issues"></a>알려진 문제  
  
-   하지만 <xref:System.Reflection.Emit.MethodBuilder> 에서 파생 된 <xref:System.Reflection.MethodInfo>에 정의 된 추상 메서드 중 일부는 <xref:System.Reflection.MethodInfo> 클래스에서 구현 되는 것은 완벽 하 게 <xref:System.Reflection.Emit.MethodBuilder>합니다. 이러한 <xref:System.Reflection.Emit.MethodBuilder> 메서드에서 throw 된 <xref:System.NotSupportedException>합니다. 예를 들어는 <xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType> 메서드가 완전 하 게 구현 되지 않았습니다. 사용 하 여 바깥쪽 형식을 검색 하 여 이러한 메서드에 반영할 수 있습니다는 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 메서드.  
  
-   사용자 지정 한정자는.NET Framework 버전 2.0부터 지원 됩니다. 이전 버전에서 지원 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Reflection.Emit.MethodBuilder> 클래스 동적 형식 내에서 메서드를 만듭니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">요청, 어설션 등과 같은 수행할 보안 작업입니다.</param>
        <param name="pset">작업이 적용되는 사용 권한 집합입니다.</param>
        <summary>이 메서드에 선언적 보안을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> 보안 동작을 지정 하는 각 호출에 여러 번 호출할 수 있습니다 (같은 `Demand`, `Assert`, 및 `Deny`) 및 작업에 적용 되는 사용 권한 집합입니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0, 1.1 및 2.0을 사용 하 여 메서드에 적용 되는 선언적 보안 특성에에서는 <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> 메서드 이전 XML 메타 데이터 형식으로 저장 됩니다. 선언적 보안 특성을 내보내기를 참조 하십시오.  
  
   
  
## Examples  
 다음 코드 예제에서는 컨텍스트를 사용 `AddDeclarativeSecurity` 게 무제한 권한을 메서드의 호출자를 요구 하도록 합니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="action" />이 유효하지 않습니다(<see langword="RequestMinimum" />, <see langword="RequestOptional" /> 및 <see langword="RequestRefuse" />가 유효하지 않음).</exception>
        <exception cref="T:System.InvalidOperationException">포함하는 형식을 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만들었습니다.  
  
 또는  
  
 사용 권한 집합 <paramref name="pset" />에 이전에 <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />에 의해 추가된 작업이 포함되어 있습니다.  
  
 또는  
  
 현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pset" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드에 대한 특성을 검색합니다.</summary>
        <value>읽기 전용입니다. 이 메서드에 대해 <see langword="MethodAttributes" />를 검색합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드의 호출 규칙을 반환합니다.</summary>
        <value>읽기 전용입니다. 메서드의 호출 규칙입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식에 대해 지원되지 않습니다.</summary>
        <value>지원되지 않습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.MethodBuilder> 항상 제네릭 메서드 정의 나타내며 호출할 수 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>를 참조하세요. 제네릭 형식에 대 한 자세한 내용은 참조 하십시오. <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="CreateMethodBody">
      <MemberSignature Language="C#" Value="public void CreateMethodBody (byte[] il, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateMethodBody(unsigned int8[] il, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMethodBody (il As Byte(), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMethodBody(cli::array &lt;System::Byte&gt; ^ il, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="il">유효한 MSIL 명령이 들어 있는 배열입니다. 이 매개 변수가 <see langword="null" />이면 메서드 본문이 지워집니다.</param>
        <param name="count">유효한 MSIL 배열의 바이트의 수입니다. MSIL이 <see langword="null" />이면 이 값은 무시됩니다.</param>
        <summary>MSIL(Microsoft Intermediate Language) 명령의 제공된 바이트 배열을 사용하여 메서드의 본문을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 만드는에서 메서드 본문이 `il`opcode로 MSIL 명령이 들어 있는 배열입니다. 유효한 MSIL의 바이트 수가 수에 따라 제공 됩니다.  
  
> [!NOTE]
>  이 현재 완전히 지원 되지 않습니다. 사용자 토큰 픽스업 및 예외 처리기의 위치를 지정할 수 없습니다.  
  
   
  
## Examples  
 아래에 제공 된 예제에서는 두 정수를 추가 하는 간단한 방법을 opcode를 사용 하 여를 통해 생성 된 `CreateMethodBody`합니다.  
  
 [!code-cpp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CPP/source.cpp#1)]
 [!code-csharp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CS/source.cs#1)]
 [!code-vb[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />이(가) 제공된 MSIL 명령 배열의 인덱스 범위 내에 있지 않으며 <paramref name="il" />이(가) <see langword="null" />이 아닙니다.</exception>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 이전에 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만든 것입니다.  
  
 또는  
  
 이 메서드는 <see langword="null" />이 아닌 <paramref name="il" /> 인수를 사용하여 이 <see langword="MethodBuilder" />에서 이전에 호출되었습니다.  
  
 또는  
  
 현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드를 선언하는 형식을 반환합니다.</summary>
        <value>읽기 전용입니다. 이 메서드를 선언하는 형식입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드에서는 사용 된 `Type` 속성입니다.  
  
 [!code-cpp[MethodBuilderClass_TypeSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CPP/methodbuilderclass.cpp#1)]
 [!code-csharp[MethodBuilderClass_TypeSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CS/methodbuilderclass.cs#1)]
 [!code-vb[MethodBuilderClass_TypeSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilderClass_TypeSample/VB/methodbuilderclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">제네릭 형식 매개 변수의 이름을 나타내는 문자열의 배열입니다.</param>
        <summary>현재 메서드에 대한 제네릭 형식 매개 변수의 개수를 설정하고 이러한 매개 변수의 이름을 지정하며 관련 제약 조건을 정의하는 데 사용할 수 있는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 개체의 배열을 반환합니다.</summary>
        <returns>제네릭 메서드의 형식 매개 변수를 나타내는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드를 사용 하면 현재 메서드가 제네릭입니다. 이 변경을 실행 취소할 방법이 없습니다. 이 메서드를 두 번째로 호출 하면 프로그램 <xref:System.InvalidOperationException>합니다.  
  
 제네릭 메서드의 형식 매개 변수를 사용 하 여 나중에 검색할 수는 <xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A> 메서드.  
  
 일반적으로 형식 매개 변수 이름은 대문자로 된 단일 문자입니다.  
  
 자세한 내용은 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>를 참조하세요. 제네릭 형식에 대 한 자세한 내용은 참조 하십시오. <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 형식을 만들 `DemoType`, 동적 제네릭 메서드를 포함 하 `DemoMethod`합니다. 이 메서드는 두 제네릭 형식 매개 변수 중 하나는 매개 변수를 지정 하 고 반환 형식으로 다른 사용 됩니다.  
  
 코드를 실행하면 동적 어셈블리가 DemoGenericMethod1.dll로 저장되며 [Ildasm.exe(IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)를 사용하여 검사할 수 있습니다.  
  
> [!NOTE]
>  이 코드 예제에서는 단순히 null 참조를 반환 하는 간단한 메서드 본문을 생성 합니다. 만들고 제네릭 형식을 사용 하는 보다 완전 한 기능된을 메서드 본문이 코드 예제를 참조 하십시오. [하는 방법: 리플렉션 내보내기를 사용 하 여 제네릭 메서드 정의](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)합니다.  
  
 [!code-cpp[GenericMethodBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#1)]
 [!code-csharp[GenericMethodBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#1)]
 [!code-vb[GenericMethodBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">제네릭 형식 매개 변수가 이 메서드에 대해 이미 정의되었습니다.  
  
 또는  
  
 메서드가 이미 완료되었습니다.  
  
 또는  
  
 현재 메서드에 대해 <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> 메서드가 호출되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="names" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="names" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" />가 빈 배열인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.DefineMethod" />
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string strParamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string strParamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, strParamName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ strParamName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="strParamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">매개 변수 목록에서 매개 변수의 위치입니다. 매개 변수 중 첫 번째 매개 변수의 경우 인덱스가 1부터 시작하며, 숫자 0은 메서드의 반환 값을 나타냅니다.</param>
        <param name="attributes">매개 변수의 매개 변수 특성입니다.</param>
        <param name="strParamName">매개 변수의 이름입니다. 이름이 null 문자열일 수 있습니다.</param>
        <summary>이 메서드의 매개 변수 특성 및 이름 또는 이 메서드의 반환 값 특성 및 이름을 설정합니다. 사용자 지정 특성을 적용하는 데 사용할 수 있는 ParameterBuilder를 반환합니다.</summary>
        <returns>이 메서드의 매개 변수 또는 이 메서드의 반환 값을 나타내는 <see langword="ParameterBuilder" /> 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ParameterBuilder> 매개 변수에 대해 기본값을 설정 하거나 사용자 지정 특성을 적용 하려면이 메서드에서 반환 된 개체를 사용할 수 있습니다.  
  
 따라서 1, 매개 변수 번호 시작 `position` 는 첫 번째 매개 변수에 대 한 1입니다. 경우 `position` 가 0 이면이 메서드는 반환 값에 영향을 줍니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0 및 1.1에서는 예외가 발생 하는 경우 `position` 가 0 이면 해당 버전에서 반환 값의 속성을 수정 하려면이 메서드를 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">메서드에 매개 변수가 없습니다.  
  
 또는  
  
 <paramref name="position" />가 0보다 작은 경우  
  
 또는  
  
 <paramref name="position" />이 메서드의 매개 변수 수보다 큽니다.</exception>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 이전에 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만든 것입니다.  
  
 또는  
  
 현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">이 <see langword="MethodBuilder" /> 인스턴스와 비교할 개체입니다.</param>
        <summary>지정된 개체가 이 인스턴스와 같은지 여부를 확인합니다.</summary>
        <returns>
          <paramref name="obj" />가 <see langword="MethodBuilder" />의 인스턴스이고 이 개체와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일치 여부는 동일한 이름, 특성 및 서명 하 여 결정 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>메서드의 기본 구현을 반환합니다.</summary>
        <returns>이 메서드의 기본 구현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재가 항상 반환 `MethodBuilder` 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 메서드에 대해 정의된 사용자 지정 특성을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">이 멤버의 상속 체인을 검색하여 사용자 지정 특성을 찾을지 여부를 지정합니다.</param>
        <summary>이 메서드에 대해 정의된 모든 사용자 지정 특성을 반환합니다.</summary>
        <returns>이 메서드의 모든 사용자 지정 특성을 나타내는 개체 배열을 반환합니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">사용자 지정 특성 유형입니다.</param>
        <param name="inherit">이 멤버의 상속 체인을 검색하여 사용자 지정 특성을 찾을지 여부를 지정합니다.</param>
        <summary>지정된 형식으로 식별되는 사용자 지정 특성을 반환합니다.</summary>
        <returns>
          <paramref name="attributeType" /> 형식인 이 메서드의 특성을 나타내는 개체의 배열을 반환합니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>제네릭인 경우 메서드의 형식 매개 변수를 나타내는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 개체의 배열을 반환합니다.</summary>
        <returns>메서드가 제네릭인 경우 형식 매개 변수를 나타내는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 개체의 배열이거나, 제네릭이 아닌 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 도 제네릭 메서드의 형식 매개 변수에서 반환 되는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드를 정의 하는 데 사용 합니다.  
  
 자세한 내용은 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>를 참조하세요. 제네릭 형식에 대 한 자세한 내용은 참조 하십시오. <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.MethodBuilder" />의 현재 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.MethodBuilder> 직접 생성 된 제네릭 메서드를 내보내는 데 사용할 수 없습니다. 내보낸된 메서드는 제네릭 메서드 정의 합니다.  
  
 자세한 내용은 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>를 참조하세요. 제네릭 형식에 대 한 자세한 내용은 참조 하십시오. <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 메서드는 제네릭이 아닙니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성이 <see langword="false" />를 반환합니다.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드의 해시 코드를 가져옵니다.</summary>
        <returns>이 메서드의 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 메서드에 대한 <see langword="ILGenerator" />를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>64바이트의 기본 MSIL(Microsoft Intermediate Language) 스트림 크기를 사용하는 이 메서드에 대한 <see langword="ILGenerator" />를 반환합니다.</summary>
        <returns>이 메서드에 대한 <see langword="ILGenerator" /> 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 사용 하 여는 `GetILGenerator` 메서드를 작성 하 고 3D 공간에서 두 점의 내적을 계산 하는 동적 어셈블리를 생성 합니다.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 메서드는 해당 <see cref="T:System.Reflection.MethodAttributes" /> 또는 <see cref="T:System.Reflection.MethodImplAttributes" /> 플래그 때문에 본문이 없어야 합니다(예: <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 플래그 포함).  
  
 또는  
  
 이 메서드는 제네릭 메서드 정의가 아닌 제네릭 메서드입니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (size As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">MSIL 스트림에 바이트의 크기입니다.</param>
        <summary>지정된 MSIL(Microsoft Intermediate Language) 스트림 크기를 사용하여 이 메서드에 대한 <see langword="ILGenerator" />를 반환합니다.</summary>
        <returns>이 메서드에 대한 <see langword="ILGenerator" /> 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 사용 하 여는 `GetILGenerator` 메서드를 작성 하 고 3D 공간에서 두 점의 내적을 계산 하는 동적 어셈블리를 생성 합니다.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 메서드는 해당 <see cref="T:System.Reflection.MethodAttributes" /> 또는 <see cref="T:System.Reflection.MethodImplAttributes" /> 플래그 때문에 본문이 없어야 합니다(예: <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 플래그 포함).  
  
 또는  
  
 이 메서드는 제네릭 메서드 정의가 아닌 제네릭 메서드입니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>메서드에 대한 구현 플래그를 반환합니다.</summary>
        <returns>메서드에 대한 구현 플래그를 반환합니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module GetModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module GetModule() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetModule" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModule () As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Module ^ GetModule();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드를 포함하는 모듈에 대한 참조를 반환합니다.</summary>
        <returns>이 메서드를 포함하는 모듈에 대한 참조를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 아래 샘플 코드의 사용법을 보여 줍니다.는 `GetModule` 메서드를 동적으로 생성 된 모듈에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CPP/source3.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CS/source3.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드의 매개 변수를 반환합니다.</summary>
        <returns>메서드의 매개 변수를 나타내는 <see langword="ParameterInfo" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 `GetParameters` 동적으로 생성 된 메서드에 전달 된 매개 변수에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CPP/source4.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CS/source4.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/VB/source4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see langword="GetParameters" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetToken () As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetToken();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드의 토큰을 나타내는 <see langword="MethodToken" />을 반환합니다.</summary>
        <returns>이 메서드의 <see langword="MethodToken" />을 반환합니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드의 로컬 변수가 0으로 초기화되었는지 여부를 지정하는 부울 값을 가져오거나 설정합니다. 이 속성의 기본값은 <see langword="true" />입니다.</summary>
        <value>
          이 메서드의 로컬 변수가 0으로 초기화되면 <see langword="true" />이고, 초기화되지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은로 설정 하는 경우 `true`, 내보낸된 MSIL 지역 변수는 초기화를 포함 합니다. 로 설정 되어 있으면 `false`, 지역 변수는 초기화 되지 및 생성된 된 코드를 확인할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다. (가져오기 또는 설정)</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">지정한 메서드를 호출할 개체입니다. 메서드가 정적이면 이 매개 변수가 무시됩니다.</param>
        <param name="invokeAttr">이것은 <see langword="InvokeMethod" />, <see langword="NonPublic" /> 등과 같은 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그여야 합니다.</param>
        <param name="binder">리플렉션을 사용하여 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 MemberInfo 개체 검색을 사용할 수 있도록 하는 개체입니다. 바인더가 <see langword="null" />이면 기본 바인더가 사용됩니다. 자세한 내용은 <see cref="T:System.Reflection.Binder" />을 참조하십시오.</param>
        <param name="parameters">인수 목록입니다. 호출되는 메서드의 매개 변수와 숫자, 순서, 형식이 동일한 인수의 배열입니다. 매개 변수가 없는 경우에는 <see langword="null" />이어야 합니다.</param>
        <param name="culture">형식의 강제 변환을 제어하는 데 사용되는 <see cref="T:System.Globalization.CultureInfo" />의 인스턴스입니다. 이 인스턴스가 null이면 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다. 예를 들면 1000은 각 문화권마다 다르게 표현되므로 1000을 나타내는 <see cref="T:System.String" />을 <see cref="T:System.Double" /> 값으로 변환하기 위해 필요합니다.</param>
        <summary>지정된 바인더의 제약 조건에 따라 지정한 매개 변수를 전달하여 지정된 개체에 있는 이 인스턴스에 의해 반영된 메서드를 동적으로 호출합니다.</summary>
        <returns>호출된 메서드의 반환 값을 포함하는 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드가 정적 이면는 `obj` 매개 변수가 무시 됩니다. Static이 아닌 메서드에 대 한 `obj` 상속 하거나 메서드를 선언 하 고이 클래스와 동일한 형식 이어야 하는 클래스의 인스턴스여야 합니다. 메서드 매개 변수가 없는 경우, 값 `parameters` 해야 `null`합니다. 그렇지 않으면 개수, 형식 및 매개 변수 배열에 있는 요소의 순서는 개수, 형식 및이 인스턴스에 의해 반영 된 메서드에 대 한 매개 변수의 순서와 같아야 합니다.  
  
> [!NOTE]
>  완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 없습니다. 즉, private 생성자, 메서드, 필드 및 속성에 액세스할 수 있습니다 및 코드를 완전히 신뢰할 수 있는 경우 리플렉션을 사용 하 여 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">사용자 지정 특성 유형입니다.</param>
        <param name="inherit">이 멤버의 상속 체인을 검색하여 사용자 지정 특성을 찾을지 여부를 지정합니다.</param>
        <summary>지정된 사용자 지정 특성 유형이 정의되었는지 확인합니다.</summary>
        <returns>
          지정된 사용자 지정 특성 형식이 정의되어 있으면 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드가 제네릭 메서드인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          메서드가 제네릭인 경우 <see langword="true" />이고, 그렇지 않은 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드는 제네릭 형식 매개 변수가 있는 경우. 제네릭으로 만들 있습니다 메서드를 호출 하 여는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드 형식 매개 변수를 추가 합니다. 이 변경은 되돌릴 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메서드의 상태를 표시합니다. 이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드.  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 개체가 제네릭 메서드의 정의를 나타내는지 여부를 표시하는 값을 가져옵니다.</summary>
        <value>
          현재 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 개체가 제네릭 메서드 정의를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.MethodBuilder> ; 제네릭 메서드 정의 만들 수만 사용할 수 생성 된 제네릭 메서드를 직접 만드는 데 사용할 수 없습니다. 그러나의 서브 클래스 <xref:System.Reflection.Emit.MethodBuilder> 생성 된 제네릭 메서드를 나타낼 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메서드의 상태를 표시합니다. 이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드.  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</summary>
        <value>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 어셈블리의 메서드에서 보안에 중요 한 인지를 확인 하려면 형식을 호출 하 여 완성 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, 호출의 <xref:System.Type.GetMethod%2A> 완료 된 유형과 get 메서드는 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> 결과에서 속성 <xref:System.Reflection.MethodInfo>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">모든 경우 동적 어셈블리에서는 이 속성이 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</summary>
        <value>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 어셈블리의 메서드에서 보안 안전에 중요 한 인지를 확인 하려면 형식을 호출 하 여 완성 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, 호출의 <xref:System.Type.GetMethod%2A> 완료 된 유형과 get 메서드는 <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> 결과에서 속성 <xref:System.Reflection.MethodInfo>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">모든 경우 동적 어셈블리에서는 이 속성이 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</summary>
        <value>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 어셈블리의 메서드에서 보안 투명 인지를 확인 하려면 형식을 호출 하 여 완성 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, 호출의 <xref:System.Type.GetMethod%2A> 완료 된 유형과 get 메서드는 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 결과에서 속성 <xref:System.Reflection.MethodInfo>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">모든 경우 동적 어셈블리에서는 이 속성이 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">제네릭 메서드의 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</param>
        <summary>지정된 제네릭 형식 인수를 사용하여 현재 제네릭 메서드 정의에서 생성된 제네릭 메서드를 반환합니다.</summary>
        <returns>지정된 제네릭 형식 인수를 사용하여 현재 제네릭 메서드 정의에서 생성된 제네릭 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 코드를 표시 하는 때가 나타내는 제네릭 메서드 정의에서 생성 된 메서드를 호출 해야 할 수도 있습니다는 <xref:System.Reflection.Emit.MethodBuilder>바깥쪽 형식 완료 되기 전에, 합니다. 사용할 수 있습니다는 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 만드는 메서드를 한 <xref:System.Reflection.MethodInfo> 이러한 생성 된 메서드 및 사용에 대 한는 <xref:System.Reflection.MethodInfo> 내보낸된 호출에 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 불완전 한 형식에 있는 불완전 한 제네릭 메서드 정의에서 생성된 된 메서드를 만듭니다.  
  
 이 예제에서는 단일 형식으로 임시 어셈블리와 모듈 만들고, 메서드 추가 `M`를 사용 하 여 형식 매개 변수 T를 추가 하 여 일반 메서드로 만듭니다는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드. 형식 매개 변수는 메서드의 매개 변수 형식 및 반환 형식으로 사용 됩니다. 바깥쪽 형식이 완료 되지 않은 채 제네릭 메서드 정의는 본문이 제공 되지 않습니다. <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 메서드 생성된 된 메서드를 만드는 데 다음 `M<String>` (`M(Of String)` Visual basic에서). 때문에 코드 예제는 아무 것도 출력의 서브 클래스 <xref:System.Reflection.MethodInfo> 에서 반환 되는 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 메서드 매개 변수 리플렉션을 허용 하지 않습니다.  
  
> [!NOTE]
>  사용 하는 다른 코드 예제에 대 한 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>, 참조 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>합니다. <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 또한 광범위 하 게 제네릭 형식을 사용 하는 코드를 내보낼 때. 참조 [하는 방법: 리플렉션 사용 하 여 제네릭 메서드 정의 내보내기](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)합니다.  
  
 [!code-cpp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cpp/source.cpp#1)]
 [!code-csharp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cs/source.cs#1)]
 [!code-vb[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드에 대한 내부 핸들을 검색합니다. 이 핸들을 사용하여 내부 메타데이터 핸들에 액세스할 수 있습니다.</summary>
        <value>읽기 전용입니다. 메서드에 대한 내부 핸들입니다. 이 핸들을 사용하여 내부 메타데이터 핸들에 액세스할 수 있습니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see cref="P:System.Reflection.MethodBase.MethodHandle" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 메서드가 정의되는 모듈을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Reflection.Module" />가 나타내는 멤버가 정의되는 <see cref="T:System.Reflection.MemberInfo" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 편의 위해 제공 됩니다. 사용 하는 것과 같습니다는 <xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A> 다음 호출 하는 메서드가 선언 되 고, 형식을 가져올 속성의 <xref:System.Type.Module%2A> 결과 속성 <xref:System.Type> 개체입니다.  
  
 이 속성은 또한 호출 <xref:System.Reflection.Emit.MethodBuilder.GetModule%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드의 이름을 검색합니다.</summary>
        <value>읽기 전용입니다. 이 메서드의 단순 이름을 포함하는 문자열을 검색합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 개체를 얻은 리플렉션에서 사용된 클래스를 검색합니다.</summary>
        <value>읽기 전용입니다. 이 메서드를 얻는 데 사용된 형식입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드의 반환 형식에 대한 정보(예: 반환 형식에 사용자 지정 한정자가 포함되는지 여부)가 포함된 <see cref="T:System.Reflection.ParameterInfo" /> 개체를 가져옵니다.</summary>
        <value>반환 형식에 대한 정보가 포함된 <see cref="T:System.Reflection.ParameterInfo" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컴파일러 디자이너에서 사용할 수는 <xref:System.Reflection.ParameterInfo> 사용자 지정 여부를 검색 하려면이 속성에서 반환 된 개체 한정자와 같은 <xref:Microsoft.VisualC.IsConstModifier>, 반환 형식에 적용 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">선언 형식이 만들어지지 않았습니다.</exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Reflection.Emit.MethodBuilder" />가 나타내는 메서드의 반환 형식을 가져옵니다.</summary>
        <value>메서드의 반환 형식입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  .NET Framework 2.0 및.NET Compact Framework 2.0 이상에서는이 멤버는 기본 클래스에서 상속 된 <xref:System.Reflection.MethodInfo>합니다. <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드 반환 형식의 사용자 지정 특성을 반환합니다.</summary>
        <value>읽기 전용입니다. 메서드 반환 형식의 사용자 지정 특성입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 항상 `null`을 반환합니다. 가져오기는 <xref:System.Reflection.MethodInfo> 포함 하는 후 <xref:System.Type> 만들어지고 호출 된 <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> 에 <xref:System.Reflection.MethodInfo>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>사용자 지정 특성을 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">사용자 지정 특성을 설명하는 도우미 클래스의 인스턴스입니다.</param>
        <summary>사용자 지정 특성 작성기를 사용하여 사용자 지정 특성을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 메서드와 상호 작용할 수는 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 조합 하 여 두 메서드를 사용할 때 메서드. 설명 섹션을 참조는 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드에 대 한 자세한 내용은 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">사용자 지정 특성에 대한 생성자입니다.</param>
        <param name="binaryAttribute">특성을 나타내는 바이트 blob입니다.</param>
        <summary>지정된 사용자 지정 특성 blob을 사용하여 사용자 지정 특성을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서식을 지정 하는 방법에 대 한 내용은 `binaryAttribute`하십시오 "II: 메타 데이터 정의 및 의미" 인프라 CLI (공용 언어) 설명서를 참조 합니다. 이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](http://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](http://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.  
  
 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 메서드와 상호 작용할 수는 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 조합 하 여 두 메서드를 사용할 때 메서드. 설명 섹션을 참조는 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드에 대 한 자세한 내용은 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> 또는 <paramref name="binaryAttribute" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetImplementationFlags">
      <MemberSignature Language="C#" Value="public void SetImplementationFlags (System.Reflection.MethodImplAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetImplementationFlags(valuetype System.Reflection.MethodImplAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetImplementationFlags (attributes As MethodImplAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetImplementationFlags(System::Reflection::MethodImplAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodImplAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">설정할 구현 플래그입니다.</param>
        <summary>이 메서드에 대한 구현 플래그를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하는 경우는 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 함께에서 메서드는 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 메서드를 상호 작용에 유의 합니다. 예를 들어,를 사용 하 여는 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 를 추가 하려면 메서드는 <xref:System.Runtime.InteropServices.DllImportAttribute> 특성 집합도는 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 플래그 합니다. 이후에 호출 하는 경우는 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드는 <xref:System.Reflection.MethodImplAttributes.PreserveSig> 플래그를 덮어씁니다. 이 문제를 방지 하는 방법은 두 가지가 있습니다.  
  
-   호출 된 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드를 호출 하기 전에 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 메서드. <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 메서드는 항상 기존 메서드 구현 플래그를 존중 합니다.  
  
-   구현 플래그를 설정 하면 호출 된 <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A> 메서드 기존 플래그를 검색, 비트를 사용 하거나 플래그를 추가 하 고 다음 호출를 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 컨텍스트를 사용은 `SetImplementationFlags` 메서드 본문에서 MSIL의 구현을 설명 하는 메서드.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 이전에 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만든 것입니다.  
  
 또는  
  
 현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMarshal">
      <MemberSignature Language="C#" Value="public void SetMarshal (System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarshal(class System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarshal(System::Reflection::Emit::UnmanagedMarshal ^ unmanagedMarshal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedMarshal" Type="System.Reflection.Emit.UnmanagedMarshal" />
      </Parameters>
      <Docs>
        <param name="unmanagedMarshal">이 메서드의 반환 형식에 대한 마샬링 정보입니다.</param>
        <summary>이 메서드의 반환 형식에 대한 마샬링 정보를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 아래 코드 예제에서는 사용 하 여는 `SetMarshal` 메서드를 다른 형식으로 메서드 호출의 결과 마샬링합니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 이전에 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만든 것입니다.  
  
 또는  
  
 현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMethodBody">
      <MemberSignature Language="C#" Value="public void SetMethodBody (byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, System.Collections.Generic.IEnumerable&lt;int&gt; tokenFixups);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMethodBody(unsigned int8[] il, int32 maxStack, unsigned int8[] localSignature, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; tokenFixups) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMethodBody (il As Byte(), maxStack As Integer, localSignature As Byte(), exceptionHandlers As IEnumerable(Of ExceptionHandler), tokenFixups As IEnumerable(Of Integer))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMethodBody(cli::array &lt;System::Byte&gt; ^ il, int maxStack, cli::array &lt;System::Byte&gt; ^ localSignature, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::ExceptionHandler&gt; ^ exceptionHandlers, System::Collections::Generic::IEnumerable&lt;int&gt; ^ tokenFixups);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="maxStack" Type="System.Int32" />
        <Parameter Name="localSignature" Type="System.Byte[]" />
        <Parameter Name="exceptionHandlers" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt;" />
        <Parameter Name="tokenFixups" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="il">유효한 MSIL 명령이 들어 있는 배열입니다.</param>
        <param name="maxStack">최대 스택 평가 깊이입니다.</param>
        <param name="localSignature">직렬화된 로컬 변수 구조를 포함하는 바이트 배열입니다. 메서드에 로컬 변수가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="exceptionHandlers">메서드에 대한 예외 처리기를 포함하는 컬렉션입니다. 메서드에 예외 처리기가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="tokenFixups">
          <c>il</c>의 오프셋을 나타내는 값 컬렉션으로, 각각이 수정할 수 있는 토큰의 시작을 지정합니다. 메서드에 수정해야 할 토큰이 없으면 <see langword="null" />을 지정합니다.</param>
        <summary>MSIL(Microsoft 중간 언어) 명령의 지정된 바이트 배열을 사용하여 메서드의 본문을 만듭니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="il" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStack" />가 음수입니다.  
  
 또는  
  
 <paramref name="exceptionHandlers" /> 중 하나가 <paramref name="il" /> 오프셋 외부를 지정합니다.  
  
 또는  
  
 <paramref name="tokenFixups" /> 중 하나가 <paramref name="il" /> 배열 외부의 오프셋을 지정합니다.</exception>
        <exception cref="T:System.InvalidOperationException">포함하는 형식이 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 메서드를 사용하여 이미 만들어져 있는 경우  
  
 또는  
  
 이 메서드는 이 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 개체에 이미 호출되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParameters">
      <MemberSignature Language="C#" Value="public void SetParameters (params Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParameters(class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParameters (ParamArray parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParameters(... cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterTypes" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parameterTypes">매개 변수 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</param>
        <summary>메서드에 대한 매개 변수 개수와 형식을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 매개 변수의 형식과 수를 알고 있는 경우 메서드가 정의 된 설정 될 수 있습니다 오버 로드를 사용 하 여는 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 매개 변수 형식의 배열을 받는 메서드입니다. 그러나 제네릭 메서드의 형식을 가진 메서드가 정의 된 후까지 정의할 수 없습니다 고유한 제네릭 형식 매개 변수 중 하나 이상의 지정 된 매개 변수가 있을 수 있습니다. 이 경우 형식 매개 변수를 설정 하려면이 메서드를 사용 합니다.  
  
 반환 형식에 선택적 또는 필수 사용자 지정 한정자를 하는 경우와 같은 <xref:System.Runtime.CompilerServices.IsConst>를 사용 하 여는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> 메서드 오버 로드 합니다.  
  
 사용 하 여 설정 된 모든 매개 변수 형식 대체이 메서드를 호출 하는 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드를 제네릭 메서드로 만듭니다. <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 메서드 형식의 첫 번째 제네릭 형식 매개 변수에 의해 지정 됩니다 메서드 하나 매개 제공 하는 데 사용 됩니다. <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> 메서드는 반환 형식을 두 번째 제네릭 형식 매개 변수로 지정 된 메서드에 제공 하는 데 사용 됩니다.  
  
 이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드.  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 메서드는 제네릭이지만 제네릭 메서드 정의는 아닙니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="SetReturnType">
      <MemberSignature Language="C#" Value="public void SetReturnType (Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReturnType(class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReturnType (returnType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReturnType(Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="returnType">메서드의 반환 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</param>
        <summary>메서드의 반환 형식을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 메서드의 제네릭 형식 매개 변수 중 하나에서 반환 형식을 지정 하는 경우 제네릭 메서드의 반환 형식을 설정 합니다. 반환 형식에 선택적 또는 필수 사용자 지정 한정자를 하는 경우와 같은 <xref:System.Runtime.CompilerServices.IsConst>를 사용 하 여는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> 메서드 오버 로드 합니다.  
  
 사용 하 여 반환 형식이 대체이 메서드를 호출 하는 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드를 제네릭 메서드로 만듭니다. <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 메서드 형식의 첫 번째 제네릭 형식 매개 변수에 의해 지정 됩니다 메서드 하나 매개 제공 하는 데 사용 됩니다. <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> 메서드는 반환 형식을 두 번째 제네릭 형식 매개 변수로 지정 된 메서드에 제공 하는 데 사용 됩니다.  
  
 이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드.  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 메서드는 제네릭이지만 제네릭 메서드 정의는 아닙니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSignature">
      <MemberSignature Language="C#" Value="public void SetSignature (Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSignature(class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSignature (returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSignature(Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="returnType">메서드의 반환 형식입니다.</param>
        <param name="returnTypeRequiredCustomModifiers">메서드의 반환 형식에 대한 필수 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 필수 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="returnTypeOptionalCustomModifiers">메서드의 반환 형식에 대한 선택적 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 선택적 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypes">메서드의 매개 변수 형식입니다.</param>
        <param name="parameterTypeRequiredCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수에 필요한 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypeOptionalCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수의 선택적 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <summary>반환 형식, 매개 변수 형식, 반환 형식과 매개 변수 형식의 필수 및 선택적 사용자 지정 한정자를 포함하여 메서드 시그니처를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 형식 및 수와 유형의 매개 변수를 알고 있는 메서드가 정의 된 경우를 설정할 수 있습니다 오버 로드를 사용 하는 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 매개 변수 형식의 배열을 받는 메서드입니다. 그러나 제네릭 메서드의 형식을 가진 메서드가 정의 된 후까지 정의할 수 없습니다 고유한 제네릭 형식 매개 변수 중 하나 이상의 지정 된 매개 변수가 있을 수 있습니다. 이 경우 형식 매개 변수를 설정 하려면이 메서드를 사용 합니다.  
  
 반환 형식이 나 형식 매개 변수를 모두 있는 경우 선택적 또는 필수 사용자 지정 한정자를 같은 <xref:Microsoft.VisualC.IsConstModifier>를 사용할 수 있습니다는 <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> 및 <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 메서드.  
  
 매개 변수 및 반환 형식을 사용 하 여 설정 대신이 메서드를 호출 하는 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 sample 형식 매개 변수가 있는 제네릭 클래스에 대 한 소스 코드를 포함 `T`합니다. 클래스에는 이름이 필드 `Field`, 형식의 `T`는 제네릭 메서드 `GM` 자체 형식 매개 변수가 있는 `U`합니다. 메서드 `GM` 고유한 형식 매개 변수를 대체 하는 샘플의 인스턴스를 만들고 `U` 샘플의 형식 매개 변수에 대 한에 해당 입력된 매개 변수를 저장 하 고 `Field`합니다. 이 소스 코드는 컴파일 되었지만 사용 되지 않습니다. 사용 하 여 볼 수는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), 클래스에 의해 생성 된 코드를 비교 하 고 `Example`합니다.  
  
 클래스의 코드 `Example` 를 사용 하는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> 제네릭 코드에서 메서드. `Main` 클래스의 메서드 `Example` 라는 클래스를 포함 하는 동적 어셈블리를 만들고 `Sample`를 사용 하 여는 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 는 형식 매개 변수를 추가 하 여 제네릭 만드는 메서드와 알림이 `T`합니다. 기본 생성자와 라는 필드 `Field`, 형식의 `T`, 클래스에 추가 `Sample`합니다. 메서드에 `GM` 추가 되 고 사용 하 여 제네릭 메서드에로 설정 되는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드. 형식 매개 변수 `GM` 라는 `U`합니다. 형식 매개 변수에서 정의 되 면의 서명을 `GM` 사용 하 여 추가 되는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> 메서드. 가 없는 반환 형식 및 없음 또는 사용자 지정 한정자를이 메서드의 모든 매개 변수는 `null` 제외 하 고 `parameterTypes`, 메서드의 유일한 매개 변수의 형식을 설정 하는이 메서드의 형식 매개 변수 설정은; `U`합니다. 메서드의 본문 생성 된 형식의 인스턴스를 만듭니다 `Sample<U>` (`Sample(Of U)` Visual basic에서), 메서드의 매개 변수를 할당 `Field`, 한 다음 값을 출력 `Field`합니다. 진입점 메서드를 보유 하기 위해 더미 형식은 정의 `Main`합니다. 본문에 `Main`, 정적 `GM` 메서드가 호출 되는 생성 된 제네릭 형식 `Sample<int>` (`Sample(Of Integer)` Visual basic에서), 형식과 <xref:System.String> 에 대 한 대체 `U`합니다. <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType> 메서드 만드는 데 사용 되는 <xref:System.Reflection.MethodInfo> 정적에 대 한 `GM` 생성 된 제네릭 형식의 메서드 `Sample<U>`, 및 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> 메서드를 만드는 데 다음는 <xref:System.Reflection.MethodInfo> 메서드 호출에서 내보낼 수 있는 합니다.  
  
 코드 예제를 실행할 때 생성된 된 어셈블리가 TypeBuilderGetFieldExample.exe로 저장 합니다. TypeBuilderGetFieldExample.exe, 실행할 수 있고 사용할 수 있습니다는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 내보낸된 코드에 대 한 코드와 비교 하는 `Sample` 자체 코드 예제에서는로 컴파일되는 클래스입니다.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 메서드는 제네릭이지만 제네릭 메서드 정의는 아닙니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">기호화된 사용자 지정 특성의 이름입니다.</param>
        <param name="data">기호화된 사용자 지정 특성의 값을 나타내는 바이트 blob입니다.</param>
        <summary>blob을 사용하여 기호화된 사용자 지정 특성을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메타 데이터 사용자 지정 특성와 달리이 사용자 지정 특성의 기호 작성기와 연결 됩니다.  
  
   
  
## Examples  
 아래 코드 예제에서는 사용 하 여는 `SetSymCustomAttribute` 메서드에 연결 된 메서드 이름 및 사용자 지정 특성의 키에 대 한 바이트 값을 설정 합니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CPP/source2.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CS/source2.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 이전에 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만든 것입니다.  
  
 또는  
  
 이 메서드를 포함하는 모듈이 디버그 모듈이 아닙니다.  
  
 또는  
  
 현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Signature">
      <MemberSignature Language="C#" Value="public string Signature { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Signature" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Signature As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Signature { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드의 시그니처를 검색합니다.</summary>
        <value>읽기 전용입니다. 이 <see langword="MethodBase" /> 인스턴스에서 리플렉션된 메서드의 시그니처를 포함하는 문자열입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="rgszNames">매핑할 전달된 이름의 배열입니다.</param>
        <param name="cNames">매핑할 이름의 수입니다.</param>
        <param name="lcid">이름을 해석할 로캘 컨텍스트입니다.</param>
        <param name="rgDispId">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</param>
        <summary>이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">반환할 형식 정보입니다.</param>
        <param name="lcid">형식 정보의 로캘 식별자입니다.</param>
        <param name="ppTInfo">요청된 형식 정보 개체에 대한 포인터를 받습니다.</param>
        <summary>인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</param>
        <summary>개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">멤버를 식별합니다.</param>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="lcid">인수를 해석할 로캘 컨텍스트입니다.</param>
        <param name="wFlags">호출의 컨텍스트를 설명하는 플래그입니다.</param>
        <param name="pDispParams">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="pVarResult">결과를 저장할 위치에 대한 포인터입니다.</param>
        <param name="pExcepInfo">예외 정보가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="puArgErr">오류가 있는 첫 번째 인수의 인덱스입니다.</param>
        <summary>개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see langword="MethodBuilder" /> 인스턴스를 문자열로 반환합니다.</summary>
        <returns>이 메서드의 이름, 특성, 메서드 서명, 예외 및 로컬 서명 뒤에 현재 MSIL(Microsoft Intermediate Language) 스트림이 포함된 문자열을 반환합니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>