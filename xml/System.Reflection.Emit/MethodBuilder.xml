<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodBuilder.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c93c1a358d5c177a5835b41cbeaeae252a6af730.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c93c1a358d5c177a5835b41cbeaeae252a6af730</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Defines and represents a method (or constructor) on a dynamic class.</source>
          <target state="translated">동적 클래스에 메서드(또는 생성자)를 정의하고 표시합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> class is used to fully describe a method in Microsoft intermediate language (MSIL), including the name, attributes, signature, and method body.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> 클래스는 완전 하 게 Microsoft MSIL (intermediate language), 이름, 특성, 서명 및 메서드 본문을 포함 하는 메서드를 설명 하는 데 사용 합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>It is used in conjunction with the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class to create classes at runtime.</source>
          <target state="translated">와 함께에서 사용 되는 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> 런타임으로 클래스를 생성 하는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods and methods as type members</source>
          <target state="translated">전역 메서드 및 형식 멤버와 메서드</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>You can use reflection emit to define global methods and to define methods as type members.</source>
          <target state="translated">리플렉션을 사용 하 여 전역 메서드를 정의 하 고 형식 멤버와 메서드를 정의를 내보냅니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The APIs that define methods return <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> objects.</source>
          <target state="translated">메서드를 정의 하는 Api 반환 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods</source>
          <target state="translated">전역 메서드</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A global method is defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <bpt id="p1">**</bpt>MethodBuilder<ept id="p1">**</ept> object.</source>
          <target state="translated">전역 메서드를 사용 하 여 정의 된 <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType&gt;</ph> 반환 하는 <bpt id="p1">**</bpt>MethodBuilder<ept id="p1">**</ept> 개체입니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods must be static.</source>
          <target state="translated">전역 메서드는 정적 이어야 합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>If a dynamic module contains global methods, the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType&gt;</ph> method must be called before persisting the dynamic module or the containing dynamic assembly because the common language runtime postpones fixing up the dynamic module until all global functions have been defined.</source>
          <target state="translated">동적 모듈에는 전역 메서드를 포함 하는 경우는 <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType&gt;</ph> 공용 언어 런타임에서 동적 모듈을 수정 하는 모든 전역 함수가 될 때까지 연기 하기 때문에 동적 모듈 또는 포함 하는 동적 어셈블리를 유지 하기 전에 메서드를 호출 해야 합니다 정의 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A global native method is defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">전역 기본 메서드를 사용 하 여 정의 된 <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Platform invoke (PInvoke) methods must not be declared abstract or virtual.</source>
          <target state="translated">플랫폼 호출 (PInvoke) 추상 또는 가상 메서드를 선언 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The runtime sets the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType&gt;</ph> attribute for a platform invoke method.</source>
          <target state="translated">런타임 설정은 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType&gt;</ph> 플랫폼에 대 한 특성 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Methods as members of types</source>
          <target state="translated">형식의 멤버와 메서드</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A method is defined as a type member by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object.</source>
          <target state="translated">메서드를 사용 하 여 형식 멤버로 정의 된 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> 반환 하는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A&gt;</ph> method is used to set the name and parameter attributes of a parameter, or of the return value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A&gt;</ph> 메서드를 사용 하는 매개 변수 또는 반환 값의 이름 및 매개 변수 특성을 설정 합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object returned by this method represents a parameter or the return value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> 이 메서드에서 반환 된 개체는 매개 변수 또는 반환 값을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object can be used to set the marshaling, to set the constant value, and to apply custom attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> 마샬링을 설정 상수 값을 설정 하 고 사용자 지정 특성을 적용 하는 개체를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Attributes</source>
          <target state="translated">특성</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Members of the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumeration define the precise character of a dynamic method:</source>
          <target state="translated">멤버는 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> 열거형 동적 메서드의 정확한 문자를 정의 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Static methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">정적 메서드를 사용 하 여 지정 된는 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph> 특성입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Final methods (methods that cannot be overridden) are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">최종 메서드 (재정의할 수 없는 메서드)를 사용 하 여 지정 된는 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType&gt;</ph> 특성입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Virtual methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">가상 메서드를 사용 하 여 지정 된는 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType&gt;</ph> 특성입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Abstract methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">추상 메서드를 사용 하 여 지정 된는 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType&gt;</ph> 특성입니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Several attributes determine method visibility.</source>
          <target state="translated">몇 가지 특성에는 메서드 표시 유형을 결정 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>See the description of the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumeration.</source>
          <target state="translated">에 대 한 설명을 참조는 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> 열거형입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Methods that implement overloaded operators must set the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">오버 로드 된 연산자를 구현 하는 메서드를 설정 해야 합니다는 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> 특성입니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Finalizers must set the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">종료자 설정 해야 합니다는 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> 특성입니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Known Issues</source>
          <target state="translated">알려진 문제</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Although <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> is derived from <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, some of the abstract methods defined in the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class are not fully implemented in <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</source>
          <target state="translated">하지만 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> 에서 파생 된 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>에 정의 된 추상 메서드 중 일부는 <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 클래스에서 구현 되는 것은 완벽 하 게 <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>These <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> methods throw the <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">이러한 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> 메서드에서 throw 된 <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>For example the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType&gt;</ph> method is not fully implemented.</source>
          <target state="translated">예를 들어는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType&gt;</ph> 메서드가 완전 하 게 구현 되지 않았습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>You can reflect on these methods by retrieving the enclosing type using the <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">사용 하 여 바깥쪽 형식을 검색 하 여 이러한 메서드에 반영할 수 있습니다는 <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Custom modifiers are supported starting with the .NET Framework version 2.0.</source>
          <target state="translated">사용자 지정 한정자는.NET Framework 버전 2.0부터 지원 됩니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>They are not supported in earlier versions.</source>
          <target state="translated">이전 버전에서 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> class to create a method within a dynamic type.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> 클래스 동적 형식 내에서 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The security action to be taken (Demand, Assert, and so on).</source>
          <target state="translated">요청, 어설션 등과 같은 수행할 보안 작업입니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The set of permissions the action applies to.</source>
          <target state="translated">작업이 적용되는 사용 권한 집합입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>Adds declarative security to this method.</source>
          <target state="translated">이 메서드에 선언적 보안을 추가합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> can be called several times, with each call specifying a security action (such as <ph id="ph2">`Demand`</ph>, <ph id="ph3">`Assert`</ph>, and <ph id="ph4">`Deny`</ph>) and a set of permissions that the action applies to.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> 보안 동작을 지정 하는 각 호출에 여러 번 호출할 수 있습니다 (같은 <ph id="ph2">`Demand`</ph>, <ph id="ph3">`Assert`</ph>, 및 <ph id="ph4">`Deny`</ph>) 및 작업에 적용 되는 사용 권한 집합입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a method by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> method are stored in the old XML metadata format.</source>
          <target state="translated">.NET Framework 버전 1.0, 1.1 및 2.0을 사용 하 여 메서드에 적용 되는 선언적 보안 특성에에서는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> 메서드 이전 XML 메타 데이터 형식으로 저장 됩니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>See Emitting Declarative Security Attributes.</source>
          <target state="translated">선언적 보안 특성을 내보내기를 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The code sample below illustrates the contextual use of <ph id="ph1">`AddDeclarativeSecurity`</ph> to require the caller of a method to have unrestricted permissions.</source>
          <target state="translated">다음 코드 예제에서는 컨텍스트를 사용 <ph id="ph1">`AddDeclarativeSecurity`</ph> 게 무제한 권한을 메서드의 호출자를 요구 하도록 합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> is invalid (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph>, and <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> are invalid).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph>이 유효하지 않습니다(<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph> 및 <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph>가 유효하지 않음).</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">포함하는 형식을 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>을 사용하여 만들었습니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The permission set <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contains an action that was added earlier by <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" /&gt;</ph>.</source>
          <target state="translated">사용 권한 집합 <ph id="ph1">&lt;paramref name="pset" /&gt;</ph>에 이전에 <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" /&gt;</ph>에 의해 추가된 작업이 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 메서드에 대해 <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>이지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pset" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Retrieves the attributes for this method.</source>
          <target state="translated">이 메서드에 대한 특성을 검색합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Read-only.</source>
          <target state="translated">읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Retrieves the <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> for this method.</source>
          <target state="translated">이 메서드에 대해 <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph>를 검색합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>Returns the calling convention of the method.</source>
          <target state="translated">메서드의 호출 규칙을 반환합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>Read-only.</source>
          <target state="translated">읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>The calling convention of the method.</source>
          <target state="translated">메서드의 호출 규칙입니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>Not supported for this type.</source>
          <target state="translated">이 형식에 대해 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> always represents a generic method definition, and thus cannot be invoked.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> 항상 제네릭 메서드 정의 나타내며 호출할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">제네릭 형식에 대 한 자세한 내용은 참조 하십시오. <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>An array containing valid MSIL instructions.</source>
          <target state="translated">유효한 MSIL 명령이 들어 있는 배열입니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>If this parameter is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the method's body is cleared.</source>
          <target state="translated">이 매개 변수가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이면 메서드 본문이 지워집니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The number of valid bytes in the MSIL array.</source>
          <target state="translated">유효한 MSIL 배열의 바이트의 수입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This value is ignored if MSIL is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">MSIL이 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이면 이 값은 무시됩니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>Creates the body of the method using a supplied byte array of Microsoft intermediate language (MSIL) instructions.</source>
          <target state="translated">MSIL(Microsoft Intermediate Language) 명령의 제공된 바이트 배열을 사용하여 메서드의 본문을 만듭니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This method creates the method's body from <ph id="ph1">`il`</ph>, an array containing MSIL instructions as opcodes.</source>
          <target state="translated">이 메서드가 만드는에서 메서드 본문이 <ph id="ph1">`il`</ph>opcode로 MSIL 명령이 들어 있는 배열입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The number of bytes of valid MSIL is given by count.</source>
          <target state="translated">유효한 MSIL의 바이트 수가 수에 따라 제공 됩니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This is currently not fully supported.</source>
          <target state="translated">이 현재 완전히 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The user cannot supply the location of token fix ups and exception handlers.</source>
          <target state="translated">사용자 토큰 픽스업 및 예외 처리기의 위치를 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>In the example provided below, a simple method that adds two integers is generated via opcode using <ph id="ph1">`CreateMethodBody`</ph>.</source>
          <target state="translated">아래에 제공 된 예제에서는 두 정수를 추가 하는 간단한 방법을 opcode를 사용 하 여를 통해 생성 된 <ph id="ph1">`CreateMethodBody`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="count" /&gt;</ph> is not within the range of indexes of the supplied MSIL instruction array and <ph id="ph2">&lt;paramref name="il" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph>이(가) 제공된 MSIL 명령 배열의 인덱스 범위 내에 있지 않으며 <ph id="ph2">&lt;paramref name="il" /&gt;</ph>이(가) <ph id="ph3">&lt;see langword="null" /&gt;</ph>이 아닙니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">포함하는 형식은 이전에 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>을 사용하여 만든 것입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This method was called previously on this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> with an <ph id="ph2">&lt;paramref name="il" /&gt;</ph> argument that was not <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 메서드는 <ph id="ph3">&lt;see langword="null" /&gt;</ph>이 아닌 <ph id="ph2">&lt;paramref name="il" /&gt;</ph> 인수를 사용하여 이 <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph>에서 이전에 호출되었습니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 메서드에 대해 <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>이지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>Returns the type that declares this method.</source>
          <target state="translated">이 메서드를 선언하는 형식을 반환합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>Read-only.</source>
          <target state="translated">읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>The type that declares this method.</source>
          <target state="translated">이 메서드를 선언하는 형식입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>The following code illustrates the use of the <ph id="ph1">`Type`</ph> property.</source>
          <target state="translated">다음 코드에서는 사용 된 <ph id="ph1">`Type`</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An array of strings that represent the names of the generic type parameters.</source>
          <target state="translated">제네릭 형식 매개 변수의 이름을 나타내는 문자열의 배열입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Sets the number of generic type parameters for the current method, specifies their names, and returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to define their constraints.</source>
          <target state="translated">현재 메서드에 대한 제네릭 형식 매개 변수의 개수를 설정하고 이러한 매개 변수의 이름을 지정하며 관련 제약 조건을 정의하는 데 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> 개체의 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects representing the type parameters of the generic method.</source>
          <target state="translated">제네릭 메서드의 형식 매개 변수를 나타내는 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method makes the current method generic.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> 메서드를 사용 하면 현재 메서드가 제네릭입니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>There is no way to undo this change.</source>
          <target state="translated">이 변경을 실행 취소할 방법이 없습니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Calling this method a second time causes an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">이 메서드를 두 번째로 호출 하면 프로그램 <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The type parameters of the generic method can be retrieved later by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A&gt;</ph> method.</source>
          <target state="translated">제네릭 메서드의 형식 매개 변수를 사용 하 여 나중에 검색할 수는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>By convention, a type parameter name is a single uppercase letter.</source>
          <target state="translated">일반적으로 형식 매개 변수 이름은 대문자로 된 단일 문자입니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">제네릭 형식에 대 한 자세한 내용은 참조 하십시오. <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The following code example creates a dynamic type, <ph id="ph1">`DemoType`</ph>, which contains the dynamic generic method <ph id="ph2">`DemoMethod`</ph>.</source>
          <target state="translated">다음 코드 예제에서는 동적 형식을 만들 <ph id="ph1">`DemoType`</ph>, 동적 제네릭 메서드를 포함 하 <ph id="ph2">`DemoMethod`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>This method has two generic type parameters, one of which is used as a parameter, and the other as the return type.</source>
          <target state="translated">이 메서드는 두 제네릭 형식 매개 변수 중 하나는 매개 변수를 지정 하 고 반환 형식으로 다른 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">코드를 실행하면 동적 어셈블리가 DemoGenericMethod1.dll로 저장되며 <bpt id="p1">[</bpt>Ildasm.exe(IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>를 사용하여 검사할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>This code example generates a simple method body that merely returns a null reference.</source>
          <target state="translated">이 코드 예제에서는 단순히 null 참조를 반환 하는 간단한 메서드 본문을 생성 합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For a code example with a more fully developed method body that creates and uses generic types, see <bpt id="p1">[</bpt>How to: Define a Generic Method with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</source>
          <target state="translated">만들고 제네릭 형식을 사용 하는 보다 완전 한 기능된을 메서드 본문이 코드 예제를 참조 하십시오. <bpt id="p1">[</bpt>하는 방법: 리플렉션 내보내기를 사용 하 여 제네릭 메서드 정의<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Generic type parameters have already been defined for this method.</source>
          <target state="translated">제네릭 형식 매개 변수가 이 메서드에 대해 이미 정의되었습니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The method has been completed already.</source>
          <target state="translated">메서드가 이미 완료되었습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /&gt;</ph> method has been called for the current method.</source>
          <target state="translated">현재 메서드에 대해 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /&gt;</ph> 메서드가 호출되었습니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An element of <ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph>의 요소가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph>가 빈 배열인 경우</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The position of the parameter in the parameter list.</source>
          <target state="translated">매개 변수 목록에서 매개 변수의 위치입니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameters are indexed beginning with the number 1 for the first parameter; the number 0 represents the return value of the method.</source>
          <target state="translated">매개 변수 중 첫 번째 매개 변수의 경우 인덱스가 1부터 시작하며, 숫자 0은 메서드의 반환 값을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The parameter attributes of the parameter.</source>
          <target state="translated">매개 변수의 매개 변수 특성입니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name of the parameter.</source>
          <target state="translated">매개 변수의 이름입니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name can be the null string.</source>
          <target state="translated">이름이 null 문자열일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Sets the parameter attributes and the name of a parameter of this method, or of the return value of this method.</source>
          <target state="translated">이 메서드의 매개 변수 특성 및 이름 또는 이 메서드의 반환 값 특성 및 이름을 설정합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Returns a ParameterBuilder that can be used to apply custom attributes.</source>
          <target state="translated">사용자 지정 특성을 적용하는 데 사용할 수 있는 ParameterBuilder를 반환합니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Returns a <ph id="ph1">&lt;see langword="ParameterBuilder" /&gt;</ph> object that represents a parameter of this method or the return value of this method.</source>
          <target state="translated">이 메서드의 매개 변수 또는 이 메서드의 반환 값을 나타내는 <ph id="ph1">&lt;see langword="ParameterBuilder" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object returned by this method can be used to set the default value for a parameter or to apply custom attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> 매개 변수에 대해 기본값을 설정 하거나 사용자 지정 특성을 적용 하려면이 메서드에서 반환 된 개체를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameter numbering begins with 1, so <ph id="ph1">`position`</ph> is 1 for the first parameter.</source>
          <target state="translated">따라서 1, 매개 변수 번호 시작 <ph id="ph1">`position`</ph> 는 첫 번째 매개 변수에 대 한 1입니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>If <ph id="ph1">`position`</ph> is zero, this method affects the return value.</source>
          <target state="translated">경우 <ph id="ph1">`position`</ph> 가 0 이면이 메서드는 반환 값에 영향을 줍니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>In the .NET Framework versions 1.0 and 1.1, an exception is thrown if <ph id="ph1">`position`</ph> is zero, so this method cannot be used to modify attributes of the return value in those versions.</source>
          <target state="translated">.NET Framework 버전 1.0 및 1.1에서는 예외가 발생 하는 경우 <ph id="ph1">`position`</ph> 가 0 이면 해당 버전에서 반환 값의 속성을 수정 하려면이 메서드를 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The method has no parameters.</source>
          <target state="translated">메서드에 매개 변수가 없습니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph>가 0보다 작은 경우</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is greater than the number of the method's parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph>이 메서드의 매개 변수 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">포함하는 형식은 이전에 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>을 사용하여 만든 것입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 메서드에 대해 <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>이지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>The object to compare with this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> instance.</source>
          <target state="translated">이 <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> 인스턴스와 비교할 개체입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>Determines whether the given object is equal to this instance.</source>
          <target state="translated">지정된 개체가 이 인스턴스와 같은지 여부를 확인합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is an instance of <ph id="ph3">&lt;see langword="MethodBuilder" /&gt;</ph> and is equal to this object; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="obj" /&gt;</ph>가 <ph id="ph3">&lt;see langword="MethodBuilder" /&gt;</ph>의 인스턴스이고 이 개체와 같으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>Equality is determined by having the same name, attributes, and signature.</source>
          <target state="translated">일치 여부는 동일한 이름, 특성 및 서명 하 여 결정 됩니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>Return the base implementation for a method.</source>
          <target state="translated">메서드의 기본 구현을 반환합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>The base implementation of this method.</source>
          <target state="translated">이 메서드의 기본 구현입니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>This always returns the current <ph id="ph1">`MethodBuilder`</ph> object.</source>
          <target state="translated">현재가 항상 반환 <ph id="ph1">`MethodBuilder`</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Returns the custom attributes defined for this method.</source>
          <target state="translated">이 메서드에 대해 정의된 사용자 지정 특성을 반환합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">이 멤버의 상속 체인을 검색하여 사용자 지정 특성을 찾을지 여부를 지정합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this method.</source>
          <target state="translated">이 메서드에 대해 정의된 모든 사용자 지정 특성을 반환합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns an array of objects representing all the custom attributes of this method.</source>
          <target state="translated">이 메서드의 모든 사용자 지정 특성을 나타내는 개체 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">이 메서드는 현재 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph>를 사용하여 메서드를 검색하고 반환된 <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>에 대해 <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>를 호출합니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The custom attribute type.</source>
          <target state="translated">사용자 지정 특성 유형입니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">이 멤버의 상속 체인을 검색하여 사용자 지정 특성을 찾을지 여부를 지정합니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns the custom attributes identified by the given type.</source>
          <target state="translated">지정된 형식으로 식별되는 사용자 지정 특성을 반환합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns an array of objects representing the attributes of this method that are of type <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> 형식인 이 메서드의 특성을 나타내는 개체의 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">이 메서드는 현재 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph>를 사용하여 메서드를 검색하고 반환된 <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>에 대해 <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>를 호출합니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that represent the type parameters of the method, if it is generic.</source>
          <target state="translated">제네릭인 경우 메서드의 형식 매개 변수를 나타내는 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> 개체의 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects representing the type parameters, if the method is generic, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method is not generic.</source>
          <target state="translated">메서드가 제네릭인 경우 형식 매개 변수를 나타내는 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> 개체의 배열이거나, 제네릭이 아닌 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>The type parameters of a generic method also are returned by the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method that is used to define them.</source>
          <target state="translated">도 제네릭 메서드의 형식 매개 변수에서 반환 되는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> 메서드를 정의 하는 데 사용 합니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">제네릭 형식에 대 한 자세한 내용은 참조 하십시오. <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>Returns this method.</source>
          <target state="translated">이 메서드를 반환합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The current instance of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>의 현재 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> cannot be used to emit a constructed generic method directly.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> 직접 생성 된 제네릭 메서드를 내보내는 데 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The emitted method is a generic method definition.</source>
          <target state="translated">내보낸된 메서드는 제네릭 메서드 정의 합니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">제네릭 형식에 대 한 자세한 내용은 참조 하십시오. <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The current method is not generic.</source>
          <target state="translated">현재 메서드는 제네릭이 아닙니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">즉, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성이 <ph id="ph2">&lt;see langword="false" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
          <source>Gets the hash code for this method.</source>
          <target state="translated">이 메서드의 해시 코드를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
          <source>The hash code for this method.</source>
          <target state="translated">이 메서드의 해시 코드입니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method.</source>
          <target state="translated">이 메서드에 대한 <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method with a default Microsoft intermediate language (MSIL) stream size of 64 bytes.</source>
          <target state="translated">64바이트의 기본 MSIL(Microsoft Intermediate Language) 스트림 크기를 사용하는 이 메서드에 대한 <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> object for this method.</source>
          <target state="translated">이 메서드에 대한 <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The code sample below demonstrates the contextual usage of the <ph id="ph1">`GetILGenerator`</ph> method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여는 <ph id="ph1">`GetILGenerator`</ph> 메서드를 작성 하 고 3D 공간에서 두 점의 내적을 계산 하는 동적 어셈블리를 생성 합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The method should not have a body because of its <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags, for example because it has the <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph> flag.</source>
          <target state="translated">이 메서드는 해당 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> 또는 <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> 플래그 때문에 본문이 없어야 합니다(예: <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph> 플래그 포함).</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The method is a generic method, but not a generic method definition.</source>
          <target state="translated">이 메서드는 제네릭 메서드 정의가 아닌 제네릭 메서드입니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">즉, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The size of the MSIL stream, in bytes.</source>
          <target state="translated">MSIL 스트림에 바이트의 크기입니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method with the specified Microsoft intermediate language (MSIL) stream size.</source>
          <target state="translated">지정된 MSIL(Microsoft Intermediate Language) 스트림 크기를 사용하여 이 메서드에 대한 <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> object for this method.</source>
          <target state="translated">이 메서드에 대한 <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The code sample below demonstrates the contextual usage of the <ph id="ph1">`GetILGenerator`</ph> method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</source>
          <target state="translated">다음 코드 예제에서는 사용 하 여는 <ph id="ph1">`GetILGenerator`</ph> 메서드를 작성 하 고 3D 공간에서 두 점의 내적을 계산 하는 동적 어셈블리를 생성 합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The method should not have a body because of its <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags, for example because it has the <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph> flag.</source>
          <target state="translated">이 메서드는 해당 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> 또는 <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> 플래그 때문에 본문이 없어야 합니다(예: <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph> 플래그 포함).</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The method is a generic method, but not a generic method definition.</source>
          <target state="translated">이 메서드는 제네릭 메서드 정의가 아닌 제네릭 메서드입니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">즉, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
          <source>Returns the implementation flags for the method.</source>
          <target state="translated">메서드에 대한 구현 플래그를 반환합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
          <source>Returns the implementation flags for the method.</source>
          <target state="translated">메서드에 대한 구현 플래그를 반환합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>Returns a reference to the module that contains this method.</source>
          <target state="translated">이 메서드를 포함하는 모듈에 대한 참조를 반환합니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>Returns a reference to the module that contains this method.</source>
          <target state="translated">이 메서드를 포함하는 모듈에 대한 참조를 반환합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>The sample code below illustrates the usage of the <ph id="ph1">`GetModule`</ph> method to retrieve information about a dynamically-generated module.</source>
          <target state="translated">아래 샘플 코드의 사용법을 보여 줍니다.는 <ph id="ph1">`GetModule`</ph> 메서드를 동적으로 생성 된 모듈에 대 한 정보를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>Returns the parameters of this method.</source>
          <target state="translated">이 메서드의 매개 변수를 반환합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>An array of <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> objects that represent the parameters of the method.</source>
          <target state="translated">메서드의 매개 변수를 나타내는 <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>The code sample below illustrates the use of <ph id="ph1">`GetParameters`</ph> to discover information on the parameters passed to a dynamically-generated method.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">`GetParameters`</ph> 동적으로 생성 된 메서드에 전달 된 매개 변수에 대 한 정보를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>This method is not currently supported.</source>
          <target state="translated">이 메서드는 현재 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see langword="GetParameters" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph>를 사용하여 메서드를 검색하고 반환된 <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>에 대해 <ph id="ph2">&lt;see langword="GetParameters" /&gt;</ph>를 호출합니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetToken">
          <source>Returns the <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> that represents the token for this method.</source>
          <target state="translated">이 메서드의 토큰을 나타내는 <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetToken">
          <source>Returns the <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> of this method.</source>
          <target state="translated">이 메서드의 <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>Gets or sets a Boolean value that specifies whether the local variables in this method are zero initialized.</source>
          <target state="translated">이 메서드의 로컬 변수가 0으로 초기화되었는지 여부를 지정하는 부울 값을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>The default value of this property is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">이 속성의 기본값은 <ph id="ph1">&lt;see langword="true" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the local variables in this method should be zero initialized; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 메서드의 로컬 변수가 0으로 초기화되면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 초기화되지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>If this property is set to <ph id="ph1">`true`</ph>, the emitted MSIL includes initialization of local variables.</source>
          <target state="translated">이 속성은로 설정 하는 경우 <ph id="ph1">`true`</ph>, 내보낸된 MSIL 지역 변수는 초기화를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>If it is set to <ph id="ph1">`false`</ph>, local variables are not initialized and the generated code is unverifiable.</source>
          <target state="translated">로 설정 되어 있으면 <ph id="ph1">`false`</ph>, 지역 변수는 초기화 되지 및 생성된 된 코드를 확인할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 메서드에 대해 <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>이지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>(Get or set.)</source>
          <target state="translated">(가져오기 또는 설정)</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the specified method.</source>
          <target state="translated">지정한 메서드를 호출할 개체입니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, this parameter is ignored.</source>
          <target state="translated">메서드가 정적이면 이 매개 변수가 무시됩니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">이것은 <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> 등과 같은 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>의 비트 플래그여야 합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of MemberInfo objects via reflection.</source>
          <target state="translated">리플렉션을 사용하여 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 MemberInfo 개체 검색을 사용할 수 있도록 하는 개체입니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If binder is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">바인더가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이면 기본 바인더가 사용됩니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For more details, see <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>을 참조하십시오.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list.</source>
          <target state="translated">인수 목록입니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked.</source>
          <target state="translated">호출되는 메서드의 매개 변수와 숫자, 순서, 형식이 동일한 인수의 배열입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters this should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">매개 변수가 없는 경우에는 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이어야 합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">형식의 강제 변환을 제어하는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>의 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is null, the <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">이 인스턴스가 null이면 현재 스레드의 <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>가 사용됩니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(Note that this is necessary to, for example, convert a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> value, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">예를 들면 1000은 각 문화권마다 다르게 표현되므로 1000을 나타내는 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>을 <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> 값으로 변환하기 위해 필요합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Dynamically invokes the method reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.</source>
          <target state="translated">지정된 바인더의 제약 조건에 따라 지정한 매개 변수를 전달하여 지정된 개체에 있는 이 인스턴스에 의해 반영된 메서드를 동적으로 호출합니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Returns an object containing the return value of the invoked method.</source>
          <target state="translated">호출된 메서드의 반환 값을 포함하는 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, the <ph id="ph1">`obj`</ph> parameter is ignored.</source>
          <target state="translated">메서드가 정적 이면는 <ph id="ph1">`obj`</ph> 매개 변수가 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For non-static methods, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the method and must be the same type as this class.</source>
          <target state="translated">Static이 아닌 메서드에 대 한 <ph id="ph1">`obj`</ph> 상속 하거나 메서드를 선언 하 고이 클래스와 동일한 형식 이어야 하는 클래스의 인스턴스여야 합니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">메서드 매개 변수가 없는 경우, 값 <ph id="ph1">`parameters`</ph> 해야 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters for the method reflected by this instance.</source>
          <target state="translated">그렇지 않으면 개수, 형식 및 매개 변수 배열에 있는 요소의 순서는 개수, 형식 및이 인스턴스에 의해 반영 된 메서드에 대 한 매개 변수의 순서와 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully-trusted code.</source>
          <target state="translated">완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 없습니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully-trusted.</source>
          <target state="translated">즉, private 생성자, 메서드, 필드 및 속성에 액세스할 수 있습니다 및 코드를 완전히 신뢰할 수 있는 경우 리플렉션을 사용 하 여 호출 합니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method is not currently supported.</source>
          <target state="translated">이 메서드는 현재 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph>를 사용하여 메서드를 검색하고 반환된 <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>에 대해 <ph id="ph2">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>를 호출합니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The custom attribute type.</source>
          <target state="translated">사용자 지정 특성 유형입니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">이 멤버의 상속 체인을 검색하여 사용자 지정 특성을 찾을지 여부를 지정합니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Checks if the specified custom attribute type is defined.</source>
          <target state="translated">지정된 사용자 지정 특성 유형이 정의되었는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified custom attribute type is defined; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">지정된 사용자 지정 특성 형식이 정의되어 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">이 메서드는 현재 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph>를 사용하여 메서드를 검색하고 반환된 <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>에 대해 <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>를 호출합니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>Gets a value indicating whether the method is a generic method.</source>
          <target state="translated">메서드가 제네릭 메서드인지 여부를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method is generic; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">메서드가 제네릭인 경우 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않은 경우 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>A method is generic if it has type parameters.</source>
          <target state="translated">메서드는 제네릭 형식 매개 변수가 있는 경우.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>You can make a method generic by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to add type parameters.</source>
          <target state="translated">제네릭으로 만들 있습니다 메서드를 호출 하 여는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> 메서드 형식 매개 변수를 추가 합니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>This change cannot be reversed.</source>
          <target state="translated">이 변경은 되돌릴 수 없습니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>The following code example displays the status of a method.</source>
          <target state="translated">다음 코드 예제에서는 메서드의 상태를 표시합니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">이 코드는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object represents the definition of a generic method.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> 개체가 제네릭 메서드의 정의를 나타내는지 여부를 표시하는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object represents the definition of a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> 개체가 제네릭 메서드 정의를 나타내면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> can only be used to create generic method definitions; it cannot be used to create a constructed generic method directly.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> ; 제네릭 메서드 정의 만들 수만 사용할 수 생성 된 제네릭 메서드를 직접 만드는 데 사용할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>However, a subclass of <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> might represent a constructed generic method.</source>
          <target state="translated">그러나의 서브 클래스 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> 생성 된 제네릭 메서드를 나타낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>The following code example displays the status of a method.</source>
          <target state="translated">다음 코드 예제에서는 메서드의 상태를 표시합니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">이 코드는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">모든 경우에 <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>을(를) throw합니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">모든 경우에 <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>을(를) throw합니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>To determine whether a method in a dynamic assembly is security-critical, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">동적 어셈블리의 메서드에서 보안에 중요 한 인지를 확인 하려면 형식을 호출 하 여 완성 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, 호출의 <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> 완료 된 유형과 get 메서드는 <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> 결과에서 속성 <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>In all cases.</source>
          <target state="translated">모든 경우</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">동적 어셈블리에서는 이 속성이 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">모든 경우에 <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>을(를) throw합니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">모든 경우에 <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>을(를) throw합니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>To determine whether a method in a dynamic assembly is security-safe-critical, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">동적 어셈블리의 메서드에서 보안 안전에 중요 한 인지를 확인 하려면 형식을 호출 하 여 완성 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, 호출의 <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> 완료 된 유형과 get 메서드는 <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> 결과에서 속성 <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>In all cases.</source>
          <target state="translated">모든 경우</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">동적 어셈블리에서는 이 속성이 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">모든 경우에 <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>을(를) throw합니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">모든 경우에 <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>을(를) throw합니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>To determine whether a method in a dynamic assembly is security-transparent, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">동적 어셈블리의 메서드에서 보안 투명 인지를 확인 하려면 형식을 호출 하 여 완성 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, 호출의 <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> 완료 된 유형과 get 메서드는 <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> 결과에서 속성 <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>In all cases.</source>
          <target state="translated">모든 경우</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">동적 어셈블리에서는 이 속성이 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments for the generic method.</source>
          <target state="translated">제네릭 메서드의 형식 인수를 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>Returns a generic method constructed from the current generic method definition using the specified generic type arguments.</source>
          <target state="translated">지정된 제네릭 형식 인수를 사용하여 현재 제네릭 메서드 정의에서 생성된 제네릭 메서드를 반환합니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> representing the generic method constructed from the current generic method definition using the specified generic type arguments.</source>
          <target state="translated">지정된 제네릭 형식 인수를 사용하여 현재 제네릭 메서드 정의에서 생성된 제네릭 메서드를 나타내는 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>When you are emitting dynamic code, you might need to emit a call to a method constructed from the generic method definition represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, before the enclosing type has been completed.</source>
          <target state="translated">동적 코드를 표시 하는 때가 나타내는 제네릭 메서드 정의에서 생성 된 메서드를 호출 해야 할 수도 있습니다는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>바깥쪽 형식 완료 되기 전에, 합니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>You can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for such a constructed method, and use the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> in the emitted call.</source>
          <target state="translated">사용할 수 있습니다는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> 만드는 메서드를 한 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 이러한 생성 된 메서드 및 사용에 대 한는 <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 내보낸된 호출에 있습니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The following code example creates a constructed method from an incomplete generic method definition in an incomplete type.</source>
          <target state="translated">다음 코드 예제에서는 불완전 한 형식에 있는 불완전 한 제네릭 메서드 정의에서 생성된 된 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The example creates a transient assembly and module with a single type, adds a method <ph id="ph1">`M`</ph>, and makes the method generic by adding a type parameter T using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">이 예제에서는 단일 형식으로 임시 어셈블리와 모듈 만들고, 메서드 추가 <ph id="ph1">`M`</ph>를 사용 하 여 형식 매개 변수 T를 추가 하 여 일반 메서드로 만듭니다는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The type parameter is used as the type of the method's parameter, and also as its return type.</source>
          <target state="translated">형식 매개 변수는 메서드의 매개 변수 형식 및 반환 형식으로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The generic method definition is not given a body, and the enclosing type is not completed.</source>
          <target state="translated">바깥쪽 형식이 완료 되지 않은 채 제네릭 메서드 정의는 본문이 제공 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method is then used to make the constructed method <ph id="ph2">`M&lt;String&gt;`</ph> (<ph id="ph3">`M(Of String)`</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> 메서드 생성된 된 메서드를 만드는 데 다음 <ph id="ph2">`M&lt;String&gt;`</ph> (<ph id="ph3">`M(Of String)`</ph> Visual basic에서).</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The example code has no output, because the subclass of <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method does not allow reflection over its parameters.</source>
          <target state="translated">때문에 코드 예제는 아무 것도 출력의 서브 클래스 <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 에서 반환 되는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> 메서드 매개 변수 리플렉션을 허용 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>For another code example that uses <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph>, see <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph>.</source>
          <target state="translated">사용 하는 다른 코드 예제에 대 한 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph>, 참조 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> is also used extensively when emitting code that uses generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> 또한 광범위 하 게 제네릭 형식을 사용 하는 코드를 내보낼 때.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>See <bpt id="p1">[</bpt>How to: Define a Generic Method with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>하는 방법: 리플렉션 사용 하 여 제네릭 메서드 정의 내보내기<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Retrieves the internal handle for the method.</source>
          <target state="translated">메서드에 대한 내부 핸들을 검색합니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Use this handle to access the underlying metadata handle.</source>
          <target state="translated">이 핸들을 사용하여 내부 메타데이터 핸들에 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Read-only.</source>
          <target state="translated">읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>The internal handle for the method.</source>
          <target state="translated">메서드에 대한 내부 핸들입니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Use this handle to access the underlying metadata handle.</source>
          <target state="translated">이 핸들을 사용하여 내부 메타데이터 핸들에 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>This method is not currently supported.</source>
          <target state="translated">이 메서드는 현재 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph>를 사용하여 메서드를 검색하고 반환된 <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>에 대해 <ph id="ph2">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>를 호출합니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>Gets the module in which the current method is being defined.</source>
          <target state="translated">현재 메서드가 정의되는 모듈을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> in which the member represented by the current <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> is being defined.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>가 나타내는 멤버가 정의되는 <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>This property is provided as a convenience.</source>
          <target state="translated">이 속성은 편의 위해 제공 됩니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>It is equivalent to using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A&gt;</ph> property to get the type in which the method is being declared, and then calling the <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> property of the resulting <ph id="ph3">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">사용 하는 것과 같습니다는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A&gt;</ph> 다음 호출 하는 메서드가 선언 되 고, 형식을 가져올 속성의 <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> 결과 속성 <ph id="ph3">&lt;xref:System.Type&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>This property is also equivalent to calling <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetModule%2A&gt;</ph>.</source>
          <target state="translated">이 속성은 또한 호출 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetModule%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Retrieves the name of this method.</source>
          <target state="translated">이 메서드의 이름을 검색합니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Read-only.</source>
          <target state="translated">읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Retrieves a string containing the simple name of this method.</source>
          <target state="translated">이 메서드의 단순 이름을 포함하는 문자열을 검색합니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>Retrieves the class that was used in reflection to obtain this object.</source>
          <target state="translated">이 개체를 얻은 리플렉션에서 사용된 클래스를 검색합니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>Read-only.</source>
          <target state="translated">읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>The type used to obtain this method.</source>
          <target state="translated">이 메서드를 얻는 데 사용된 형식입니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</source>
          <target state="translated">메서드의 반환 형식에 대한 정보(예: 반환 형식에 사용자 지정 한정자가 포함되는지 여부)가 포함된 <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type.</source>
          <target state="translated">반환 형식에 대한 정보가 포함된 <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>Compiler designers can use the <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> object returned by this property to discover whether custom modifiers, such as <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, have been applied to the return type.</source>
          <target state="translated">컴파일러 디자이너에서 사용할 수는 <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> 사용자 지정 여부를 검색 하려면이 속성에서 반환 된 개체 한정자와 같은 <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, 반환 형식에 적용 된 합니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>The declaring type has not been created.</source>
          <target state="translated">선언 형식이 만들어지지 않았습니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>Gets the return type of the method represented by this <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>가 나타내는 메서드의 반환 형식을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>The return type of the method.</source>
          <target state="translated">메서드의 반환 형식입니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>Starting with the .NET Framework 2.0 and the .NET Compact Framework 2.0, this member is inherited from the base class, <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">.NET Framework 2.0 및.NET Compact Framework 2.0 이상에서는이 멤버는 기본 클래스에서 상속 된 <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType&gt;</ph>을 참조하세요.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Returns the custom attributes of the method's return type.</source>
          <target state="translated">메서드 반환 형식의 사용자 지정 특성을 반환합니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Read-only.</source>
          <target state="translated">읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>The custom attributes of the method's return type.</source>
          <target state="translated">메서드 반환 형식의 사용자 지정 특성입니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>This method always returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">이 메서드는 항상 <ph id="ph1">`null`</ph>을 반환합니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Get the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> after the containing <ph id="ph2">&lt;xref:System.Type&gt;</ph> has been created and invoked <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> on the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">가져오기는 <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 포함 하는 후 <ph id="ph2">&lt;xref:System.Type&gt;</ph> 만들어지고 호출 된 <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> 에 <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Sets a custom attribute.</source>
          <target state="translated">사용자 지정 특성을 설정합니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class to describe the custom attribute.</source>
          <target state="translated">사용자 지정 특성을 설명하는 도우미 클래스의 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Sets a custom attribute using a custom attribute builder.</source>
          <target state="translated">사용자 지정 특성 작성기를 사용하여 사용자 지정 특성을 설정합니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method can interact with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method when the two methods are used in combination.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> 메서드와 상호 작용할 수는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> 조합 하 여 두 메서드를 사용할 때 메서드.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method for details.</source>
          <target state="translated">설명 섹션을 참조는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> 메서드에 대 한 자세한 내용은 합니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 메서드에 대해 <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>이지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">사용자 지정 특성에 대한 생성자입니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte blob representing the attributes.</source>
          <target state="translated">특성을 나타내는 바이트 blob입니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Sets a custom attribute using a specified custom attribute blob.</source>
          <target state="translated">지정된 사용자 지정 특성 blob을 사용하여 사용자 지정 특성을 설정합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For details on how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">서식을 지정 하는 방법에 대 한 내용은 <ph id="ph1">`binaryAttribute`</ph>하십시오 "II: 메타 데이터 정의 및 의미" 인프라 CLI (공용 언어) 설명서를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">이 설명서는 온라인으로 제공됩니다. MSDN의 <bpt id="p1">[</bpt>ECMA C# 및 공용 언어 인프라 표준<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> 및 Ecma International 웹 사이트의 <bpt id="p2">[</bpt>표준 ECMA-335 - CLI(공용 언어 인프라)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>를 참조하세요.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method can interact with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method when the two methods are used in combination.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> 메서드와 상호 작용할 수는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> 조합 하 여 두 메서드를 사용할 때 메서드.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method for details.</source>
          <target state="translated">설명 섹션을 참조는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> 메서드에 대 한 자세한 내용은 합니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 메서드에 대해 <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>이지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The implementation flags to set.</source>
          <target state="translated">설정할 구현 플래그입니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>Sets the implementation flags for this method.</source>
          <target state="translated">이 메서드에 대한 구현 플래그를 설정합니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>When you use the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method in combination with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method, be aware of potential interactions.</source>
          <target state="translated">사용 하는 경우는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> 함께에서 메서드는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> 메서드를 상호 작용에 유의 합니다.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>For example, using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method to add the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> attribute also sets the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">예를 들어,를 사용 하 여는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> 를 추가 하려면 메서드는 <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> 특성 집합도는 <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> 플래그 합니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>If you subsequently call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method, the <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig&gt;</ph> flag is overwritten.</source>
          <target state="translated">이후에 호출 하는 경우는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> 메서드는 <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig&gt;</ph> 플래그를 덮어씁니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>There are two ways to avoid this:</source>
          <target state="translated">이 문제를 방지 하는 방법은 두 가지가 있습니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method before you call the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> 메서드를 호출 하기 전에 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method always respects existing method implementation flags.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> 메서드는 항상 기존 메서드 구현 플래그를 존중 합니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>When you set implementation flags, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A&gt;</ph> method to retrieve the existing flags, use bitwise OR to add your flag, and then call the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method.</source>
          <target state="translated">구현 플래그를 설정 하면 호출 된 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A&gt;</ph> 메서드 기존 플래그를 검색, 비트를 사용 하거나 플래그를 추가 하 고 다음 호출를 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The code sample below illustrates the contextual use of the <ph id="ph1">`SetImplementationFlags`</ph> method to describe the implementation of MSIL in a method body.</source>
          <target state="translated">다음 코드 예제에서는 컨텍스트를 사용은 <ph id="ph1">`SetImplementationFlags`</ph> 메서드 본문에서 MSIL의 구현을 설명 하는 메서드.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">포함하는 형식은 이전에 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>을 사용하여 만든 것입니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 메서드에 대해 <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>이지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>Marshaling information for the return type of this method.</source>
          <target state="translated">이 메서드의 반환 형식에 대한 마샬링 정보입니다.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>Sets marshaling information for the return type of this method.</source>
          <target state="translated">이 메서드의 반환 형식에 대한 마샬링 정보를 설정합니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>The code sample below illustrates the contextual usage of the <ph id="ph1">`SetMarshal`</ph> method to marshal the results of a method call as a different type.</source>
          <target state="translated">아래 코드 예제에서는 사용 하 여는 <ph id="ph1">`SetMarshal`</ph> 메서드를 다른 형식으로 메서드 호출의 결과 마샬링합니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">포함하는 형식은 이전에 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>을 사용하여 만든 것입니다.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 메서드에 대해 <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>이지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>An array that contains valid MSIL instructions.</source>
          <target state="translated">유효한 MSIL 명령이 들어 있는 배열입니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>The maximum stack evaluation depth.</source>
          <target state="translated">최대 스택 평가 깊이입니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>An array of bytes that contain the serialized local variable structure.</source>
          <target state="translated">직렬화된 로컬 변수 구조를 포함하는 바이트 배열입니다.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no local variables.</source>
          <target state="translated">메서드에 로컬 변수가 없으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 지정합니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>A collection that contains the exception handlers for the method.</source>
          <target state="translated">메서드에 대한 예외 처리기를 포함하는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no exception handlers.</source>
          <target state="translated">메서드에 예외 처리기가 없으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 지정합니다.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>A collection of values that represent offsets in <bpt id="p1">&lt;c&gt;</bpt>il<ept id="p1">&lt;/c&gt;</ept>, each of which specifies the beginning of a token that may be modified.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>il<ept id="p1">&lt;/c&gt;</ept>의 오프셋을 나타내는 값 컬렉션으로, 각각이 수정할 수 있는 토큰의 시작을 지정합니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no tokens that have to be modified.</source>
          <target state="translated">메서드에 수정해야 할 토큰이 없으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 지정합니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Creates the body of the method by using a specified byte array of Microsoft intermediate language (MSIL) instructions.</source>
          <target state="translated">MSIL(Microsoft 중간 언어) 명령의 지정된 바이트 배열을 사용하여 메서드의 본문을 만듭니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="il" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="il" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="maxStack" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxStack" /&gt;</ph>가 음수입니다.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>One of <ph id="ph1">&lt;paramref name="exceptionHandlers" /&gt;</ph> specifies an offset outside of <ph id="ph2">&lt;paramref name="il" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="exceptionHandlers" /&gt;</ph> 중 하나가 <ph id="ph2">&lt;paramref name="il" /&gt;</ph> 오프셋 외부를 지정합니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>One of <ph id="ph1">&lt;paramref name="tokenFixups" /&gt;</ph> specifies an offset that is outside the <ph id="ph2">&lt;paramref name="il" /&gt;</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="tokenFixups" /&gt;</ph> 중 하나가 <ph id="ph2">&lt;paramref name="il" /&gt;</ph> 배열 외부의 오프셋을 지정합니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>The containing type was previously created using the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">포함하는 형식이 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> 메서드를 사용하여 이미 만들어져 있는 경우</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>This method was called previously on this <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object.</source>
          <target state="translated">이 메서드는 이 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> 개체에 이미 호출되었습니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the parameter types.</source>
          <target state="translated">매개 변수 형식을 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Sets the number and types of parameters for a method.</source>
          <target state="translated">메서드에 대한 매개 변수 개수와 형식을 설정합니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>If the number and types of the parameters are known when the method is defined, they can be set using any overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method that accepts an array of parameter types.</source>
          <target state="translated">매개 변수의 형식과 수를 알고 있는 경우 메서드가 정의 된 설정 될 수 있습니다 오버 로드를 사용 하 여는 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> 매개 변수 형식의 배열을 받는 메서드입니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</source>
          <target state="translated">그러나 제네릭 메서드의 형식을 가진 메서드가 정의 된 후까지 정의할 수 없습니다 고유한 제네릭 형식 매개 변수 중 하나 이상의 지정 된 매개 변수가 있을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Use this method to set the parameter types in that case.</source>
          <target state="translated">이 경우 형식 매개 변수를 설정 하려면이 메서드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>If the return type has optional or required custom modifiers, such as <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> method overload.</source>
          <target state="translated">반환 형식에 선택적 또는 필수 사용자 지정 한정자를 하는 경우와 같은 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>를 사용 하 여는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Calling this method replaces any parameter types that were set using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">사용 하 여 설정 된 모든 매개 변수 형식 대체이 메서드를 호출 하는 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to make a method generic.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> 메서드를 제네릭 메서드로 만듭니다.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> 메서드 형식의 첫 번째 제네릭 형식 매개 변수에 의해 지정 됩니다 메서드 하나 매개 제공 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> method is used to give the method a return type, specified by the second generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> 메서드는 반환 형식을 두 번째 제네릭 형식 매개 변수로 지정 된 메서드에 제공 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">이 코드는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">현재 메서드는 제네릭이지만 제네릭 메서드 정의는 아닙니다.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">즉, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the return type of the method.</source>
          <target state="translated">메서드의 반환 형식을 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Sets the return type of the method.</source>
          <target state="translated">메서드의 반환 형식을 설정합니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Use this method to set the return type of a generic method, when the return type is specified by one of the generic type parameters of the method.</source>
          <target state="translated">이 메서드를 사용 하 여 메서드의 제네릭 형식 매개 변수 중 하나에서 반환 형식을 지정 하는 경우 제네릭 메서드의 반환 형식을 설정 합니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>If the return type has optional or required custom modifiers, such as <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> method overload.</source>
          <target state="translated">반환 형식에 선택적 또는 필수 사용자 지정 한정자를 하는 경우와 같은 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>를 사용 하 여는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Calling this method replaces a return type established using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">사용 하 여 반환 형식이 대체이 메서드를 호출 하는 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to make a method generic.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> 메서드를 제네릭 메서드로 만듭니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> 메서드 형식의 첫 번째 제네릭 형식 매개 변수에 의해 지정 됩니다 메서드 하나 매개 제공 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> method is used to give the method a return type, specified by the second generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> 메서드는 반환 형식을 두 번째 제네릭 형식 매개 변수로 지정 된 메서드에 제공 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">이 코드는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">현재 메서드는 제네릭이지만 제네릭 메서드 정의는 아닙니다.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">즉, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">메서드의 반환 형식입니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">메서드의 반환 형식에 대한 필수 사용자 지정 한정자를 나타내는 형식의 배열(예: <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>)입니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">반환 형식에 필수 사용자 지정 한정자가 없으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 지정합니다.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">메서드의 반환 형식에 대한 선택적 사용자 지정 한정자를 나타내는 형식의 배열(예: <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>)입니다.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">반환 형식에 선택적 사용자 지정 한정자가 없으면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 지정합니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">메서드의 매개 변수 형식입니다.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">형식 배열의 배열입니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">각 형식의 배열은 해당 매개 변수에 필요한 사용자 지정 한정자를 나타냅니다(예: <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">특정 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 지정합니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 지정합니다.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">형식 배열의 배열입니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">각 형식의 배열은 해당 매개 변수의 선택적 사용자 지정 한정자를 나타냅니다(예: <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">특정 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 지정합니다.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을 지정합니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Sets the method signature, including the return type, the parameter types, and the required and optional custom modifiers of the return type and parameter types.</source>
          <target state="translated">반환 형식, 매개 변수 형식, 반환 형식과 매개 변수 형식의 필수 및 선택적 사용자 지정 한정자를 포함하여 메서드 시그니처를 설정합니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type and the number and types of the parameters are known when the method is defined, they can be established using any overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method that accepts an array of parameter types.</source>
          <target state="translated">반환 형식 및 수와 유형의 매개 변수를 알고 있는 메서드가 정의 된 경우를 설정할 수 있습니다 오버 로드를 사용 하는 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> 매개 변수 형식의 배열을 받는 메서드입니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</source>
          <target state="translated">그러나 제네릭 메서드의 형식을 가진 메서드가 정의 된 후까지 정의할 수 없습니다 고유한 제네릭 형식 매개 변수 중 하나 이상의 지정 된 매개 변수가 있을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Use this method to set the parameter types in that case.</source>
          <target state="translated">이 경우 형식 매개 변수를 설정 하려면이 메서드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If neither the return type nor the parameter types have optional or required custom modifiers, such as <ph id="ph1">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, you can use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> methods.</source>
          <target state="translated">반환 형식이 나 형식 매개 변수를 모두 있는 경우 선택적 또는 필수 사용자 지정 한정자를 같은 <ph id="ph1">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>를 사용할 수 있습니다는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Calling this method replaces the parameters and return type established using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">매개 변수 및 반환 형식을 사용 하 여 설정 대신이 메서드를 호출 하는 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The following code example contains source code for a generic class named Sample that has a type parameter <ph id="ph1">`T`</ph>.</source>
          <target state="translated">다음 코드 예제에서는 sample 형식 매개 변수가 있는 제네릭 클래스에 대 한 소스 코드를 포함 <ph id="ph1">`T`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method <ph id="ph3">`GM`</ph> with its own type parameter, <ph id="ph4">`U`</ph>.</source>
          <target state="translated">클래스에는 이름이 필드 <ph id="ph1">`Field`</ph>, 형식의 <ph id="ph2">`T`</ph>는 제네릭 메서드 <ph id="ph3">`GM`</ph> 자체 형식 매개 변수가 있는 <ph id="ph4">`U`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of Sample, substituting its own type parameter <ph id="ph2">`U`</ph> for the type parameter of Sample, and stores its input parameter in <ph id="ph3">`Field`</ph>.</source>
          <target state="translated">메서드 <ph id="ph1">`GM`</ph> 고유한 형식 매개 변수를 대체 하는 샘플의 인스턴스를 만들고 <ph id="ph2">`U`</ph> 샘플의 형식 매개 변수에 대 한에 해당 입력된 매개 변수를 저장 하 고 <ph id="ph3">`Field`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">이 소스 코드는 컴파일 되었지만 사용 되지 않습니다. 사용 하 여 볼 수는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, 클래스에 의해 생성 된 코드를 비교 하 고 <ph id="ph1">`Example`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> method in emitting generic code.</source>
          <target state="translated">클래스의 코드 <ph id="ph1">`Example`</ph> 를 사용 하는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> 제네릭 코드에서 메서드.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph>, and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Main`</ph> 클래스의 메서드 <ph id="ph2">`Example`</ph> 라는 클래스를 포함 하는 동적 어셈블리를 만들고 <ph id="ph3">`Sample`</ph>를 사용 하 여는 <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> 는 형식 매개 변수를 추가 하 여 제네릭 만드는 메서드와 알림이 <ph id="ph5">`T`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">기본 생성자와 라는 필드 <ph id="ph1">`Field`</ph>, 형식의 <ph id="ph2">`T`</ph>, 클래스에 추가 <ph id="ph3">`Sample`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A method <ph id="ph1">`GM`</ph> is added, and turned into a generic method using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">메서드에 <ph id="ph1">`GM`</ph> 추가 되 고 사용 하 여 제네릭 메서드에로 설정 되는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">형식 매개 변수 <ph id="ph1">`GM`</ph> 라는 <ph id="ph2">`U`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Once the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added, using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> method.</source>
          <target state="translated">형식 매개 변수에서 정의 되 면의 서명을 <ph id="ph1">`GM`</ph> 사용 하 여 추가 되는 <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>There is no return type, and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>, which sets the type of the only parameter of the method; this is set to the method's type parameter, <ph id="ph3">`U`</ph>.</source>
          <target state="translated">가 없는 반환 형식 및 없음 또는 사용자 지정 한정자를이 메서드의 모든 매개 변수는 <ph id="ph1">`null`</ph> 제외 하 고 <ph id="ph2">`parameterTypes`</ph>, 메서드의 유일한 매개 변수의 형식을 설정 하는이 메서드의 형식 매개 변수 설정은; <ph id="ph3">`U`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">메서드의 본문 생성 된 형식의 인스턴스를 만듭니다 <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> Visual basic에서), 메서드의 매개 변수를 할당 <ph id="ph3">`Field`</ph>, 한 다음 값을 출력 <ph id="ph4">`Field`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A dummy type is defined, to hold the entry point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">진입점 메서드를 보유 하기 위해 더미 형식은 정의 <ph id="ph1">`Main`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">본문에 <ph id="ph1">`Main`</ph>, 정적 <ph id="ph2">`GM`</ph> 메서드가 호출 되는 생성 된 제네릭 형식 <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> Visual basic에서), 형식과 <ph id="ph5">&lt;xref:System.String&gt;</ph> 에 대 한 대체 <ph id="ph6">`U`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the static <ph id="ph3">`GM`</ph> method of the constructed generic type <ph id="ph4">`Sample&lt;U&gt;`</ph>, and the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method is then used to create a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can emitted in a method call.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType&gt;</ph> 메서드 만드는 데 사용 되는 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 정적에 대 한 <ph id="ph3">`GM`</ph> 생성 된 제네릭 형식의 메서드 <ph id="ph4">`Sample&lt;U&gt;`</ph>, 및 <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> 메서드를 만드는 데 다음는 <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 메서드 호출에서 내보낼 수 있는 합니다.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">코드 예제를 실행할 때 생성된 된 어셈블리가 TypeBuilderGetFieldExample.exe로 저장 합니다.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">TypeBuilderGetFieldExample.exe, 실행할 수 있고 사용할 수 있습니다는 <bpt id="p1">[</bpt>Ildasm.exe (IL 디스어셈블러)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> 내보낸된 코드에 대 한 코드와 비교 하는 <ph id="ph1">`Sample`</ph> 자체 코드 예제에서는로 컴파일되는 클래스입니다.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">현재 메서드는 제네릭이지만 제네릭 메서드 정의는 아닙니다.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">즉, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The name of the symbolic custom attribute.</source>
          <target state="translated">기호화된 사용자 지정 특성의 이름입니다.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The byte blob that represents the value of the symbolic custom attribute.</source>
          <target state="translated">기호화된 사용자 지정 특성의 값을 나타내는 바이트 blob입니다.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Set a symbolic custom attribute using a blob.</source>
          <target state="translated">blob을 사용하여 기호화된 사용자 지정 특성을 설정합니다.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Unlike the metadata custom attribute, this custom attribute is associated with a symbol writer.</source>
          <target state="translated">메타 데이터 사용자 지정 특성와 달리이 사용자 지정 특성의 기호 작성기와 연결 됩니다.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The code sample below illustrates the contextual usage of the <ph id="ph1">`SetSymCustomAttribute`</ph> method to set the byte values for the name and key of a custom attribute attached to a method.</source>
          <target state="translated">아래 코드 예제에서는 사용 하 여는 <ph id="ph1">`SetSymCustomAttribute`</ph> 메서드에 연결 된 메서드 이름 및 사용자 지정 특성의 키에 대 한 바이트 값을 설정 합니다.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">포함하는 형식은 이전에 <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>을 사용하여 만든 것입니다.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The module that contains this method is not a debug module.</source>
          <target state="translated">이 메서드를 포함하는 모듈이 디버그 모듈이 아닙니다.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">현재 메서드에 대해 <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> 속성은 <ph id="ph2">&lt;see langword="true" /&gt;</ph>이지만 <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> 속성은 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>Retrieves the signature of the method.</source>
          <target state="translated">메서드의 시그니처를 검색합니다.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>Read-only.</source>
          <target state="translated">읽기 전용입니다.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>A String containing the signature of the method reflected by this <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> instance.</source>
          <target state="translated">이 <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> 인스턴스에서 리플렉션된 메서드의 시그니처를 포함하는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">나중에 사용하기 위해 예약되어 있습니다.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">IID_NULL이어야 합니다.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">매핑할 전달된 이름의 배열입니다.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">매핑할 이름의 수입니다.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">이름을 해석할 로캘 컨텍스트입니다.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, MSDN Library를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">반환할 형식 정보입니다.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">형식 정보의 로캘 식별자입니다.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">요청된 형식 정보 개체에 대한 포인터를 받습니다.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, MSDN Library를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, MSDN Library를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">멤버를 식별합니다.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">나중에 사용하기 위해 예약되어 있습니다.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">IID_NULL이어야 합니다.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">인수를 해석할 로캘 컨텍스트입니다.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">호출의 컨텍스트를 설명하는 플래그입니다.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">결과를 저장할 위치에 대한 포인터입니다.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">예외 정보가 포함된 구조체에 대한 포인터입니다.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">오류가 있는 첫 번째 인수의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">`IDispatch::Invoke`</ph>, MSDN Library를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.ToString">
          <source>Returns this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> instance as a string.</source>
          <target state="translated">이 <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> 인스턴스를 문자열로 반환합니다.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.ToString">
          <source>Returns a string containing the name, attributes, method signature, exceptions, and local signature of this method followed by the current Microsoft intermediate language (MSIL) stream.</source>
          <target state="translated">이 메서드의 이름, 특성, 메서드 서명, 예외 및 로컬 서명 뒤에 현재 MSIL(Microsoft Intermediate Language) 스트림이 포함된 문자열을 반환합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>