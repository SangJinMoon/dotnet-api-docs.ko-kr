<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2d2648e46890987df7b96cd4787aa5d57de2433b" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34285355" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>컴파일, 실행 및 삭제할 수 있는 동적 메서드를 정의하고 나타냅니다. 삭제된 메서드는 가비지 수집에 사용할 수 있습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Reflection.Emit.DynamicMethod> 클래스가 생성 하는 메서드를 포함 하는 동적 어셈블리 및 동적 형식을 생성 하지 않고 실행 시 메서드를 실행 합니다. 실행 시간 (JIT) 컴파일러에서 만든 코드 회수 될 때는 <xref:System.Reflection.Emit.DynamicMethod> 개체를 회수 합니다. 동적 메서드 생성 하 고 적은 양의 코드를 실행 하는 가장 효율적인 방법은 됩니다.  
  
 동적 메서드가 익명으로 호스팅할 수 있습니다 또는 모듈 또는 형식에 논리적으로 연결 될 수 있습니다.  
  
-   동적 메서드가 익명으로 호스팅된 시스템에서 제공한 어셈블리에 있으며 따라서은 다른 코드에서 격리 합니다. 기본적으로 public이 아닌 데이터에 액세스할 수 없는 것입니다. 익명으로 호스팅된 동적 메서드는 부여 된 경우 JIT 컴파일러의 가시성 검사를 건너뛰는 기능을 제한 될 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그입니다. 인 public이 아닌 멤버에 동적 메서드에서 액세스 하는 어셈블리의 신뢰 수준에는 다음과 같은 경우, 또는 동적 메서드를 내보내는 호출 스택의 트러스트 수준의 하위 집합 이어야 합니다. 익명으로 호스팅된 동적 메서드에 대 한 자세한 내용은 참조 [연습: 부분 신뢰 시나리오에서 코드 내보내기](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)합니다.  
  
-   동적 메서드를 지정 하는 모듈에 연결 된 경우에 동적 메서드는 해당 모듈에 효과적으로 전역 합니다. 모듈의 모든 형식 및 모든 액세스할 수 `internal` (`Friend` Visual basic에서) 형식의 멤버입니다. 동적 연결할 수 있습니다에 대 한 요청 하는 메서드는 모듈을 만들었는지 여부에 관계 없이 모든 모듈과 함께 제공 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 코드를 포함 하는 호출 스택에서 플래그를 충족할 수 있습니다. 경우는 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 권한 부여에 플래그가 포함 되, 동적 메서드가 JIT 컴파일러의 가시성 검사를 생략 하 고 모든 어셈블리에 있는 다른 모듈에서 모듈에 선언 된 모든 종류의 개인 데이터에 액세스할 수 있습니다.  
  
    > [!NOTE]
    >  동적 메서드가 연결 된 모듈을 지정 하면 해당 모듈에서 익명 호스팅에 사용 되는 시스템에서 제공한 어셈블리 수 없습니다.  
  
-   동적 메서드를 지정 하는 형식과 연결 된 경우에 형식의 모든 멤버에 대 한 액세스 액세스 수준에 관계 없이 있습니다. 또한 JIT 가시성 검사를 건너뛸 수 있습니다. 모든 어셈블리에 있는 다른 모듈에서 동일한 모듈에 선언 된 다른 종류의 개인 데이터에 동적 메서드에 액세스할을 수 있습니다. 모든 형식에 동적 메서드를 연결할 수 있지만 사용자 코드에 부여 되어야 <xref:System.Security.Permissions.ReflectionPermission> 둘 다와 함께 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 및 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> 플래그입니다.  
  
 다음 표에 나와 있는 유형 및 멤버는 익명으로 호스팅된 동적 메서드를와 사용 여부에 따라 JIT 가시성 검사를 하지 않는 액세스할 수 있는 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 플래그 권한이 부여 됩니다.  
  
||<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>를 사용하지 않는 경우|<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>과 함께|  
|-|-|-|  
|JIT 표시 유형 확인을 생략할 필요 없이|모든 어셈블리에 있는 public 형식의 public 멤버입니다.|모든 어셈블리에 있는 public 형식의 public 멤버입니다.|  
|건너뛴 JIT 가시성 검사를 제한적으로|모든 어셈블리에 있는 public 형식의 public 멤버입니다.|동적 메서드를 내보내는 어셈블리의 신뢰 수준 보다 작은 해당 신뢰 수준이 어셈블리에만 모든 형식의 모든 멤버입니다.|  
  
> [!NOTE]
>  이전에 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 필요한 코드를 내보내거나 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. FullTrust 및 명명 된 권한 집합 LocalIntranet에 기본적으로이 권한이 포함 되어 있지만 인터넷 권한 집합입니다. 따라서 이전 버전의에서 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 은 경우에 인터넷 권한이 있는 라이브러리를 사용할 수는 <xref:System.Security.SecurityCriticalAttribute> 특성을 실행 한 <xref:System.Security.PermissionSet.Assert%2A> 에 대 한 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>합니다. 코딩 오류가 있을 경우 보안 허점이 발생할 수 있으므로 이러한 라이브러리는 신중한 보안 검토가 필요합니다. [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]에서는 코드 생성이 기본적으로 권한 있는 작업이 아니기 때문에 보안 요구를 실행하지 않고 부분 신뢰 시나리오에서 코드를 내보낼 수 있습니다. 즉, 생성된 코드에 코드를 내보내는 어셈블리보다 많은 권한이 없습니다. 따라서 코드를 내보내는 라이브러리가 보안상 투명할 수 있으며 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>를 어설션할 필요가 없으므로 보안 라이브러리 작성 작업이 간소화됩니다. 이 기능을 사용 하려면 응용 프로그램이 대상 해야는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상.  
  
 다음 표에 나와 있는 유형 및 멤버는 모듈 또는 모듈의 형식은와 관련 되는 동적 메서드를 액세스할 수입니다.  
  
||모듈에 연결 된|형식과 연결 된|  
|-|-|-|  
|JIT 표시 유형 확인을 생략할 필요 없이|모듈에 있는 공개, 내부 및 개인 형식의 public 및 내부 멤버입니다.<br /><br /> 모든 어셈블리에 있는 public 형식의 public 멤버입니다.|연결 된 형식의 모든 멤버입니다. 모듈의 다른 모든 종류의 public 및 내부 멤버입니다.<br /><br /> 모든 어셈블리에 있는 public 형식의 public 멤버입니다.|  
|JIT 가시성 검사를 건너뛰는 중|모든 어셈블리에 있는 모든 형식의 모든 멤버입니다.|모든 어셈블리에 있는 모든 형식의 모든 멤버입니다.|  
  
 모듈과 연결 되는 동적 메서드에 해당 모듈의 권한이 있습니다. 형식에 연결 되는 동적 메서드에 해당 형식이 포함 된 모듈의 권한이 있습니다.  
  
 동적 메서드 및 매개 변수 이름을 지정 하지 않아도 되지만 디버깅을 돕기 위해 이름을 지정할 수 있습니다. 동적 메서드 또는 매개 변수에서 사용자 지정 특성이 지원 되지 않습니다.  
  
 동적 메서드는 `static` 메서드 (`Shared` Visual Basic의 메서드), 여에서 도입 된 대리자 바인딩 규칙을 완화는 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 인스턴스 메서드처럼 작동할 수 있도록 동적 메서드를 개체에 바인딩할 수 있도록 때 해당 대리자 인스턴스를 사용 하 여 호출 합니다. 이 보여 주는 예제는 제공 된 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> 메서드 오버 로드 합니다.  
  
> [!NOTE]
>  에 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], 기호 정보를, 지역 변수 이름 및 줄 번호 매핑 동적 메서드를 지원 하지 않습니다. 이 제한 사항은 이후 버전에서 제거 될 수 있습니다. 사용할 수 있습니다 <xref:System.Reflection.Emit.AssemblyBuilder> 개발 하는 생성 된 Microsoft 중간 언어 (MSIL) 디버깅을 간소화 하기 때문에 동적 메서드를 최종 배포 하는 동안 다음 전환 하는 동안는 <xref:System.Reflection.Emit.ILGenerator> 호출 두 경우 모두에서 동일 합니다.  
  
## <a name="verification"></a>확인  
 다음 목록에는 동적 메서드는 확인할 수 없는 코드를 포함할 수는 조건을 요약 되어 있습니다. (동적 메서드를 확인할 수 없는 예를 들어 경우 해당 <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> 속성이 `false`.)  
  
-   보안에 중요 한 어셈블리와 연결 된 동적 메서드가 보안에 중요 한 되며 확인을 건너뛸 수 있습니다. 예를 들어 데스크톱 응용 프로그램으로 실행 하는 보안 특성이 없는 어셈블리는 런타임에서 보안에 중요로 처리 됩니다. 동적 메서드는 어셈블리와 연결 하는 경우 동적 메서드에 확인할 수 없는 코드를 포함할 수 있습니다.  
  
-   비안정형 코드를 포함 하는 동적 메서드는 수준 1 투명도 어셈블리와 관련이 있으면 적시에 (JIT) 컴파일러는 보안 요청을 추가 합니다. 요청에는 완전히 신뢰할 수 있는 코드에서 동적 메서드를 실행 하는 경우에 성공 합니다. 참조 [보안 투명 코드, 수준 1](~/docs/framework/misc/security-transparent-code-level-1.md)합니다.  
  
-   비안정형 코드를 포함 하는 동적 메서드 (예: mscorlib.dll) 수준 2 투명도 사용 하는 어셈블리와 관련이 있으면 보안 요청을 하는 대신 (JIT 컴파일러에 의해 삽입) 예외를 throw 합니다. 참조 [보안 투명 코드, 수준 2](~/docs/framework/misc/security-transparent-code-level-2.md)합니다.  
  
-   항상 확인할 수 없는 코드를 포함 하는 익명으로 호스팅된 동적 메서드는 예외를 throw 합니다. 생성 되 고 완전히 신뢰할 수 있는 코드에서 실행 하는 경우에 확인을 생략할 수 없습니다.  
  
 확인할 수 없는 코드에 대해 throw 되는 예외 동적 메서드가 호출 되는 방식에 따라 달라 집니다. 반환 된 대리자를 사용 하 여 동적 메서드를 호출 하는 경우는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 메서드를 한 <xref:System.Security.VerificationException> throw 됩니다. 사용 하 여 동적 메서드를 호출 하는 경우는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드를 한 <xref:System.Reflection.TargetInvocationException> 는 내부 조인와 함께 발생 <xref:System.Security.VerificationException>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다. 이 예제에서는 콘솔에 첫 번째 매개 변수를 출력 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다. 이 예제에서는 대리자를 만들어 메서드를 완료 합니다. 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드.  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>동적 메서드를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <summary>메서드 이름, 반환 형식 및 매개 변수 형식을 지정하여 익명으로 호스팅된 동적 메서드를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에 의해 만들어진 동적 메서드는 기존 형식이 나 모듈 대신 익명 어셈블리와 연결 합니다. 익명 어셈블리에만 동적 메서드에 대 한 샌드박스 환경 즉, 제공를 다른 코드에서 격리 하 고 있습니다. 이 환경에서는 동적 메서드를 내보내지고 부분적으로 신뢰할 수 있는 코드 실행에 대 한 안전 하 게 보호 합니다.  
  
 이 생성자는 (적시에 JIT) 가시성 검사를 Microsoft intermediate language (MSIL)에 대 한 적용 동적 메서드를 지정 합니다. 즉, 동적 메서드의 코드에서에서 공용 클래스의 공용 메서드에 대 한 액세스를 있습니다. 메서드가 형식 또는 멤버에 액세스 하려고 하는 경우 예외가 throw 됩니다 `private`, `protected`, 또는 `internal` (`Friend` Visual basic에서). JIT 가시성 검사를 건너뛰는 기능을 제한 된 동적 메서드를 만들려면 사용은 <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> 생성자입니다.  
  
 익명으로 호스팅된 동적 메서드를 생성 하는 경우 내보내는 어셈블리의 호출 스택이 포함 됩니다. 메서드가 호출 되 면 내보내는 어셈블리의 권한이 실제 호출자의 권한 대신 사용 됩니다. 따라서 동적 메서드에 전달 되 고 더 높은 신뢰 수준에 있는 어셈블리에서 실행 하는 경우에 내보내는 어셈블리 보다 더 높은 수준의 권한에서 실행할 수 없습니다.  
  
 이 생성자 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 호출 규칙 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  이 생성자는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="restrictedSkipVisibility">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에 대해 JIT 가시성 검사를 건너뛰려면(단, 이러한 형식과 멤버를 포함하는 어셈블리의 트러스트 수준이 동적 메서드를 내보내는 호출 스택의 트러스트 수준보다 작거나 같아야 한다는 제한이 적용되는 경우) <see langword="true" />이며, 건너뛰지 않으려면 <see langword="false" />입니다.</param>
        <summary>메서드 이름, 반환 형식, 매개 변수 형식, 그리고 동적 메서드의 MSIL(Microsoft Intermediate Language)에서 액세스하는 형식 및 멤버에 대해 JIT(적시) 가시성 검사를 건너뛰어야 하는지 여부를 지정하는 익명으로 호스팅된 동적 메서드를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에 의해 만들어진 동적 메서드는 기존 형식이 나 모듈 대신 익명 어셈블리와 연결 합니다. 익명 어셈블리에만 동적 메서드에 대 한 샌드박스 환경 즉, 제공를 다른 코드에서 격리 하 고 있습니다. 이 환경에서는 동적 메서드를 내보내지고 부분적으로 신뢰할 수 있는 코드 실행에 대 한 안전 하 게 보호 합니다.  
  
 익명으로 호스팅된 동적 메서드 형식 또는 멤버에 자동으로 액세스할 필요가 없습니다 `private`, `protected`, 또는 `internal` (`Friend` Visual basic에서). 이 해당 범위의 숨겨진된 멤버에 대 한 액세스를 포함 하는 기존 형식이 나 모듈을 연관 된 동적 메서드와에서 다릅니다.  
  
 지정 `true` 에 대 한 `restrictedSkipVisibility` 형식 또는 멤버에 액세스 하 여 동적 메서드는 `private`, `protected`, 또는 `internal`합니다. 이러한 멤버에 제한 된 동적 메서드가 액세스할을 수 있습니다. 즉, 멤버는 다음 조건이 충족 될 경우에 액세스할 수 있습니다.  
  
-   대상 구성원이 동적 메서드를 내보내는 호출 스택의 보다 낮거나 같아야 신뢰 수준이 어셈블리에 속해 있습니다.  
  
-   동적 메서드를 내보내는 호출 스택의 부여 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그입니다. 이 항상 있을 경우 코드가 완전 신뢰로 실행 됩니다. 부분적으로 신뢰할 수 있는 코드는 호스트에 명시적으로 사용 권한을 부여 하는 경우에 true.  
  
    > [!IMPORTANT]
    >  보안 예외를 사용 하는 경우 throw 권한이 부여 되지 않은 경우 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 라고 또는 동적 메서드가 호출 되 면 호출 되지 않는 경우이 생성자가 있습니다. 동적 메서드를 내보낼 수 없는 특별 한 권한이 필요 합니다.  
  
 예를 들어는 동적 메서드를 사용 하 여 만든 `restrictedSkipVisibility` 로 설정 `true` 호출 스택을 제한 된 멤버 액세스 권한이 부여 된 경우 호출 스택에 있는 모든 어셈블리의 private 멤버에 액세스할 수 있습니다. 호출 스택에 부분적으로 신뢰할 수 있는 코드를 동적 메서드를 만드는 경우에 형식의 private 멤버에 액세스할 수 없습니다 것을 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 어셈블리는 완전히 신뢰할 수 있는 합니다.  
  
 경우 `restrictedSkipVisibility` 은 `false`, JIT 가시성 검사를 적용 합니다. 동적 메서드의 코드에서에서 공용 클래스의 public 메서드에 액세스할 수 있고 되는 형식 또는 멤버에 액세스 하려고 시도 하면 예외가 throw 됩니다 `private`, `protected`, 또는 `internal`합니다.  
  
 익명으로 호스팅된 동적 메서드를 생성 하는 경우 내보내는 어셈블리의 호출 스택이 포함 됩니다. 메서드가 호출 되 면 내보내는 호출 스택의 권한에 실제 호출자의 권한 대신 사용 됩니다. 따라서 동적 메서드에 전달 되 고 더 높은 신뢰 수준에 있는 어셈블리에서 실행 하는 경우에 내보내는 어셈블리 보다 더 높은 수준의 권한에서 실행할 수 없습니다.  
  
 이 생성자 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 호출 규칙 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  이 생성자는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="m">동적 메서드를 논리적으로 연결할 모듈을 나타내는 <see cref="T:System.Reflection.Module" />입니다.</param>
        <summary>메서드 이름, 반환 형식, 매개 변수 형식 및 모듈을 지정하여 모듈 전체에서 사용되는 동적 메서드를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 호출 규칙 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, 및 (JIT) 가시성 검사를 건너뛰지 않습니다.  
  
 이 생성자를 사용 하 여 만든 동적 메서드가 public에 대 한 액세스 및 `internal` (`Friend` Visual basic에서) 모듈에 포함 된 모든 형식의 멤버 `m`합니다.  
  
> [!NOTE]
>  이 생성자에 대 한 이전 버전과 호환성 요구 <xref:System.Security.Permissions.SecurityPermission> 와 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 모두 다음과 같은 경우 true: `m` 는 호출 모듈과 수요 이외의 모듈 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그 실패 했습니다. 경우에 대 한 요구 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 필요 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다. 이 예제에서는 콘솔에 첫 번째 매개 변수를 출력 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다. 이 예제에서는 대리자를 만들어 메서드를 완료 합니다. 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> 메서드.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  -또는-  <paramref name="m" />이 동적 메서드에 대한 익명 호스팅을 제공하는 모듈입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  -또는-  <paramref name="m" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">모듈 호출 모듈이 이외의 동적 메서드를 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="owner">동적 메서드가 논리적으로 연결되는 <see cref="T:System.Type" />입니다. 동적 메서드에 해당 형식의 모든 멤버에 대한 액세스 권한이 있습니다.</param>
        <summary>메서드 이름, 반환 형식, 매개 변수 형식 및 동적 메서드가 논리적으로 연결된 형식을 지정하여 동적 메서드를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여 만든 동적 메서드에 해당 형식의 모든 멤버에 대 한 액세스 권한이 `owner`, 및 public로 및 `internal` (`Friend` Visual basic에서)의 포함 된 모듈의 다른 모든 형식 멤버 `owner`합니다.  
  
 이 생성자 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 호출 규칙 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, 및 (JIT) 가시성 검사를 건너뛰지 않습니다.  
  
> [!NOTE]
>  이 생성자에 대 한 이전 버전과 호환성 요구 <xref:System.Security.Permissions.SecurityPermission> 와 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 모두 다음과 같은 경우 true: `owner` 가 호출 모듈과 수요 아닌 모듈에 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그에 실패 했습니다. 경우에 대 한 요구 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 필요 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 한 <xref:System.Reflection.Emit.DynamicMethod> 형식으로 논리적으로 연결 합니다. 이 연결에 액세스할 해당 형식의 private 멤버입니다.  
  
 라는 클래스를 정의 하는 코드 예제에서는 `Example` 라는 클래스는 private 필드와 `DerivedFromxample` 첫 번째 클래스에서 파생 된 이라는 대리자 형식을 `UseLikeStatic` 반환 하는 <xref:System.Int32> 형식의 매개 변수에 `Example` 및 <xref:System.Int32>, 및 이라는 대리자 형식을 `UseLikeInstance` 반환 하는 <xref:System.Int32> 형식의 매개 변수가 하나 있으며 <xref:System.Int32>합니다.  
  
 다음 예제 코드를 만듭니다는 <xref:System.Reflection.Emit.DynamicMethod> 인스턴스의 private 필드를 변경 하는 `Example` 이전 값을 반환 합니다.  
  
> [!NOTE]
>  일반적으로 클래스의 내부 필드를 변경 합니다. 아닌 경우 좋은 개체 지향 코딩 사례  
  
 예제 코드의 인스턴스를 만들고 `Example` 다음 두 대리자를 만듭니다. 형식의 첫 번째는 `UseLikeStatic`을 동적 방법으로 동일한 매개 변수가 있는 합니다. 형식의 두 번째는 `UseLikeInstance`, 첫 번째 매개 변수 부족 (형식의 `Example`). 이 대리자를 사용 하 여 만들어집니다는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> 메서드 오버 로드, 두 번째 해당 메서드 오버 로드의 매개 변수는 인스턴스의 `Example`,이 경우에 새로 생성된 된 대리자에 바인딩된 인스턴스 방금 만든 합니다. 바인딩된 인스턴스에 대해 동적 메서드는 작동 해당 대리자를 호출할 때마다 `Example`합니다.  
  
> [!NOTE]
>  도입 된 대리자 바인딩이 이것이 완화 된 규칙의 예는 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], 함께 새 오버 로드는 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> 메서드. 자세한 내용은 <xref:System.Delegate> 클래스를 참조하세요.  
  
 `UseLikeStatic` 대리자가 호출의 인스턴스를 전달 `Example` 에 바인딩되는 `UseLikeInstance` 위임 합니다. 그런 다음 `UseLikeInstance` 두 대리자의 동일한 인스턴스에서 작동 되도록 대리자가 호출 `Example`합니다. 내부 필드의 값의 변동은 각 호출 후 표시 됩니다. 마지막으로, 한 `UseLikeInstance` 대리자 인스턴스에 바인딩되어 `DerivedFromxample`, 대리자를 호출 하 여 반복 됩니다.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  -또는-  <paramref name="owner" />가 인터페이스, 배열, 개방형 제네릭 형식, 제네릭 형식 또는 메서드의 형식 매개 변수입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  -또는-  <paramref name="owner" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" />은 <see langword="null" />이거나 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 모듈이 이외의 모듈의 형식은와 동적 메서드를 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="m">동적 메서드를 논리적으로 연결할 모듈을 나타내는 <see cref="T:System.Reflection.Module" />입니다.</param>
        <param name="skipVisibility">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <see langword="true" />입니다.</param>
        <summary>모듈 전체에 적용되는 동적 메서드를 만들어 메서드 이름, 반환 형식, 매개 변수 형식, 모듈을 지정하고, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 호출 규칙 및 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>합니다.  
  
 이 생성자를 사용 하 여 만든 동적 메서드가 public에 대 한 액세스 및 `internal` (`Friend` Visual basic에서) 포함 된 모듈에 있는 모든 형식의 멤버 `m`합니다. 건너뛴 JIT 컴파일러의 가시성 검사 모든 다른 형식 에서도의 private 컨트롤과 protected 멤버에 액세스 동적 메서드를 사용할 수 있습니다. 예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.  
  
> [!NOTE]
>  이 생성자에 대 한 이전 버전과 호환성 요구 <xref:System.Security.Permissions.SecurityPermission> 와 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 모두 다음과 같은 경우 true: `m` 는 호출 모듈과 수요 이외의 모듈 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그 실패 했습니다. 경우에 대 한 요구 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 필요 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  -또는-  <paramref name="m" />이 동적 메서드에 대한 익명 호스팅을 제공하는 모듈입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  -또는-  <paramref name="m" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">모듈 호출 모듈이 이외의 동적 메서드를 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="owner">동적 메서드가 논리적으로 연결되는 <see cref="T:System.Type" />입니다. 동적 메서드에 해당 형식의 모든 멤버에 대한 액세스 권한이 있습니다.</param>
        <param name="skipVisibility">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>동적 메서드를 만들고, 메서드 이름, 반환 형식, 매개 변수 형식, 동적 메서드가 논리적으로 연결되는 형식, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여 만든 동적 메서드에 해당 형식의 모든 멤버에 대 한 액세스 권한이 `owner`, 및 public로 및 `internal` (`Friend` Visual basic에서)의 포함 된 모듈의 다른 모든 형식 멤버 `owner`합니다. 건너뛴 JIT 컴파일러의 가시성 검사 모든 다른 형식 에서도의 private 컨트롤과 protected 멤버에 액세스 동적 메서드를 사용할 수 있습니다. 예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.  
  
 이 생성자 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 호출 규칙 및 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  이 생성자에 대 한 이전 버전과 호환성 요구 <xref:System.Security.Permissions.SecurityPermission> 와 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 모두 다음과 같은 경우 true: `owner` 가 호출 모듈과 수요 아닌 모듈에 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그에 실패 했습니다. 경우에 대 한 요구 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 필요 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  -또는-  <paramref name="owner" />가 인터페이스, 배열, 개방형 제네릭 형식, 제네릭 형식 또는 메서드의 형식 매개 변수입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  -또는-  <paramref name="owner" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" />은 <see langword="null" />이거나 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 모듈이 이외의 모듈의 형식은와 동적 메서드를 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="attributes">동적 메서드의 특성을 지정하는 <see cref="T:System.Reflection.MethodAttributes" /> 값의 비트 조합입니다. 허용되는 유일한 조합은 <see cref="F:System.Reflection.MethodAttributes.Public" /> 및 <see cref="F:System.Reflection.MethodAttributes.Static" />입니다.</param>
        <param name="callingConvention">동적 메서드에 대한 호출 규칙입니다. <see cref="F:System.Reflection.CallingConventions.Standard" />여야 합니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="m">To be added.</param>
        <param name="skipVisibility">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>모듈 전체에 적용되는 동적 메서드를 만들어 메서드 이름, 특성, 호출 규칙, 반환 형식, 매개 변수 형식, 모듈을 지정하고, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여 만든 동적 메서드가 public에 대 한 액세스 및 `internal` (`Friend` Visual basic에서) 모듈에 포함 된 모든 public 및 내부 형식 멤버 `m`합니다.  
  
 건너뛴 JIT 컴파일러의 가시성 검사 모듈 및 다른 모든 어셈블리에도 다른 모든 종류의 전용 및 보호 된 멤버에 액세스 동적 메서드를 사용할 수 있습니다. 예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.  
  
> [!NOTE]
>  이 생성자에 대 한 이전 버전과 호환성 요구 <xref:System.Security.Permissions.SecurityPermission> 와 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 모두 다음과 같은 경우 true: `m` 는 호출 모듈과 수요 이외의 모듈 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그 실패 했습니다. 경우에 대 한 요구 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 필요 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  -또는-  <paramref name="m" />이 동적 메서드에 대한 익명 호스팅을 제공하는 모듈입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  -또는-  <paramref name="m" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" />는 <see cref="F:System.Reflection.MethodAttributes.Public" /> 및 <see cref="F:System.Reflection.MethodAttributes.Static" /> 이외의 플래그 조합입니다.  -또는-  <paramref name="callingConvention" />이 <see cref="F:System.Reflection.CallingConventions.Standard" />가 아닙니다.  -또는-  <paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">모듈 호출 모듈이 이외의 동적 메서드를 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="attributes">동적 메서드의 특성을 지정하는 <see cref="T:System.Reflection.MethodAttributes" /> 값의 비트 조합입니다. 허용되는 유일한 조합은 <see cref="F:System.Reflection.MethodAttributes.Public" /> 및 <see cref="F:System.Reflection.MethodAttributes.Static" />입니다.</param>
        <param name="callingConvention">동적 메서드에 대한 호출 규칙입니다. <see cref="F:System.Reflection.CallingConventions.Standard" />여야 합니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="owner">동적 메서드가 논리적으로 연결되는 <see cref="T:System.Type" />입니다. 동적 메서드에 해당 형식의 모든 멤버에 대한 액세스 권한이 있습니다.</param>
        <param name="skipVisibility">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>동적 메서드를 만들고, 메서드 이름, 특성, 호출 규칙, 반환 형식, 매개 변수 형식, 동적 메서드가 논리적으로 연결되는 형식, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 메서드는 형식이 포함 된 모듈에 전역 `owner`합니다. 형식의 모든 멤버에 액세스할 수 `owner`합니다.  
  
 이 생성자를 사용 하 여 만든 동적 메서드에 해당 형식의 모든 멤버에 대 한 액세스 권한이 `owner`, 및 public로 및 `internal` (`Friend` Visual basic에서) 포함 하는 모듈에 포함 된 모든 형식의 멤버 `owner`합니다. 건너뛴 JIT 컴파일러의 가시성 검사 모든 다른 형식 에서도의 private 컨트롤과 protected 멤버에 액세스 동적 메서드를 사용할 수 있습니다. 예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.  
  
> [!NOTE]
>  이 생성자에 대 한 이전 버전과 호환성 요구 <xref:System.Security.Permissions.SecurityPermission> 와 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 모두 다음과 같은 경우 true: `owner` 가 호출 모듈과 수요 아닌 모듈에 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그에 실패 했습니다. 경우에 대 한 요구 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터는 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 필요 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  -또는-  <paramref name="owner" />가 인터페이스, 배열, 개방형 제네릭 형식, 제네릭 형식 또는 메서드의 형식 매개 변수입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우  -또는-  <paramref name="owner" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" />는 <see cref="F:System.Reflection.MethodAttributes.Public" /> 및 <see cref="F:System.Reflection.MethodAttributes.Static" /> 이외의 플래그 조합입니다.  -또는-  <paramref name="callingConvention" />이 <see cref="F:System.Reflection.CallingConventions.Standard" />가 아닙니다.  -또는-  <paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 모듈이 이외의 모듈의 형식은와 동적 메서드를 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드를 만들 때 지정된 특성을 가져옵니다.</summary>
        <value>메서드의 특성을 나타내는 <see cref="T:System.Reflection.MethodAttributes" /> 값의 비트 조합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재, 동적 메서드가 메서드 특성은 항상 <xref:System.Reflection.MethodAttributes.Public> 및 <xref:System.Reflection.MethodAttributes.Static>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드의 메서드 특성을 표시합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드를 만들 때 지정된 호출 규칙을 가져옵니다.</summary>
        <value>메서드의 호출 규칙을 나타내는 <see cref="T:System.Reflection.CallingConventions" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재, 동적 메서드의 호출 규칙은 항상 <xref:System.Reflection.CallingConventions.Standard>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드의 호출 규칙을 표시합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>동적 메서드를 완료하고 실행하는 데 사용할 수 있는 대리자를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">서명이 동적 메서드의 서명과 일치하는 대리자 형식입니다.</param>
        <summary>동적 메서드를 완료하고 실행하는 데 사용할 수 있는 대리자를 만듭니다.</summary>
        <returns>지정된 형식의 대리자로, 동적 메서드를 실행하는 데 사용할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 메서드 또는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드는 동적 메서드를 완료 합니다. 추가 매개 변수 정의 수정 하는 등 동적 메서드를 변경 하도록 또는 더 많은 Microsoft MSIL (intermediate language)을 표시 하 고는 무시 됩니다. 예외가 throw 되지 않습니다.  
  
 동적 메서드의 메서드 본문을 만들려면 사용자 고유의 MSIL 생성기 있으면 호출는 <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> 를 얻는 메서드를 한 <xref:System.Reflection.Emit.DynamicILInfo> 개체입니다. 사용자 고유의 MSIL 생성기가 없는 경우 호출는 <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> 를 얻는 메서드를 한 <xref:System.Reflection.Emit.ILGenerator> 메서드 본문을 생성 하는 데 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다. 이 예제에서는 콘솔에 첫 번째 매개 변수를 출력 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다. 이 예제에서는 대리자를 만들어 메서드를 완료 합니다. 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에 메서드 본문이 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" />의 매개 변수 개수가 잘못되었거나 매개 변수 유형이 잘못되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">서명이 동적 메서드의 서명과 일치하는 대리자 형식에서 첫 번째 매개 변수를 뺀 값입니다.</param>
        <param name="target">대리자가 바인딩된 개체입니다. 동적 메서드의 첫 번째 매개 변수와 동일한 형식이어야 합니다.</param>
        <summary>동적 메서드를 완료하고 대리자 형식과 대리자가 바인딩되는 개체를 지정하여 해당 메서드를 실행하는 데 사용할 수 있는 대리자를 만듭니다.</summary>
        <returns>지정된 형식의 대리자로, 지정된 대상 개체를 사용하여 동적 메서드를 실행하는 데 사용할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드는 특정 개체에 바인딩된 대리자를 만듭니다. 이러한 대리자는 첫 번째 인수에 대해 닫혀 라고 합니다. 마치; 인스턴스 메서드인 것 처럼 동작 메서드가 정적 이지만, 인스턴스가 `target`합니다.  
  
 이 메서드 오버 로드 해야 `target` 동적 메서드의 첫 번째 매개 변수로 동일한 형식이 되도록 하거나 해당 형식 (예를 들어 파생된 클래스)에 할당할 수 있습니다.  시그니처 `delegateType` 동적 메서드의 첫 번째를 제외한 모든 매개 변수가 있습니다. 예를 들어 동적 메서드에 매개 변수가 <xref:System.String>, <xref:System.Int32>, 및 <xref:System.Byte>, 다음 `delegateType` 매개 변수에 <xref:System.Int32> 및 <xref:System.Byte>; `target` 유형의 <xref:System.String>합니다.  
  
 호출 된 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 메서드 또는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드는 동적 메서드를 완료 합니다. 추가 매개 변수 정의 수정 하는 등 동적 메서드를 변경 하도록 또는 더 많은 Microsoft MSIL (intermediate language)을 표시 하 고는 무시 됩니다. 예외가 throw 되지 않습니다.  
  
 동적 메서드의 메서드 본문을 만들려면 사용자 고유의 MSIL 생성기 있으면 호출는 <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> 를 얻는 메서드를 한 <xref:System.Reflection.Emit.DynamicILInfo> 개체입니다. 사용자 고유의 MSIL 생성기가 없는 경우 호출는 <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> 를 얻는 메서드를 한 <xref:System.Reflection.Emit.ILGenerator> 메서드 본문을 생성 하는 데 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 대리자 바인딩하 만듭니다는 <xref:System.Reflection.Emit.DynamicMethod> 형식의 인스턴스로 메서드가 될 때마다 동일한 인스턴스에서 작동할 수 있도록 호출 됩니다.  
  
 라는 클래스를 정의 하는 코드 예제에서는 `Example` 라는 클래스는 private 필드와 `DerivedFromxample` 첫 번째 클래스에서 파생 된 이라는 대리자 형식을 `UseLikeStatic` 반환 하는 <xref:System.Int32> 형식의 매개 변수에 `Example` 및 <xref:System.Int32>, 및 이라는 대리자 형식을 `UseLikeInstance` 반환 하는 <xref:System.Int32> 형식의 매개 변수가 하나 있으며 <xref:System.Int32>합니다.  
  
 다음 예제 코드를 만듭니다는 <xref:System.Reflection.Emit.DynamicMethod> 인스턴스의 private 필드를 변경 하는 `Example` 이전 값을 반환 합니다.  
  
> [!NOTE]
>  일반적으로 클래스의 내부 필드를 변경 합니다. 아닌 경우 좋은 개체 지향 코딩 사례  
  
 예제 코드의 인스턴스를 만들고 `Example` 다음 두 대리자를 만듭니다. 형식의 첫 번째는 `UseLikeStatic`을 동적 방법으로 동일한 매개 변수가 있는 합니다. 형식의 두 번째는 `UseLikeInstance`, 첫 번째 매개 변수 부족 (형식의 `Example`). 이 대리자를 사용 하 여 만들어집니다는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> 메서드 오버 로드, 두 번째 해당 메서드 오버 로드의 매개 변수는 인스턴스의 `Example`,이 경우에 새로 생성된 된 대리자에 바인딩된 인스턴스 방금 만든 합니다. 바인딩된 인스턴스에 대해 동적 메서드는 작동 해당 대리자를 호출할 때마다 `Example`합니다.  
  
> [!NOTE]
>  도입 된 대리자 바인딩이 이것이 완화 된 규칙의 예는 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], 함께 새 오버 로드는 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> 메서드. 자세한 내용은 <xref:System.Delegate> 클래스를 참조하세요.  
  
 `UseLikeStatic` 대리자가 호출의 인스턴스를 전달 `Example` 에 바인딩되는 `UseLikeInstance` 위임 합니다. 그런 다음 `UseLikeInstance` 두 대리자의 동일한 인스턴스에서 작동 되도록 대리자가 호출 `Example`합니다. 내부 필드의 값의 변동은 각 호출 후 표시 됩니다. 마지막으로, 한 `UseLikeInstance` 대리자 인스턴스에 바인딩되어 `DerivedFromxample`, 대리자를 호출 하 여 반복 됩니다.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에 메서드 본문이 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" />이 동적 메서드의 첫 번째 매개 변수와 동일한 형식이 아니며 해당 형식에 할당할 수 없습니다.  -또는-  <paramref name="delegateType" />의 매개 변수 개수가 잘못되었거나 매개 변수 유형이 잘못되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드에 대해 항상 <see langword="null" />인 메서드를 선언하는 형식을 가져옵니다.</summary>
        <value>항상 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 항상 반환 `null` 동적 메서드에 대 한 합니다. 동적 메서드가 논리적으로 형식과 연결 인 경우에 형식에서 선언 되지 않았습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드의 선언 형식이 표시 됩니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">매개 변수 목록에서 매개 변수의 위치입니다. 매개 변수가 첫 번째 매개 변수에 대한 숫자 1부터 시작해서 인덱싱됩니다.</param>
        <param name="attributes">매개 변수의 특성을 지정하는 <see cref="T:System.Reflection.ParameterAttributes" /> 값의 비트 조합입니다.</param>
        <param name="parameterName">매개 변수의 이름입니다. 이름은 빈 문자열일 수 있습니다.</param>
        <summary>동적 메서드의 매개 변수를 정의합니다.</summary>
        <returns>항상 <see langword="null" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `position` 가 0 이면는 <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> 메서드 반환 값을 나타냅니다. 매개 변수 정보 설정에 반환 값에 영향을 주지 않습니다.  
  
 동적 메서드가 이미 완료 되었는지 여부를 호출 하 여는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 또는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드는 <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> 메서드는 영향을 주지 않습니다. 예외가 throw되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드에 대 한 매개 변수 정보를 정의 하는 방법을 보여 줍니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">메서드에 매개 변수가 없습니다.  -또는-  <paramref name="position" />이 0보다 작습니다.  -또는-  <paramref name="position" />이 메서드의 매개 변수 개수보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>메서드에 대한 기본 구현을 반환합니다.</summary>
        <returns>메서드의 기본 구현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 항상 현재 반환 `DynamicMethod` 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>메서드에 적용된 사용자 지정 특성을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">메서드의 상속 체인을 검색하여 사용자 지정 특성을 찾으려면 <see langword="true" />이고, 현재 메서드만 검사하려면 <see langword="false" />입니다.</param>
        <summary>이 메서드에 대해 정의된 모든 사용자 지정 특성을 반환합니다.</summary>
        <returns>이 메서드의 모든 사용자 지정 특성을 나타내는 개체 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 하는 동적 메서드에 대 한 `true` 에 대 한 `inherit` 메서드 형식에서 선언 되지 않았으므로 아무 효과가 있습니다.  
  
> [!NOTE]
>  동적 메서드에 사용자 지정 특성이 현재 지원 되지 않습니다. 속성만 반환은 <xref:System.Runtime.CompilerServices.MethodImplAttribute>; 얻을 수 있습니다 메서드 구현 플래그 사용 하 여 보다 쉽게는 <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">반환할 사용자 지정 특성의 형식을 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="inherit">메서드의 상속 체인을 검색하여 사용자 지정 특성을 찾으려면 <see langword="true" />이고, 현재 메서드만 검사하려면 <see langword="false" />입니다.</param>
        <summary>메서드에 적용된 지정된 형식의 사용자 지정 특성을 반환합니다.</summary>
        <returns>
          <paramref name="attributeType" /> 형식의 메서드 또는 <paramref name="attributeType" /> 형식에서 파생된 메서드의 특성을 나타내는 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 하는 동적 메서드에 대 한 `true` 에 대 한 `inherit` 메서드 형식에서 선언 되지 않았으므로 아무 효과가 있습니다.  
  
> [!NOTE]
>  동적 메서드에 사용자 지정 특성이 현재 지원 되지 않습니다. 속성만 반환은 <xref:System.Runtime.CompilerServices.MethodImplAttribute>; 얻을 수 있습니다 메서드 구현 플래그 사용 하 여 보다 쉽게는 <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>메타데이터 토큰, 범위 및 MSIL(Microsoft Intermediate Language) 스트림에서 메서드 본문을 생성하는 데 사용할 수 있는 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 개체를 반환합니다.</summary>
        <returns>메타데이터 토큰, 범위 및 MSIL 스트림에서 메서드 본문을 생성하는 데 사용할 수 있는 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicILInfo> 클래스는 관리 되지 않는 코드 생성을 지원 하기 위해 제공 됩니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>동적 메서드의 본문을 내보내는 데 사용할 수 있는 MSIL 생성기를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>64바이트의 기본 MSIL(Microsoft Intermediate Language) 스트림 크기를 사용하는 메서드에 대한 MSIL 생성기를 반환합니다.</summary>
        <returns>메서드에 대한 <see cref="T:System.Reflection.Emit.ILGenerator" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 메서드가 완료 되 면 호출 하 여 후의 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 또는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드를 모두 추가 하려고 하면 MSIL은 무시 됩니다. 예외가 throw되지 않습니다.  
  
> [!NOTE]
>  일부 완전 신뢰 시나리오에도 동적 메서드에 확인할 수 없는 코드에는 제한이 있습니다. <xref:System.Reflection.Emit.DynamicMethod>에 대한 설명에서 "확인" 섹션을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다. 이 예제에서는 콘솔에 첫 번째 매개 변수를 출력 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다. 이 예제에서는 대리자를 만들어 메서드를 완료 합니다. 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">MSIL 스트림에 바이트의 크기입니다.</param>
        <summary>지정된 된 MSIL 스트림 크기를 사용하는 메서드에 대한 MSIL(Microsoft Intermediate Language) 생성기를 반환합니다.</summary>
        <returns>지정된 MSIL 스트림 크기를 가진 메서드의 <see cref="T:System.Reflection.Emit.ILGenerator" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 메서드가 완료 되 면 호출 하 여 후의 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 또는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드를 모두 추가 하려고 하면 MSIL은 무시 됩니다. 예외가 throw되지 않습니다.  
  
> [!NOTE]
>  일부 완전 신뢰 시나리오에도 동적 메서드에 확인할 수 없는 코드에는 제한이 있습니다. <xref:System.Reflection.Emit.DynamicMethod>에 대한 설명에서 "확인" 섹션을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는이 메서드 오버 로드 하는 방법을 보여 줍니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>메서드에 대한 구현 플래그를 반환합니다.</summary>
        <returns>메서드에 대한 구현 플래그를 나타내는 <see cref="T:System.Reflection.MethodImplAttributes" /> 값의 비트 조합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재, 동적 메서드의 메서드 구현 특성은 항상 <xref:System.Reflection.MethodImplAttributes.IL> 및 <xref:System.Reflection.MethodImplAttributes.NoInlining>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>동적 메서드의 매개 변수를 반환합니다.</summary>
        <returns>동적 메서드의 매개 변수를 나타내는 <see cref="T:System.Reflection.ParameterInfo" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.ParameterInfo> 이 메서드에 의해 반환 되는 개체는 정보 제공 용입니다. 사용 하 여는 <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> 메서드를 설정 하거나 매개 변수 특징을 변경 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드의 매개 변수를 표시 합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드의 로컬 변수가 0으로 초기화되었는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>메서드의 로컬 변수가 0으로 초기화되었으면 <see langword="true" />이고, 초기화되지 않았으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은로 설정 하는 경우 `true`, 내보낸된 Microsoft intermediate language (MSIL) 지역 변수 초기화를 포함 합니다. 로 설정 되어 있으면 `false`, 지역 변수는 초기화 되지 및 생성된 된 코드를 확인할 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> 동적 메서드의 속성입니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">이 매개 변수는 정적이기 때문에 동적 메서드에 대해 무시됩니다. <see langword="null" />을 지정합니다.</param>
        <param name="invokeAttr">
          <see cref="T:System.Reflection.BindingFlags" /> 값의 비트 조합입니다.</param>
        <param name="binder">리플렉션을 통해 바인딩, 인수 형식 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.Binder" /> 개체의 검색을 가능하게 하는 <see cref="T:System.Reflection.MemberInfo" /> 개체입니다. <c>바인더</c>가 <see langword="null" />이면 기본 바인더가 사용됩니다. 자세한 내용은 <see cref="T:System.Reflection.Binder" />을 참조하십시오.</param>
        <param name="parameters">인수 목록입니다. 호출되는 메서드의 매개 변수와 숫자, 순서, 형식이 동일한 인수의 배열입니다. 매개 변수가 없는 경우 이 매개 변수는 <see langword="null" />이어야 합니다.</param>
        <param name="culture">형식의 강제 변환을 제어하는 데 사용되는 <see cref="T:System.Globalization.CultureInfo" />의 인스턴스입니다. 이 매개 변수가 <see langword="null" />이면 현재 스레드에 대한 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다. 예를 들어, 1000은 각 문화권마다 다르게 표현되므로 1000을 나타내는 <see cref="T:System.String" />을 <see cref="T:System.Double" /> 값으로 올바르게 변환하는 데 이 정보가 필요합니다.</param>
        <summary>지정된 문화권 정보를 사용하고 지정된 바인더의 제약 조건에 따라, 지정된 매개 변수를 사용하여 동적 메서드를 호출합니다.</summary>
        <returns>호출된 메서드의 반환 값이 들어 있는 <see cref="T:System.Object" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 나열 된 예외 뿐 아니라 동적 메서드에 의해 throw 된 예외를 catch을 호출 하는 코드를 준비 해야 합니다.  
  
 동적 메서드를 실행 하 여 만든 대리자와는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 메서드를 실행할 때 보다 더 효율적입니다.는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드.  
  
 호출 된 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드 또는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 메서드는 동적 메서드를 완료 합니다. 추가 매개 변수 정의 수정 하는 등 동적 메서드를 변경 하도록 또는 더 많은 Microsoft MSIL (intermediate language)을 표시 하 고는 무시 됩니다. 예외가 throw 되지 않습니다.  
  
 모든 동적 메서드는 정적 이므로 `obj` 매개 변수는 항상 무시 됩니다. 인스턴스 메서드인 것 처럼 동적 메서드를 처리할 사용 된 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> 개체 인스턴스를 사용 하는 오버 로드 합니다.  
  
 동적 메서드의 매개 변수가 없는 경우, 값 `parameters` 해야 `null`합니다. 그렇지 않으면 개수, 형식 및 매개 변수 배열에 있는 요소의 순서는 개수, 형식 및 동적 메서드의 매개 변수의 순서와 같아야 합니다.  
  
> [!NOTE]
>  이 메서드 오버 로드는 <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> 에서 상속 된 메서드 오버 로드는 <xref:System.Reflection.MethodBase> 클래스, 위에서 설명한 내용이 오버 로드 모두에 적용 합니다.  
  
 이 메서드는 권한이 직접 필요 하지 않지만 동적 메서드를 호출 하는 방법에 따라 보안 요구 사항을 충족에서 될 수 있습니다. 익명으로 호스팅된 동적 메서드를 사용 하 여 만든 필요 하지 않습니다는 원활 예를 들어는 `restrictedSkipVisibility` 매개 변수 설정 `false`합니다. 반면, 사용 하 여 메서드를 만들면 `restrictedSkipVisibility` 로 설정 `true` 메서드 더하기 대상 어셈블리의 사용 권한에 대 한 요청을 하면 대상 어셈블리의 숨겨진된 멤버를 액세스할 수 있도록 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그입니다.  
  
> [!NOTE]
>  이전에 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를 요구 하는이 방법 <xref:System.Security.Permissions.ReflectionPermission> 와 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> 플래그입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 미국-영어 culture를 사용 하 여 정확한 바인딩으로 동적 메서드를 호출 합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="F:System.Reflection.CallingConventions.VarArgs" /> 호출 규칙이 지원되지 않는 경우</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <paramref name="parameters" />에 있는 요소의 수가 동적 메서드에 있는 매개 변수의 수와 일치하지 않는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameters" />에 있는 하나 이상의 요소 형식이 동적 메서드에 있는 해당 매개 변수의 형식과 일치하지 않는 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">동적 메서드를 모듈과 연결했고 익명으로 호스팅하지 않았으며 이를 생성할 때 <paramref name="skipVisibility" />를 <see langword="false" />로 설정했지만 이 동적 메서드에서 <see langword="public" /> 또는 <see langword="internal" />(Visual Basic의 경우 <see langword="Friend" />)이 아닌 멤버에 액세스하는 경우  -또는-  동적 메서드가 익명으로 호스팅되고 <paramref name="skipVisibility" /> 값을 <see langword="false" />로 설정하여 만들어졌지만, <see langword="public" />이 아닌 멤버에 액세스합니다.  -또는-  동적 메서드에 확인할 수 없는 코드가 포함되어 있습니다. <see cref="T:System.Reflection.Emit.DynamicMethod" />에 대한 설명에서 "확인" 섹션을 참조하세요.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">검색할 사용자 지정 특성의 형식을 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="inherit">메서드의 상속 체인을 검색하여 사용자 지정 특성을 찾으려면 <see langword="true" />이고, 현재 메서드만 검사하려면 <see langword="false" />입니다.</param>
        <summary>지정된 사용자 지정 특성 유형이 정의되었는지 여부를 나타냅니다.</summary>
        <returns>지정된 사용자 지정 특성 형식이 정의되어 있으면 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 하는 동적 메서드에 대 한 `true` 에 대 한 `inherit` 영향을 주지 않습니다. 동적 메서드는 상속 체인에 없습니다.  
  
> [!NOTE]
>  동적 메서드에 사용자 지정 특성이 현재 지원 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 동적 메서드가 보안에 중요하거나 보안 안전에 중요하여 중요한 작업을 수행할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 동적 메서드가 보안에 중요한 형식이거나 보안 안전에 중요한 형식이면 <see langword="true" />이고, 투명 형식이면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> 속성 공용 언어 런타임 (CLR)에 의해 결정 된 동적 메서드의 투명도 수준을 보고 합니다. 다음 표에서 이러한 속성의 조합은 같습니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
 동적 메서드의 투명도와 연결 된 모듈에 따라 달라 집니다. 동적 메서드가 모듈 대신 형식와 관련이 있으면 투명도 유형을 포함 하는 모듈에 따라 달라 집니다. 연결 된 모듈에 대 한 기본 투명도 할당 된 동적 메서드 없으므로 보안 주석을 않습니다.  
  
-   익명으로 호스팅된 동적 메서드는 포함 하는 시스템 제공 모듈 투명 하기 때문에 투명 하 게 항상입니다.  
  
-   신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)와 연결 된 동적 메서드가의 투명도 다음 표에 설명 되어 있습니다.  
  
    |어셈블리 주석|수준 1 투명도|수준 2 투명도|  
    |-------------------------|--------------------------|--------------------------|  
    |완전히 투명 한|투명|투명|  
    |완전 하 게 중요 한|위험|위험|  
    |혼합 된 투명도|투명|투명|  
    |알 수 없는 보안|안전에 중요|위험|  
  
     예를 들어 2의 혼합된 투명도 수준에 mscorlib.dll에 있는 형식으로는 동적 메서드를 연결 하는 경우 동적 메서드는 투명 및 중요 한 코드를 실행할 수 없습니다. 투명도 수준에 대 한 정보를 참조 하십시오. [보안 투명 코드, 수준 1](~/docs/framework/misc/security-transparent-code-level-1.md) 및 [보안 투명 코드, 수준 2](~/docs/framework/misc/security-transparent-code-level-2.md)합니다.  
  
    > [!NOTE]
    >  동적 메서드는 보안에 종속 되지 않으므로, System.dll과 같이 신뢰할 수 있는 수준 1 어셈블리에 모듈에 연결 하는 신뢰 권한 상승이 허용 하지 않습니다. 동적 메서드를 호출 하는 코드의 권한 부여 집합 (즉, 완전 신뢰), System.dll의 권한 부여 집합을 포함 되지 않은 경우 <xref:System.Security.SecurityException> 동적 메서드를 호출할 때 throw 됩니다.  
  
-   부분적으로 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드가의 투명도 어셈블리가 로드 되는 방식에 따라 달라 집니다. 부분 신뢰 (예를 들어 샌드 박싱된 응용 프로그램 도메인)에 로드 된 어셈블리가 있으면 런타임에서 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식 및 멤버에 동적 메서드를 포함 하 여 투명 하 게 처리 됩니다. 런타임은 부분 신뢰 어셈블리는 (예를 들어 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 완전히 신뢰 되어 로드 하는 경우에 보안 주석에 주의 유용 합니다. 이 경우 런타임에서 어셈블리의 주석이 따라 메서드에 대 한 기본 투명도 동적 메서드를 할당합니다.  
  
 리플렉션에 대 한 자세한 내용은 내보내기 및 참조 투명도 [리플렉션 내보내기의 보안 문제](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)합니다. 투명도 대 한 정보를 참조 하십시오. [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에는 메서드 본문이 없습니다.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 동적 메서드가 현재 신뢰 수준에서 보안 안전에 중요한 형식인지, 즉 중요한 작업을 수행할 수 있고 투명 코드로 액세스할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>동적 메서드가 현재 신뢰 수준에서 보안 안전에 중요하면 <see langword="true" />이고, 보안에 중요하거나 투명하면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> 속성 공용 언어 런타임 (CLR)에 의해 결정 된 동적 메서드의 투명도 수준을 보고 합니다. 다음 표에서 이러한 속성의 조합은 같습니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
 동적 메서드의 투명도와 연결 된 모듈에 따라 달라 집니다. 동적 메서드가 모듈 대신 형식와 관련이 있으면 투명도 유형을 포함 하는 모듈에 따라 달라 집니다. 연결 된 모듈에 대 한 기본 투명도 할당 된 동적 메서드 없으므로 보안 주석을 않습니다.  
  
-   익명으로 호스팅된 동적 메서드는 포함 하는 시스템 제공 모듈 투명 하기 때문에 투명 하 게 항상입니다.  
  
-   신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)와 연결 된 동적 메서드가의 투명도 다음 표에 설명 되어 있습니다.  
  
    |어셈블리 주석|수준 1 투명도|수준 2 투명도|  
    |-------------------------|--------------------------|--------------------------|  
    |완전히 투명 한|투명|투명|  
    |완전 하 게 중요 한|위험|위험|  
    |혼합 된 투명도|투명|투명|  
    |알 수 없는 보안|안전에 중요|위험|  
  
     예를 들어 2의 혼합된 투명도 수준에 mscorlib.dll에 있는 형식으로는 동적 메서드를 연결 하는 경우 동적 메서드는 투명 및 중요 한 코드를 실행할 수 없습니다. 투명도 수준에 대 한 정보를 참조 하십시오. [보안 투명 코드, 수준 1](~/docs/framework/misc/security-transparent-code-level-1.md) 및 [보안 투명 코드, 수준 2](~/docs/framework/misc/security-transparent-code-level-2.md)합니다.  
  
    > [!NOTE]
    >  동적 메서드는 보안에 종속 되지 않으므로, System.dll과 같이 신뢰할 수 있는 수준 1 어셈블리에 모듈에 연결 하는 신뢰 권한 상승이 허용 하지 않습니다. 동적 메서드를 호출 하는 코드의 권한 부여 집합 (즉, 완전 신뢰), System.dll의 권한 부여 집합을 포함 되지 않은 경우 <xref:System.Security.SecurityException> 동적 메서드를 호출할 때 throw 됩니다.  
  
-   부분적으로 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드가의 투명도 어셈블리가 로드 되는 방식에 따라 달라 집니다. 부분 신뢰 (예를 들어 샌드 박싱된 응용 프로그램 도메인)에 로드 된 어셈블리가 있으면 런타임에서 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식 및 멤버에 동적 메서드를 포함 하 여 투명 하 게 처리 됩니다. 런타임은 부분 신뢰 어셈블리는 (예를 들어 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 완전히 신뢰 되어 로드 하는 경우에 보안 주석에 주의 유용 합니다. 이 경우 런타임에서 어셈블리의 주석이 따라 메서드에 대 한 기본 투명도 동적 메서드를 할당합니다.  
  
 리플렉션에 대 한 자세한 내용은 내보내기 및 참조 투명도 [리플렉션 내보내기의 보안 문제](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)합니다. 투명도 대 한 정보를 참조 하십시오. [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에는 메서드 본문이 없습니다.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 동적 메서드가 현재 신뢰 수준에서 투명하여 중요한 작업을 수행할 수 없는지를 나타내는 값을 가져옵니다.</summary>
        <value>동적 메서드가 현재 신뢰 수준에서 보안에 투명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> 속성 공용 언어 런타임 (CLR)에 의해 결정 된 동적 메서드의 투명도 수준을 보고 합니다. 다음 표에서 이러한 속성의 조합은 같습니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
 동적 메서드의 투명도와 연결 된 모듈에 따라 달라 집니다. 동적 메서드가 모듈 대신 형식와 관련이 있으면 투명도 유형을 포함 하는 모듈에 따라 달라 집니다. 연결 된 모듈에 대 한 기본 투명도 할당 된 동적 메서드 없으므로 보안 주석을 않습니다.  
  
-   익명으로 호스팅된 동적 메서드는 포함 하는 시스템 제공 모듈 투명 하기 때문에 투명 하 게 항상입니다.  
  
-   신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)와 연결 된 동적 메서드가의 투명도 다음 표에 설명 되어 있습니다.  
  
    |어셈블리 주석|수준 1 투명도|수준 2 투명도|  
    |-------------------------|--------------------------|--------------------------|  
    |완전히 투명 한|투명|투명|  
    |완전 하 게 중요 한|위험|위험|  
    |혼합 된 투명도|투명|투명|  
    |알 수 없는 보안|안전에 중요|위험|  
  
     예를 들어 2의 혼합된 투명도 수준에 mscorlib.dll에 있는 형식으로는 동적 메서드를 연결 하는 경우 동적 메서드는 투명 및 중요 한 코드를 실행할 수 없습니다. 투명도 수준에 대 한 정보를 참조 하십시오. [보안 투명 코드, 수준 1](~/docs/framework/misc/security-transparent-code-level-1.md) 및 [보안 투명 코드, 수준 2](~/docs/framework/misc/security-transparent-code-level-2.md)합니다.  
  
    > [!NOTE]
    >  동적 메서드는 보안에 종속 되지 않으므로, System.dll과 같이 신뢰할 수 있는 수준 1 어셈블리에 모듈에 연결 하는 신뢰 권한 상승이 허용 하지 않습니다. 동적 메서드를 호출 하는 코드의 권한 부여 집합 (즉, 완전 신뢰), System.dll의 권한 부여 집합을 포함 되지 않은 경우 <xref:System.Security.SecurityException> 동적 메서드를 호출할 때 throw 됩니다.  
  
-   부분적으로 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드가의 투명도 어셈블리가 로드 되는 방식에 따라 달라 집니다. 부분 신뢰 (예를 들어 샌드 박싱된 응용 프로그램 도메인)에 로드 된 어셈블리가 있으면 런타임에서 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식 및 멤버에 동적 메서드를 포함 하 여 투명 하 게 처리 됩니다. 런타임은 부분 신뢰 어셈블리는 (예를 들어 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 완전히 신뢰 되어 로드 하는 경우에 보안 주석에 주의 유용 합니다. 이 경우 런타임에서 어셈블리의 주석이 따라 메서드에 대 한 기본 투명도 동적 메서드를 할당합니다.  
  
 리플렉션에 대 한 자세한 내용은 내보내기 및 참조 투명도 [리플렉션 내보내기의 보안 문제](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)합니다. 투명도 대 한 정보를 참조 하십시오. [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에는 메서드 본문이 없습니다.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드에는 지원되지 않습니다.</summary>
        <value>동적 메서드에는 지원되지 않습니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에는 허용되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드가 논리적으로 연결되는 모듈을 가져옵니다.</summary>
        <value>현재 동적 메서드가 연결된 <see cref="T:System.Reflection.Module" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모듈에 동적 메서드를 만들 때 지정 된 경우이 속성이 해당 모듈을 반환 합니다. 동적 메서드를 만들 때 소유자로 형식이 지정 된,이 속성 해당 형식의 포함 된 모듈을 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Reflection.Emit.DynamicMethod.Module%2A> 동적 메서드의 속성입니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드의 이름입니다.</summary>
        <value>메서드의 단순한 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  동적 메서드 이름 필요는 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드 이름을 표시합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드를 얻기 위해 리플렉션에 사용된 클래스를 가져옵니다.</summary>
        <value>항상 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 항상 반환 `null` 동적 메서드에 대 한 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 리플렉션된 형식과 동적 메서드를 표시합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드의 반환 매개 변수를 가져옵니다.</summary>
        <value>항상 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 항상 반환 `null` 동적 메서드에 대 한 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드에 대한 반환 값 형식을 가져옵니다.</summary>
        <value>현재 메서드의 반환 값 형식을 나타내는 <see cref="T:System.Type" />입니다. 메서드에 반환 형식이 없으면 <see cref="T:System.Void" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `null` 이 속성은 반환 된 동적 메서드를 만들 때 반환 형식에 지정 된 <xref:System.Void?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드의 반환 형식을 표시합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드에 대한 반환 형식의 사용자 지정 특성을 가져옵니다.</summary>
        <value>동적 메서드의 반환 형식에 대한 사용자 지정 특성을 나타내는 <see cref="T:System.Reflection.ICustomAttributeProvider" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 특성의 배열 반환 하므로 동적 메서드의 반환 형식에 사용자 지정 특성이 지원 되지 않습니다는 <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> 메서드는 항상 비어 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드의 반환 형식의 사용자 지정 특성을 표시 하는 방법을 보여 줍니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>문자열로 표현된 메서드의 서명을 반환합니다.</summary>
        <returns>메서드 시그니처를 나타내는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서명이 있는 경우 형식과 메서드 이름, 포함 됩니다. 매개 변수 이름은 포함 되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> 동적 메서드의 메서드. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>