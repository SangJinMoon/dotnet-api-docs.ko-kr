<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DynamicMethod.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5862a235668e7e4b96457329cbd2f33598707245d.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">862a235668e7e4b96457329cbd2f33598707245d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Defines and represents a dynamic method that can be compiled, executed, and discarded.</source>
          <target state="translated">컴파일, 실행 및 삭제할 수 있는 동적 메서드를 정의하고 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Discarded methods are available for garbage collection.</source>
          <target state="translated">삭제된 메서드는 가비지 수집에 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class to generate and execute a method at run time, without having to generate a dynamic assembly and a dynamic type to contain the method.</source>
          <target state="translated">사용할 수는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스가 생성 하는 메서드를 포함 하는 동적 어셈블리 및 동적 형식을 생성 하지 않고 실행 시 메서드를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The executable code created by the just-in-time (JIT) compiler is reclaimed when the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> object is reclaimed.</source>
          <target state="translated">실행 시간 (JIT) 컴파일러에서 만든 코드 회수 될 때는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 개체를 회수 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Dynamic methods are the most efficient way to generate and execute small amounts of code.</source>
          <target state="translated">동적 메서드 생성 하 고 적은 양의 코드를 실행 하는 가장 효율적인 방법은 됩니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method can be anonymously hosted, or it can belogically associated with a module or with a type.</source>
          <target state="translated">동적 메서드가 익명으로 호스팅할 수 있습니다 또는 관련 된 모듈 형식 belogically 수 있습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the dynamic method is anonymously hosted, it is located in a system-provided assembly, and therefore is isolated from other code.</source>
          <target state="translated">동적 메서드가 익명으로 호스팅된 시스템에서 제공한 어셈블리에 있으며 따라서은 다른 코드에서 격리 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>By default, it does not have access to any non-public data.</source>
          <target state="translated">기본적으로 public이 아닌 데이터에 액세스할 수 없는 것입니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>An anonymously hosted dynamic method can have restricted ability to skip the JIT compiler's visibility checks, if it has been granted <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">익명으로 호스팅된 동적 메서드는 부여 된 경우 JIT 컴파일러의 가시성 검사를 건너뛰는 기능을 제한 될 수 있습니다 <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The trust level of the assembly whose non-public members are accessed by the dynamic method must be equal to, or a subset of, the trust level of the call stack that emitted the dynamic method.</source>
          <target state="translated">인 public이 아닌 멤버에 동적 메서드에서 액세스 하는 어셈블리의 신뢰 수준에는 다음과 같은 경우, 또는 동적 메서드를 내보내는 호출 스택의 트러스트 수준의 하위 집합 이어야 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>For more information about anonymously hosted dynamic methods, see <bpt id="p1">[</bpt>Walkthrough: Emitting Code in Partial Trust Scenarios<ept id="p1">](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)</ept>.</source>
          <target state="translated">익명으로 호스팅된 동적 메서드에 대 한 자세한 내용은 참조 <bpt id="p1">[</bpt>연습: 부분 신뢰 시나리오에서 코드 내보내기<ept id="p1">](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the dynamic method is associated with a module that you specify, the dynamic method is effectively global to that module.</source>
          <target state="translated">동적 메서드를 지정 하는 모듈에 연결 된 경우에 동적 메서드는 해당 모듈에 효과적으로 전역 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>It can access all types in the module and all <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of the types.</source>
          <target state="translated">모듈의 모든 형식 및 모든 액세스할 수 <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> Visual basic에서) 형식의 멤버입니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can associate a dynamic method with any module, regardless of whether you created the module, provided that a demand for <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> flag can be satisfied by the call stack that includes your code.</source>
          <target state="translated">동적 연결할 수 있습니다에 대 한 요청 하는 메서드는 모듈을 만들었는지 여부에 관계 없이 모든 모듈과 함께 제공 <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> 코드를 포함 하는 호출 스택에서 플래그를 충족할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag is included in the grant, the dynamic method can skip the JIT compiler's visibility checks and access the private data of all types declared in the module or in any other module in any assembly.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> 권한 부여에 플래그가 포함 되, 동적 메서드가 JIT 컴파일러의 가시성 검사를 생략 하 고 모든 어셈블리에 있는 다른 모듈에서 모듈에 선언 된 모든 종류의 개인 데이터에 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>When you specify the module with which a dynamic method is associated, that module must not be in the system-provided assembly that is used for anonymous hosting.</source>
          <target state="translated">동적 메서드가 연결 된 모듈을 지정 하면 해당 모듈에서 익명 호스팅에 사용 되는 시스템에서 제공한 어셈블리 수 없습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the dynamic method is associated with a type that you specify, it has access to all members of the type, regardless of access level.</source>
          <target state="translated">동적 메서드를 지정 하는 형식과 연결 된 경우에 형식의 모든 멤버에 대 한 액세스 액세스 수준에 관계 없이 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>In addition, JIT visibility checks can be skipped.</source>
          <target state="translated">또한 JIT 가시성 검사를 건너뛸 수 있습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This gives the dynamic method access to the private data of other types declared in the same module or in any other module in any assembly.</source>
          <target state="translated">모든 어셈블리에 있는 다른 모듈에서 동일한 모듈에 선언 된 다른 종류의 개인 데이터에 동적 메서드에 액세스할을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can associate a dynamic method with any type, but your code must be granted <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with both the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> flags.</source>
          <target state="translated">모든 형식에 동적 메서드를 연결할 수 있지만 사용자 코드에 부여 되어야 <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 둘 다와 함께 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following table shows which types and members are accessible to an anonymously hosted dynamic method, with and without JIT visibility checks, depending on whether <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> flag is granted.</source>
          <target state="translated">다음 표에 나와 있는 유형 및 멤버는 익명으로 호스팅된 동적 메서드를와 사용 여부에 따라 JIT 가시성 검사를 하지 않는 액세스할 수 있는 <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> 플래그 권한이 부여 됩니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Without <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph>를 사용하지 않는 경우</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>With <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph>과 함께</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Without skipping JIT visibility checks</source>
          <target state="translated">JIT 표시 유형 확인을 생략할 필요 없이</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">모든 어셈블리에 있는 public 형식의 public 멤버입니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">모든 어셈블리에 있는 public 형식의 public 멤버입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Skipping JIT visibility checks, with restrictions</source>
          <target state="translated">건너뛴 JIT 가시성 검사를 제한적으로</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">모든 어셈블리에 있는 public 형식의 public 멤버입니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of all types, only in assemblies whose trust levels are equal to or less than the trust level of the assembly that emitted the dynamic method.</source>
          <target state="translated">동적 메서드를 내보내는 어셈블리의 신뢰 수준 보다 작은 해당 신뢰 수준이 어셈블리에만 모든 형식의 모든 멤버입니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Prior to the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, emitting code required <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">이전에 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, 필요한 코드를 내보내거나 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This permission is included by default in the FullTrust and LocalIntranet named permission sets, but not in the Internet permission set.</source>
          <target state="translated">FullTrust 및 명명 된 권한 집합 LocalIntranet에 기본적으로이 권한이 포함 되어 있지만 인터넷 권한 집합입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Therefore, in earlier versions of the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> a library can be used with Internet permissions only if it has the <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> attribute and also executes an <ph id="ph3">&lt;xref:System.Security.PermissionSet.Assert%2A&gt;</ph> for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>.</source>
          <target state="translated">따라서 이전 버전의에서 <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> 은 경우에 인터넷 권한이 있는 라이브러리를 사용할 수는 <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> 특성을 실행 한 <ph id="ph3">&lt;xref:System.Security.PermissionSet.Assert%2A&gt;</ph> 에 대 한 <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Such libraries require careful security review because coding errors could result in security holes.</source>
          <target state="translated">코딩 오류가 있을 경우 보안 허점이 발생할 수 있으므로 이러한 라이브러리는 신중한 보안 검토가 필요합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph> allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>에서는 코드 생성이 기본적으로 권한 있는 작업이 아니기 때문에 보안 요구를 실행하지 않고 부분 신뢰 시나리오에서 코드를 내보낼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>That is, the generated code has no more permissions than the assembly that emits it.</source>
          <target state="translated">즉, 생성된 코드에 코드를 내보내는 어셈블리보다 많은 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This allows libraries that emit code to be security transparent and removes the need to assert <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>, which simplifies the task of writing a secure library.</source>
          <target state="translated">따라서 코드를 내보내는 라이브러리가 보안상 투명할 수 있으며 <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>를 어설션할 필요가 없으므로 보안 라이브러리 작성 작업이 간소화됩니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>To use this feature, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 기능을 사용 하려면 응용 프로그램이 대상 해야는 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following table shows which types and members are accessible to a dynamic method that is associated with a module or with a type in a module.</source>
          <target state="translated">다음 표에 나와 있는 유형 및 멤버는 모듈 또는 모듈의 형식은와 관련 되는 동적 메서드를 액세스할 수입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Associated with module</source>
          <target state="translated">모듈에 연결 된</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Associated with type</source>
          <target state="translated">형식과 연결 된</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Without skipping JIT visibility checks</source>
          <target state="translated">JIT 표시 유형 확인을 생략할 필요 없이</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public and internal members of public, internal, and private types in the module.</source>
          <target state="translated">모듈에 있는 공개, 내부 및 개인 형식의 public 및 내부 멤버입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">모든 어셈블리에 있는 public 형식의 public 멤버입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of the associated type.</source>
          <target state="translated">연결 된 형식의 모든 멤버입니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public and internal members of all the other types in the module.</source>
          <target state="translated">모듈의 다른 모든 종류의 public 및 내부 멤버입니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">모든 어셈블리에 있는 public 형식의 public 멤버입니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Skipping JIT visibility checks</source>
          <target state="translated">JIT 가시성 검사를 건너뛰는 중</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of all types in any assembly.</source>
          <target state="translated">모든 어셈블리에 있는 모든 형식의 모든 멤버입니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of all types in any assembly.</source>
          <target state="translated">모든 어셈블리에 있는 모든 형식의 모든 멤버입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method that is associated with a module has the permissions of that module.</source>
          <target state="translated">모듈과 연결 되는 동적 메서드에 해당 모듈의 권한이 있습니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method that is associated with a type has the permissions of the module containing that type.</source>
          <target state="translated">형식에 연결 되는 동적 메서드에 해당 형식이 포함 된 모듈의 권한이 있습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Dynamic methods and their parameters do not have to be named, but you can specify names to assist in debugging.</source>
          <target state="translated">동적 메서드 및 매개 변수 이름을 지정 하지 않아도 되지만 디버깅을 돕기 위해 이름을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Custom attributes are not supported on dynamic methods or their parameters.</source>
          <target state="translated">동적 메서드 또는 매개 변수에서 사용자 지정 특성이 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Although dynamic methods are <ph id="ph1">`static`</ph> methods (<ph id="ph2">`Shared`</ph> methods in Visual Basic), the relaxed rules for delegate binding introduced in the <ph id="ph3">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> allow a dynamic method to be bound to an object, so that it acts like an instance method when called using that delegate instance.</source>
          <target state="translated">동적 메서드는 <ph id="ph1">`static`</ph> 메서드 (<ph id="ph2">`Shared`</ph> Visual Basic의 메서드), 여에서 도입 된 대리자 바인딩 규칙을 완화는 <ph id="ph3">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> 인스턴스 메서드처럼 작동할 수 있도록 동적 메서드를 개체에 바인딩할 수 있도록 때 해당 대리자 인스턴스를 사용 하 여 호출 합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>An example that demonstrates this is provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> method overload.</source>
          <target state="translated">이 보여 주는 예제는 제공 된 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> 메서드 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, dynamic methods do not support symbol information, that is, local variable names and line-number mapping.</source>
          <target state="translated">에 <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, 기호 정보를, 지역 변수 이름 및 줄 번호 매핑 동적 메서드를 지원 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This limitation might be removed in a future version.</source>
          <target state="translated">이 제한 사항은 이후 버전에서 제거 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can use <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> during development to simplify debugging the generated Microsoft intermediate language (MSIL), and then switch to dynamic methods during final deployment, because the <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> calls are the same in both cases.</source>
          <target state="translated">사용할 수 있습니다 <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> 개발 하는 생성 된 Microsoft 중간 언어 (MSIL) 디버깅을 간소화 하기 때문에 동적 메서드를 최종 배포 하는 동안 다음 전환 하는 동안는 <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> 호출 두 경우 모두에서 동일 합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Verification</source>
          <target state="translated">확인</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following list summarizes the conditions under which dynamic methods can contain unverifiable code.</source>
          <target state="translated">다음 목록에는 동적 메서드는 확인할 수 없는 코드를 포함할 수는 조건을 요약 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>(For example, a dynamic method is unverifiable if its <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.)</source>
          <target state="translated">(동적 메서드를 확인할 수 없는 예를 들어 경우 해당 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> 속성이 <ph id="ph2">`false`</ph>.)</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method that is associated with a security-critical assembly is also security-critical, and can skip verification.</source>
          <target state="translated">보안에 중요 한 어셈블리와 연결 된 동적 메서드가 보안에 중요 한 되며 확인을 건너뛸 수 있습니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>For example, an assembly without security attributes that is run as a desktop application is treated as security-critical by the runtime.</source>
          <target state="translated">예를 들어 데스크톱 응용 프로그램으로 실행 하는 보안 특성이 없는 어셈블리는 런타임에서 보안에 중요로 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If you associate a dynamic method with the assembly, the dynamic method can contain unverifiable code.</source>
          <target state="translated">동적 메서드는 어셈블리와 연결 하는 경우 동적 메서드에 확인할 수 없는 코드를 포함할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If a dynamic method that contains unverifiable code is associated with an assembly that has level 1 transparency, the just-in-time (JIT) compiler injects a security demand.</source>
          <target state="translated">비안정형 코드를 포함 하는 동적 메서드는 수준 1 투명도 어셈블리와 관련이 있으면 적시에 (JIT) 컴파일러는 보안 요청을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The demand succeeds only if the dynamic method is executed by fully trusted code.</source>
          <target state="translated">요청에는 완전히 신뢰할 수 있는 코드에서 동적 메서드를 실행 하는 경우에 성공 합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>See <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept>.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>보안 투명 코드, 수준 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If a dynamic method that contains unverifiable code is associated with an assembly that has level 2 transparency (such as mscorlib.dll), it throws an exception (injected by the JIT compiler) instead of making a security demand.</source>
          <target state="translated">비안정형 코드를 포함 하는 동적 메서드 (예: mscorlib.dll) 수준 2 투명도 사용 하는 어셈블리와 관련이 있으면 보안 요청을 하는 대신 (JIT 컴파일러에 의해 삽입) 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>See <bpt id="p1">[</bpt>Security-Transparent Code, Level 2<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">참조 <bpt id="p1">[</bpt>보안 투명 코드, 수준 2<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>An anonymously hosted dynamic method that contains unverifiable code always throws an exception.</source>
          <target state="translated">항상 확인할 수 없는 코드를 포함 하는 익명으로 호스팅된 동적 메서드는 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>It can never skip verification, even if it is created and executed by fully trusted code.</source>
          <target state="translated">생성 되 고 완전히 신뢰할 수 있는 코드에서 실행 하는 경우에 확인을 생략할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The exception that is thrown for unverifiable code varies depending on the way the dynamic method is invoked.</source>
          <target state="translated">확인할 수 없는 코드에 대해 throw 되는 예외 동적 메서드가 호출 되는 방식에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If you invoke a dynamic method by using a delegate returned from the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method, a <ph id="ph2">&lt;xref:System.Security.VerificationException&gt;</ph> is thrown.</source>
          <target state="translated">반환 된 대리자를 사용 하 여 동적 메서드를 호출 하는 경우는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> 메서드를 한 <ph id="ph2">&lt;xref:System.Security.VerificationException&gt;</ph> throw 됩니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If you invoke the dynamic method by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, a <ph id="ph2">&lt;xref:System.Reflection.TargetInvocationException&gt;</ph> is thrown with an inner <ph id="ph3">&lt;xref:System.Security.VerificationException&gt;</ph>.</source>
          <target state="translated">사용 하 여 동적 메서드를 호출 하는 경우는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> 메서드를 한 <ph id="ph2">&lt;xref:System.Reflection.TargetInvocationException&gt;</ph> 는 내부 조인와 함께 발생 <ph id="ph3">&lt;xref:System.Security.VerificationException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">이 예제에서는 콘솔에 첫 번째 매개 변수를 출력 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">이 예제에서는 대리자를 만들어 메서드를 완료 합니다. 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Creates a dynamic method.</source>
          <target state="translated">동적 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>The name of the dynamic method.</source>
          <target state="translated">동적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 항목에는 빈 문자열을 지정할 수 있지만 <ph id="ph1">&lt;see langword="null" /&gt;</ph>은 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">동적 메서드의 반환 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체이거나, 메서드에 반환 형식이 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">동적 메서드의 매개 변수 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>Initializes an anonymously hosted dynamic method, specifying the method name, return type, and parameter types.</source>
          <target state="translated">메서드 이름, 반환 형식 및 매개 변수 형식을 지정하여 익명으로 호스팅된 동적 메서드를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>The dynamic method that is created by this constructor is associated with an anonymous assembly instead of an existing type or module.</source>
          <target state="translated">이 생성자에 의해 만들어진 동적 메서드는 기존 형식이 나 모듈 대신 익명 어셈블리와 연결 합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>The anonymous assembly exists only to provide a sandbox environment for dynamic methods, that is, to isolate them from other code.</source>
          <target state="translated">익명 어셈블리에만 동적 메서드에 대 한 샌드박스 환경 즉, 제공를 다른 코드에서 격리 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This environment makes it safe for the dynamic method to be emitted and executed by partially trusted code.</source>
          <target state="translated">이 환경에서는 동적 메서드를 내보내지고 부분적으로 신뢰할 수 있는 코드 실행에 대 한 안전 하 게 보호 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This constructor specifies that just-in-time (JIT) visibility checks will be enforced for the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">이 생성자는 (적시에 JIT) 가시성 검사를 Microsoft intermediate language (MSIL)에 대 한 적용 동적 메서드를 지정 합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>That is, the code in the dynamic method has access to public methods of public classes.</source>
          <target state="translated">즉, 동적 메서드의 코드에서에서 공용 클래스의 공용 메서드에 대 한 액세스를 있습니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>Exceptions are thrown if the method tries to access types or members that are <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, or <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">메서드가 형식 또는 멤버에 액세스 하려고 하는 경우 예외가 throw 됩니다 <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, 또는 <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> Visual basic에서).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>To create a dynamic method that has restricted ability to skip JIT visibility checks, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">JIT 가시성 검사를 건너뛰는 기능을 제한 된 동적 메서드를 만들려면 사용은 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29&gt;</ph> 생성자입니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>When an anonymously hosted dynamic method is constructed, the call stack of the emitting assembly is included.</source>
          <target state="translated">익명으로 호스팅된 동적 메서드를 생성 하는 경우 내보내는 어셈블리의 호출 스택이 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>When the method is invoked, the permissions of the emitting assembly are used instead of the permissions of the actual caller.</source>
          <target state="translated">메서드가 호출 되 면 내보내는 어셈블리의 권한이 실제 호출자의 권한 대신 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>Thus, the dynamic method cannot execute at a higher level of privilege than that of the assembly that emitted it, even if it is passed to and executed by an assembly that has a higher trust level.</source>
          <target state="translated">따라서 동적 메서드에 전달 되 고 더 높은 신뢰 수준에 있는 어셈블리에서 실행 하는 경우에 내보내는 어셈블리 보다 더 높은 수준의 권한에서 실행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This constructor specifies the method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and the calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">이 생성자 메서드 특성 지정 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, 호출 규칙 <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This constructor was introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 생성자는 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>의 요소는 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 또는 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph>은 <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph>가 <ph id="ph3">&lt;see langword="true" /&gt;</ph>를 반환하는 형식입니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">동적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 항목에는 빈 문자열을 지정할 수 있지만 <ph id="ph1">&lt;see langword="null" /&gt;</ph>은 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">동적 메서드의 반환 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체이거나, 메서드에 반환 형식이 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">동적 메서드의 매개 변수 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method, with this restriction: the trust level of the assemblies that contain those types and members must be equal to or less than the trust level of the call stack that emits the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에 대해 JIT 가시성 검사를 건너뛰려면(단, 이러한 형식과 멤버를 포함하는 어셈블리의 트러스트 수준이 동적 메서드를 내보내는 호출 스택의 트러스트 수준보다 작거나 같아야 한다는 제한이 적용되는 경우) <ph id="ph1">&lt;see langword="true" /&gt;</ph>이며, 건너뛰지 않으려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Initializes an anonymously hosted dynamic method, specifying the method name, return type, parameter types, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">메서드 이름, 반환 형식, 매개 변수 형식, 그리고 동적 메서드의 MSIL(Microsoft Intermediate Language)에서 액세스하는 형식 및 멤버에 대해 JIT(적시) 가시성 검사를 건너뛰어야 하는지 여부를 지정하는 익명으로 호스팅된 동적 메서드를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The dynamic method that is created by this constructor is associated with an anonymous assembly instead of an existing type or module.</source>
          <target state="translated">이 생성자에 의해 만들어진 동적 메서드는 기존 형식이 나 모듈 대신 익명 어셈블리와 연결 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The anonymous assembly exists only to provide a sandbox environment for dynamic methods, that is, to isolate them from other code.</source>
          <target state="translated">익명 어셈블리에만 동적 메서드에 대 한 샌드박스 환경 즉, 제공를 다른 코드에서 격리 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This environment makes it safe for the dynamic method to be emitted and executed by partially trusted code.</source>
          <target state="translated">이 환경에서는 동적 메서드를 내보내지고 부분적으로 신뢰할 수 있는 코드 실행에 대 한 안전 하 게 보호 합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Anonymously hosted dynamic methods do not have automatic access to any types or members that are <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, or <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">익명으로 호스팅된 동적 메서드 형식 또는 멤버에 자동으로 액세스할 필요가 없습니다 <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, 또는 <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> Visual basic에서).</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This is different from dynamic methods that are associated with an existing type or module, which have access to hidden members in their associated scope.</source>
          <target state="translated">이 해당 범위의 숨겨진된 멤버에 대 한 액세스를 포함 하는 기존 형식이 나 모듈을 연관 된 동적 메서드와에서 다릅니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Specify <ph id="ph1">`true`</ph> for <ph id="ph2">`restrictedSkipVisibility`</ph> if your dynamic method has to access types or members that are <ph id="ph3">`private`</ph>, <ph id="ph4">`protected`</ph>, or <ph id="ph5">`internal`</ph>.</source>
          <target state="translated">지정 <ph id="ph1">`true`</ph> 에 대 한 <ph id="ph2">`restrictedSkipVisibility`</ph> 형식 또는 멤버에 액세스 하 여 동적 메서드는 <ph id="ph3">`private`</ph>, <ph id="ph4">`protected`</ph>, 또는 <ph id="ph5">`internal`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This gives the dynamic method restricted access to these members.</source>
          <target state="translated">이러한 멤버에 제한 된 동적 메서드가 액세스할을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>That is, the members can be accessed only if the following conditions are met:</source>
          <target state="translated">즉, 멤버는 다음 조건이 충족 될 경우에 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The target members belong to an assembly that has a level of trust equal to or lower than the call stack that emits the dynamic method.</source>
          <target state="translated">대상 구성원이 동적 메서드를 내보내는 호출 스택의 보다 낮거나 같아야 신뢰 수준이 어셈블리에 속해 있습니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The call stack that emits the dynamic method is granted <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">동적 메서드를 내보내는 호출 스택의 부여 <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This is always true when the code is executed with full trust.</source>
          <target state="translated">이 항상 있을 경우 코드가 완전 신뢰로 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>For partially trusted code, it is true only if the host explicitly grants the permission.</source>
          <target state="translated">부분적으로 신뢰할 수 있는 코드는 호스트에 명시적으로 사용 권한을 부여 하는 경우에 true.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>If the permission has not been granted, a security exception is thrown when <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> is called or when the dynamic method is invoked, not when this constructor is called.</source>
          <target state="translated">보안 예외를 사용 하는 경우 throw 권한이 부여 되지 않은 경우 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> 라고 또는 동적 메서드가 호출 되 면 호출 되지 않는 경우이 생성자가 있습니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>No special permissions are required to emit the dynamic method.</source>
          <target state="translated">동적 메서드를 내보낼 수 없는 특별 한 권한이 필요 합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>For example, a dynamic method that is created with <ph id="ph1">`restrictedSkipVisibility`</ph> set to <ph id="ph2">`true`</ph> can access a private member of any assembly on the call stack if the call stack has been granted restricted member access.</source>
          <target state="translated">예를 들어는 동적 메서드를 사용 하 여 만든 <ph id="ph1">`restrictedSkipVisibility`</ph> 로 설정 <ph id="ph2">`true`</ph> 호출 스택을 제한 된 멤버 액세스 권한이 부여 된 경우 호출 스택에 있는 모든 어셈블리의 private 멤버에 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>If the dynamic method is created with partially trusted code on the call stack, it cannot access a private member of a type in a <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> assembly, because such assemblies are fully trusted.</source>
          <target state="translated">호출 스택에 부분적으로 신뢰할 수 있는 코드를 동적 메서드를 만드는 경우에 형식의 private 멤버에 액세스할 수 없습니다 것을 <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> 어셈블리는 완전히 신뢰할 수 있는 합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>If <ph id="ph1">`restrictedSkipVisibility`</ph> is <ph id="ph2">`false`</ph>, JIT visibility checks are enforced.</source>
          <target state="translated">경우 <ph id="ph1">`restrictedSkipVisibility`</ph> 은 <ph id="ph2">`false`</ph>, JIT 가시성 검사를 적용 합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The code in the dynamic method has access to public methods of public classes, and exceptions are thrown if it tries to access types or members that are <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, or <ph id="ph3">`internal`</ph>.</source>
          <target state="translated">동적 메서드의 코드에서에서 공용 클래스의 public 메서드에 액세스할 수 있고 되는 형식 또는 멤버에 액세스 하려고 시도 하면 예외가 throw 됩니다 <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, 또는 <ph id="ph3">`internal`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>When an anonymously hosted dynamic method is constructed, the call stack of the emitting assembly is included.</source>
          <target state="translated">익명으로 호스팅된 동적 메서드를 생성 하는 경우 내보내는 어셈블리의 호출 스택이 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>When the method is invoked, the permissions of the emitting call stack are used instead of the permissions of the actual caller.</source>
          <target state="translated">메서드가 호출 되 면 내보내는 호출 스택의 권한에 실제 호출자의 권한 대신 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Thus, the dynamic method cannot execute at a higher level of privilege than that of the assembly that emitted it, even if it is passed to and executed by an assembly that has a higher trust level.</source>
          <target state="translated">따라서 동적 메서드에 전달 되 고 더 높은 신뢰 수준에 있는 어셈블리에서 실행 하는 경우에 내보내는 어셈블리 보다 더 높은 수준의 권한에서 실행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This constructor specifies the method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and the calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">이 생성자 메서드 특성 지정 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, 호출 규칙 <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This constructor was introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">이 생성자는 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>의 요소는 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 또는 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph>은 <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph>가 <ph id="ph3">&lt;see langword="true" /&gt;</ph>를 반환하는 형식입니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The name of the dynamic method.</source>
          <target state="translated">동적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 항목에는 빈 문자열을 지정할 수 있지만 <ph id="ph1">&lt;see langword="null" /&gt;</ph>은 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">동적 메서드의 반환 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체이거나, 메서드에 반환 형식이 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">동적 메서드의 매개 변수 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> representing the module with which the dynamic method is to be logically associated.</source>
          <target state="translated">동적 메서드를 논리적으로 연결할 모듈을 나타내는 <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>Creates a dynamic method that is global to a module, specifying the method name, return type, parameter types, and module.</source>
          <target state="translated">메서드 이름, 반환 형식, 매개 변수 형식 및 모듈을 지정하여 모듈 전체에서 사용되는 동적 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>, and does not skip just-in-time (JIT) visibility checks.</source>
          <target state="translated">이 생성자 메서드 특성 지정 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, 호출 규칙 <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>, 및 (JIT) 가시성 검사를 건너뛰지 않습니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The dynamic method created with this constructor has access to public and <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of all the types contained in module <ph id="ph3">`m`</ph>.</source>
          <target state="translated">이 생성자를 사용 하 여 만든 동적 메서드가 public에 대 한 액세스 및 <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> Visual basic에서) 모듈에 포함 된 모든 형식의 멤버 <ph id="ph3">`m`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`m`</ph> is a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">이 생성자에 대 한 이전 버전과 호환성 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> 플래그를 모두 다음과 같은 경우 true: <ph id="ph3">`m`</ph> 는 호출 모듈과 수요 이외의 모듈 <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 실패 했습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">경우에 대 한 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 성공 하면이 작업은 허용 합니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>를이 멤버는 더 이상 필요 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션 내보내기의 보안 문제점<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) 이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">이 예제에서는 콘솔에 첫 번째 매개 변수를 출력 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> method.</source>
          <target state="translated">이 예제에서는 대리자를 만들어 메서드를 완료 합니다. 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>의 요소는 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 또는 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is a module that provides anonymous hosting for dynamic methods.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph>이 동적 메서드에 대한 익명 호스팅을 제공하는 모듈입니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph>은 <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph>가 <ph id="ph3">&lt;see langword="true" /&gt;</ph>를 반환하는 형식입니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>to associate the dynamic method with a module other than the calling module.</source>
          <target state="translated">모듈 호출 모듈이 이외의 동적 메서드를 연결 합니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The name of the dynamic method.</source>
          <target state="translated">동적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 항목에는 빈 문자열을 지정할 수 있지만 <ph id="ph1">&lt;see langword="null" /&gt;</ph>은 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">동적 메서드의 반환 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체이거나, 메서드에 반환 형식이 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">동적 메서드의 매개 변수 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with which the dynamic method is logically associated.</source>
          <target state="translated">동적 메서드가 논리적으로 연결되는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The dynamic method has access to all members of the type.</source>
          <target state="translated">동적 메서드에 해당 형식의 모든 멤버에 대한 액세스 권한이 있습니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Creates a dynamic method, specifying the method name, return type, parameter types, and the type with which the dynamic method is logically associated.</source>
          <target state="translated">메서드 이름, 반환 형식, 매개 변수 형식 및 동적 메서드가 논리적으로 연결된 형식을 지정하여 동적 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The dynamic method created with this constructor has access to all members of the type <ph id="ph1">`owner`</ph>, and to public and <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) members of all the other types in the module that contains <ph id="ph4">`owner`</ph>.</source>
          <target state="translated">이 생성자를 사용 하 여 만든 동적 메서드에 해당 형식의 모든 멤버에 대 한 액세스 권한이 <ph id="ph1">`owner`</ph>, 및 public로 및 <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> Visual basic에서)의 포함 된 모듈의 다른 모든 형식 멤버 <ph id="ph4">`owner`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>, and does not skip just-in-time (JIT) visibility checks.</source>
          <target state="translated">이 생성자 메서드 특성 지정 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, 호출 규칙 <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>, 및 (JIT) 가시성 검사를 건너뛰지 않습니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`owner`</ph> is in a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">이 생성자에 대 한 이전 버전과 호환성 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> 플래그를 모두 다음과 같은 경우 true: <ph id="ph3">`owner`</ph> 가 호출 모듈과 수요 아닌 모듈에 <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> 플래그에 실패 했습니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">경우에 대 한 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 성공 하면이 작업은 허용 합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>를이 멤버는 더 이상 필요 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션 내보내기의 보안 문제점<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) 이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The following code example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> that is logically associated with a type.</source>
          <target state="translated">다음 코드 예제에서는 한 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 형식으로 논리적으로 연결 합니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This association gives it access to the private members of that type.</source>
          <target state="translated">이 연결에 액세스할 해당 형식의 private 멤버입니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The code example defines a class named <ph id="ph1">`Example`</ph> with a private field, a class named <ph id="ph2">`DerivedFromxample`</ph> that derives from the first class, a delegate type named <ph id="ph3">`UseLikeStatic`</ph> that returns <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and has parameters of type <ph id="ph5">`Example`</ph> and <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, and a delegate type named <ph id="ph7">`UseLikeInstance`</ph> that returns <ph id="ph8">&lt;xref:System.Int32&gt;</ph> and has one parameter of type <ph id="ph9">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">라는 클래스를 정의 하는 코드 예제에서는 <ph id="ph1">`Example`</ph> 라는 클래스는 private 필드와 <ph id="ph2">`DerivedFromxample`</ph> 첫 번째 클래스에서 파생 된 이라는 대리자 형식을 <ph id="ph3">`UseLikeStatic`</ph> 반환 하는 <ph id="ph4">&lt;xref:System.Int32&gt;</ph> 형식의 매개 변수에 <ph id="ph5">`Example`</ph> 및 <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, 및 이라는 대리자 형식을 <ph id="ph7">`UseLikeInstance`</ph> 반환 하는 <ph id="ph8">&lt;xref:System.Int32&gt;</ph> 형식의 매개 변수가 하나 있으며 <ph id="ph9">&lt;xref:System.Int32&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The example code then creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> that changes the private field of an instance of <ph id="ph2">`Example`</ph> and returns the previous value.</source>
          <target state="translated">다음 예제 코드를 만듭니다는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 인스턴스의 private 필드를 변경 하는 <ph id="ph2">`Example`</ph> 이전 값을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>In general, changing the internal fields of classes is not good object-oriented coding practice.</source>
          <target state="translated">일반적으로 클래스의 내부 필드를 변경 합니다. 아닌 경우 좋은 개체 지향 코딩 사례</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The example code creates an instance of <ph id="ph1">`Example`</ph> and then creates two delegates.</source>
          <target state="translated">예제 코드의 인스턴스를 만들고 <ph id="ph1">`Example`</ph> 다음 두 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The first is of type <ph id="ph1">`UseLikeStatic`</ph>, which has the same parameters as the dynamic method.</source>
          <target state="translated">형식의 첫 번째는 <ph id="ph1">`UseLikeStatic`</ph>을 동적 방법으로 동일한 매개 변수가 있는 합니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The second is of type <ph id="ph1">`UseLikeInstance`</ph>, which lacks the first parameter (of type <ph id="ph2">`Example`</ph>).</source>
          <target state="translated">형식의 두 번째는 <ph id="ph1">`UseLikeInstance`</ph>, 첫 번째 매개 변수 부족 (형식의 <ph id="ph2">`Example`</ph>).</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This delegate is created using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> method overload; the second parameter of that method overload is an instance of <ph id="ph2">`Example`</ph>, in this case the instance just created, which is bound to the newly created delegate.</source>
          <target state="translated">이 대리자를 사용 하 여 만들어집니다는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> 메서드 오버 로드, 두 번째 해당 메서드 오버 로드의 매개 변수는 인스턴스의 <ph id="ph2">`Example`</ph>,이 경우에 새로 생성된 된 대리자에 바인딩된 인스턴스 방금 만든 합니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Whenever that delegate is invoked, the dynamic method acts on the bound instance of <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">바인딩된 인스턴스에 대해 동적 메서드는 작동 해당 대리자를 호출할 때마다 <ph id="ph1">`Example`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This is an example of the relaxed rules for delegate binding introduced in the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, along with new overloads of the <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">도입 된 대리자 바인딩이 이것이 완화 된 규칙의 예는 <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, 함께 새 오버 로드는 <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> 클래스를 참조하세요.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The <ph id="ph1">`UseLikeStatic`</ph> delegate is invoked, passing in the instance of <ph id="ph2">`Example`</ph> that is bound to the <ph id="ph3">`UseLikeInstance`</ph> delegate.</source>
          <target state="translated"><ph id="ph1">`UseLikeStatic`</ph> 대리자가 호출의 인스턴스를 전달 <ph id="ph2">`Example`</ph> 에 바인딩되는 <ph id="ph3">`UseLikeInstance`</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Then the <ph id="ph1">`UseLikeInstance`</ph> delegate is invoked, so that both delegates act on the same instance of <ph id="ph2">`Example`</ph>.</source>
          <target state="translated">그런 다음 <ph id="ph1">`UseLikeInstance`</ph> 두 대리자의 동일한 인스턴스에서 작동 되도록 대리자가 호출 <ph id="ph2">`Example`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The changes in the values of the internal field are displayed after each call.</source>
          <target state="translated">내부 필드의 값의 변동은 각 호출 후 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Finally, a <ph id="ph1">`UseLikeInstance`</ph> delegate is bound to an instance of <ph id="ph2">`DerivedFromxample`</ph>, and the delegate calls are repeated.</source>
          <target state="translated">마지막으로, 한 <ph id="ph1">`UseLikeInstance`</ph> 대리자 인스턴스에 바인딩되어 <ph id="ph2">`DerivedFromxample`</ph>, 대리자를 호출 하 여 반복 됩니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>의 요소는 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 또는 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph>가 인터페이스, 배열, 개방형 제네릭 형식, 제네릭 형식 또는 메서드의 형식 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, or is a type for which <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph>은 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이거나 <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph>가 <ph id="ph4">&lt;see langword="true" /&gt;</ph>를 반환하는 형식입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>to associate the dynamic method with a type in a module other than the calling module.</source>
          <target state="translated">호출 모듈이 이외의 모듈의 형식은와 동적 메서드를 연결 합니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">동적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 항목에는 빈 문자열을 지정할 수 있지만 <ph id="ph1">&lt;see langword="null" /&gt;</ph>은 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">동적 메서드의 반환 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체이거나, 메서드에 반환 형식이 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">동적 메서드의 매개 변수 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> representing the module with which the dynamic method is to be logically associated.</source>
          <target state="translated">동적 메서드를 논리적으로 연결할 모듈을 나타내는 <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method.</source>
          <target state="translated">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <ph id="ph1">&lt;see langword="true" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Creates a dynamic method that is global to a module, specifying the method name, return type, parameter types, module, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">모듈 전체에 적용되는 동적 메서드를 만들어 메서드 이름, 반환 형식, 매개 변수 형식, 모듈을 지정하고, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">이 생성자 메서드 특성 지정 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, 호출 규칙 및 <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The dynamic method created with this constructor has access to public and <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of all the types in contained module <ph id="ph3">`m`</ph>.</source>
          <target state="translated">이 생성자를 사용 하 여 만든 동적 메서드가 public에 대 한 액세스 및 <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> Visual basic에서) 포함 된 모듈에 있는 모든 형식의 멤버 <ph id="ph3">`m`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</source>
          <target state="translated">건너뛴 JIT 컴파일러의 가시성 검사 모든 다른 형식 에서도의 private 컨트롤과 protected 멤버에 액세스 동적 메서드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`m`</ph> is a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">이 생성자에 대 한 이전 버전과 호환성 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> 플래그를 모두 다음과 같은 경우 true: <ph id="ph3">`m`</ph> 는 호출 모듈과 수요 이외의 모듈 <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 실패 했습니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">경우에 대 한 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 성공 하면이 작업은 허용 합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>를이 멤버는 더 이상 필요 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션 내보내기의 보안 문제점<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) 이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>의 요소는 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 또는 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is a module that provides anonymous hosting for dynamic methods.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph>이 동적 메서드에 대한 익명 호스팅을 제공하는 모듈입니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph>은 <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph>가 <ph id="ph3">&lt;see langword="true" /&gt;</ph>를 반환하는 형식입니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>to associate the dynamic method with a module other than the calling module.</source>
          <target state="translated">모듈 호출 모듈이 이외의 동적 메서드를 연결 합니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">동적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 항목에는 빈 문자열을 지정할 수 있지만 <ph id="ph1">&lt;see langword="null" /&gt;</ph>은 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">동적 메서드의 반환 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체이거나, 메서드에 반환 형식이 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">동적 메서드의 매개 변수 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with which the dynamic method is logically associated.</source>
          <target state="translated">동적 메서드가 논리적으로 연결되는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method has access to all members of the type.</source>
          <target state="translated">동적 메서드에 해당 형식의 모든 멤버에 대한 액세스 권한이 있습니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그러지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Creates a dynamic method, specifying the method name, return type, parameter types, the type with which the dynamic method is logically associated, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">동적 메서드를 만들고, 메서드 이름, 반환 형식, 매개 변수 형식, 동적 메서드가 논리적으로 연결되는 형식, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method created with this constructor has access to all members of the type <ph id="ph1">`owner`</ph>, and to public and <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) members of all the other types in the module that contains <ph id="ph4">`owner`</ph>.</source>
          <target state="translated">이 생성자를 사용 하 여 만든 동적 메서드에 해당 형식의 모든 멤버에 대 한 액세스 권한이 <ph id="ph1">`owner`</ph>, 및 public로 및 <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> Visual basic에서)의 포함 된 모듈의 다른 모든 형식 멤버 <ph id="ph4">`owner`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</source>
          <target state="translated">건너뛴 JIT 컴파일러의 가시성 검사 모든 다른 형식 에서도의 private 컨트롤과 protected 멤버에 액세스 동적 메서드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">이 생성자 메서드 특성 지정 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, 호출 규칙 및 <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`owner`</ph> is in a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">이 생성자에 대 한 이전 버전과 호환성 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> 플래그를 모두 다음과 같은 경우 true: <ph id="ph3">`owner`</ph> 가 호출 모듈과 수요 아닌 모듈에 <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> 플래그에 실패 했습니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">경우에 대 한 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 성공 하면이 작업은 허용 합니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>를이 멤버는 더 이상 필요 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션 내보내기의 보안 문제점<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) 이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>의 요소는 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 또는 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph>가 인터페이스, 배열, 개방형 제네릭 형식, 제네릭 형식 또는 메서드의 형식 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, or is a type for which <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph>은 <ph id="ph2">&lt;see langword="null" /&gt;</ph>이거나 <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph>가 <ph id="ph4">&lt;see langword="true" /&gt;</ph>를 반환하는 형식입니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>to associate the dynamic method with a type in a module other than the calling module.</source>
          <target state="translated">호출 모듈이 이외의 모듈의 형식은와 동적 메서드를 연결 합니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">동적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 항목에는 빈 문자열을 지정할 수 있지만 <ph id="ph1">&lt;see langword="null" /&gt;</ph>은 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values that specifies the attributes of the dynamic method.</source>
          <target state="translated">동적 메서드의 특성을 지정하는 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The only combination allowed is <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">허용되는 유일한 조합은 <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The calling convention for the dynamic method.</source>
          <target state="translated">동적 메서드에 대한 호출 규칙입니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Must be <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>여야 합니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">동적 메서드의 반환 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체이거나, 메서드에 반환 형식이 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">동적 메서드의 매개 변수 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그러지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Creates a dynamic method that is global to a module, specifying the method name, attributes, calling convention, return type, parameter types, module, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">모듈 전체에 적용되는 동적 메서드를 만들어 메서드 이름, 특성, 호출 규칙, 반환 형식, 매개 변수 형식, 모듈을 지정하고, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The dynamic method created with this constructor has access to public and <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of all the public and internal types contained in module <ph id="ph3">`m`</ph>.</source>
          <target state="translated">이 생성자를 사용 하 여 만든 동적 메서드가 public에 대 한 액세스 및 <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> Visual basic에서) 모듈에 포함 된 모든 public 및 내부 형식 멤버 <ph id="ph3">`m`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types in the module and in all other assemblies as well.</source>
          <target state="translated">건너뛴 JIT 컴파일러의 가시성 검사 모듈 및 다른 모든 어셈블리에도 다른 모든 종류의 전용 및 보호 된 멤버에 액세스 동적 메서드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`m`</ph> is a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">이 생성자에 대 한 이전 버전과 호환성 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> 플래그를 모두 다음과 같은 경우 true: <ph id="ph3">`m`</ph> 는 호출 모듈과 수요 이외의 모듈 <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> 플래그 실패 했습니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">경우에 대 한 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 성공 하면이 작업은 허용 합니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>를이 멤버는 더 이상 필요 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션 내보내기의 보안 문제점<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) 이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>의 요소는 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 또는 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is a module that provides anonymous hosting for dynamic methods.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph>이 동적 메서드에 대한 익명 호스팅을 제공하는 모듈입니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> is a combination of flags other than <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph>는 <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> 및 <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph> 이외의 플래그 조합입니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph>이 <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>가 아닙니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph>은 <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph>가 <ph id="ph3">&lt;see langword="true" /&gt;</ph>를 반환하는 형식입니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>to associate the dynamic method with a module other than the calling module.</source>
          <target state="translated">모듈 호출 모듈이 이외의 동적 메서드를 연결 합니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">동적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">이 항목에는 빈 문자열을 지정할 수 있지만 <ph id="ph1">&lt;see langword="null" /&gt;</ph>은 지정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values that specifies the attributes of the dynamic method.</source>
          <target state="translated">동적 메서드의 특성을 지정하는 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The only combination allowed is <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">허용되는 유일한 조합은 <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The calling convention for the dynamic method.</source>
          <target state="translated">동적 메서드에 대한 호출 규칙입니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Must be <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>여야 합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">동적 메서드의 반환 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체이거나, 메서드에 반환 형식이 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">동적 메서드의 매개 변수 형식을 지정하는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with which the dynamic method is logically associated.</source>
          <target state="translated">동적 메서드가 논리적으로 연결되는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method has access to all members of the type.</source>
          <target state="translated">동적 메서드에 해당 형식의 모든 멤버에 대한 액세스 권한이 있습니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그러지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Creates a dynamic method, specifying the method name, attributes, calling convention, return type, parameter types, the type with which the dynamic method is logically associated, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">동적 메서드를 만들고, 메서드 이름, 특성, 호출 규칙, 반환 형식, 매개 변수 형식, 동적 메서드가 논리적으로 연결되는 형식, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method is global to the module that contains the type <ph id="ph1">`owner`</ph>.</source>
          <target state="translated">동적 메서드는 형식이 포함 된 모듈에 전역 <ph id="ph1">`owner`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>It has access to all members of the type <ph id="ph1">`owner`</ph>.</source>
          <target state="translated">형식의 모든 멤버에 액세스할 수 <ph id="ph1">`owner`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method created with this constructor has access to all members of the type <ph id="ph1">`owner`</ph>, and to public and <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) members of all the types contained in the module that contains <ph id="ph4">`owner`</ph>.</source>
          <target state="translated">이 생성자를 사용 하 여 만든 동적 메서드에 해당 형식의 모든 멤버에 대 한 액세스 권한이 <ph id="ph1">`owner`</ph>, 및 public로 및 <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> Visual basic에서) 포함 하는 모듈에 포함 된 모든 형식의 멤버 <ph id="ph4">`owner`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</source>
          <target state="translated">건너뛴 JIT 컴파일러의 가시성 검사 모든 다른 형식 에서도의 private 컨트롤과 protected 멤버에 액세스 동적 메서드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`owner`</ph> is in a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">이 생성자에 대 한 이전 버전과 호환성 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 와 <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> 플래그를 모두 다음과 같은 경우 true: <ph id="ph3">`owner`</ph> 가 호출 모듈과 수요 아닌 모듈에 <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> 플래그에 실패 했습니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">경우에 대 한 요구 <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> 성공 하면이 작업은 허용 합니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>를이 멤버는 더 이상 필요 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(참조 <bpt id="p1">[</bpt>리플렉션 내보내기의 보안 문제점<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) 이 기능을 사용하려면 응용 프로그램이 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 이상을 대상으로 해야 합니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>의 요소는 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 또는 <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph>가 인터페이스, 배열, 개방형 제네릭 형식, 제네릭 형식 또는 메서드의 형식 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> is a combination of flags other than <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph>는 <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> 및 <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph> 이외의 플래그 조합입니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph>이 <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>가 아닙니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph>은 <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph>가 <ph id="ph3">&lt;see langword="true" /&gt;</ph>를 반환하는 형식입니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>to associate the dynamic method with a type in a module other than the calling module.</source>
          <target state="translated">호출 모듈이 이외의 모듈의 형식은와 동적 메서드를 연결 합니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>Gets the attributes specified when the dynamic method was created.</source>
          <target state="translated">동적 메서드를 만들 때 지정된 특성을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values representing the attributes for the method.</source>
          <target state="translated">메서드의 특성을 나타내는 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>Currently, the method attributes for a dynamic method are always <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static&gt;</ph>.</source>
          <target state="translated">현재, 동적 메서드가 메서드 특성은 항상 <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>The following code example displays the method attributes of a dynamic method.</source>
          <target state="translated">다음 코드 예제에서는 동적 메서드의 메서드 특성을 표시합니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>Gets the calling convention specified when the dynamic method was created.</source>
          <target state="translated">동적 메서드를 만들 때 지정된 호출 규칙을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> values that indicates the calling convention of the method.</source>
          <target state="translated">메서드의 호출 규칙을 나타내는 <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> 값 중 하나입니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>Currently, the calling convention for a dynamic method is always <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard&gt;</ph>.</source>
          <target state="translated">현재, 동적 메서드의 호출 규칙은 항상 <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>The following code example displays the calling convention of a dynamic method.</source>
          <target state="translated">다음 코드 예제에서는 동적 메서드의 호출 규칙을 표시합니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Completes the dynamic method and creates a delegate that can be used to execute it.</source>
          <target state="translated">동적 메서드를 완료하고 실행하는 데 사용할 수 있는 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>A delegate type whose signature matches that of the dynamic method.</source>
          <target state="translated">서명이 동적 메서드의 서명과 일치하는 대리자 형식입니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>Completes the dynamic method and creates a delegate that can be used to execute it.</source>
          <target state="translated">동적 메서드를 완료하고 실행하는 데 사용할 수 있는 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>A delegate of the specified type, which can be used to execute the dynamic method.</source>
          <target state="translated">지정된 형식의 대리자로, 동적 메서드를 실행하는 데 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method completes the dynamic method.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> 메서드 또는 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> 메서드는 동적 메서드를 완료 합니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</source>
          <target state="translated">추가 매개 변수 정의 수정 하는 등 동적 메서드를 변경 하도록 또는 더 많은 Microsoft MSIL (intermediate language)을 표시 하 고는 무시 됩니다. 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>To create a method body for a dynamic method when you have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> object.</source>
          <target state="translated">동적 메서드의 메서드 본문을 만들려면 사용자 고유의 MSIL 생성기 있으면 호출는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> 를 얻는 메서드를 한 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>If you do not have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> method to obtain an <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> object that can be used to generate the method body.</source>
          <target state="translated">사용자 고유의 MSIL 생성기가 없는 경우 호출는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> 를 얻는 메서드를 한 <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> 메서드 본문을 생성 하는 데 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">이 예제에서는 콘솔에 첫 번째 매개 변수를 출력 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">이 예제에서는 대리자를 만들어 메서드를 완료 합니다. 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The dynamic method has no method body.</source>
          <target state="translated">동적 메서드에 메서드 본문이 없습니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph> has the wrong number of parameters or the wrong parameter types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph>의 매개 변수 개수가 잘못되었거나 매개 변수 유형이 잘못되었습니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>A delegate type whose signature matches that of the dynamic method, minus the first parameter.</source>
          <target state="translated">서명이 동적 메서드의 서명과 일치하는 대리자 형식에서 첫 번째 매개 변수를 뺀 값입니다.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>An object the delegate is bound to.</source>
          <target state="translated">대리자가 바인딩된 개체입니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Must be of the same type as the first parameter of the dynamic method.</source>
          <target state="translated">동적 메서드의 첫 번째 매개 변수와 동일한 형식이어야 합니다.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Completes the dynamic method and creates a delegate that can be used to execute it, specifying the delegate type and an object the delegate is bound to.</source>
          <target state="translated">동적 메서드를 완료하고 대리자 형식과 대리자가 바인딩되는 개체를 지정하여 해당 메서드를 실행하는 데 사용할 수 있는 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>A delegate of the specified type, which can be used to execute the dynamic method with the specified target object.</source>
          <target state="translated">지정된 형식의 대리자로, 지정된 대상 개체를 사용하여 동적 메서드를 실행하는 데 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This method overload creates a delegate bound to a particular object.</source>
          <target state="translated">이 메서드 오버 로드는 특정 개체에 바인딩된 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Such a delegate is said to be closed over its first argument.</source>
          <target state="translated">이러한 대리자는 첫 번째 인수에 대해 닫혀 라고 합니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Although the method is static, it acts as if it were an instance method; the instance is <ph id="ph1">`target`</ph>.</source>
          <target state="translated">마치; 인스턴스 메서드인 것 처럼 동작 메서드가 정적 이지만, 인스턴스가 <ph id="ph1">`target`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This method overload requires <ph id="ph1">`target`</ph> to be of the same type as the first parameter of the dynamic method, or to be assignable to that type (for example, a derived class).</source>
          <target state="translated">이 메서드 오버 로드 해야 <ph id="ph1">`target`</ph> 동적 메서드의 첫 번째 매개 변수로 동일한 형식이 되도록 하거나 해당 형식 (예를 들어 파생된 클래스)에 할당할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The signature of <ph id="ph1">`delegateType`</ph> has all the parameters of the dynamic method except the first.</source>
          <target state="translated">시그니처 <ph id="ph1">`delegateType`</ph> 동적 메서드의 첫 번째를 제외한 모든 매개 변수가 있습니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>For example, if the dynamic method has the parameters <ph id="ph1">&lt;xref:System.String&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and <ph id="ph3">&lt;xref:System.Byte&gt;</ph>, then <ph id="ph4">`delegateType`</ph> has the parameters <ph id="ph5">&lt;xref:System.Int32&gt;</ph> and <ph id="ph6">&lt;xref:System.Byte&gt;</ph>; <ph id="ph7">`target`</ph> is of type <ph id="ph8">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">예를 들어 동적 메서드에 매개 변수가 <ph id="ph1">&lt;xref:System.String&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.Byte&gt;</ph>, 다음 <ph id="ph4">`delegateType`</ph> 매개 변수에 <ph id="ph5">&lt;xref:System.Int32&gt;</ph> 및 <ph id="ph6">&lt;xref:System.Byte&gt;</ph>; <ph id="ph7">`target`</ph> 유형의 <ph id="ph8">&lt;xref:System.String&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method completes the dynamic method.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> 메서드 또는 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> 메서드는 동적 메서드를 완료 합니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</source>
          <target state="translated">추가 매개 변수 정의 수정 하는 등 동적 메서드를 변경 하도록 또는 더 많은 Microsoft MSIL (intermediate language)을 표시 하 고는 무시 됩니다. 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>To create a method body for a dynamic method when you have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> object.</source>
          <target state="translated">동적 메서드의 메서드 본문을 만들려면 사용자 고유의 MSIL 생성기 있으면 호출는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> 를 얻는 메서드를 한 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>If you do not have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> method to obtain an <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> object that can be used to generate the method body.</source>
          <target state="translated">사용자 고유의 MSIL 생성기가 없는 경우 호출는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> 를 얻는 메서드를 한 <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> 메서드 본문을 생성 하는 데 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The following code example creates delegate that binds a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> to an instance of a type, so that the method acts on the same instance each time it is invoked.</source>
          <target state="translated">다음 코드 예제에서는 대리자 바인딩하 만듭니다는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 형식의 인스턴스로 메서드가 될 때마다 동일한 인스턴스에서 작동할 수 있도록 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The code example defines a class named <ph id="ph1">`Example`</ph> with a private field, a class named <ph id="ph2">`DerivedFromxample`</ph> that derives from the first class, a delegate type named <ph id="ph3">`UseLikeStatic`</ph> that returns <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and has parameters of type <ph id="ph5">`Example`</ph> and <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, and a delegate type named <ph id="ph7">`UseLikeInstance`</ph> that returns <ph id="ph8">&lt;xref:System.Int32&gt;</ph> and has one parameter of type <ph id="ph9">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">라는 클래스를 정의 하는 코드 예제에서는 <ph id="ph1">`Example`</ph> 라는 클래스는 private 필드와 <ph id="ph2">`DerivedFromxample`</ph> 첫 번째 클래스에서 파생 된 이라는 대리자 형식을 <ph id="ph3">`UseLikeStatic`</ph> 반환 하는 <ph id="ph4">&lt;xref:System.Int32&gt;</ph> 형식의 매개 변수에 <ph id="ph5">`Example`</ph> 및 <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, 및 이라는 대리자 형식을 <ph id="ph7">`UseLikeInstance`</ph> 반환 하는 <ph id="ph8">&lt;xref:System.Int32&gt;</ph> 형식의 매개 변수가 하나 있으며 <ph id="ph9">&lt;xref:System.Int32&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The example code then creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> that changes the private field of an instance of <ph id="ph2">`Example`</ph> and returns the previous value.</source>
          <target state="translated">다음 예제 코드를 만듭니다는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 인스턴스의 private 필드를 변경 하는 <ph id="ph2">`Example`</ph> 이전 값을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>In general, changing the internal fields of classes is not good object-oriented coding practice.</source>
          <target state="translated">일반적으로 클래스의 내부 필드를 변경 합니다. 아닌 경우 좋은 개체 지향 코딩 사례</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The example code creates an instance of <ph id="ph1">`Example`</ph> and then creates two delegates.</source>
          <target state="translated">예제 코드의 인스턴스를 만들고 <ph id="ph1">`Example`</ph> 다음 두 대리자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The first is of type <ph id="ph1">`UseLikeStatic`</ph>, which has the same parameters as the dynamic method.</source>
          <target state="translated">형식의 첫 번째는 <ph id="ph1">`UseLikeStatic`</ph>을 동적 방법으로 동일한 매개 변수가 있는 합니다.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The second is of type <ph id="ph1">`UseLikeInstance`</ph>, which lacks the first parameter (of type <ph id="ph2">`Example`</ph>).</source>
          <target state="translated">형식의 두 번째는 <ph id="ph1">`UseLikeInstance`</ph>, 첫 번째 매개 변수 부족 (형식의 <ph id="ph2">`Example`</ph>).</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This delegate is created using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> method overload; the second parameter of that method overload is an instance of <ph id="ph2">`Example`</ph>, in this case the instance just created, which is bound to the newly created delegate.</source>
          <target state="translated">이 대리자를 사용 하 여 만들어집니다는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> 메서드 오버 로드, 두 번째 해당 메서드 오버 로드의 매개 변수는 인스턴스의 <ph id="ph2">`Example`</ph>,이 경우에 새로 생성된 된 대리자에 바인딩된 인스턴스 방금 만든 합니다.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Whenever that delegate is invoked, the dynamic method acts on the bound instance of <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">바인딩된 인스턴스에 대해 동적 메서드는 작동 해당 대리자를 호출할 때마다 <ph id="ph1">`Example`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This is an example of the relaxed rules for delegate binding introduced in the <ph id="ph1">[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]</ph>, along with new overloads of the <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">도입 된 대리자 바인딩이 이것이 완화 된 규칙의 예는 <ph id="ph1">[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]</ph>, 함께 새 오버 로드는 <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> 클래스를 참조하세요.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The <ph id="ph1">`UseLikeStatic`</ph> delegate is invoked, passing in the instance of <ph id="ph2">`Example`</ph> that is bound to the <ph id="ph3">`UseLikeInstance`</ph> delegate.</source>
          <target state="translated"><ph id="ph1">`UseLikeStatic`</ph> 대리자가 호출의 인스턴스를 전달 <ph id="ph2">`Example`</ph> 에 바인딩되는 <ph id="ph3">`UseLikeInstance`</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Then the <ph id="ph1">`UseLikeInstance`</ph> delegate is invoked, so that both delegates act on the same instance of <ph id="ph2">`Example`</ph>.</source>
          <target state="translated">그런 다음 <ph id="ph1">`UseLikeInstance`</ph> 두 대리자의 동일한 인스턴스에서 작동 되도록 대리자가 호출 <ph id="ph2">`Example`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The changes in the values of the internal field are displayed after each call.</source>
          <target state="translated">내부 필드의 값의 변동은 각 호출 후 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Finally, a <ph id="ph1">`UseLikeInstance`</ph> delegate is bound to an instance of <ph id="ph2">`DerivedFromxample`</ph>, and the delegate calls are repeated.</source>
          <target state="translated">마지막으로, 한 <ph id="ph1">`UseLikeInstance`</ph> 대리자 인스턴스에 바인딩되어 <ph id="ph2">`DerivedFromxample`</ph>, 대리자를 호출 하 여 반복 됩니다.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The dynamic method has no method body.</source>
          <target state="translated">동적 메서드에 메서드 본문이 없습니다.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not the same type as the first parameter of the dynamic method, and is not assignable to that type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph>이 동적 메서드의 첫 번째 매개 변수와 동일한 형식이 아니며 해당 형식에 할당할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph> has the wrong number of parameters or the wrong parameter types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph>의 매개 변수 개수가 잘못되었거나 매개 변수 유형이 잘못되었습니다.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>Gets the type that declares the method, which is always <ph id="ph1">&lt;see langword="null" /&gt;</ph> for dynamic methods.</source>
          <target state="translated">동적 메서드에 대해 항상 <ph id="ph1">&lt;see langword="null" /&gt;</ph>인 메서드를 선언하는 형식을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">항상 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>This property always returns <ph id="ph1">`null`</ph> for dynamic methods.</source>
          <target state="translated">이 속성은 항상 반환 <ph id="ph1">`null`</ph> 동적 메서드에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>Even when a dynamic method is logically associated with a type, it is not declared by the type.</source>
          <target state="translated">동적 메서드가 논리적으로 형식과 연결 인 경우에 형식에서 선언 되지 않았습니다.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>The following code example displays the declaring type of a dynamic method.</source>
          <target state="translated">다음 코드 예제에서는 동적 메서드의 선언 형식이 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The position of the parameter in the parameter list.</source>
          <target state="translated">매개 변수 목록에서 매개 변수의 위치입니다.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameters are indexed beginning with the number 1 for the first parameter.</source>
          <target state="translated">매개 변수가 첫 번째 매개 변수에 대한 숫자 1부터 시작해서 인덱싱됩니다.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterAttributes" /&gt;</ph> values that specifies the attributes of the parameter.</source>
          <target state="translated">매개 변수의 특성을 지정하는 <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterAttributes" /&gt;</ph> 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name of the parameter.</source>
          <target state="translated">매개 변수의 이름입니다.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name can be a zero-length string.</source>
          <target state="translated">이름은 빈 문자열일 수 있습니다.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Defines a parameter of the dynamic method.</source>
          <target state="translated">동적 메서드의 매개 변수를 정의합니다.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Always returns <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">항상 <ph id="ph1">&lt;see langword="null" /&gt;</ph>를 반환합니다.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>If <ph id="ph1">`position`</ph> is 0, the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> method refers to the return value.</source>
          <target state="translated">경우 <ph id="ph1">`position`</ph> 가 0 이면는 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> 메서드 반환 값을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Setting parameter information has no effect on the return value.</source>
          <target state="translated">매개 변수 정보 설정에 반환 값에 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>If the dynamic method has already been completed, by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, the <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> method has no effect.</source>
          <target state="translated">동적 메서드가 이미 완료 되었는지 여부를 호출 하 여는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> 메서드는 <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> 메서드는 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw되지 않습니다.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The following code example shows how to define parameter information for a dynamic method.</source>
          <target state="translated">다음 코드 예제에서는 동적 메서드에 대 한 매개 변수 정보를 정의 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The method has no parameters.</source>
          <target state="translated">메서드에 매개 변수가 없습니다.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph>가 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is greater than the number of the method's parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph>이 메서드의 매개 변수 수보다 큽니다.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition">
          <source>Returns the base implementation for the method.</source>
          <target state="translated">메서드에 대한 기본 구현을 반환합니다.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition">
          <source>The base implementation of the method.</source>
          <target state="translated">메서드의 기본 구현입니다.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition">
          <source>This method always returns the current <ph id="ph1">`DynamicMethod`</ph> object.</source>
          <target state="translated">이 메서드는 항상 현재 반환 <ph id="ph1">`DynamicMethod`</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Returns the custom attributes applied to the method.</source>
          <target state="translated">메서드에 적용된 사용자 지정 특성을 반환합니다.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search the method's inheritance chain to find the custom attributes; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to check only the current method.</source>
          <target state="translated">메서드의 상속 체인을 검색하여 사용자 지정 특성을 찾으려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 현재 메서드만 검사하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for the method.</source>
          <target state="translated">이 메서드에 대해 정의된 모든 사용자 지정 특성을 반환합니다.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>An array of objects representing all the custom attributes of the method.</source>
          <target state="translated">이 메서드의 모든 사용자 지정 특성을 나타내는 개체 배열입니다.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>For dynamic methods, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`inherit`</ph> has no effect, because the method is not declared in a type.</source>
          <target state="translated">지정 하는 동적 메서드에 대 한 <ph id="ph1">`true`</ph> 에 대 한 <ph id="ph2">`inherit`</ph> 메서드 형식에서 선언 되지 않았으므로 아무 효과가 있습니다.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>Custom attributes are not currently supported on dynamic methods.</source>
          <target state="translated">동적 메서드에 사용자 지정 특성이 현재 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>The only attribute returned is <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; you can get the method implementation flags more easily using the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> method.</source>
          <target state="translated">속성만 반환은 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; 얻을 수 있습니다 메서드 구현 플래그 사용 하 여 보다 쉽게는 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of custom attribute to return.</source>
          <target state="translated">반환할 사용자 지정 특성의 형식을 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search the method's inheritance chain to find the custom attributes; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to check only the current method.</source>
          <target state="translated">메서드의 상속 체인을 검색하여 사용자 지정 특성을 찾으려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 현재 메서드만 검사하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns the custom attributes of the specified type that have been applied to the method.</source>
          <target state="translated">메서드에 적용된 지정된 형식의 사용자 지정 특성을 반환합니다.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of objects representing the attributes of the method that are of type <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> or derive from type <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> 형식의 메서드 또는 <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> 형식에서 파생된 메서드의 특성을 나타내는 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>For dynamic methods, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`inherit`</ph> has no effect, because the method is not declared in a type.</source>
          <target state="translated">지정 하는 동적 메서드에 대 한 <ph id="ph1">`true`</ph> 에 대 한 <ph id="ph2">`inherit`</ph> 메서드 형식에서 선언 되지 않았으므로 아무 효과가 있습니다.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Custom attributes are not currently supported on dynamic methods.</source>
          <target state="translated">동적 메서드에 사용자 지정 특성이 현재 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The only attribute returned is <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; you can get the method implementation flags more easily using the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> method.</source>
          <target state="translated">속성만 반환은 <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; 얻을 수 있습니다 메서드 구현 플래그 사용 하 여 보다 쉽게는 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph> object that can be used to generate a method body from metadata tokens, scopes, and Microsoft intermediate language (MSIL) streams.</source>
          <target state="translated">메타데이터 토큰, 범위 및 MSIL(Microsoft Intermediate Language) 스트림에서 메서드 본문을 생성하는 데 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph> object that can be used to generate a method body from metadata tokens, scopes, and MSIL streams.</source>
          <target state="translated">메타데이터 토큰, 범위 및 MSIL 스트림에서 메서드 본문을 생성하는 데 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> class is provided to support unmanaged code generation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> 클래스는 관리 되지 않는 코드 생성을 지원 하기 위해 제공 됩니다.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>to execute unmanaged code.</source>
          <target state="translated">비관리 코드를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">연관된 열거형: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Returns an MSIL generator that can be used to emit a body for the dynamic method.</source>
          <target state="translated">동적 메서드의 본문을 내보내는 데 사용할 수 있는 MSIL 생성기를 반환합니다.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>Returns a Microsoft intermediate language (MSIL) generator for the method with a default MSIL stream size of 64 bytes.</source>
          <target state="translated">64바이트의 기본 MSIL(Microsoft Intermediate Language) 스트림 크기를 사용하는 메서드에 대한 MSIL 생성기를 반환합니다.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> object for the method.</source>
          <target state="translated">메서드에 대한 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>After a dynamic method has been completed, by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, any further attempt to add MSIL is ignored.</source>
          <target state="translated">동적 메서드가 완료 되 면 호출 하 여 후의 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> 메서드를 모두 추가 하려고 하면 MSIL은 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw되지 않습니다.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>There are restrictions on unverifiable code in dynamic methods, even in some full-trust scenarios.</source>
          <target state="translated">일부 완전 신뢰 시나리오에도 동적 메서드에 확인할 수 없는 코드에는 제한이 있습니다.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>에 대한 설명에서 "확인" 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">이 예제에서는 콘솔에 첫 번째 매개 변수를 출력 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">이 예제에서는 대리자를 만들어 메서드를 완료 합니다. 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>The size of the MSIL stream, in bytes.</source>
          <target state="translated">MSIL 스트림에 바이트의 크기입니다.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>Returns a Microsoft intermediate language (MSIL) generator for the method with the specified MSIL stream size.</source>
          <target state="translated">지정된 된 MSIL 스트림 크기를 사용하는 메서드에 대한 MSIL(Microsoft Intermediate Language) 생성기를 반환합니다.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> object for the method, with the specified MSIL stream size.</source>
          <target state="translated">지정된 MSIL 스트림 크기를 가진 메서드의 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>After a dynamic method has been completed, by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, any further attempt to add MSIL is ignored.</source>
          <target state="translated">동적 메서드가 완료 되 면 호출 하 여 후의 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> 메서드를 모두 추가 하려고 하면 MSIL은 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw되지 않습니다.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>There are restrictions on unverifiable code in dynamic methods, even in some full-trust scenarios.</source>
          <target state="translated">일부 완전 신뢰 시나리오에도 동적 메서드에 확인할 수 없는 코드에는 제한이 있습니다.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>에 대한 설명에서 "확인" 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>The following code example demonstrates this method overload.</source>
          <target state="translated">다음 코드 예제에서는이 메서드 오버 로드 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags">
          <source>Returns the implementation flags for the method.</source>
          <target state="translated">메서드에 대한 구현 플래그를 반환합니다.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> values representing the implementation flags for the method.</source>
          <target state="translated">메서드에 대한 구현 플래그를 나타내는 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags">
          <source>Currently, method implementation attributes for dynamic methods are always <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.IL&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.NoInlining&gt;</ph>.</source>
          <target state="translated">현재, 동적 메서드의 메서드 구현 특성은 항상 <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.IL&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.NoInlining&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>Returns the parameters of the dynamic method.</source>
          <target state="translated">동적 메서드의 매개 변수를 반환합니다.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> objects that represent the parameters of the dynamic method.</source>
          <target state="translated">동적 메서드의 매개 변수를 나타내는 <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> 개체의 배열입니다.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> objects returned by this method are for information only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> 이 메서드에 의해 반환 되는 개체는 정보 제공 용입니다.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> method to set or change the characteristics of the parameters.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> 메서드를 설정 하거나 매개 변수 특징을 변경 합니다.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>The following code example displays the parameters of a dynamic method.</source>
          <target state="translated">다음 코드 예제에서는 동적 메서드의 매개 변수를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>Gets or sets a value indicating whether the local variables in the method are zero-initialized.</source>
          <target state="translated">메서드의 로컬 변수가 0으로 초기화되었는지 여부를 나타내는 값을 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the local variables in the method are zero-initialized; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">메서드의 로컬 변수가 0으로 초기화되었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 초기화되지 않았으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">기본값은 <ph id="ph1">&lt;see langword="true" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>If this property is set to <ph id="ph1">`true`</ph>, the emitted Microsoft intermediate language (MSIL) includes initialization of local variables.</source>
          <target state="translated">이 속성은로 설정 하는 경우 <ph id="ph1">`true`</ph>, 내보낸된 Microsoft intermediate language (MSIL) 지역 변수 초기화를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>If it is set to <ph id="ph1">`false`</ph>, local variables are not initialized and the generated code is unverifiable.</source>
          <target state="translated">로 설정 되어 있으면 <ph id="ph1">`false`</ph>, 지역 변수는 초기화 되지 및 생성된 된 코드를 확인할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> property of a dynamic method.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> 동적 메서드의 속성입니다.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This parameter is ignored for dynamic methods, because they are static.</source>
          <target state="translated">이 매개 변수는 정적이기 때문에 동적 메서드에 대해 무시됩니다.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>을 지정합니다.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 값의 비트 조합입니다.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">리플렉션을 통해 바인딩, 인수 형식 강제 변환, 멤버 호출 및 <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> 개체의 검색을 가능하게 하는 <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>바인더<ept id="p1">&lt;/c&gt;</ept>가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이면 기본 바인더가 사용됩니다.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For more details, see <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>을 참조하십시오.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list.</source>
          <target state="translated">인수 목록입니다.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked.</source>
          <target state="translated">호출되는 메서드의 매개 변수와 숫자, 순서, 형식이 동일한 인수의 배열입니다.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters this parameter should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">매개 변수가 없는 경우 이 매개 변수는 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이어야 합니다.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">형식의 강제 변환을 제어하는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>의 인스턴스입니다.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">이 매개 변수가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>이면 현재 스레드에 대한 <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>가 사용됩니다.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, this information is needed to correctly convert a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> value, because 1000 is represented differently by different cultures.</source>
          <target state="translated">예를 들어, 1000은 각 문화권마다 다르게 표현되므로 1000을 나타내는 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>을 <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> 값으로 올바르게 변환하는 데 이 정보가 필요합니다.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Invokes the dynamic method using the specified parameters, under the constraints of the specified binder, with the specified culture information.</source>
          <target state="translated">지정된 문화권 정보를 사용하고 지정된 바인더의 제약 조건에 따라, 지정된 매개 변수를 사용하여 동적 메서드를 호출합니다.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> containing the return value of the invoked method.</source>
          <target state="translated">호출된 메서드의 반환 값이 들어 있는 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>In addition to the listed exceptions, the calling code should be prepared to catch any exceptions thrown by the dynamic method.</source>
          <target state="translated">나열 된 예외 뿐 아니라 동적 메서드에 의해 throw 된 예외를 catch을 호출 하는 코드를 준비 해야 합니다.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Executing a dynamic method with a delegate created by the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method is more efficient than executing it with the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">동적 메서드를 실행 하 여 만든 대리자와는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> 메서드를 실행할 때 보다 더 효율적입니다.는 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method completes the dynamic method.</source>
          <target state="translated">호출 된 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> 메서드 또는 <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> 메서드는 동적 메서드를 완료 합니다.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</source>
          <target state="translated">추가 매개 변수 정의 수정 하는 등 동적 메서드를 변경 하도록 또는 더 많은 Microsoft MSIL (intermediate language)을 표시 하 고는 무시 됩니다. 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>All dynamic methods are static, so the <ph id="ph1">`obj`</ph> parameter is always ignored.</source>
          <target state="translated">모든 동적 메서드는 정적 이므로 <ph id="ph1">`obj`</ph> 매개 변수는 항상 무시 됩니다.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To treat a dynamic method as if it were an instance method, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> overload that takes an object instance.</source>
          <target state="translated">인스턴스 메서드인 것 처럼 동적 메서드를 처리할 사용 된 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> 개체 인스턴스를 사용 하는 오버 로드 합니다.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the dynamic method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">동적 메서드의 매개 변수가 없는 경우, 값 <ph id="ph1">`parameters`</ph> 해야 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters of the dynamic method.</source>
          <target state="translated">그렇지 않으면 개수, 형식 및 매개 변수 배열에 있는 요소의 순서는 개수, 형식 및 동적 메서드의 매개 변수의 순서와 같아야 합니다.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method overload is called by the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29&gt;</ph> method overload inherited from the <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> class, so the preceding remarks apply to both overloads.</source>
          <target state="translated">이 메서드 오버 로드는 <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29&gt;</ph> 에서 상속 된 메서드 오버 로드는 <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> 클래스, 위에서 설명한 내용이 오버 로드 모두에 적용 합니다.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method does not demand permissions directly, but invoking the dynamic method can result in security demands, depending on the method.</source>
          <target state="translated">이 메서드는 권한이 직접 필요 하지 않지만 동적 메서드를 호출 하는 방법에 따라 보안 요구 사항을 충족에서 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, no demands are made for anonymously hosted dynamic methods that are created with the <ph id="ph1">`restrictedSkipVisibility`</ph> parameter set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">익명으로 호스팅된 동적 메서드를 사용 하 여 만든 필요 하지 않습니다는 원활 예를 들어는 <ph id="ph1">`restrictedSkipVisibility`</ph> 매개 변수 설정 <ph id="ph2">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>On the other hand, if you create a method with <ph id="ph1">`restrictedSkipVisibility`</ph> set to <ph id="ph2">`true`</ph> so it can access a hidden member of a target assembly, the method will cause a demand for the permissions of the target assembly plus <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">반면, 사용 하 여 메서드를 만들면 <ph id="ph1">`restrictedSkipVisibility`</ph> 로 설정 <ph id="ph2">`true`</ph> 메서드 더하기 대상 어셈블리의 사용 권한에 대 한 요청을 하면 대상 어셈블리의 숨겨진된 멤버를 액세스할 수 있도록 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Prior to the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method required <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> flag.</source>
          <target state="translated">이전에 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>를 요구 하는이 방법 <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> 와 <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> 플래그입니다.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The following code example invokes a dynamic method with exact binding, using the US-English culture.</source>
          <target state="translated">다음 코드 예제에서는 미국-영어 culture를 사용 하 여 정확한 바인딩으로 동적 메서드를 호출 합니다.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.VarArgs" /&gt;</ph> calling convention is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.VarArgs" /&gt;</ph> 호출 규칙이 지원되지 않는 경우</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> does not match the number of parameters in the dynamic method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameters" /&gt;</ph>에 있는 요소의 수가 동적 메서드에 있는 매개 변수의 수와 일치하지 않는 경우</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of one or more elements of <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> does not match the type of the corresponding parameter of the dynamic method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameters" /&gt;</ph>에 있는 하나 이상의 요소 형식이 동적 메서드에 있는 해당 매개 변수의 형식과 일치하지 않는 경우</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The dynamic method is associated with a module, is not anonymously hosted, and was constructed with <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph> set to <ph id="ph2">&lt;see langword="false" /&gt;</ph>, but the dynamic method accesses members that are not <ph id="ph3">&lt;see langword="public" /&gt;</ph> or <ph id="ph4">&lt;see langword="internal" /&gt;</ph> (<ph id="ph5">&lt;see langword="Friend" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">동적 메서드를 모듈과 연결했고 익명으로 호스팅하지 않았으며 이를 생성할 때 <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph>를 <ph id="ph2">&lt;see langword="false" /&gt;</ph>로 설정했지만 이 동적 메서드에서 <ph id="ph3">&lt;see langword="public" /&gt;</ph> 또는 <ph id="ph4">&lt;see langword="internal" /&gt;</ph>(Visual Basic의 경우 <ph id="ph5">&lt;see langword="Friend" /&gt;</ph>)이 아닌 멤버에 액세스하는 경우</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The dynamic method is anonymously hosted and was constructed with <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph> set to <ph id="ph2">&lt;see langword="false" /&gt;</ph>, but it accesses members that are not <ph id="ph3">&lt;see langword="public" /&gt;</ph>.</source>
          <target state="translated">동적 메서드를 익명으로 호스팅했고 이를 생성할 때 <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph>를 <ph id="ph2">&lt;see langword="false" /&gt;</ph>로 설정했지만 이 동적 메서드에서 <ph id="ph3">&lt;see langword="public" /&gt;</ph>이 아닌 멤버에 액세스하는 경우</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The dynamic method contains unverifiable code.</source>
          <target state="translated">동적 메서드에 확인할 수 없는 코드가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>에 대한 설명에서 "확인" 섹션을 참조하세요.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of custom attribute to search for.</source>
          <target state="translated">검색할 사용자 지정 특성의 형식을 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search the method's inheritance chain to find the custom attributes; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to check only the current method.</source>
          <target state="translated">메서드의 상속 체인을 검색하여 사용자 지정 특성을 찾으려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 현재 메서드만 검사하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>Indicates whether the specified custom attribute type is defined.</source>
          <target state="translated">지정된 사용자 지정 특성 유형이 정의되었는지 여부를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified custom attribute type is defined; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">지정된 사용자 지정 특성 형식이 정의되어 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>For dynamic methods, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`inherit`</ph> has no effect.</source>
          <target state="translated">지정 하는 동적 메서드에 대 한 <ph id="ph1">`true`</ph> 에 대 한 <ph id="ph2">`inherit`</ph> 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>Dynamic methods have no inheritance chain.</source>
          <target state="translated">동적 메서드는 상속 체인에 없습니다.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>Custom attributes are not currently supported on dynamic methods.</source>
          <target state="translated">동적 메서드에 사용자 지정 특성이 현재 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Gets a value that indicates whether the current dynamic method is security-critical or security-safe-critical, and therefore can perform critical operations.</source>
          <target state="translated">현재 동적 메서드가 보안에 중요하거나 보안 안전에 중요하여 중요한 작업을 수행할 수 있는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current dynamic method is security-critical or security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated">현재 동적 메서드가 보안에 중요한 형식이거나 보안 안전에 중요한 형식이면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 투명 형식이면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> 속성 공용 언어 런타임 (CLR)에 의해 결정 된 동적 메서드의 투명도 수준을 보고 합니다.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">다음 표에서 이러한 속성의 조합은 같습니다.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">보안 수준</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">안전 중요</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The transparency of a dynamic method depends on the module it is associated with.</source>
          <target state="translated">동적 메서드의 투명도와 연결 된 모듈에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</source>
          <target state="translated">동적 메서드가 모듈 대신 형식와 관련이 있으면 투명도 유형을 포함 하는 모듈에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</source>
          <target state="translated">연결 된 모듈에 대 한 기본 투명도 할당 된 동적 메서드 없으므로 보안 주석을 않습니다.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</source>
          <target state="translated">익명으로 호스팅된 동적 메서드는 포함 하는 시스템 제공 모듈 투명 하기 때문에 투명 하 게 항상입니다.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</source>
          <target state="translated">신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)와 연결 된 동적 메서드가의 투명도 다음 표에 설명 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Assembly annotation</source>
          <target state="translated">어셈블리 주석</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Level 1 transparency</source>
          <target state="translated">수준 1 투명도</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Level 2 transparency</source>
          <target state="translated">수준 2 투명도</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Fully transparent</source>
          <target state="translated">완전히 투명 한</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Fully critical</source>
          <target state="translated">완전 하 게 중요 한</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Mixed transparency</source>
          <target state="translated">혼합 된 투명도</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Security-agnostic</source>
          <target state="translated">알 수 없는 보안</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Safe-critical</source>
          <target state="translated">안전에 중요</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</source>
          <target state="translated">예를 들어 2의 혼합된 투명도 수준에 mscorlib.dll에 있는 형식으로는 동적 메서드를 연결 하는 경우 동적 메서드는 투명 및 중요 한 코드를 실행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For information about transparency levels, see <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> and <bpt id="p2">[</bpt>Security-Transparent Code, Level 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">투명도 수준에 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>보안 투명 코드, 수준 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> 및 <bpt id="p2">[</bpt>보안 투명 코드, 수준 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</source>
          <target state="translated">동적 메서드는 보안에 종속 되지 않으므로, System.dll과 같이 신뢰할 수 있는 수준 1 어셈블리에 모듈에 연결 하는 신뢰 권한 상승이 허용 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the dynamic method is called.</source>
          <target state="translated">동적 메서드를 호출 하는 코드의 권한 부여 집합 (즉, 완전 신뢰), System.dll의 권한 부여 집합을 포함 되지 않은 경우 <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> 동적 메서드를 호출할 때 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</source>
          <target state="translated">부분적으로 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드가의 투명도 어셈블리가 로드 되는 방식에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">부분 신뢰 (예를 들어 샌드 박싱된 응용 프로그램 도메인)에 로드 된 어셈블리가 있으면 런타임에서 어셈블리의 보안 주석을 무시 합니다.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The assembly and all its types and members, including dynamic methods, are treated as transparent.</source>
          <target state="translated">어셈블리 및 모든 해당 형식 및 멤버에 동적 메서드를 포함 하 여 투명 하 게 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</source>
          <target state="translated">런타임은 부분 신뢰 어셈블리는 (예를 들어 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 완전히 신뢰 되어 로드 하는 경우에 보안 주석에 주의 유용 합니다.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</source>
          <target state="translated">이 경우 런타임에서 어셈블리의 주석이 따라 메서드에 대 한 기본 투명도 동적 메서드를 할당합니다.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">리플렉션에 대 한 자세한 내용은 내보내기 및 참조 투명도 <bpt id="p1">[</bpt>리플렉션 내보내기의 보안 문제<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">투명도 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>보안 변경 내용<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The dynamic method doesn't have a method body.</source>
          <target state="translated">동적 메서드에는 메서드 본문이 없습니다.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current dynamic method is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">현재 동적 메서드가 현재 신뢰 수준에서 보안 안전에 중요한 형식인지, 즉 중요한 작업을 수행할 수 있고 투명 코드로 액세스할 수 있는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dynamic method is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated">동적 메서드가 현재 신뢰 수준에서 보안 안전에 중요하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 보안에 중요하거나 투명하면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> 속성 공용 언어 런타임 (CLR)에 의해 결정 된 동적 메서드의 투명도 수준을 보고 합니다.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">다음 표에서 이러한 속성의 조합은 같습니다.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">보안 수준</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">안전 중요</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The transparency of a dynamic method depends on the module it is associated with.</source>
          <target state="translated">동적 메서드의 투명도와 연결 된 모듈에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</source>
          <target state="translated">동적 메서드가 모듈 대신 형식와 관련이 있으면 투명도 유형을 포함 하는 모듈에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</source>
          <target state="translated">연결 된 모듈에 대 한 기본 투명도 할당 된 동적 메서드 없으므로 보안 주석을 않습니다.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</source>
          <target state="translated">익명으로 호스팅된 동적 메서드는 포함 하는 시스템 제공 모듈 투명 하기 때문에 투명 하 게 항상입니다.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</source>
          <target state="translated">신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)와 연결 된 동적 메서드가의 투명도 다음 표에 설명 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Assembly annotation</source>
          <target state="translated">어셈블리 주석</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Level 1 transparency</source>
          <target state="translated">수준 1 투명도</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Level 2 transparency</source>
          <target state="translated">수준 2 투명도</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Fully transparent</source>
          <target state="translated">완전히 투명 한</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Fully critical</source>
          <target state="translated">완전 하 게 중요 한</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Mixed transparency</source>
          <target state="translated">혼합 된 투명도</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Security-agnostic</source>
          <target state="translated">알 수 없는 보안</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Safe-critical</source>
          <target state="translated">안전에 중요</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</source>
          <target state="translated">예를 들어 2의 혼합된 투명도 수준에 mscorlib.dll에 있는 형식으로는 동적 메서드를 연결 하는 경우 동적 메서드는 투명 및 중요 한 코드를 실행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For information about transparency levels, see <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> and <bpt id="p2">[</bpt>Security-Transparent Code, Level 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">투명도 수준에 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>보안 투명 코드, 수준 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> 및 <bpt id="p2">[</bpt>보안 투명 코드, 수준 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</source>
          <target state="translated">동적 메서드는 보안에 종속 되지 않으므로, System.dll과 같이 신뢰할 수 있는 수준 1 어셈블리에 모듈에 연결 하는 신뢰 권한 상승이 허용 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the dynamic method is called.</source>
          <target state="translated">동적 메서드를 호출 하는 코드의 권한 부여 집합 (즉, 완전 신뢰), System.dll의 권한 부여 집합을 포함 되지 않은 경우 <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> 동적 메서드를 호출할 때 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</source>
          <target state="translated">부분적으로 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드가의 투명도 어셈블리가 로드 되는 방식에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">부분 신뢰 (예를 들어 샌드 박싱된 응용 프로그램 도메인)에 로드 된 어셈블리가 있으면 런타임에서 어셈블리의 보안 주석을 무시 합니다.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The assembly and all its types and members, including dynamic methods, are treated as transparent.</source>
          <target state="translated">어셈블리 및 모든 해당 형식 및 멤버에 동적 메서드를 포함 하 여 투명 하 게 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</source>
          <target state="translated">런타임은 부분 신뢰 어셈블리는 (예를 들어 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 완전히 신뢰 되어 로드 하는 경우에 보안 주석에 주의 유용 합니다.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</source>
          <target state="translated">이 경우 런타임에서 어셈블리의 주석이 따라 메서드에 대 한 기본 투명도 동적 메서드를 할당합니다.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">리플렉션에 대 한 자세한 내용은 내보내기 및 참조 투명도 <bpt id="p1">[</bpt>리플렉션 내보내기의 보안 문제<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">투명도 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>보안 변경 내용<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The dynamic method doesn't have a method body.</source>
          <target state="translated">동적 메서드에는 메서드 본문이 없습니다.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current dynamic method is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">현재 동적 메서드가 현재 신뢰 수준에서 투명하여 중요한 작업을 수행할 수 없는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dynamic method is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">동적 메서드가 현재 신뢰 수준에서 보안에 투명하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> 속성 공용 언어 런타임 (CLR)에 의해 결정 된 동적 메서드의 투명도 수준을 보고 합니다.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">다음 표에서 이러한 속성의 조합은 같습니다.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Security level</source>
          <target state="translated">보안 수준</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Safe critical</source>
          <target state="translated">안전 중요</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The transparency of a dynamic method depends on the module it is associated with.</source>
          <target state="translated">동적 메서드의 투명도와 연결 된 모듈에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</source>
          <target state="translated">동적 메서드가 모듈 대신 형식와 관련이 있으면 투명도 유형을 포함 하는 모듈에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</source>
          <target state="translated">연결 된 모듈에 대 한 기본 투명도 할당 된 동적 메서드 없으므로 보안 주석을 않습니다.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</source>
          <target state="translated">익명으로 호스팅된 동적 메서드는 포함 하는 시스템 제공 모듈 투명 하기 때문에 투명 하 게 항상입니다.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</source>
          <target state="translated">신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)와 연결 된 동적 메서드가의 투명도 다음 표에 설명 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Assembly annotation</source>
          <target state="translated">어셈블리 주석</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Level 1 transparency</source>
          <target state="translated">수준 1 투명도</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Level 2 transparency</source>
          <target state="translated">수준 2 투명도</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Fully transparent</source>
          <target state="translated">완전히 투명 한</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Fully critical</source>
          <target state="translated">완전 하 게 중요 한</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Mixed transparency</source>
          <target state="translated">혼합 된 투명도</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">투명</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Security-agnostic</source>
          <target state="translated">알 수 없는 보안</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Safe-critical</source>
          <target state="translated">안전에 중요</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">위험</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</source>
          <target state="translated">예를 들어 2의 혼합된 투명도 수준에 mscorlib.dll에 있는 형식으로는 동적 메서드를 연결 하는 경우 동적 메서드는 투명 및 중요 한 코드를 실행할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For information about transparency levels, see <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> and <bpt id="p2">[</bpt>Security-Transparent Code, Level 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">투명도 수준에 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>보안 투명 코드, 수준 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> 및 <bpt id="p2">[</bpt>보안 투명 코드, 수준 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</source>
          <target state="translated">동적 메서드는 보안에 종속 되지 않으므로, System.dll과 같이 신뢰할 수 있는 수준 1 어셈블리에 모듈에 연결 하는 신뢰 권한 상승이 허용 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the dynamic method is called.</source>
          <target state="translated">동적 메서드를 호출 하는 코드의 권한 부여 집합 (즉, 완전 신뢰), System.dll의 권한 부여 집합을 포함 되지 않은 경우 <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> 동적 메서드를 호출할 때 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</source>
          <target state="translated">부분적으로 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드가의 투명도 어셈블리가 로드 되는 방식에 따라 달라 집니다.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">부분 신뢰 (예를 들어 샌드 박싱된 응용 프로그램 도메인)에 로드 된 어셈블리가 있으면 런타임에서 어셈블리의 보안 주석을 무시 합니다.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The assembly and all its types and members, including dynamic methods, are treated as transparent.</source>
          <target state="translated">어셈블리 및 모든 해당 형식 및 멤버에 동적 메서드를 포함 하 여 투명 하 게 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</source>
          <target state="translated">런타임은 부분 신뢰 어셈블리는 (예를 들어 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 완전히 신뢰 되어 로드 하는 경우에 보안 주석에 주의 유용 합니다.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</source>
          <target state="translated">이 경우 런타임에서 어셈블리의 주석이 따라 메서드에 대 한 기본 투명도 동적 메서드를 할당합니다.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">리플렉션에 대 한 자세한 내용은 내보내기 및 참조 투명도 <bpt id="p1">[</bpt>리플렉션 내보내기의 보안 문제<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">투명도 대 한 정보를 참조 하십시오. <bpt id="p1">[</bpt>보안 변경 내용<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The dynamic method doesn't have a method body.</source>
          <target state="translated">동적 메서드에는 메서드 본문이 없습니다.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.MethodHandle">
          <source>Not supported for dynamic methods.</source>
          <target state="translated">동적 메서드에는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.MethodHandle">
          <source>Not supported for dynamic methods.</source>
          <target state="translated">동적 메서드에는 지원되지 않습니다.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.MethodHandle">
          <source>Not allowed for dynamic methods.</source>
          <target state="translated">동적 메서드에는 허용되지 않습니다.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>Gets the module with which the dynamic method is logically associated.</source>
          <target state="translated">동적 메서드가 논리적으로 연결되는 모듈을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> with which the current dynamic method is associated.</source>
          <target state="translated">현재 동적 메서드가 연결된 <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>If a module was specified when the dynamic method was created, this property returns that module.</source>
          <target state="translated">모듈에 동적 메서드를 만들 때 지정 된 경우이 속성이 해당 모듈을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>If a type was specified as the owner when the dynamic method was created, this property returns the module which contains that type.</source>
          <target state="translated">동적 메서드를 만들 때 소유자로 형식이 지정 된,이 속성 해당 형식의 포함 된 모듈을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Module%2A&gt;</ph> property of a dynamic method.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Module%2A&gt;</ph> 동적 메서드의 속성입니다.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>Gets the name of the dynamic method.</source>
          <target state="translated">동적 메서드의 이름입니다.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>The simple name of the method.</source>
          <target state="translated">메서드의 단순한 이름입니다.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>It is not necessary to name dynamic methods.</source>
          <target state="translated">동적 메서드 이름 필요는 없습니다.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>The following code example displays the name of a dynamic method.</source>
          <target state="translated">다음 코드 예제에서는 동적 메서드 이름을 표시합니다.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>This code example is part of a larger example provided for  the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>Gets the class that was used in reflection to obtain the method.</source>
          <target state="translated">메서드를 얻기 위해 리플렉션에 사용된 클래스를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">항상 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>This property always returns <ph id="ph1">`null`</ph> for dynamic methods.</source>
          <target state="translated">이 속성은 항상 반환 <ph id="ph1">`null`</ph> 동적 메서드에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>The following code example displays the reflected type of a dynamic method.</source>
          <target state="translated">다음 코드 예제에서는 리플렉션된 형식과 동적 메서드를 표시합니다.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReturnParameter">
          <source>Gets the return parameter of the dynamic method.</source>
          <target state="translated">동적 메서드의 반환 매개 변수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnParameter">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">항상 <ph id="ph1">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnParameter">
          <source>This property always returns <ph id="ph1">`null`</ph> for dynamic methods.</source>
          <target state="translated">이 속성은 항상 반환 <ph id="ph1">`null`</ph> 동적 메서드에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>Gets the type of return value for the dynamic method.</source>
          <target state="translated">동적 메서드에 대한 반환 값 형식을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of the return value of the current method; <ph id="ph2">&lt;see cref="T:System.Void" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">현재 메서드의 반환 값 형식을 나타내는 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>입니다. 메서드에 반환 형식이 없으면 <ph id="ph2">&lt;see cref="T:System.Void" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>If <ph id="ph1">`null`</ph> was specified for the return type when the dynamic method was created, this property returns <ph id="ph2">&lt;xref:System.Void?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`null`</ph> 이 속성은 반환 된 동적 메서드를 만들 때 반환 형식에 지정 된 <ph id="ph2">&lt;xref:System.Void?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>The following code example displays the return type of a dynamic method.</source>
          <target state="translated">다음 코드 예제에서는 동적 메서드의 반환 형식을 표시합니다.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>Gets the custom attributes of the return type for the dynamic method.</source>
          <target state="translated">동적 메서드에 대한 반환 형식의 사용자 지정 특성을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.ICustomAttributeProvider" /&gt;</ph> representing the custom attributes of the return type for the dynamic method.</source>
          <target state="translated">동적 메서드의 반환 형식에 대한 사용자 지정 특성을 나타내는 <ph id="ph1">&lt;see cref="T:System.Reflection.ICustomAttributeProvider" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>Custom attributes are not supported on the return type of a dynamic method, so the array of custom attributes returned by the <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A&gt;</ph> method is always empty.</source>
          <target state="translated">사용자 지정 특성의 배열 반환 하므로 동적 메서드의 반환 형식에 사용자 지정 특성이 지원 되지 않습니다는 <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A&gt;</ph> 메서드는 항상 비어 있습니다.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>The following code example shows how to display the custom attributes of the return type of a dynamic method.</source>
          <target state="translated">다음 코드 예제에서는 동적 메서드의 반환 형식의 사용자 지정 특성을 표시 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>Returns the signature of the method, represented as a string.</source>
          <target state="translated">문자열로 표현된 메서드의 서명을 반환합니다.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>A string representing the method signature.</source>
          <target state="translated">메서드 시그니처를 나타내는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>The signature includes only types and the method name, if any.</source>
          <target state="translated">서명이 있는 경우 형식과 메서드 이름, 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>Parameter names are not included.</source>
          <target state="translated">매개 변수 이름은 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.ToString%2A&gt;</ph> method of a dynamic method.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.ToString%2A&gt;</ph> 동적 메서드의 메서드.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> 클래스입니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>