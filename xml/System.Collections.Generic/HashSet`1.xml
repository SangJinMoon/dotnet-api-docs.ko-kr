<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="HashSet`1.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac57008b2a31c9e55a7a5f90738637426f9e23c7967.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7008b2a31c9e55a7a5f90738637426f9e23c7967</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The type of elements in the hash set.</source>
          <target state="translated">해시 집합에 있는 요소의 형식입니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.HashSet`1">
          <source>Represents a set of values.</source>
          <target state="translated">값 집합을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class provides high-performance set operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 고성능 집합 작업 클래스를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>A set is a collection that contains no duplicate elements, and whose elements are in no particular order.</source>
          <target state="translated">없는 중복 요소를 포함 하는 컬렉션 집합이 요소가 임의의 순서로 합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601&gt;</ph> interface starting with the <ph id="ph3">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>; in previous versions of the .NET Framework, the <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class did not implement this interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 구현 하는 <ph id="ph2">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601&gt;</ph> 로 시작 하는 인터페이스는 <ph id="ph3">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>; 이전 버전의.NET Framework는 <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 클래스는이 인터페이스를 구현 하지 않았습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">용량을 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체는 개체가 보유할 수 있는 요소의 수입니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class is based on the model of mathematical sets and provides high-performance set operations similar to accessing the keys of the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> collections.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 클래스는 수학 집합의 모델에 기반 하 고 고성능 집합 작업의 키에 액세스 하는 유사한 제공는 <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> 또는 <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>In simple terms, the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class can be thought of as a <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> collection without values.</source>
          <target state="translated">간단히 말해서에서는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 클래스도 생각할 수 있습니다는 <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> 값이 없는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection is not sorted and cannot contain duplicate elements.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 컬렉션 정렬 되지 않은 한 중복 요소를 포함할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>If order or element duplication is more important than performance for your application, consider using the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class together with the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> method.</source>
          <target state="translated">순서나 요소 중복 응용 프로그램에 대 한 성능 보다 더 중요 한 경우에 사용 하 여는 <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> 와 함께 클래스는 <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> provides many mathematical set operations, such as set addition (unions) and set subtraction.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 많은 수학 집합 더하기 (합집합) 등의 작업을 설정 하 고 집합 빼기를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The following table lists the provided <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> operations and their mathematical equivalents.</source>
          <target state="translated">다음 표에 제공 된 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 작업 및 수학 상응 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>HashSet(Of T) operation</source>
          <target state="translated">HashSet (Of T) 작업</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Mathematical equivalent</source>
          <target state="translated">해당 하는 수학</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Union or set addition</source>
          <target state="translated">Union 또는 설정 추가</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Intersection</source>
          <target state="translated">교차</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Set subtraction</source>
          <target state="translated">집합 빼기</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Symmetric difference</source>
          <target state="translated">대칭 차이</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>In addition to the listed set operations, the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class also provides methods for determining set equality, overlap of sets, and whether a set is a subset or superset of another set.</source>
          <target state="translated">나열 된 집합 작업 이외에 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 클래스 집합 같음, 집합, 잠금의 겹쳐진 부분을 결정 하기 위한 메서드도 제공 및 집합을 다른 집합의 상위 또는 하위 집합 인지 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
          <target state="translated">에 대 한 매우 큰 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를 설정 하 여 64 비트 시스템의 2 십억 요소에 최대 용량을 늘릴 수는 <ph id="ph2">`enabled`</ph> 에 구성 요소의 특성 <ph id="ph3">`true`</ph> 런타임 환경에서 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class implements the <ph id="ph3">&lt;xref:System.Collections.Generic.ISet%601&gt;</ph> interface.</source>
          <target state="translated">부터는 <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 클래스가 구현 하는 <ph id="ph3">&lt;xref:System.Collections.Generic.ISet%601&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>HashSet and LINQ Set Operations</source>
          <target state="translated">HashSet 및 LINQ 집합 작업</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>LINQ provides access to the <ph id="ph1">`Distinct`</ph>, <ph id="ph2">`Union`</ph>, <ph id="ph3">`Intersect`</ph> and <ph id="ph4">`Except`</ph> set operations on any data source that implements the <ph id="ph5">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph6">&lt;xref:System.Linq.IQueryable&gt;</ph> interfaces.</source>
          <target state="translated">LINQ에 대 한 액세스를 제공는 <ph id="ph1">`Distinct`</ph>, <ph id="ph2">`Union`</ph>, <ph id="ph3">`Intersect`</ph> 및 <ph id="ph4">`Except`</ph> 작업을 구현 하는 모든 데이터 원본에 설정 된 <ph id="ph5">&lt;xref:System.Collections.IEnumerable&gt;</ph> 또는 <ph id="ph6">&lt;xref:System.Linq.IQueryable&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> provides a larger and more robust collection of set operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 집합 작업의 더 큰 보다 강력 하 고 컬렉션을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>For example, <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> provides comparisons such as <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A&gt;</ph>.</source>
          <target state="translated">예를 들어 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 비교와 같은 제공 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The primary difference between LINQ set operations and <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> operations is that LINQ set operations always return a new <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection, whereas the <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> equivalent methods modify the current collection.</source>
          <target state="translated">LINQ 사이의 주요 차이점은 설정 작업 및 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 운영은 LINQ 집합 항상 반환 연산 새 <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> 컬렉션 반면는 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 동일한 메서드는 현재 컬렉션을 수정 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Typically, if you must create a new set or if your application needs access only to the provided set operations, using LINQ set operations on any <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection or array will be sufficient.</source>
          <target state="translated">일반적으로 새 집합을 다시 만들어야 하는 경우 또는 응용 프로그램에서 제공 된 작업 집합에 대해서만 액세스 해야 하는 경우 LINQ를 사용 하 여 설정에서 작업을 <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> 컬렉션이 나 배열의 적용 됩니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>However, if your application requires access to additional set operations, or if it is not desirable or necessary to create a new collection, use the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class.</source>
          <target state="translated">그러나 응용 프로그램에 필요한 추가 집합 작업에 대 한 액세스 또는 바람직한 또는 새 컬렉션을 만드는 데 필요한 경우 사용할는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The following table shows the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> operations and their equivalent LINQ set operations.</source>
          <target state="translated">다음 표는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 작업 및 해당 하는 LINQ의 set 작업이 있습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>HashSet(Of T) operation</source>
          <target state="translated">HashSet (Of T) 작업</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>LINQ equivalent</source>
          <target state="translated">해당 하는 LINQ</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">제공 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">제공 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">제공 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">제공 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">제공 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">제공 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">제공 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">제공 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The following example demonstrates how to merge two disparate sets.</source>
          <target state="translated">다음 예제에서는 서로 다른 두 집합을 병합 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>This example creates two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects, and populates them with even and odd numbers, respectively.</source>
          <target state="translated">이 예제에서는 두 개의 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체 하 고 각각에 및 홀수 번호에 채웁니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>A third <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is created from the set that contains the even numbers.</source>
          <target state="translated">세 번째 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 짝수를 포함 하는 집합에서 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> method, which adds the odd number set to the third set.</source>
          <target state="translated">이 예에서는 다음 호출는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> 메서드 홀수 집합 세 번째 집합에 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.HashSet`1">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class that is empty and uses the default equality comparer for the set type.</source>
          <target state="translated">비어 있으며 집합 형식에 대한 기본 같음 비교자를 사용하는 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">용량을 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체는 개체가 보유할 수 있는 요소의 수입니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">이 생성자는 o (1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>The following example demonstrates how to create and populate two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects.</source>
          <target state="translated">다음 예제에서는 만들고 채우는 두 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> method.</source>
          <target state="translated">이 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection whose elements are copied to the new set.</source>
          <target state="translated">해당 요소가 새 집합에 복사되는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class that uses the default equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</source>
          <target state="translated">집합 형식에 대한 기본 같음 비교자를 사용하고 지정된 컬렉션에서 복사한 요소가 들어 있으며 복사된 요소 수를 수용하기에 용량이 충분한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">용량을 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체는 개체가 보유할 수 있는 요소의 수입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>If <ph id="ph1">`collection`</ph> contains duplicates, the set will contain one of each unique element.</source>
          <target state="translated">경우 <ph id="ph1">`collection`</ph> 중복이 포함 집합 각각의 고유한 요소 중 하나가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>No exception will be thrown.</source>
          <target state="translated">예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>Therefore, the size of the resulting set is not identical to the size of <ph id="ph1">`collection`</ph>.</source>
          <target state="translated">따라서 결과 집합의 크기의 크기와 동일 하지는 <ph id="ph1">`collection`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`collection`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`collection`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example shows how to create a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection from an existing set.</source>
          <target state="translated">만드는 방법을 보여 주는 다음 예제는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 기존 집합을 수집 합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, two sets are created with even and odd integers, respectively.</source>
          <target state="translated">이 예제에서는 두 개의 집합 만들어집니다 홀수, 짝수 정수로 각각.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>A third <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is then created from the even integer set.</source>
          <target state="translated">세 번째 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체 집합에서 그런 다음 생성 됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> implementation to use when comparing values in the set, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the default <ph id="ph3">&lt;see cref="T:System.Collections.Generic.EqualityComparer`1" /&gt;</ph> implementation for the set type.</source>
          <target state="translated">집합의 값을 비교하려면 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> 구현을 사용하고, 집합 형식에 대한 기본 <ph id="ph3">&lt;see cref="T:System.Collections.Generic.EqualityComparer`1" /&gt;</ph> 구현을 사용하려면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을(를) 지정합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class that is empty and uses the specified equality comparer for the set type.</source>
          <target state="translated">비어 있으며 집합 형식에 대한 지정된 같음 비교자를 사용하는 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">용량을 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체는 개체가 보유할 수 있는 요소의 수입니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">이 생성자는 o (1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The collection whose elements are copied to the new set.</source>
          <target state="translated">해당 요소가 새 집합에 복사되는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> implementation to use when comparing values in the set, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the default <ph id="ph3">&lt;see cref="T:System.Collections.Generic.EqualityComparer`1" /&gt;</ph> implementation for the set type.</source>
          <target state="translated">집합의 값을 비교하려면 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> 구현을 사용하고, 집합 형식에 대한 기본 <ph id="ph3">&lt;see cref="T:System.Collections.Generic.EqualityComparer`1" /&gt;</ph> 구현을 사용하려면 <ph id="ph2">&lt;see langword="null" /&gt;</ph>을(를) 지정합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class that uses the specified equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</source>
          <target state="translated">집합 형식에 대한 지정된 같음 비교자를 사용하고 지정된 컬렉션에서 복사한 요소가 들어 있으며 복사된 요소 수를 수용하기에 용량이 충분한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">용량을 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체는 개체가 보유할 수 있는 요소의 수입니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>If <ph id="ph1">`collection`</ph> contains duplicates, the set will contain one of each unique element.</source>
          <target state="translated">경우 <ph id="ph1">`collection`</ph> 중복이 포함 집합 각각의 고유한 요소 중 하나가 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>No exception will be thrown.</source>
          <target state="translated">예외가 throw 됩니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>Therefore, the size of the resulting set is not identical to the size of <ph id="ph1">`collection`</ph>.</source>
          <target state="translated">따라서 결과 집합의 크기의 크기와 동일 하지는 <ph id="ph1">`collection`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`collection`</ph> parameter.</source>
          <target state="translated">이 생성자는는 O (<ph id="ph1">`n`</ph>) 작업을 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`collection`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The following example uses a supplied <ph id="ph1">&lt;xref:System.Collections.Generic.IEqualityComparer%601&gt;</ph> to allow case-insensitive comparisons on the elements of a  <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection of vehicle types.</source>
          <target state="translated">다음 예제에서는 제공 된 <ph id="ph1">&lt;xref:System.Collections.Generic.IEqualityComparer%601&gt;</ph> 의 요소에 대해 대/소문자 구분 비교를 허용 하는 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 차량 유형의 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object that contains the information required to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체를 serialize하는 데 필요한 정보가 포함된 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> structure that contains the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에 연결되어 있는 serialize된 스트림의 소스와 대상이 포함된 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> 구조체입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class with serialized data.</source>
          <target state="translated">serialize된 데이터를 사용하여 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This constructor is called during deserialization to reconstitute an object that is transmitted over a stream.</source>
          <target state="translated">이 생성자는 역직렬화 스트림을 통해 전송 되는 개체를 다시 구성 하는 동안 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>For more information, see <bpt id="p1">[</bpt>XML and SOAP Serialization<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>XML 및 SOAP Serialization<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>The element to add to the set.</source>
          <target state="translated">집합에 추가할 요소입니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>Adds the specified element to a set.</source>
          <target state="translated">지정된 요소를 집합에 추가합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is added to the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the element is already present.</source>
          <target state="translated">요소가 <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에 추가되었으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 요소가 이미 있으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> already equals the capacity of the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, the capacity is automatically adjusted to accommodate the new item.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 이미의 용량과 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체 용량 새 항목을 수용 하기 위해 자동으로 조정 됩니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is less than the capacity of the internal array, this method is an O(1) operation.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 작으면 내부 배열의 용량 보다이 메서드는 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object must be resized, this method becomes an O(<ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체 크기를 조정 해야,이 메서드는 O 됩니다 (<ph id="ph2">`n`</ph>) 작업, 여기서 <ph id="ph3">`n`</ph> 은 <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>The following example demonstrates how to create and populate two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects.</source>
          <target state="translated">다음 예제에서는 만들고 채우는 두 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> method.</source>
          <target state="translated">이 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Clear">
          <source>Removes all elements from a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에서 요소를 모두 제거합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is set to zero and references to other objects from elements of the collection are also released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 0으로 설정 된 한 컬렉션의 요소에 다른 개체에 대 한 참조도 해제 됩니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Clear">
          <source>The capacity remains unchanged until a call to <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.TrimExcess%2A&gt;</ph> is made.</source>
          <target state="translated">용량에 대 한 호출 될 때까지 변경 되지 않습니다 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.TrimExcess%2A&gt;</ph> 이루어집니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Clear">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Clear">
          <source>The following example creates and populates a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection, then clears it and releases the memory referenced by the collection.</source>
          <target state="translated">다음 예제를 만들고 채웁니다는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 컬렉션 다음 삭제 하는 예제 및 컬렉션에 의해 참조 되는 메모리를 해제 합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.HashSet`1.Comparer">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> object that is used to determine equality for the values in the set.</source>
          <target state="translated">집합의 값이 같은지 확인하는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Comparer">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> object that is used to determine equality for the values in the set.</source>
          <target state="translated">집합의 값이 같은지 확인하는 데 사용되는 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Comparer">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source>The element to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에서 찾을 요소입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object contains the specified element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에 지정된 요소가 포함되어 있는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object contains the specified element; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에 지정된 요소가 들어 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source>The following example demonstrates how to remove values from a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection using the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 값을 제거 하는 방법을 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 사용 하 여 컬렉션의 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source>In this example, the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Contains%2A&gt;</ph> method verifies that the set contains a value before removing it.</source>
          <target state="translated">이 예제는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Contains%2A&gt;</ph> 메서드 제거 하기 전에 집합에는 값이 들어 있는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.HashSet`1">
          <source>Copies the elements of a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> collection to an array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 컬렉션의 요소를 배열에 복사합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에서 복사한 요소의 대상인 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">배열에는 0부터 시작하는 인덱스가 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
          <source>Copies the elements of a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to an array.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체의 요소를 배열에 복사합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에서 복사한 요소의 대상인 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">배열에는 0부터 시작하는 인덱스가 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>배열<ept id="p1">&lt;/c&gt;</ept>에서 복사를 시작할 인덱스입니다. 이 인덱스는 0부터 시작합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source>Copies the elements of a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to an array, starting at the specified array index.</source>
          <target state="translated">지정된 배열 인덱스에서 시작하여 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체의 요소를 배열에 복사합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph>가 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is greater than the length of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph>가 대상 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 길이보다 큰 경우</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에서 복사한 요소의 대상인 1차원 배열입니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">배열에는 0부터 시작하는 인덱스가 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>배열<ept id="p1">&lt;/c&gt;</ept>에서 복사를 시작할 인덱스입니다. 이 인덱스는 0부터 시작합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>The number of elements to copy to <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>배열<ept id="p1">&lt;/c&gt;</ept>에 복사할 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>Copies the specified number of elements of a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to an array, starting at the specified array index.</source>
          <target state="translated">지정된 배열 인덱스에서 시작하여 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에서 지정된 수의 요소를 배열에 복사합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">`count`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph>가 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph>가 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is greater than the length of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph>가 대상 <ph id="ph2">&lt;paramref name="array" /&gt;</ph>의 길이보다 큰 경우</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the available space from the <ph id="ph2">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph>가 <ph id="ph2">&lt;paramref name="index" /&gt;</ph>에서 대상 <ph id="ph3">&lt;paramref name="array" /&gt;</ph> 끝까지 사용 가능한 공간보다 큰 경우</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>Gets the number of elements that are contained in a set.</source>
          <target state="translated">집합에 포함된 요소 수를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>The number of elements that are contained in the set.</source>
          <target state="translated">집합에 포함된 요소 수입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">용량을 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체는 개체가 보유할 수 있는 요소의 수입니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>The capacity is always greater than or equal to <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">용량 보다 크거나 같은 경우는 항상 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> exceeds the capacity while adding elements, the capacity is set to the first prime number that is greater than double the previous capacity.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 요소를 추가 하는 동안 용량을 초과, 용량은 보다 큰 첫 번째 소수로으로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>The following example demonstrates how to create, populate, and manipulate two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects.</source>
          <target state="translated">다음 예제에서는을 채우고, 만들고, 조작 하는 두 개의 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>In this example, both the contents of the set and <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> display to the console.</source>
          <target state="translated">이 예제에서는 두 집합의 내용과 및 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 콘솔에 표시 합니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CreateSetComparer">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that can be used for equality testing of a <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에 대한 같음 테스트에 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> 개체를 반환합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CreateSetComparer">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that can be used for deep equality testing of the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에 대한 전체 같음 테스트에 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.CreateSetComparer">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object checks for equality at only one level; however, you can chain together comparers at additional levels to perform deeper equality testing.</source>
          <target state="translated">하지만 <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> 함께 연결할 수 있습니다 더 깊은 같음 테스트를 수행 하려면 추가 수준에서 비교자를 개체 하나만 수준에서 같은지 검사 합니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.CreateSetComparer">
          <source>Calling this method is an O(1) operation.</source>
          <target state="translated">이 메서드를 호출 하는 것은 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection of items to remove from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에서 제거할 항목의 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Removes all elements in the specified collection from the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에서 지정된 컬렉션의 모든 요소를 제거합니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.ExceptWith%2A&gt;</ph> method is the equivalent of mathematical set subtraction.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.ExceptWith%2A&gt;</ph> 메서드는 수학 집합 빼기는 것에 해당 합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`other`</ph> parameter.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`other`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collections with overlapping sets of data.</source>
          <target state="translated">다음 예제에서는 두 개의 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 로 데이터 집합에 중복 되는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The lower range of values is then removed from the larger set using the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.ExceptWith%2A&gt;</ph> method.</source>
          <target state="translated">그런 다음 하위 범위의 값을 사용 하 여 더 큰 집합에서 제거 되 고 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.ExceptWith%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Returns an enumerator that iterates through a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에서 반복되는 열거자를 반환합니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>A <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /&gt;</ph> object for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에 대한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of enumerators.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> C# 언어의 (<ph id="ph2">`for each`</ph> c + +에서는 <ph id="ph3">`For Each`</ph> Visual basic에서)은 열거자의 복잡성을 숨깁니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended instead of directly manipulating the enumerator.</source>
          <target state="translated">따라서 사용 하 여 <ph id="ph1">`foreach`</ph> 열거자를 직접 조작 하는 대신 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> property is undefined.</source>
          <target state="translated">이 위치에서의 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> 속성이 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">따라서 호출 해야 합니다는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> 하 여 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소로 메서드 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> property returns the same object until <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> 속성 반환 될 때까지 동일한 개체 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph>는 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph>를 다음 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">열거자가 있는 경우이 위치에 대 한 후속 호출에서 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> 반환할 수도 <ph id="ph2">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">마지막으로 호출 하는 경우 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>You cannot set <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> to the first element of the collection again; you must create a new enumerator object instead.</source>
          <target state="translated">설정할 수 없습니다. <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> 다시; 컬렉션의 첫 번째 요소에 새 열거자 개체를 대신 만들어야 합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace are not synchronized.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object that contains the information required to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체를 serialize하는 데 필요한 정보가 포함된 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> structure that contains the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에 연결되어 있는 serialize된 스트림의 소스와 대상이 포함된 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> 구조체입니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interface and returns the data needed to serialize a <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> 인터페이스를 구현하고 <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체를 serialize하는 데 필요한 데이터를 반환합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Calling this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드를 호출 하는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>for providing serialization services.</source>
          <target state="translated">serialization 서비스를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">보안 동작: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 비교할 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Modifies the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to contain only elements that are present in that object and in the specified collection.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체를 수정하여 해당 개체와 지정된 컬렉션에 동시에 있는 요소만 포함합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by the <ph id="ph1">`other`</ph> parameter is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">으로 표시 되는 컬렉션의 <ph id="ph1">`other`</ph> 매개 변수는 한 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를이 메서드는 O는 (<ph id="ph4">`n`</ph>) 작업 합니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> and <ph id="ph6">`m`</ph> is the number of elements in <ph id="ph7">`other`</ph>.</source>
          <target state="translated">그렇지 않으면이 메서드는는 O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) 작업, 여기서 <ph id="ph4">`n`</ph> 은 <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 및 <ph id="ph6">`m`</ph> 에 있는 요소의 수는 <ph id="ph7">`other`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 비교할 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a proper subset of the specified collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체가 지정된 컬렉션의 적합한 하위 집합인지 확인합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a proper subset of <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체가 <ph id="ph3">&lt;paramref name="other" /&gt;</ph>의 적합한 하위 집합이면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>An empty set is a proper subset of any other collection.</source>
          <target state="translated">빈 집합은 다른 컬렉션의 적절 한 하위 집합입니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Therefore, this method returns <ph id="ph1">`true`</ph> if the collection represented by the current <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is empty unless the <ph id="ph3">`other`</ph> parameter is also an empty set.</source>
          <target state="translated">따라서이 메서드는 반환 <ph id="ph1">`true`</ph> 현재 나타내는 컬렉션이 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체가 비어 경우가 아니면는 <ph id="ph3">`other`</ph> 매개 변수는 빈 집합 이기도 합니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>This method always returns <ph id="ph1">`false`</ph> if <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is greater than or equal to the number of elements in <ph id="ph3">`other`</ph>.</source>
          <target state="translated">이 메서드는 항상 반환 <ph id="ph1">`false`</ph> 경우 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 에 있는 요소의 수를 보다 크거나 <ph id="ph3">`other`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, then this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">컬렉션으로 표시 되는 <ph id="ph1">`other`</ph> 는 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체 면이 메서드는 O (<ph id="ph4">`n`</ph>) 작업입니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> and <ph id="ph6">`m`</ph> is the number of elements in <ph id="ph7">`other`</ph>.</source>
          <target state="translated">그렇지 않으면이 메서드는는 O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) 작업, 여기서 <ph id="ph4">`n`</ph> 은 <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 및 <ph id="ph6">`m`</ph> 에 있는 요소의 수는 <ph id="ph7">`other`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each other.</source>
          <target state="translated">다음 예제에서는 두 개의 서로 다른 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를 서로 비교 합니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, <ph id="ph1">`lowNumbers`</ph> is both a subset and a proper subset of <ph id="ph2">`allNumbers`</ph> until <ph id="ph3">`allNumbers`</ph> is modified, using the <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> method, to contain only values that are present in both sets.</source>
          <target state="translated">이 예제에서는 <ph id="ph1">`lowNumbers`</ph> 의 적절 한 하위 집합 및 하위 집합 <ph id="ph2">`allNumbers`</ph> 될 때까지 <ph id="ph3">`allNumbers`</ph> 를 사용 하 여 수정 되는 <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> 메서드를 두 집합 모두에 있는 값만 포함 합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Once <ph id="ph1">`allNumbers`</ph> and <ph id="ph2">`lowNumbers`</ph> are identical, <ph id="ph3">`lowNumbers`</ph> is still a subset of <ph id="ph4">`allNumbers`</ph> but is no longer a proper subset.</source>
          <target state="translated">한 번 <ph id="ph1">`allNumbers`</ph> 및 <ph id="ph2">`lowNumbers`</ph> 동일 <ph id="ph3">`lowNumbers`</ph> 의 하위 집합은 여전히 <ph id="ph4">`allNumbers`</ph> 하지만 더 이상 적절 한 하위 집합입니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 비교할 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a proper superset of the specified collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체가 지정된 컬렉션의 적합한 상위 집합인지 확인합니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a proper superset of <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체가 <ph id="ph3">&lt;paramref name="other" /&gt;</ph>의 적합한 상위 집합이면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>An empty set is a proper superset of any other collection.</source>
          <target state="translated">빈 집합은 다른 컬렉션의 적절 한 상위 집합입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Therefore, this method returns <ph id="ph1">`true`</ph> if the collection represented by the <ph id="ph2">`other`</ph> parameter is empty unless the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection is also empty.</source>
          <target state="translated">따라서이 메서드는 반환 <ph id="ph1">`true`</ph> 컬렉션으로 표시 되는 <ph id="ph2">`other`</ph> 매개 변수는 비어 하지 않으면 현재 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 또한 컬렉션은 비어 있습니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>This method always returns <ph id="ph1">`false`</ph> if <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is less than or equal to the number of elements in <ph id="ph3">`other`</ph>.</source>
          <target state="translated">이 메서드는 항상 반환 <ph id="ph1">`false`</ph> 경우 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 의 요소 수가 보다 작은 <ph id="ph3">`other`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">컬렉션으로 표시 되는 <ph id="ph1">`other`</ph> 는 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를이 메서드는 O는 (<ph id="ph4">`n`</ph>) 작업입니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements in <ph id="ph5">`other`</ph> and <ph id="ph6">`m`</ph> is <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">그렇지 않으면이 메서드는는 O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) 작업, 여기서 <ph id="ph4">`n`</ph> 에 있는 요소의 수는 <ph id="ph5">`other`</ph> 및 <ph id="ph6">`m`</ph> 은 <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each other.</source>
          <target state="translated">다음 예제에서는 두 개의 서로 다른 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를 서로 비교 합니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, <ph id="ph1">`allNumbers`</ph> is both a superset and a proper superset of <ph id="ph2">`lowNumbers`</ph> until <ph id="ph3">`allNumbers`</ph> is modified, using the <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> method, to contain only values that are present in both sets.</source>
          <target state="translated">이 예제에서는 <ph id="ph1">`allNumbers`</ph> 는 상위 집합 하면서의 적절 한 상위 집합이 <ph id="ph2">`lowNumbers`</ph> 될 때까지 <ph id="ph3">`allNumbers`</ph> 를 사용 하 여 수정 되는 <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> 메서드를 두 집합 모두에 있는 값만 포함 합니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Once <ph id="ph1">`allNumbers`</ph> and <ph id="ph2">`lowNumbers`</ph> are identical, <ph id="ph3">`allNumbers`</ph> is still a superset of <ph id="ph4">`lowNumbers`</ph> but is no longer a proper superset.</source>
          <target state="translated">한 번 <ph id="ph1">`allNumbers`</ph> 및 <ph id="ph2">`lowNumbers`</ph> 동일 <ph id="ph3">`allNumbers`</ph> 의 상위 집합은 여전히 <ph id="ph4">`lowNumbers`</ph> 하지만 더 이상 적절 한 상위 집합입니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 비교할 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a subset of the specified collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체가 지정된 컬렉션의 하위 집합인지 확인합니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a subset of <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체가 <ph id="ph3">&lt;paramref name="other" /&gt;</ph>의 하위 집합이면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>An empty set is a subset of any other collection, including an empty set; therefore, this method returns <ph id="ph1">`true`</ph> if the collection represented by the current <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is empty, even if the <ph id="ph3">`other`</ph> parameter is an empty set.</source>
          <target state="translated">빈 집합은;는 빈 집합을 포함 하 여 모든 다른 컬렉션의 하위 집합 따라서이 메서드는 반환 <ph id="ph1">`true`</ph> 현재 나타내는 컬렉션이 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체가 비어 경우에는 <ph id="ph3">`other`</ph> 매개 변수는 빈 집합입니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>This method always returns <ph id="ph1">`false`</ph> if <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is greater than the number of elements in <ph id="ph3">`other`</ph>.</source>
          <target state="translated">이 메서드는 항상 반환 <ph id="ph1">`false`</ph> 경우 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 의 요소 수보다 큽니다 <ph id="ph3">`other`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">컬렉션으로 표시 되는 <ph id="ph1">`other`</ph> 는 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를이 메서드는 O는 (<ph id="ph4">`n`</ph>) 작업입니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> and <ph id="ph6">`m`</ph> is the number of elements in <ph id="ph7">`other`</ph>.</source>
          <target state="translated">그렇지 않으면이 메서드는는 O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) 작업, 여기서 <ph id="ph4">`n`</ph> 은 <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 및 <ph id="ph6">`m`</ph> 에 있는 요소의 수는 <ph id="ph7">`other`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each other.</source>
          <target state="translated">다음 예제에서는 두 개의 서로 다른 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를 서로 비교 합니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, <ph id="ph1">`lowNumbers`</ph> is both a subset and a proper subset of <ph id="ph2">`allNumbers`</ph> until <ph id="ph3">`allNumbers`</ph> is modified, using the <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> method, to contain only values that are present in both sets.</source>
          <target state="translated">이 예제에서는 <ph id="ph1">`lowNumbers`</ph> 의 적절 한 하위 집합 및 하위 집합 <ph id="ph2">`allNumbers`</ph> 될 때까지 <ph id="ph3">`allNumbers`</ph> 를 사용 하 여 수정 되는 <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> 메서드를 두 집합 모두에 있는 값만 포함 합니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Once <ph id="ph1">`allNumbers`</ph> and <ph id="ph2">`lowNumbers`</ph> are identical, <ph id="ph3">`lowNumbers`</ph> is still a subset of <ph id="ph4">`allNumbers`</ph> but is no longer a proper subset.</source>
          <target state="translated">한 번 <ph id="ph1">`allNumbers`</ph> 및 <ph id="ph2">`lowNumbers`</ph> 동일 <ph id="ph3">`lowNumbers`</ph> 의 하위 집합은 여전히 <ph id="ph4">`allNumbers`</ph> 하지만 더 이상 적절 한 하위 집합입니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 비교할 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a superset of the specified collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체가 지정된 컬렉션의 상위 집합인지 확인합니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a superset of <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체가 <ph id="ph3">&lt;paramref name="other" /&gt;</ph>의 상위 집합이면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>All collections, including the empty set, are supersets of the empty set.</source>
          <target state="translated">모든 컬렉션을 빈 집합을 포함 하는 빈 집합의 상위 집합입니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Therefore, this method returns <ph id="ph1">`true`</ph> if the collection represented by the <ph id="ph2">`other`</ph> parameter is empty, even if the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is empty.</source>
          <target state="translated">따라서이 메서드는 반환 <ph id="ph1">`true`</ph> 으로 표시 되는 컬렉션의 <ph id="ph2">`other`</ph> 매개 변수가 비어 경우에 현재 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체가 비어 있습니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>This method always returns <ph id="ph1">`false`</ph> if <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is less than the number of elements in <ph id="ph3">`other`</ph>.</source>
          <target state="translated">이 메서드는 항상 반환 <ph id="ph1">`false`</ph> 경우 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> 에 있는 요소의 수보다 작을 경우 <ph id="ph3">`other`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">컬렉션으로 표시 되는 <ph id="ph1">`other`</ph> 는 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를이 메서드는 O는 (<ph id="ph4">`n`</ph>) 작업입니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements in <ph id="ph5">`other`</ph> and <ph id="ph6">`m`</ph> is <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">그렇지 않으면이 메서드는는 O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) 작업, 여기서 <ph id="ph4">`n`</ph> 에 있는 요소의 수는 <ph id="ph5">`other`</ph> 및 <ph id="ph6">`m`</ph> 은 <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each other.</source>
          <target state="translated">다음 예제에서는 두 개의 서로 다른 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를 서로 비교 합니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, <ph id="ph1">`allNumbers`</ph> is both a superset and a proper superset of <ph id="ph2">`lowNumbers`</ph> until <ph id="ph3">`allNumbers`</ph> is modified, using the <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> method, to contain only values that are present in both sets.</source>
          <target state="translated">이 예제에서는 <ph id="ph1">`allNumbers`</ph> 는 상위 집합 하면서의 적절 한 상위 집합이 <ph id="ph2">`lowNumbers`</ph> 될 때까지 <ph id="ph3">`allNumbers`</ph> 를 사용 하 여 수정 되는 <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> 메서드를 두 집합 모두에 있는 값만 포함 합니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Once <ph id="ph1">`allNumbers`</ph> and <ph id="ph2">`lowNumbers`</ph> are identical, <ph id="ph3">`allNumbers`</ph> is still a superset of <ph id="ph4">`lowNumbers`</ph> but is no longer a proper superset.</source>
          <target state="translated">한 번 <ph id="ph1">`allNumbers`</ph> 및 <ph id="ph2">`lowNumbers`</ph> 동일 <ph id="ph3">`allNumbers`</ph> 의 상위 집합은 여전히 <ph id="ph4">`lowNumbers`</ph> 하지만 더 이상 적절 한 상위 집합입니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)">
          <source>The source of the deserialization event.</source>
          <target state="translated">deserialization 이벤트의 소스입니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interface and raises the deserialization event when the deserialization is complete.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> 인터페이스를 구현하고, deserialization이 완료되면 deserialization 이벤트를 발생시킵니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)">
          <source>Calling this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드를 호출 하는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object associated with the current <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is invalid.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> 개체와 관련된 <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체가 잘못된 경우</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 비교할 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object and a specified collection share common elements.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 지정된 컬렉션이 공통 요소를 공유하는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object and <ph id="ph3">&lt;paramref name="other" /&gt;</ph> share at least one common element; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 <ph id="ph3">&lt;paramref name="other" /&gt;</ph>이(가) 요소를 하나 이상 공유하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`other`</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`other`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each another.</source>
          <target state="translated">다음 예제에서는 두 개의 서로 다른 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를 서로 비교 합니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, <ph id="ph1">`allNumbers`</ph> and <ph id="ph2">`lowNumbers`</ph> are shown to share common elements using the <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Overlaps%2A&gt;</ph> method.</source>
          <target state="translated">이 예제에서는 <ph id="ph1">`allNumbers`</ph> 및 <ph id="ph2">`lowNumbers`</ph> 를 사용 하 여 공통 요소를 공유 하도록 표시 된는 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Overlaps%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>The element to remove.</source>
          <target state="translated">제거할 요소입니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>Removes the specified element from a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체에서 지정된 요소를 제거합니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is successfully found and removed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">요소를 성공적으로 찾아서 제거한 경우 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>This method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> is not found in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="item" /&gt;</ph> 개체에 <ph id="ph3">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>이(가) 없으면 이 메서드는 <ph id="ph1">&lt;see langword="false" /&gt;</ph>을(를) 반환합니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object does not contain the specified element, the object remains unchanged.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체는 지정된 된 요소를 포함 하지 않습니다, 개체가 변경 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>No exception is thrown.</source>
          <target state="translated">예외가 throw되지 않습니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>The following example demonstrates how to remove values from a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection using the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 값을 제거 하는 방법을 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 사용 하 여 컬렉션의 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>In this example, zero is arbitrarily removed from the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection.</source>
          <target state="translated">이 예제에서는 임의로 0을 제거에서 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the elements to remove.</source>
          <target state="translated">제거할 요소의 조건을 정의하는 <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> 대리자입니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>Removes all elements that match the conditions defined by the specified predicate from a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 컬렉션에서 지정된 조건자에 정의된 조건과 일치하는 요소를 모두 제거합니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>The number of elements that were removed from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 컬렉션에서 제거된 요소의 수입니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>Calling this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드를 호출 하는 O (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>The following example demonstrates how to remove values from a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection using the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서는 값을 제거 하는 방법을 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 사용 하 여 컬렉션의 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>In this example, all odd integers are removed from the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection as specified by the <ph id="ph2">`match`</ph> delegate.</source>
          <target state="translated">이 예제에서는 모든 홀수에서 제거 됩니다는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 컬렉션에 지정 된 대로 <ph id="ph2">`match`</ph> 위임 합니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 비교할 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object and the specified collection contain the same elements.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 지정된 컬렉션에 같은 요소가 포함되어 있는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is equal to <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; otherwise, false.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체가 <ph id="ph3">&lt;paramref name="other" /&gt;</ph>과(와) 같으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 false입니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SetEquals%2A&gt;</ph> method ignores duplicate entries and the order of elements in the <ph id="ph2">`other`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SetEquals%2A&gt;</ph> 메서드가 중복 된 항목 및에서 요소의 순서를 무시는 <ph id="ph2">`other`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">컬렉션으로 표시 되는 <ph id="ph1">`other`</ph> 는 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를이 메서드는 O는 (<ph id="ph4">`n`</ph>) 작업입니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements in <ph id="ph5">`other`</ph> and <ph id="ph6">`m`</ph> is <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">그렇지 않으면이 메서드는는 O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) 작업, 여기서 <ph id="ph4">`n`</ph> 에 있는 요소의 수는 <ph id="ph5">`other`</ph> 및 <ph id="ph6">`m`</ph> 은 <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each another.</source>
          <target state="translated">다음 예제에서는 두 개의 서로 다른 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를 서로 비교 합니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>Initially, the two sets are not equal, which is demonstrated by using the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SetEquals%2A&gt;</ph> method.</source>
          <target state="translated">처음에 두 집합 서로 다름을 사용 하 여 보여 줍니다는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SetEquals%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>The <ph id="ph1">`allNumbers`</ph><ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is then modified, after which the sets are equal.</source>
          <target state="translated"><ph id="ph1">`allNumbers`</ph> <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 지나면 집합이 같으면 개체는 수정 됩니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 비교할 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Modifies the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to contain only elements that are present either in that object or in the specified collection, but not both.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체를 수정하여 해당 개체와 지정된 컬렉션 중 하나에 있는 요소만 포함합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>If the <ph id="ph1">`other`</ph> parameter is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">경우는 <ph id="ph1">`other`</ph> 매개 변수는 한 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체를이 메서드는 O는 (<ph id="ph4">`n`</ph>) 작업입니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements in <ph id="ph5">`other`</ph> and <ph id="ph6">`m`</ph> is <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">그렇지 않으면이 메서드는는 O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) 작업, 여기서 <ph id="ph4">`n`</ph> 에 있는 요소의 수는 <ph id="ph5">`other`</ph> 및 <ph id="ph6">`m`</ph> 은 <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collections with overlapping sets of data.</source>
          <target state="translated">다음 예제에서는 두 개의 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 로 데이터 집합에 중복 되는 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The set that contains the lower values is then modified, using the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A&gt;</ph> method, to contain only the values that are not present in both sets.</source>
          <target state="translated">낮은 값을 포함 하는 집합은 다음 수정 하 여는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A&gt;</ph> 메서드를 두 집합 모두에 존재 하지 않는 값만 포함 합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#Add(`0)">
          <source>The object to add to the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> 개체에 추가할 개체입니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#Add(`0)">
          <source>Adds an item to an <ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> 개체에 항목을 추가합니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#Add(`0)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is less than <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, this method is an O(1) operation.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> 는 보다 작은 <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>,이 메서드는 o (1) 작업입니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#Add(`0)">
          <source>If the capacity must be increased to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">용량을 증가 시켜를 새 요소로 적용 해야 하는 경우이 메서드는 O 됩니다 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#Add(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph>이 읽기 전용인 경우</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source>Gets a value indicating whether a collection is read-only.</source>
          <target state="translated">컬렉션이 읽기 전용인지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the collection is read-only; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">컬렉션이 읽기 전용이면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">이 속성 값을 검색하는 것은 O(1) 연산입니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Returns an enumerator that iterates through a collection.</source>
          <target state="translated">컬렉션을 반복하는 열거자를 반환합니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> object that can be used to iterate through the collection.</source>
          <target state="translated">컬렉션을 반복하는 데 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of enumerators.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> C# 언어의 (<ph id="ph2">`for each`</ph> c + +에서는 <ph id="ph3">`For Each`</ph> Visual basic에서)은 열거자의 복잡성을 숨깁니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">그러므로 열거자를 직접 조작하는 대신 <ph id="ph1">`foreach`</ph>를 사용하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> property is undefined.</source>
          <target state="translated">이 위치에서의 <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> 속성이 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph>.</source>
          <target state="translated">따라서 호출 해야 합니다는 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 하 여 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소로 메서드 <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> property returns the same object until <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> 속성 반환 될 때까지 동일한 개체 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 호출 됩니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>는 <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph>를 다음 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">열거자가 있는 경우이 위치에 대 한 후속 호출에서 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환할 수도 <ph id="ph2">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">마지막으로 호출 하는 경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>You cannot set <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> to the first element of the collection again; you must create a new enumerator object instead.</source>
          <target state="translated">설정할 수 없습니다. <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> 다시; 컬렉션의 첫 번째 요소에 새 열거자 개체를 대신 만들어야 합니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace are not synchronized.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an enumerator that iterates through a collection.</source>
          <target state="translated">컬렉션을 반복하는 열거자를 반환합니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> object that can be used to iterate through the collection.</source>
          <target state="translated">컬렉션을 반복하는 데 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of enumerators.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> C# 언어의 (<ph id="ph2">`for each`</ph> c + +에서는 <ph id="ph3">`For Each`</ph> Visual basic에서)은 열거자의 복잡성을 숨깁니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">그러므로 열거자를 직접 조작하는 대신 <ph id="ph1">`foreach`</ph>를 사용하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>을 실행하면 열거자가 이 위치로 복원됩니다.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> property is undefined.</source>
          <target state="translated">이 위치에서의 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> 속성이 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">따라서 호출 해야 합니다는 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 하 여 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소로 메서드 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> property returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> 될 때까지 동일한 개체를 반환 하는 속성 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 또는 <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> 라고 합니다.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>는 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>를 다음 요소로 설정합니다.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph3">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">열거자가 있는 경우이 위치에 대 한 후속 호출에서 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환할 수도 <ph id="ph2">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">마지막으로 호출 하는 경우 <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> 반환 <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> 정의 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>를 컬렉션의 첫째 요소에 다시 설정하려면 <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>을 호출한 뒤 <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>를 호출해야 합니다.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace are not synchronized.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">이 메서드는 o (1) 작업.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.TrimExcess">
          <source>Sets the capacity of a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체의 용량을 실제로 포함된 요소 수로 설정하고 구현별로 다른 근방 값으로 반올림합니다.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.TrimExcess">
          <source>You can use the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.TrimExcess%2A&gt;</ph> method to minimize a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's memory overhead once it is known that no new elements will be added.</source>
          <target state="translated">사용할 수는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.TrimExcess%2A&gt;</ph> 최소화 하는 메서드는 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 새 요소가 삽입 되 알려진 개체의 메모리 오버 헤드입니다.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.TrimExcess">
          <source>To completely clear a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object and release all memory referenced by it, call this method after calling the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Clear%2A&gt;</ph> method.</source>
          <target state="translated">완전히 지울는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체 및 여기에서 참조 하는 모든 메모리를 해제 하 고,이 메서드를 호출한 후 호출는 <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Clear%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.TrimExcess">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 은 <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.TrimExcess">
          <source>The following example creates and populates a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection, and then clears the collection and releases the memory referenced by it.</source>
          <target state="translated">다음 예제를 만들고 채웁니다는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 컬렉션, 컬렉션을 지웁니다 고 여기에서 참조 하는 메모리를 해제 합니다.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체와 비교할 컬렉션입니다.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Modifies the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to contain all elements that are present in itself, the specified collection, or both.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> 개체를 수정하여 해당 개체와 지정된 컬렉션에 있는 모든 요소를 포함시킵니다.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`other`</ph> parameter.</source>
          <target state="translated">이 메서드는 O는 (<ph id="ph1">`n`</ph>) 작업, 여기서 <ph id="ph2">`n`</ph> 에 있는 요소의 수는 <ph id="ph3">`other`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example demonstrates how to merge two disparate sets.</source>
          <target state="translated">다음 예제에서는 서로 다른 두 집합을 병합 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>This example creates two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects, and populates them with even and odd numbers, respectively.</source>
          <target state="translated">이 예제에서는 두 개의 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 개체 하 고 각각에 및 홀수 번호에 채웁니다.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>A third <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is created from the set that contains the even numbers.</source>
          <target state="translated">세 번째 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> 짝수를 포함 하는 집합에서 개체가 만들어집니다.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> method, which adds the odd number set to the third set.</source>
          <target state="translated">이 예에서는 다음 호출는 <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> 메서드 홀수 집합 세 번째 집합에 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>