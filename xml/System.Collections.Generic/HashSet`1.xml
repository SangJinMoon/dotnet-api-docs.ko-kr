<Type Name="HashSet&lt;T&gt;" FullName="System.Collections.Generic.HashSet&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bd60a2feb07a08a4c2ff30ce143f1e02c4125256" />
    <Meta Name="ms.sourcegitcommit" Value="850a55c780d5a95b534467969add0232fd3a6125" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/07/2018" />
    <Meta Name="ms.locfileid" Value="34829130" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.HashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Class HashSet(Of T)&#xA;Implements ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable, ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class HashSet : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">해시 집합에 있는 요소의 형식입니다.</typeparam>
    <summary>값 집합을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.HashSet%601> 고성능 집합 작업 클래스를 제공 합니다. 없는 중복 요소를 포함 하는 컬렉션 집합이 요소가 임의의 순서로 합니다.  
  
> [!NOTE]
>  <xref:System.Collections.Generic.HashSet%601> 구현 하는 <xref:System.Collections.Generic.IReadOnlyCollection%601> 로 시작 하는 인터페이스는 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; 이전 버전의.NET Framework는 <xref:System.Collections.Generic.HashSet%601> 클래스는이 인터페이스를 구현 하지 않았습니다.  
  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체가 보유할 수 있는 요소의 수입니다. A <xref:System.Collections.Generic.HashSet%601> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.  
  
 <xref:System.Collections.Generic.HashSet%601> 클래스는 수학 집합의 모델에 기반 하 고 고성능 집합 작업의 키에 액세스 하는 유사한 제공는 <xref:System.Collections.Generic.Dictionary%602> 또는 <xref:System.Collections.Hashtable> 컬렉션입니다. 간단히 말해서에서는 <xref:System.Collections.Generic.HashSet%601> 클래스도 생각할 수 있습니다는 <xref:System.Collections.Generic.Dictionary%602> 값이 없는 컬렉션입니다.  
  
 A <xref:System.Collections.Generic.HashSet%601> 컬렉션 정렬 되지 않은 한 중복 요소를 포함할 수 없습니다. 순서나 요소 중복 응용 프로그램에 대 한 성능 보다 더 중요 한 경우에 사용 하 여는 <xref:System.Collections.Generic.List%601> 와 함께 클래스는 <xref:System.Collections.Generic.List%601.Sort%2A> 메서드.  
  
 <xref:System.Collections.Generic.HashSet%601> 많은 수학 집합 더하기 (합집합) 등의 작업을 설정 하 고 집합 빼기를 제공 합니다. 다음 표에 제공 된 <xref:System.Collections.Generic.HashSet%601> 작업 및 수학 상응 합니다.  
  
|HashSet (Of T) 작업|해당 하는 수학|  
|-------------------------------|-----------------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|Union 또는 설정 추가|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|교차|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|집합 빼기|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|대칭 차이|  
  
 나열 된 집합 작업 이외에 <xref:System.Collections.Generic.HashSet%601> 클래스 집합 같음, 집합, 잠금의 겹쳐진 부분을 결정 하기 위한 메서드도 제공 및 집합을 다른 집합의 상위 또는 하위 집합 인지 합니다.  
  
 에 대 한 매우 큰 <xref:System.Collections.Generic.HashSet%601> 개체를 설정 하 여 64 비트 시스템의 2 십억 요소에 최대 용량을 늘릴 수는 `enabled` 에 구성 요소의 특성 `true` 런타임 환경에서 합니다.  
  
 부터는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Collections.Generic.HashSet%601> 클래스가 구현 하는 <xref:System.Collections.Generic.ISet%601> 인터페이스입니다.  
  
## <a name="hashset-and-linq-set-operations"></a>HashSet 및 LINQ 집합 작업  
 LINQ에 대 한 액세스를 제공는 `Distinct`, `Union`, `Intersect` 및 `Except` 작업을 구현 하는 모든 데이터 원본에 설정 된 <xref:System.Collections.IEnumerable> 또는 <xref:System.Linq.IQueryable> 인터페이스입니다.  <xref:System.Collections.Generic.HashSet%601> 집합 작업의 더 큰 보다 강력 하 고 컬렉션을 제공 합니다. 예를 들어 <xref:System.Collections.Generic.HashSet%601> 비교와 같은 제공 <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> 및 <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>합니다.  
  
 LINQ 사이의 주요 차이점은 설정 작업 및 <xref:System.Collections.Generic.HashSet%601> 운영은 LINQ 집합 항상 반환 연산 새 <xref:System.Collections.Generic.IEnumerable%601> 컬렉션 반면는 <xref:System.Collections.Generic.HashSet%601> 동일한 메서드는 현재 컬렉션을 수정 합니다.  
  
 일반적으로 새 집합을 다시 만들어야 하는 경우 또는 응용 프로그램에서 제공 된 작업 집합에 대해서만 액세스 해야 하는 경우 LINQ를 사용 하 여 설정에서 작업을 <xref:System.Collections.Generic.IEnumerable%601> 컬렉션이 나 배열의 적용 됩니다. 그러나 응용 프로그램에 필요한 추가 집합 작업에 대 한 액세스 또는 바람직한 또는 새 컬렉션을 만드는 데 필요한 경우 사용할는 <xref:System.Collections.Generic.HashSet%601> 클래스입니다.  
  
 다음 표는 <xref:System.Collections.Generic.HashSet%601> 작업 및 해당 하는 LINQ의 set 작업이 있습니다.  
  
|HashSet (Of T) 작업|해당 하는 LINQ|  
|-------------------------------|---------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<xref:System.Linq.Enumerable.Union%2A>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<xref:System.Linq.Enumerable.Intersect%2A>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<xref:System.Linq.Enumerable.Except%2A>|  
|제공 되지 않습니다.|<xref:System.Linq.Enumerable.Distinct%2A>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSubsetOf%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSupersetOf%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>|제공 되지 않습니다.|  
  
   
  
## Examples  
 다음 예제에서는 서로 다른 두 집합을 병합 하는 방법을 보여 줍니다. 이 예제에서는 두 개의 <xref:System.Collections.Generic.HashSet%601> 개체 하 고 각각에 및 홀수 번호에 채웁니다. 세 번째 <xref:System.Collections.Generic.HashSet%601> 짝수를 포함 하는 집합에서 개체가 만들어집니다. 이 예에서는 다음 호출는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 메서드 홀수 집합 세 번째 집합에 추가 됩니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Generic.SortedSet`1" />
    <altmember cref="T:System.Collections.Generic.ISet`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>비어 있으며 집합 형식에 대한 기본 같음 비교자를 사용하는 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체가 보유할 수 있는 요소의 수입니다. A <xref:System.Collections.Generic.HashSet%601> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.  
  
 이 생성자는 o (1) 연산입니다.  
  
   
  
## Examples  
 다음 예제에서는 만들고 채우는 두 <xref:System.Collections.Generic.HashSet%601> 개체입니다. 이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 메서드.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">해당 요소가 새 집합에 복사되는 컬렉션입니다.</param>
        <summary>집합 형식에 대한 기본 같음 비교자를 사용하고 지정된 컬렉션에서 복사한 요소가 들어 있으며 복사된 요소 수를 수용하기에 용량이 충분한 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체가 보유할 수 있는 요소의 수입니다. A <xref:System.Collections.Generic.HashSet%601> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.  
  
 경우 `collection` 중복이 포함 집합 각각의 고유한 요소 중 하나가 포함 됩니다. 예외가 throw 됩니다. 따라서 결과 집합의 크기의 크기와 동일 하지는 `collection`합니다.  
  
 이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `collection` 매개 변수입니다.  
  
   
  
## Examples  
 만드는 방법을 보여 주는 다음 예제는 <xref:System.Collections.Generic.HashSet%601> 기존 집합을 수집 합니다. 이 예제에서는 두 개의 집합 만들어집니다 홀수, 짝수 정수로 각각. 세 번째 <xref:System.Collections.Generic.HashSet%601> 개체 집합에서 그런 다음 생성 됩니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">집합의 값을 비교하려면 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하고, 집합 형식에 대한 기본 <see cref="T:System.Collections.Generic.EqualityComparer`1" /> 구현을 사용하려면 <see langword="null" />을(를) 지정합니다.</param>
        <summary>비어 있으며 집합 형식에 대한 지정된 같음 비교자를 사용하는 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체가 보유할 수 있는 요소의 수입니다. A <xref:System.Collections.Generic.HashSet%601> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.  
  
 이 생성자는 o (1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Generic.HashSet`1" />의 초기 크기입니다.</param>
        <summary>비어 있지만 <paramref name="capacity" /> 항목에 대한 공간이 예약되어 있고 집합 형식에 대한 기본 같음 비교자를 사용하는 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 크기가 조정 되어는 상대적으로 비용이 많이 드는 (해싱하여 필요)의 값에 따라 초기 용량을 설정 하 여 크기를 조정 하려면 최소화 하기 위해이 시도 `capacity`합니다.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T), comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">해당 요소가 새 집합에 복사되는 컬렉션입니다.</param>
        <param name="comparer">집합의 값을 비교하려면 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하고, 집합 형식에 대한 기본 <see cref="T:System.Collections.Generic.EqualityComparer`1" /> 구현을 사용하려면 <see langword="null" />을(를) 지정합니다.</param>
        <summary>집합 형식에 대한 지정된 같음 비교자를 사용하고 지정된 컬렉션에서 복사한 요소가 들어 있으며 복사된 요소 수를 수용하기에 용량이 충분한 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체가 보유할 수 있는 요소의 수입니다. A <xref:System.Collections.Generic.HashSet%601> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.  
  
 경우 `collection` 중복이 포함 집합 각각의 고유한 요소 중 하나가 포함 됩니다. 예외가 throw 됩니다. 따라서 결과 집합의 크기의 크기와 동일 하지는 `collection`합니다.  
  
 이 생성자는는 O (`n`) 작업을 여기서 `n` 에 있는 요소의 수는 `collection` 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 제공 된 <xref:System.Collections.Generic.IEqualityComparer%601> 의 요소에 대해 대/소문자 구분 비교를 허용 하는 <xref:System.Collections.Generic.HashSet%601> 차량 유형의 컬렉션입니다.  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/source2.cpp#03)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/source2.cs#03)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/source2.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Generic.HashSet`1" />의 초기 크기입니다.</param>
        <param name="comparer">집합의 값을 비교하려면 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하고, 집합 형식에 대한 기본 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하려면 null(Visual Basic의 경우 Nothing)을 지정합니다.</param>
        <summary>집합 형식에 대해 지정된 같음 비교자를 사용하고 <paramref name="capacity" /> 요소를 수용할 수 있을 만큼 용량이 충분한 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 크기가 조정 되어는 상대적으로 비용이 많이 드는 (해싱하여 필요)의 값에 따라 초기 용량을 설정 하 여 크기를 조정 하려면 최소화 하기 위해이 시도 `capacity`합니다.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 serialize하는 데 필요한 정보가 포함된 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
        <param name="context">
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 연결되어 있는 serialize된 스트림의 소스와 대상이 포함된 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 구조체입니다.</param>
        <summary>serialize된 데이터를 사용하여 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 역직렬화 스트림을 통해 전송 되는 개체를 다시 구성 하는 동안 호출 됩니다. 자세한 내용은 참조 [XML 및 SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">집합에 추가할 요소입니다.</param>
        <summary>지정된 요소를 집합에 추가합니다.</summary>
        <returns>요소가 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 추가되었으면 <see langword="true" />이고, 요소가 이미 있으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 이미의 용량과 <xref:System.Collections.Generic.HashSet%601> 개체 용량 새 항목을 수용 하기 위해 자동으로 조정 됩니다.  
  
 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 작으면 내부 배열의 용량 보다이 메서드는 o (1) 작업입니다. 경우는 <xref:System.Collections.Generic.HashSet%601> 개체 크기를 조정 해야,이 메서드는 O 됩니다 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 만들고 채우는 두 <xref:System.Collections.Generic.HashSet%601> 개체입니다. 이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 메서드.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 요소를 모두 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.HashSet%601.Count%2A> 0으로 설정 된 한 컬렉션의 요소에 다른 개체에 대 한 참조도 해제 됩니다. 용량에 대 한 호출 될 때까지 변경 되지 않습니다 <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> 이루어집니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제를 만들고 채웁니다는 <xref:System.Collections.Generic.HashSet%601> 컬렉션 다음 삭제 하는 예제 및 컬렉션에 의해 참조 되는 메모리를 해제 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>집합의 값이 같은지 확인하는 데 사용되는 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 개체를 가져옵니다.</summary>
        <value>집합의 값이 같은지 확인하는 데 사용되는 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 찾을 요소입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 지정된 요소가 포함되어 있는지 확인합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 지정된 요소가 들어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 예제에서는 값을 제거 하는 방법을 <xref:System.Collections.Generic.HashSet%601> 사용 하 여 컬렉션의 <xref:System.Collections.Generic.HashSet%601.Remove%2A> 메서드. 이 예제는 <xref:System.Collections.Generic.HashSet%601.Contains%2A> 메서드 제거 하기 전에 집합에는 값이 들어 있는지 확인 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 컬렉션의 요소를 배열에 복사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 복사한 요소의 대상인 1차원 배열입니다. 배열에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체의 요소를 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 복사한 요소의 대상인 1차원 배열입니다. 배열에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex">
          <c>배열</c>에서 복사를 시작할 인덱스입니다. 이 인덱스는 0부터 시작합니다.</param>
        <summary>지정된 배열 인덱스에서 시작하여 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체의 요소를 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayIndex" />가 대상 <paramref name="array" />의 길이보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 복사한 요소의 대상인 1차원 배열입니다. 배열에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex">
          <c>배열</c>에서 복사를 시작할 인덱스입니다. 이 인덱스는 0부터 시작합니다.</param>
        <param name="count">
          <c>배열</c>에 복사할 요소 수입니다.</param>
        <summary>지정된 배열 인덱스에서 시작하여 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 지정된 수의 요소를 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 `count`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" />가 0보다 작습니다.  -또는-  <paramref name="count" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayIndex" />가 대상 <paramref name="array" />의 길이보다 큰 경우  -또는-  <paramref name="count" />가 <paramref name="index" />에서 대상 <paramref name="array" /> 끝까지 사용 가능한 공간보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>집합에 포함된 요소 수를 가져옵니다.</summary>
        <value>집합에 포함된 요소 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체가 보유할 수 있는 요소의 수입니다. A <xref:System.Collections.Generic.HashSet%601> 개체의 용량이 요소 개체에 추가 될 때 자동으로 증가 합니다.  
  
 용량 보다 크거나 같은 경우는 항상 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다. 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 요소를 추가 하는 동안 용량을 초과, 용량은 보다 큰 첫 번째 소수로으로 설정 됩니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 예제에서는을 채우고, 만들고, 조작 하는 두 개의 <xref:System.Collections.Generic.HashSet%601> 개체입니다. 이 예제에서는 두 집합의 내용과 및 <xref:System.Collections.Generic.HashSet%601.Count%2A> 콘솔에 표시 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.HashSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CreateSetComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer () As IEqualityComparer(Of HashSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::HashSet&lt;T&gt; ^&gt; ^ CreateSetComparer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 대한 같음 테스트에 사용할 수 있는 <see cref="T:System.Collections.IEqualityComparer" /> 개체를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 대한 전체 같음 테스트에 사용할 수 있는 <see cref="T:System.Collections.IEqualityComparer" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하지만 <xref:System.Collections.IEqualityComparer> 함께 연결할 수 있습니다 더 깊은 같음 테스트를 수행 하려면 추가 수준에서 비교자를 개체 하나만 수준에서 같은지 검사 합니다.  
  
 이 메서드를 호출 하는 것은 o (1) 작업입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 제거할 항목의 컬렉션입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 지정된 컬렉션의 모든 요소를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> 메서드는 수학 집합 빼기는 것에 해당 합니다.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 에 있는 요소의 수는 `other` 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 <xref:System.Collections.Generic.HashSet%601> 로 데이터 집합에 중복 되는 컬렉션입니다. 그런 다음 하위 범위의 값을 사용 하 여 더 큰 집합에서 제거 되 고 <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> 메서드.  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/program.cpp#02)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.HashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.HashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As HashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::HashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 반복되는 열거자를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 대한 <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서)은 열거자의 복잡성을 숨깁니다. 따라서 사용 하 여 `foreach` 열거자를 직접 조작 하는 대신 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. 이 위치에서의 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 속성이 정의 되지 않습니다. 따라서 호출 해야 합니다는 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 하 여 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소로 메서드 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>합니다.  
  
 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 속성 반환 될 때까지 동일한 개체 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 호출 됩니다. <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A>는 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 정의 되지 않습니다. 설정할 수 없습니다. <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 다시; 컬렉션의 첫 번째 요소에 새 열거자 개체를 대신 만들어야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 변경, 추가 하는 등 컬렉션을 수정 하거나 요소를 삭제 하면 열거자가 더 유효 하지 않으며을 다음에 호출할 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 또는 <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> throw는 <xref:System.InvalidOperationException>합니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 serialize하는 데 필요한 정보가 포함된 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
        <param name="context">
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 연결되어 있는 serialize된 스트림의 소스와 대상이 포함된 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 구조체입니다.</param>
        <summary>
          <see cref="T:System.Runtime.Serialization.ISerializable" /> 인터페이스를 구현하고 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 serialize하는 데 필요한 데이터를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 O (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">serialization 서비스를 제공 합니다. 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 수정하여 해당 개체와 지정된 컬렉션에 동시에 있는 요소만 포함합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 으로 표시 되는 컬렉션의 `other` 매개 변수는 한 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O는 (`n`) 작업 합니다. 그렇지 않으면이 메서드는는 O (`n` + `m`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A> 및 `m` 에 있는 요소의 수는 `other`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 적합한 하위 집합인지 확인합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 적합한 하위 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 빈 집합은 다른 컬렉션의 적절 한 하위 집합입니다. 따라서이 메서드는 반환 `true` 현재 나타내는 컬렉션이 <xref:System.Collections.Generic.HashSet%601> 개체가 비어 경우가 아니면는 `other` 매개 변수는 빈 집합 이기도 합니다.  
  
 이 메서드는 항상 반환 `false` 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 에 있는 요소의 수를 보다 크거나 `other`합니다.  
  
 컬렉션으로 표시 되는 `other` 는 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체 면이 메서드는 O (`n`) 작업입니다. 그렇지 않으면이 메서드는는 O (`n` + `m`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A> 및 `m` 에 있는 요소의 수는 `other`합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 이 예제에서는 `lowNumbers` 의 적절 한 하위 집합 및 하위 집합 `allNumbers` 될 때까지 `allNumbers` 를 사용 하 여 수정 되는 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 있는 값만 포함 합니다. 한 번 `allNumbers` 및 `lowNumbers` 동일 `lowNumbers` 의 하위 집합은 여전히 `allNumbers` 하지만 더 이상 적절 한 하위 집합입니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 적합한 상위 집합인지 확인합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 적합한 상위 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 빈 집합은 다른 컬렉션의 적절 한 상위 집합입니다. 따라서이 메서드는 반환 `true` 컬렉션으로 표시 되는 `other` 매개 변수는 비어 하지 않으면 현재 <xref:System.Collections.Generic.HashSet%601> 또한 컬렉션은 비어 있습니다.  
  
 이 메서드는 항상 반환 `false` 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 의 요소 수가 보다 작은 `other`합니다.  
  
 컬렉션으로 표시 되는 `other` 는 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O는 (`n`) 작업입니다. 그렇지 않으면이 메서드는는 O (`n` + `m`) 작업, 여기서 `n` 에 있는 요소의 수는 `other` 및 `m` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 이 예제에서는 `allNumbers` 는 상위 집합 하면서의 적절 한 상위 집합이 `lowNumbers` 될 때까지 `allNumbers` 를 사용 하 여 수정 되는 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 있는 값만 포함 합니다. 한 번 `allNumbers` 및 `lowNumbers` 동일 `allNumbers` 의 상위 집합은 여전히 `lowNumbers` 하지만 더 이상 적절 한 상위 집합입니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 하위 집합인지 확인합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 하위 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 빈 집합은;는 빈 집합을 포함 하 여 모든 다른 컬렉션의 하위 집합 따라서이 메서드는 반환 `true` 현재 나타내는 컬렉션이 <xref:System.Collections.Generic.HashSet%601> 개체가 비어 경우에는 `other` 매개 변수는 빈 집합입니다.  
  
 이 메서드는 항상 반환 `false` 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 의 요소 수보다 큽니다 `other`합니다.  
  
 컬렉션으로 표시 되는 `other` 는 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O는 (`n`) 작업입니다. 그렇지 않으면이 메서드는는 O (`n` + `m`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A> 및 `m` 에 있는 요소의 수는 `other`합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 이 예제에서는 `lowNumbers` 의 적절 한 하위 집합 및 하위 집합 `allNumbers` 될 때까지 `allNumbers` 를 사용 하 여 수정 되는 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 있는 값만 포함 합니다. 한 번 `allNumbers` 및 `lowNumbers` 동일 `lowNumbers` 의 하위 집합은 여전히 `allNumbers` 하지만 더 이상 적절 한 하위 집합입니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 상위 집합인지 확인합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 상위 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 컬렉션을 빈 집합을 포함 하는 빈 집합의 상위 집합입니다. 따라서이 메서드는 반환 `true` 으로 표시 되는 컬렉션의 `other` 매개 변수가 비어 경우에 현재 <xref:System.Collections.Generic.HashSet%601> 개체가 비어 있습니다.  
  
 이 메서드는 항상 반환 `false` 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 에 있는 요소의 수보다 작을 경우 `other`합니다.  
  
 컬렉션으로 표시 되는 `other` 는 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O는 (`n`) 작업입니다. 그렇지 않으면이 메서드는는 O (`n` + `m`) 작업, 여기서 `n` 에 있는 요소의 수는 `other` 및 `m` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 이 예제에서는 `allNumbers` 는 상위 집합 하면서의 적절 한 상위 집합이 `lowNumbers` 될 때까지 `allNumbers` 를 사용 하 여 수정 되는 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 있는 값만 포함 합니다. 한 번 `allNumbers` 및 `lowNumbers` 동일 `allNumbers` 의 상위 집합은 여전히 `lowNumbers` 하지만 더 이상 적절 한 상위 집합입니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">deserialization 이벤트의 소스입니다.</param>
        <summary>
          <see cref="T:System.Runtime.Serialization.ISerializable" /> 인터페이스를 구현하고, deserialization이 완료되면 deserialization 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 O (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">현재 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체와 관련된 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 잘못된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 지정된 컬렉션이 공통 요소를 공유하는지 확인합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 <paramref name="other" />이(가) 요소를 하나 이상 공유하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 에 있는 요소의 수는 `other`합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 이 예제에서는 `allNumbers` 및 `lowNumbers` 를 사용 하 여 공통 요소를 공유 하도록 표시 된는 <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> 메서드.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">제거할 요소입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 지정된 요소를 제거합니다.</summary>
        <returns>요소를 성공적으로 찾아서 제거한 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.  <paramref name="item" /> 개체에 <see cref="T:System.Collections.Generic.HashSet`1" />이(가) 없으면 이 메서드는 <see langword="false" />을(를) 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Collections.Generic.HashSet%601> 개체는 지정된 된 요소를 포함 하지 않습니다, 개체가 변경 되지 않습니다. 예외가 throw되지 않습니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 예제에서는 값을 제거 하는 방법을 <xref:System.Collections.Generic.HashSet%601> 사용 하 여 컬렉션의 <xref:System.Collections.Generic.HashSet%601.Remove%2A> 메서드. 이 예제에서는 임의로 0을 제거에서 <xref:System.Collections.Generic.HashSet%601> 컬렉션입니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveWhere (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveWhere(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">제거할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 컬렉션에서 지정된 조건자에 정의된 조건과 일치하는 요소를 모두 제거합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 컬렉션에서 제거된 요소의 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 O (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 값을 제거 하는 방법을 <xref:System.Collections.Generic.HashSet%601> 사용 하 여 컬렉션의 <xref:System.Collections.Generic.HashSet%601.Remove%2A> 메서드. 이 예제에서는 모든 홀수에서 제거 됩니다는 <xref:System.Collections.Generic.HashSet%601> 컬렉션에 지정 된 대로 `match` 위임 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 지정된 컬렉션에 같은 요소가 포함되어 있는지 확인합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />과(와) 같으면 <see langword="true" />이고, 그렇지 않으면 false입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> 메서드가 중복 된 항목 및에서 요소의 순서를 무시는 `other` 매개 변수입니다.  
  
 컬렉션으로 표시 되는 `other` 는 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O는 (`n`) 작업입니다. 그렇지 않으면이 메서드는는 O (`n` + `m`) 작업, 여기서 `n` 에 있는 요소의 수는 `other` 및 `m` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 처음에 두 집합 서로 다름을 사용 하 여 보여 줍니다는 <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> 메서드. `allNumbers` <xref:System.Collections.Generic.HashSet%601> 지나면 집합이 같으면 개체는 수정 됩니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SymmetricExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 수정하여 해당 개체와 지정된 컬렉션 중 하나에 있는 요소만 포함합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `other` 매개 변수는 한 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O는 (`n`) 작업입니다. 그렇지 않으면이 메서드는는 O (`n` + `m`) 작업, 여기서 `n` 에 있는 요소의 수는 `other` 및 `m` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 <xref:System.Collections.Generic.HashSet%601> 로 데이터 집합에 중복 되는 컬렉션입니다. 낮은 값을 포함 하는 집합은 다음 수정 하 여는 <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> 메서드를 두 집합 모두에 존재 하지 않는 값만 포함 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.ICollection`1" /> 개체에 추가할 개체입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.ICollection`1" /> 개체에 항목을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 <xref:System.Collections.Generic.List%601.Count%2A> 는 보다 작은 <xref:System.Collections.Generic.List%601.Capacity%2A>,이 메서드는 o (1) 작업입니다. 용량을 증가 시켜를 새 요소로 적용 해야 하는 경우이 메서드는 O 됩니다 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Generic.ICollection`1" />이 읽기 전용인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컬렉션이 읽기 전용인지를 나타내는 값을 가져옵니다.</summary>
        <value>컬렉션이 읽기 전용이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
        <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.Generic.IEnumerator`1" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서)은 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. 이 위치에서의 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 속성이 정의 되지 않습니다. 따라서 호출 해야 합니다는 <xref:System.Collections.IEnumerator.MoveNext%2A> 하 여 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소로 메서드 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>합니다.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 속성 반환 될 때까지 동일한 개체 <xref:System.Collections.IEnumerator.MoveNext%2A> 호출 됩니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 정의 되지 않습니다. 설정할 수 없습니다. <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 다시; 컬렉션의 첫 번째 요소에 새 열거자 개체를 대신 만들어야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
        <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서)은 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다.  이 위치에서의 <xref:System.Collections.IEnumerator.Current%2A> 속성이 정의 되지 않습니다. 따라서 호출 해야 합니다는 <xref:System.Collections.IEnumerator.MoveNext%2A> 하 여 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소로 메서드 <xref:System.Collections.IEnumerator.Current%2A>합니다.  
  
 <xref:System.Collections.IEnumerator.Current%2A> 될 때까지 동일한 개체를 반환 하는 속성 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A> 라고 합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.IEnumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> 개체의 용량을 실제로 포함된 요소 수로 설정하고 구현별로 다른 근방 값으로 반올림합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> 최소화 하는 메서드는 <xref:System.Collections.Generic.HashSet%601> 새 요소가 삽입 되 알려진 개체의 메모리 오버 헤드입니다. 완전히 지울는 <xref:System.Collections.Generic.HashSet%601> 개체 및 여기에서 참조 하는 모든 메모리를 해제 하 고,이 메서드를 호출한 후 호출는 <xref:System.Collections.Generic.HashSet%601.Clear%2A> 메서드.  
  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제를 만들고 채웁니다는 <xref:System.Collections.Generic.HashSet%601> 컬렉션, 컬렉션을 지웁니다 고 여기에서 참조 하는 메모리를 해제 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue">검색할 값입니다.</param>
        <param name="actualValue">집합에서 검색한 값입니다. 검색에서 일치하는 항목을 찾지 못한 경우 T의 기본값입니다.</param>
        <summary>집합에서 지정된 값을 검색하여 동일한 값을 찾은 경우 해당 값을 반환합니다.</summary>
        <returns>검색에 성공했는지 여부를 나타내는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 경우 유용할 수 있습니다 (참조의 더 많은 공유 발생할 수 있도록) 대신 새로 생성 된 이전에 저장 된 참조를 다시 사용 하거나 있지만 현재 있는 값 보다 자세한 데이터를 포함 하는 값을 조회 하는 비교자 함수 같은지를 나타냅니다.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnionWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 수정하여 해당 개체와 지정된 컬렉션에 있는 모든 요소를 포함시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O는 (`n`) 작업, 여기서 `n` 에 있는 요소의 수는 `other` 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 서로 다른 두 집합을 병합 하는 방법을 보여 줍니다. 이 예제에서는 두 개의 <xref:System.Collections.Generic.HashSet%601> 개체 하 고 각각에 및 홀수 번호에 채웁니다. 세 번째 <xref:System.Collections.Generic.HashSet%601> 짝수를 포함 하는 집합에서 개체가 만들어집니다. 이 예에서는 다음 호출는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 메서드 홀수 집합 세 번째 집합에 추가 됩니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
  </Members>
</Type>