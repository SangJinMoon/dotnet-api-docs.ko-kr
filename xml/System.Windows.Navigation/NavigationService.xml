<Type Name="NavigationService" FullName="System.Windows.Navigation.NavigationService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d4d64e95223ead25be6eb0a447e2f5dd78e82b25" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36465085" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NavigationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NavigationService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Navigation.NavigationService" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NavigationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class NavigationService sealed" />
  <TypeSignature Language="F#" Value="type NavigationService = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contains methods, properties, and events to support navigation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService> 브라우저 스타일 탐색의 컨텍스트 내에서 콘텐츠를 다운로드 하는 기능을 캡슐화 합니다.  
  
 콘텐츠는.NET Framework 개체와 HTML 파일 형식일을 수 있습니다. 그러나 일반적으로 페이지는 콘텐츠를 탐색 하는 방법으로 기본 설정 (참조 <xref:System.Windows.Controls.Page>).  
  
 개체의 인스턴스를 제공 하 고 오버 로드를 호출 하 여 콘텐츠를 탐색할 수 있습니다는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 개체를 받는 메서드:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>  
  
 또는 콘텐츠 탐색할 수 있습니다는 상대 또는 절대 URI 중 하나로 전달 하 여는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> URI를 허용 하는 메서드 오버 로드 합니다.  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%2CSystem.Boolean%29?displayProperty=nameWithType>  
  
 URI에서 콘텐츠를 탐색 하는 경우 <xref:System.Windows.Navigation.NavigationService> 콘텐츠를 포함 하는 개체를 반환 합니다.  
  
 다음 이벤트를 통해 탐색 수명을 추적할 수 있습니다.  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigated>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
-   <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
-   <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>.  
  
 일부 이벤트가 발생 될 때마다 탐색에는 다음이 발생 합니다. 발생 하는 이벤트 집합이 (취소, 중지, 또는 실패) 형식 (콘텐츠 또는 콘텐츠 조각) 발생 하는 탐색 및 탐색이 완료 되는 방식에 따라 결정 됩니다.  
  
 다음 그림에서는 이러한 이벤트는 발생 순서를 보여 줍니다.  
  
 ![페이지 탐색 흐름 차트](~/add/media/navigationoverviewfigure11.png "페이지 탐색 흐름 차트")  
  
 중 이나 탐색 후 <xref:System.Windows.Navigation.NavigationService> 탐색 중인, 탐색 중인 콘텐츠에의 URI를 포함 하 여 콘텐츠에 대 한 정보를 제공 (<xref:System.Windows.Navigation.NavigationService.Source%2A>), 현재 콘텐츠의 URI (<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>), 그리고 포함 된 개체는 탐색 된 콘텐츠 (<xref:System.Windows.Navigation.NavigationService.Content%2A>).  
  
 콘텐츠 탐색 <xref:System.Windows.Navigation.NavigationService> 탐색 기록의 항목으로 탐색 기록 합니다. 호출 하 여 새 탐색 발생할 때 탐색 기록 백업 하는 항목이 추가 됩니다는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 메서드를 호출 하 여 앞으로 탐색 기록의 항목으로 이동 하 여 또는 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>합니다. 항목이 이동 하 여 뒤에 항목으로 호출 하 여 앞으로 탐색 기록에 추가 됩니다 <xref:System.Windows.Navigation.NavigationService.GoBack%2A>합니다. <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 및 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 있는지 여부를 보고 하 고 앞으로 탐색 기록 항목 뒤에 각각 있습니다. 또한 가장 최근 항목 뒤에 호출 하 여 탐색 기록을 제거할 수 있습니다 <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>합니다.  
  
 기본적으로 <xref:System.Windows.Navigation.NavigationService> 탐색 기록의 콘텐츠 개체의 인스턴스를 저장 하지 않습니다. 대신, <xref:System.Windows.Navigation.NavigationService> 탐색 기록을 사용 하 여 탐색할 될 때마다 콘텐츠 개체의 새 인스턴스를 만듭니다. 이 문제는 많은 수 및 대규모 콘텐츠를 탐색할 때 과도 한 메모리 소비를 방지 하도록 설계 되었습니다. 따라서 콘텐츠 상태는 다음 탐색에서 저장 되지 않습니다. 그러나 WPF 탐색 기록의 콘텐츠의 부분에 대 한 상태를 저장할 수 있는 몇 가지 방법을 제공 합니다.  
  
 사용 하 여 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>, 여러 인스턴스를 단일 페이지에 대 한 상태 집합을 기억할 수도 있습니다.  
  
 <xref:System.Windows.Navigation.NavigationService> 이 `sealed` 클래스 및 따라서 인스턴스화할 수 없습니다; 대신, <xref:System.Windows.Navigation.NavigationService> 기가 탐색을 설정 하는 데 사용 됩니다. WPF에는 두 탐색기: <xref:System.Windows.Navigation.NavigationWindow> 및 <xref:System.Windows.Controls.Frame>합니다.  
  
 시각적으로 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 사용 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 통합 된 사용자 환경을 제공할 수 있도록을 탐색기로 합니다. 물리적으로 그러나 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 실제로 사용 하 여 <xref:System.Windows.Navigation.NavigationWindow> 탐색기;로 <xref:System.Windows.Application.MainWindow%2A> 속성의는 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 에서 실행 중인 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 에 대 한 참조를 반환 합니다는 <xref:System.Windows.Navigation.NavigationWindow>, 및 탐색 기록에서 관리 되는 <xref:System.Windows.Navigation.NavigationWindow> 탐색 기록에서 관리 되는 통합 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 다음과 같은 방법으로:  
  
-   호출 하 여 콘텐츠를 탐색 하는 경우 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, 및 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> 내에서 한 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 관련 탐색 기록 항목에도 추가 됩니다 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 탐색 기록 합니다.  
  
-   때 항목에는 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 탐색 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 선택 되어 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 하면 <xref:System.Windows.Navigation.NavigationService> 이러한 항목에 연관 된 콘텐츠를 뒤로 또는 앞으로 이동 하려면.  
  
> [!NOTE]
>  A <xref:System.Windows.Controls.Frame> 호스팅하고 있는 탐색기의 탐색 기록을 사용 하 여 또는 자체 탐색 기록을 제공할 수 있습니다. 경우 <xref:System.Windows.Controls.Frame> 자체 탐색 기록을 제공 자체 탐색을 표시 하려면 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 탐색 기록의 항목을 탐색 하려면 해당 항목을 호스트 탐색기의 탐색 기록에 추가 되지 않습니다 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, [!INCLUDE[TLA2#tla_iegeneric](~/includes/tla2sharptla-iegeneric-md.md)]) 따라서을 탐색할 수 없습니다 탐색에서 및 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 각 (참조 <xref:System.Windows.Controls.Frame.JournalOwnership%2A>).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddBackEntry : System.Windows.Navigation.CustomContentState -&gt; unit" Usage="navigationService.AddBackEntry state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Windows.Navigation.CustomContentState" /> object that represents application-defined state that is associated with a specific piece of content.</param>
        <summary>Adds an entry to back navigation history that contains a <see cref="T:System.Windows.Navigation.CustomContentState" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A><xref:System.Windows.Navigation.CustomContentState>, 및 <xref:System.Windows.Navigation.IProvideCustomContentState> 여러 집합이 현재 콘텐츠에 대 한 상태를 기억 하는 데 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="state" /> is <see langword="null" />, and a <see cref="T:System.Windows.Navigation.CustomContentState" /> object isn't returned from <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" />.</exception>
        <altmember cref="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether there is at least one entry in back navigation history.</summary>
        <value>
          <see langword="true" /> 뒤로 탐색 기록에 적어도 하나의 항목이 없는 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 뒤로 탐색 기록에서 하나 이상의 항목이 있는지 여부를 결정 합니다. 호출 하기 전에이 속성을 검사 해야 <xref:System.Windows.Navigation.NavigationService.GoBack%2A>경우 <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 라고 뒤로 탐색 기록의 항목이 고는 <xref:System.InvalidOperationException> throw 됩니다.  
  
> [!NOTE]
>  여러 탐색기에서 탐색 기록을 공유 하는 경우 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>)는 가장 최근 항목 뒤에 탐색 기록 되지 추가 된 여는 <xref:System.Windows.Navigation.NavigationService> 현재 탐색기에 대 한 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether there is at least one entry in forward navigation history.</summary>
        <value>
          <see langword="true" /> 앞으로 탐색 기록에 적어도 하나의 항목이 없는 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 앞으로 탐색 기록에서 하나 이상의 항목이 있는지 여부를 결정 합니다. 호출 하기 전에이 속성을 검사 해야 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>경우 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> 라고 있고 앞으로 탐색 기록에 항목이 없습니다.이 <xref:System.InvalidOperationException> throw 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Navigation.NavigationService.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a reference to the object that contains the current content.</summary>
        <value>현재 콘텐츠를 포함 하는 개체에 대 한 참조는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두 가지 방법 중 하나에서 콘텐츠를 설정할 수 있습니다.  
  
-   개체에 대 한 참조로 설정으로 직접 합니다.  
  
-   를 직접 호출 하 여 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, 또는 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>합니다.  
  
 설정 <xref:System.Windows.Navigation.NavigationService> 탐색 비동기 이므로 새 탐색; 시작 <xref:System.Windows.Navigation.NavigationService.Content%2A> 설정 된 후 바로 검사 하면 값을 반환 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSource : Uri" Usage="System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the URI of the content that was last navigated to.</summary>
        <value>A <see cref="T:System.Uri" /> URI를 사용 하 여 탐색 하 고, 그렇지 않으면 마지막으로 탐색 하는 콘텐츠에 대 한 <see langword="null" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값은 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> 다른 URI로 탐색 성공적으로 완료 되기 전에 속성이 변경 되지 않습니다.  
  
 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> 한 조각만 URI로 설정할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when navigation to a content fragment begins, which occurs immediately, if the desired fragment is in the current content, or after the source [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] content has been loaded, if the desired fragment is in different content.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 콘텐츠 조각을 콘텐츠 즉 명명 된 포함 된 <xref:System.Windows.UIElement>,이 <xref:System.Windows.UIElement> 인 <xref:System.Windows.FrameworkElement.Name%2A> 특성 설정 된:  
  
```  
<TextBlock Name="FragmentName">...</TextBlock>  
```  
  
 로 이동는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 다음과 같은 형식의 접미사와 함께 URI를 제공 하 여 조각:  
  
 \#*FragmentName*  
  
 다음 콘텐츠 조각으로 참조 하는 URI의 예를 보여 줍니다.  
  
 `http://www.microsoft.com/targetpage.xaml#FragmentName`  
  
 원본 페이지를 로드 한 후 (후 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 이벤트가 발생), 조각 탐색이 시작 되 고 <xref:System.Windows.Navigation.NavigationService> 찾으려고 시도 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 조각 합니다. 경우는 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 조각이 <xref:System.Windows.Navigation.NavigationService> 지시 내용 보기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) 하는 조각을 보여 줍니다. 처리할 수 있습니다이 동작을 변경 해야 할 경우 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 사용자 고유의 조각을 탐색 동작을 제공 합니다. <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 전달 되는 <xref:System.Windows.Navigation.FragmentNavigationEventArgs> 이 작업을 위해 유용한 속성을 노출 하는 포함 하 여:  
  
-   이 탐색 서비스를 소유 하 여 탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   조각 이름입니다.  
  
 처리할 수 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 지정 구현으로 기본 WPF 조각 구현을 재정의 하 합니다. 이렇게 하면 경우 설정 해야 <xref:System.Windows.Navigation.FragmentNavigationEventArgs.Handled%2A> 를 `true`, 그렇지 않으면 기본 WPF 조각 처리 동작이 적용 됩니다.  
  
 직접 내에서 탐색을 시작 하지 않아야는 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 이벤트 처리기입니다. 이후 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 에서 새 탐색을 시작 하는 기존 탐색 중에 발생 한 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 이벤트 처리기를 일으킬 수 있는 중첩 된 탐색을 만듭니다는 <xref:System.ExecutionEngineException> throw 됩니다. 대신, 있습니다 간접적으로 시작할 수 탐색 항목를 사용 하 여 비동기 작업을 만들어는 <xref:System.Windows.Threading.Dispatcher>합니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>, 발생 <xref:System.Windows.Application.FragmentNavigation?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
> [!IMPORTANT]
>  조각 탐색 느슨하게 지원 되지 않습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 페이지 (태그 전용 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 확장명이 `Page` 루트 요소로) 다음과 같은 경우:  
>   
>  • 느슨한의 조각으로 이동 하는 경우 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 페이지.  
>   
>  • 느슨한를 탐색할 때 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 느슨한 다른 조각에는 페이지 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 페이지.  
>   
>  그러나 느슨한 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 페이지 자체 조각을 탐색할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다. <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 사용자 지정 조각 탐색 동작을 제공 합니다. 이 경우 오류를 열고 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 페이지 경우 원본에 조각의 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 페이지를 찾을 수 없습니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowfragmentnavigationcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowfragmentnavigationcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetNavigationService">
      <MemberSignature Language="C#" Value="public static System.Windows.Navigation.NavigationService GetNavigationService (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Navigation.NavigationService GetNavigationService(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GetNavigationService(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Navigation::NavigationService ^ GetNavigationService(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetNavigationService : System.Windows.DependencyObject -&gt; System.Windows.Navigation.NavigationService" Usage="System.Windows.Navigation.NavigationService.GetNavigationService dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">The <see cref="T:System.Windows.DependencyObject" /> in content that is hosted by a navigator.</param>
        <summary>Gets a reference to the <see cref="T:System.Windows.Navigation.NavigationService" /> for the navigator whose content contains the specified <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>A reference to the <see cref="T:System.Windows.Navigation.NavigationService" /> for the navigator whose content contains the specified <see cref="T:System.Windows.DependencyObject" />; can be <see langword="null" /> in some cases.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기에는 <xref:System.Windows.Navigation.NavigationService> 콘텐츠 탐색을 처리 하는 합니다. WPF에는 두가지: <xref:System.Windows.Navigation.NavigationWindow> 및 <xref:System.Windows.Controls.Frame>합니다. 탐색기 탐색 요청 처리를 탐색 수명 관리 및 요소로 구현 되는 WPF 탐색 서비스를 사용 하 여 <xref:System.Windows.Navigation.NavigationService> 클래스입니다. 탐색기에서 호스트 되는 콘텐츠에 탐색기의에 대 한 참조를 가져올 수 <xref:System.Windows.Navigation.NavigationService> 호출 하 여는 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> 메서드.  
  
 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> 반환 `null` 때는 `dependencyObject`:  
  
-   이 <xref:System.Windows.Navigation.NavigationWindow>합니다.  
  
-   이 <xref:System.Windows.Controls.Frame> 입니다.  
  
    1.  다른 탐색기에 의해 호스팅됩니다.  
  
    2.  에 해당 <xref:System.Windows.Controls.Frame.JournalOwnership%2A> 속성이로 설정 <xref:System.Windows.Navigation.JournalOwnership.UsesParentJournal>합니다.  
  
-   탐색기에서 호스팅하는 콘텐츠 일부가 아닙니다.  
  
 WPF에 대 한 참조를 인식 하기 위한 두 개의 바로 가기를 제공는 <xref:System.Windows.Navigation.NavigationService>:  
  
-   <xref:System.Windows.Navigation.NavigationService> 탐색을 처리 하는 <xref:System.Windows.Controls.Page> 에서 액세스할 수는 <xref:System.Windows.Controls.Page> 자체의 값을 가져오고 해당 <xref:System.Windows.Controls.Page.NavigationService%2A?displayProperty=nameWithType> 속성입니다.  
  
-   <xref:System.Windows.Navigation.NavigationService> 에서 사용 하는 <xref:System.Windows.Controls.Frame> 탐색을 처리 하 여 값을 가져오는 액세스할 수 있습니다는 <xref:System.Windows.Controls.Frame.NavigationService%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 어떻게는 <xref:System.Windows.Controls.UserControl> 탐색 서비스를 호출 하 여 검색할 수 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>합니다.  
  
 [!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode1)]
 [!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode1)]  
[!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode2)]
[!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="dependencyObject" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="navigationService.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navigates to the most recent entry in back navigation history, if there is one.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하기 전에 <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 뒤로 탐색 기록의 항목이 있는지 여부를 확인 하려면 속성을 검사할 수 있습니다.  
  
   
  
## Examples  
 다음 예에서는 탐색 뒤에 가장 최근 항목에 탐색 기록 있는 경우.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowbackcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowbackcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Navigation.NavigationService.GoBack" /> is called when there are no entries in back navigation history.</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="navigationService.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navigate to the most recent entry in forward navigation history, if there is one.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하기 전에 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>, <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 앞으로 탐색 기록에서 항목이 있는지 여부를 확인 하려면 속성을 검사할 수 있습니다.  
  
   
  
## Examples  
 있는 경우 다음 예제에서는 앞으로 탐색 기록의 가장 최근 항목으로 이동 합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowforwardcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowforwardcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Navigation.NavigationService.GoForward" /> is called when there are no entries in forward navigation history.</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when content that was navigated to has been loaded, parsed, and has begun rendering.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처리할 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 로드가 완료 될 때 탐색 요청 관련 정보를 검색 하려는 경우. 이 정보는에서 사용할 수는 <xref:System.Windows.Navigation.NavigationEventArgs> 에 전달 되는 개체는 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 이벤트 처리기와 포함:  
  
-   내용과 해당 URI입니다.  
  
-   탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   추가 데이터를 호출 하 여 탐색을 시작한 경우 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 또는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>합니다.  
  
-   응답 세부 정보 (사용 하는 <xref:System.Net.WebResponse> 개체).  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 원본 페이지를 찾을 수 또는 쿼리에서 로드할 수 없을 때 발생 하지 않는 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 발생 합니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.LoadCompleted>, 발생 <xref:System.Windows.Application.LoadCompleted?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다. <xref:System.Windows.Navigation.NavigationService.LoadCompleted>합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowloadcompletedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowloadcompletedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Navigate asynchronously to the specified source content.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj -&gt; bool" Usage="navigationService.Navigate root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">An object that contains the content to navigate to.</param>
        <summary>Navigate asynchronously to content that is contained by an object.</summary>
        <returns>
          <see langword="true" /> if a navigation is not canceled; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 으로 이동 되는 <xref:System.Object> 에 지정 된 `root` 다음 조건이 true 인 경우:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating> 이벤트는 취소 되지 않습니다.  
  
-   웹 요청 (참조 <xref:System.Windows.Navigation.NavigationService.Navigating>)를 만들 수 있습니다.  
  
 경우 `root` 은 `null`, 기존 콘텐츠 (<xref:System.Windows.Navigation.NavigationService.Content%2A>)의 선택을 취소 합니다.  
  
> [!NOTE]
>  웹 콘텐츠를 다운로드할 웹 예외가 나타날 수 있습니다 (예를 들어 404: 파일을 찾을 수 없습니다). 이러한 예외를 처리할 수 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>합니다.  
  
   
  
## Examples  
 다음 예제에서는 이동 하는 방법을 보여 줍니다는 <xref:System.Windows.Controls.Page> 원본 콘텐츠 트리를 포함 하는 개체입니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigateobjectcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigateobjectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; bool" Usage="navigationService.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">A <see cref="T:System.Uri" /> object initialized with the URI for the desired content.</param>
        <summary>Navigate asynchronously to content that is specified by a URI.</summary>
        <returns>
          <see langword="true" /> if a navigation is not canceled; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값 `source` 은 웹 [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] 또는 유효한 pack URI (참조 [WPF의 Pack Uri](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 이 지정 된 URI로 탐색 `source` 다음 조건이 true 인 경우:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating> 이벤트는 취소 되지 않습니다.  
  
-   웹 요청 (참조 <xref:System.Windows.Navigation.NavigationService.Navigating>)를 만들 수 있습니다.  
  
 경우 `source` 은 `null`, 기존 콘텐츠 (<xref:System.Windows.Navigation.NavigationService.Content%2A>)의 선택을 취소 합니다.  
  
> [!NOTE]
>  웹 콘텐츠를 다운로드할 웹 예외가 나타날 수 있습니다 (예를 들어 404: 파일을 찾을 수 없습니다). 이러한 예외를 처리할 수 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>합니다.  
  
 사용할 수 있습니다 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 콘텐츠 조각 탐색 합니다. 현재 콘텐츠가 콘텐츠 URI로 식별을 사용 하는 경우 다시 다운로드 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 URI로 이동 하는 방법을 보여 줍니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatecode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatecode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj * obj -&gt; bool" Usage="navigationService.Navigate (root, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">An object that contains the content to navigate to.</param>
        <param name="navigationState">An object that contains data to be used for processing during navigation.</param>
        <summary>Navigate asynchronously to content that is contained by an object, and pass an object that contains data to be used for processing during navigation.</summary>
        <returns>
          <see langword="true" /> if a navigation is not canceled; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 같은 동작 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>않더라도 개체는 URI 대신 전달 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 이동 하는 방법을 보여 줍니다는 <xref:System.Windows.Controls.Page> 개체는 원본 콘텐츠를 포함 하 고 탐색 상태를 전달 합니다.  
  
 [!code-csharp[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj -&gt; bool" Usage="navigationService.Navigate (source, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">A <see cref="T:System.Uri" /> object initialized with the URI for the desired content.</param>
        <param name="navigationState">An object that contains data to be used for processing during navigation.</param>
        <summary>Navigate asynchronously to source content located at a URI, and pass an object that contains data to be used for processing during navigation.</summary>
        <returns>
          <see langword="true" /> if a navigation is not canceled; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색은, 동시에 진행에서 되도록 여러 탐색 같습니다. 예를 들어 단일 페이지에 두 개의 자식 프레임이 있는 경우 모두 프레임을 탐색할 수 있습니다. 이 경우 여러 탐색 이벤트에 의해 발생 하는 <xref:System.Windows.Navigation.NavigationService> 발생된 여러, 탐색 대상인 콘텐츠의 각 부분에 대 한 번 수와 다를 탐색이 요청을 수 있습니다. 따라서 특정 탐색 요청을 개별 요청에만 적용 되는 데이터를 처리 하는 경우 모든 탐색 요청에 사용할 수 있는 데이터를 사용할 수 없습니다. 대신 사용할 수 있습니다 `navigationState` 탐색 요청 하는 탐색을 처리에 대 한 데이터를 전달할 수 있습니다.  
  
 다음 이벤트 인수 탐색 상태에 대 한 액세스를 제공합니다.  
  
-   <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ExtraData%2A> (에 전달 되는 <xref:System.Windows.Navigation.NavigationService.Navigating> 이벤트).  
  
-   <xref:System.Windows.Navigation.NavigationEventArgs.ExtraData%2A> (에 전달 되는 <xref:System.Windows.Navigation.NavigationService.Navigated>, <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 이벤트 처리기).  
  
   
  
## Examples  
 다음 예제에서는 URI로 탐색 하 고 탐색 상태를 전달 하는 방법을 보여 줍니다.  
  
 [!code-csharp[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState, bool sandboxExternalContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object, sandboxExternalContent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj * bool -&gt; bool" Usage="navigationService.Navigate (source, navigationState, sandboxExternalContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
        <Parameter Name="sandboxExternalContent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">A <see cref="T:System.Uri" /> object initialized with the URI for the desired content.</param>
        <param name="navigationState">An object that contains data to be used for processing during navigation.</param>
        <param name="sandboxExternalContent">Download content into a partial trust security sandbox (with the default Internet zone set of permissions, if <see langword="true" />. The default is <see langword="false" />.</param>
        <summary>Navigate asynchronously to source content located at a URI, pass an object containing navigation state for processing during navigation, and sandbox the content.</summary>
        <returns>
          <see langword="true" /> if a navigation is not canceled; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 독립 실행형 응용 프로그램에 대해서만 및 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 콘텐츠입니다.  
  
 이 메서드는 동일한 동작으로 유효 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>, 콘텐츠를 다운로드 하는 부분 신뢰 보안 샌드박스에 배치 됩니다 되도록 하 여 확장 하 고 (사용 권한-기본 인터넷 영역 집합과 함께 참조 [WPF 부분 신뢰 보안](~/docs/framework/wpf/wpf-partial-trust-security.md)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the content that is being navigated to has been found, and is available from the <see cref="P:System.Windows.Navigation.NavigationService.Content" /> property, although it may not have completed loading.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처리할 <xref:System.Windows.Navigation.NavigationService.Navigated> 다운로드를 시작할 때 탐색 요청 관련 정보를 검색 하려는 경우. 이 정보는에서 사용할 수는 <xref:System.Windows.Navigation.NavigationEventArgs> 에 전달 되는 개체는 <xref:System.Windows.Navigation.NavigationService.Navigated> 이벤트 처리기와 포함:  
  
-   원본 페이지입니다. 때 <xref:System.Windows.Navigation.NavigationService.Navigated> 발생 원본 페이지의 일부분이 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 트리를 구문 분석 하 고 대상 콘텐츠 컨트롤에 연결 되었습니다.  
  
-   요청 된 URI입니다.  
  
-   탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   추가 데이터를 호출 하 여 탐색을 시작한 경우 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 또는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>합니다.  
  
-   응답 세부 정보 (사용 하는 <xref:System.Net.WebResponse> 개체).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigated> 원본 페이지를 찾을 수 또는 쿼리에서 로드할 수 없을 때 발생 하지 않는 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 발생 합니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>, 발생 <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다. <xref:System.Windows.Navigation.NavigationService.Navigated>합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a new navigation is requested.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigating> 새 탐색 요청 되었지만 원본 하기 전에 콘텐츠를 요청 될 때를 포함 하 여 때 발생 합니다.  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%2A>가 호출된 경우  
  
-   <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 또는 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> 라고 (탐색에서 한 항목을 선택 또는 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]).  
  
-   콘텐츠 조각을 탐색 하는 경우  
  
 처리할 <xref:System.Windows.Navigation.NavigationService.Navigating> 탐색이 시작 되기 전에 탐색 요청 관련 정보를 검색 하려는 경우. 이 정보는에서 사용할 수는 <xref:System.Windows.Navigation.NavigatingCancelEventArgs> 에 전달 되는 개체는 <xref:System.Windows.Navigation.NavigationService.Navigating> 이벤트 처리기입니다.  
  
 A <xref:System.Net.WebRequest> 탐색 생성 되어에서 사용할 수 있는 개체는 <xref:System.Windows.Navigation.NavigatingCancelEventArgs> ; 매개 변수는 실제 요청이 시점에서, 때문에 다시 구성할 수 있습니다는 <xref:System.Net.WebRequest> 개체, 필요한 경우.  
  
 또한 처리 <xref:System.Windows.Navigation.NavigatingCancelEventArgs> 탐색을 설정 하 여 필요한 경우 취소 하도록 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> true로 합니다. 탐색을 취소 하면 다른 탐색 이벤트가 발생 합니다.  
  
> [!NOTE]
>  취소 하 여 응용 프로그램에서 다른 페이지로 이동에서 사용자를 방지할 수 응용 프로그램을 브라우저에서 호스트 된 경우는 <xref:System.Windows.Navigation.NavigationService.Navigating> 이벤트입니다.  
  
 탐색기에서 첫 번째 부분 콘텐츠 탐색 한 후 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>)에서 멀리 탐색 각 콘텐츠 탐색 기록에 추가 됩니다. 멀리 탐색 중인 콘텐츠에 대 한 상태 정보를 저장 해야 할 경우 추가할 수 있습니다 상태 해당 콘텐츠에 대 한 업무 일지 항목을 설정 하 여 <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ContentStateToSave%2A> 와 <xref:System.Windows.Navigation.CustomContentState> 개체입니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.Navigating>, 발생 <xref:System.Windows.Application.Navigating?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다. <xref:System.Windows.Navigation.NavigationService.Navigating> 하며 감지 하는 정적 콘텐츠를 새로 요청, 요청을 취소 하려는 경우.  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an error occurs while navigating to the requested content.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 중 하나는 <xref:System.Net.WebException> 또는 <xref:System.IO.IOException> 탐색 중에 throw 되는 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 이벤트가 발생 합니다. <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 전달 되는 <xref:System.Windows.Navigation.NavigationFailedEventArgs> 예외와 예외를 발생 시킨 탐색의 세부 정보에 대 한 정보를 캡슐화 하 합니다.  
  
 예외는 실패 한 탐색에서 결과 처리 되지 않은 경우 다음 이벤트가 순서 대로 발생 합니다.  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed?displayProperty=nameWithType> 또는 <xref:System.Windows.Navigation.NavigationWindow.NavigationFailed?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) 하나 이상의 탐색기에서 호스팅되는 `NavigationFailed` 그 중 하나에 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다. <xref:System.Windows.Navigation.NavigationService.NavigationFailed>합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationfailedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationfailedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs periodically during a download to provide navigation progress information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 전달 되는 <xref:System.Windows.Navigation.NavigationProgressEventArgs> 다음 진행 상황 정보를 노출 하는:  
  
-   지금까지 다운로드 된 바이트 수 (<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>).  
  
-   다운로드 한 총 바이트 수입니다 (<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>).  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 콘텐츠의 모든 1024 바이트에 대 한 다운로드 된 후 한 번 더 남아 있는 바이트 수는 1024 바이트 보다 작은 경우 발생 합니다. 이러한 이유로 처리 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 추적 하 고 현재 다운로드의 진행률을 표시 하는 유용한 방법을 제공 합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 동일한 콘텐츠의 탐색 하는 경우 또는에 현재 로드 된 콘텐츠에 콘텐츠 조각을 탐색 하는 경우와 같은 일부 경우에 발생 하지 않습니다 (즉, 값은 <xref:System.Windows.Navigation.NavigationService.Content%2A> 속성).  
  
 컴파일된 XAML 리소스 최종을 탐색할 때 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 이벤트가 발생 하지 않을 수 있습니다. 이 다운로드의 끝 마지막 보고 의미 <xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A> 값과 같지 않을 수 있습니다는 <xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A> 값입니다. 처리는 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 탐색 완료 되 면 알림을 받을 수는 이벤트입니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.NavigationProgress>, 발생 <xref:System.Windows.Application.NavigationProgress?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다. <xref:System.Windows.Navigation.NavigationService.NavigationProgress>합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationprogresscode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationprogresscode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="M:System.Windows.Navigation.NavigationService.StopLoading" /> method is called, or when a new navigation is requested while a current navigation is in progress.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처리할 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> 다운로드를 중지할 때 탐색 요청 관련 정보를 검색 해야 합니다. 이 정보는에서 사용할 수는 <xref:System.Windows.Navigation.NavigationEventArgs> 에 전달 되는 개체는 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> 이벤트 처리기와 포함:  
  
-   요청 된 URI입니다.  
  
-   탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   추가 데이터를 호출 하 여 탐색을 시작한 경우 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType> 또는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, 발생 <xref:System.Windows.Application.NavigationStopped?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다. <xref:System.Windows.Navigation.NavigationService.NavigationStopped>합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationstoppedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationstoppedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="navigationService.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reloads the current content.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 현재 콘텐츠 (의 값으로 지정 된는 <xref:System.Windows.Navigation.NavigationService.Source%2A> 속성)를 다시, 탐색 <xref:System.Windows.Navigation.NavigationService> 콘텐츠를 다시 다운로드 하지 않습니다. 강제로 <xref:System.Windows.Navigation.NavigationService> 콘텐츠 다시 탐색 하려면 호출 <xref:System.Windows.Navigation.NavigationService.Refresh%2A>합니다.  
  
 경우 유의 현재 콘텐츠를 탐색 하는 다시 여부를 호출 하 여 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 또는 <xref:System.Windows.Navigation.NavigationService.Refresh%2A>, 탐색 기록에 새 항목이 추가 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberSignature Language="F#" Value="member this.RemoveBackEntry : unit -&gt; System.Windows.Navigation.JournalEntry" Usage="navigationService.RemoveBackEntry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes the most recent journal entry from back history.</summary>
        <returns>The most recent <see cref="T:System.Windows.Navigation.JournalEntry" /> in back navigation history, if there is one.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 두 개 이상의 탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) 하면 동일한 공유 하거나, 한 탐색기 צ ְ ײ <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A> 를 다른 탐색기에 발생 한 탐색을 위한 뒤로 탐색 기록 항목을 검색 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Navigation.NavigationService.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the URI of the current content, or the URI of new content that is currently being navigated to.</summary>
        <value>A <see cref="T:System.Uri" /> 현재 콘텐츠 또는 현재 탐색 중인 콘텐츠에 대 한 URI를 포함 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 표시 되 고 식 탐색기 보다 다른 URI로이 속성을 설정 하는 경우 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) 지정된 된 URI로 이동 합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> 탐색을 취소 하지 않으면 탐색 되는 URI에서 로드 된 내용으로 설정 됩니다.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> 한 조각만 URI로 설정할 수 있으며로 설정할 수 있습니다 `null`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopLoading();" />
      <MemberSignature Language="F#" Value="member this.StopLoading : unit -&gt; unit" Usage="navigationService.StopLoading " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops further downloading of content for the current navigation request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 호출할 수는 즉시 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 반환 하 고 자식 프레임에서 진행 중인 탐색이 중지 됩니다.  
  
 (<xref:System.Windows.Controls.Frame>).  
  
 호출의 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 메서드 발생은 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> 이벤트입니다.  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 탐색을 시작한 스레드와 동일한 스레드에서 호출 되어야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 로드를 중지 하는 방법을 보여 줍니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowstoploadingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowstoploadingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
  </Members>
</Type>