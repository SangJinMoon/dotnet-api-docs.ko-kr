<Type Name="Contract" FullName="System.Diagnostics.Contracts.Contract">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="18ccddeb7c646934cfcc1b40673135a0998cbc53" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30399707" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Contract" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Contract extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Contracts.Contract" />
  <TypeSignature Language="VB.NET" Value="Public Class Contract" />
  <TypeSignature Language="C++ CLI" Value="public ref class Contract abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="d08ec-101">사전 조건, 사후 조건, 개체 고정 조건 같은 프로그램 계약을 나타내는 정적 메서드가 포함됩니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d08ec-101">Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-102">코드 계약 클래스에는 코드에서 사전 조건, 사후 조건, 및 개체 고정을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-102">Code contract classes let you specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="d08ec-103">사전 조건은 메서드 또는 속성을 입력할 때 충족해야 하는 요구 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-103">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="d08ec-104">사후 조건은 메서드 또는 속성 코드가 종료될 때의 예상을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-104">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="d08ec-105">개체 고정 조건 문제가 없는 하는 클래스에 대 한 예상 되는 상태에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-105">Object invariants describe the expected state for a class that has no condition problems.</span></span> <span data-ttu-id="d08ec-106">사전 조건, 사후 조건, 개체 고정에 대 한 자세한 내용은 참조 [코드 계약](~/docs/framework/debug-trace-profile/code-contracts.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-106">For more information about preconditions, postconditions, and object invariants, see [Code Contracts](~/docs/framework/debug-trace-profile/code-contracts.md).</span></span>  
  
 <span data-ttu-id="d08ec-107">코드 계약을 사용하기 위한 도구 및 자세한 지침은 MSDN DevLabs 웹 사이트의 [코드 계약](http://go.microsoft.com/fwlink/?LinkId=152461)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d08ec-107">For tools and detailed instructions for using code contracts, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d08ec-108">이진 재작성 기를 사용 하 여 계약의 런타임 적용 삽입 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-108">You must use a binary rewriter to insert run-time enforcement of contracts.</span></span> <span data-ttu-id="d08ec-109">그렇지 않은 경우와 같은 계약 서비스 계약의 <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> 정적으로 테스트할 수만 메서드와 계약을 위반 하는 경우 런타임 시 예외를 throw 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-109">Otherwise, contracts such as the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> method can only be tested statically and will not throw exceptions during run time if a contract is violated.</span></span> <span data-ttu-id="d08ec-110">이진 재작성 기 CCRewrite를 다운로드할 수에서 [코드 계약](http://go.microsoft.com/fwlink/?LinkId=152461) MSDN DevLabs 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-110">You can download the binary rewriter CCRewrite from [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span> <span data-ttu-id="d08ec-111">CCRewrite는 Visual Studio 추가 기능으로 프로젝트에서 런타임에 계약 적용을 활성화할 수 있도록 제공 **속성** 페이지.</span><span class="sxs-lookup"><span data-stu-id="d08ec-111">CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project **Properties** page.</span></span> <span data-ttu-id="d08ec-112">이진 재작성 기 및 Visual Studio 추가 기능을 함께 제공 되지 않는 [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] 또는 Windows SDK가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-112">The binary rewriter and the Visual Studio add-in do not ship with [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] or the Windows SDK.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d08ec-113">디버그 빌드에서 지정된 조건으로 런타임 테스트를 수행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-113">In debug builds, performs a run-time test for a specified condition.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="d08ec-114">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-114">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-115">조건을 확인합니다. 조건이 <see langword="false" />이면 분석기에 설정된 에스컬레이션 정책을 따릅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-115">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set for the analyzer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-116">기본 에스컬레이션 정책은 인지 계약 실패에 대 한 연결된 된 디버거에 알리기 위해 표시 하는 **Assert** 디버거가 연결 되어 있지 않으면 대화 상자.</span><span class="sxs-lookup"><span data-stu-id="d08ec-116">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="d08ec-117">필요에 따라 분석기 예외를 throw 하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-117">Optionally, the analyzer can be instructed to throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="d08ec-118">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-118">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="d08ec-119">조건이 충족되지 않으면 표시할 메시지입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-119">A message to display if the condition is not met.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-120">조건을 확인합니다. 조건이 <see langword="false" />이면 분석기에 설정된 에스컬레이션 정책을 따르고 지정된 메시지를 표시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-120">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set by the analyzer and displays the specified message.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-121">기본 에스컬레이션 정책은 인지 계약 실패에 대 한 연결된 된 디버거에 알리기 위해 표시 하는 **Assert** 디버거가 연결 되어 있지 않으면 대화 상자.</span><span class="sxs-lookup"><span data-stu-id="d08ec-121">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="d08ec-122">필요에 따라 분석기 예외를 throw 하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-122">Optionally, the analyzer can be instructed to throw an exception.</span></span> <span data-ttu-id="d08ec-123">`userMessage` 매개 변수는 디버거 출력에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-123">The `userMessage` parameter is passed to the debugger output.</span></span> <span data-ttu-id="d08ec-124">경우 `userMessage` 상수 문자열인 리터럴 도구 못할을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-124">If `userMessage` is not a constant string literal, tools may not be able to read it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Assume">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d08ec-125">조건이 항상 <see langword="true" />인지 고정적으로 입증할 수 없는 경우를 포함하여, 코드 분석 도구가 조건을 <see langword="true" />라고 가정하도록 지시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-125">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="d08ec-126">
            <see langword="true" />라고 가정할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-126">The conditional expression to assume <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-127">조건이 항상 <see langword="true" />인지 고정적으로 입증할 수 없는 경우를 포함하여, 코드 분석 도구가 지정된 조건을 <see langword="true" />라고 가정하도록 지시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-127">Instructs code analysis tools to assume that the specified condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-128">런타임 시이 메서드를 사용 하 여 사용 하는 것은 <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="d08ec-128">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="d08ec-129">
            <see langword="true" />라고 가정할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-129">The conditional expression to assume <see langword="true" />.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="d08ec-130">가정이 실패할 경우 게시되는 메시지입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-130">The message to post if the assumption fails.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-131">조건이 항상 <see langword="true" />인지 고정적으로 입증할 수 없는 경우를 포함하여, 코드 분석 도구가 조건을 <see langword="true" />라고 가정하고 가정이 실패한 경우 메시지를 표시하도록 지시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-131">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />, and displays a message if the assumption fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-132">경우 `userMessage` 은 상수 문자열 리터럴, 도구에서 계약을 인식 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-132">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 <span data-ttu-id="d08ec-133">런타임 시이 메서드를 사용 하 여 사용 하는 것은 <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="d08ec-133">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractFailed">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Contracts.Contract.ContractFailed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ContractFailed As EventHandler(Of ContractFailedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Diagnostics::Contracts::ContractFailedEventArgs ^&gt; ^ ContractFailed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d08ec-134">계약이 실패한 경우 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-134">Occurs when a contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-135">이 이벤트에 대 한 이벤트 정보는에서 제공 된 <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> 이벤트 처리기에 전달 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-135">The event information for this event is supplied by the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> object that is passed to the event handler.</span></span> <span data-ttu-id="d08ec-136">이 이벤트는 대화형 인터프리터 또는 계약이 실패 하는 웹 브라우저 호스트와 같은 관리 되는 응용 프로그램 환경을 알립니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-136">This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed.</span></span> <span data-ttu-id="d08ec-137">이렇게 하기 전에 응용 프로그램은 필요할 때 처리할 수 있는 이벤트를 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-137">Before doing so, it will raise an event that an application can handle as it sees fit.</span></span> <span data-ttu-id="d08ec-138">예를 들어 코드 테스트 프레임 워크에서를 실행 하는 경우 테스트 실패를 로그 한 다음 테스트를 끝낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-138">For example, if code is being run in a testing framework, you can log a test failure and then end the test.</span></span>  
  
 <span data-ttu-id="d08ec-139">기본 구현에서 <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> 메서드.NET Framework 클래스 라이브러리의 등록 된 각 처리기를 호출 하는 것은 <xref:System.Diagnostics.Contracts.Contract.ContractFailed> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-139">The default implementation of the <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> method in the .NET Framework class library is to call each handler that is registered with the <xref:System.Diagnostics.Contracts.Contract.ContractFailed> event.</span></span> <span data-ttu-id="d08ec-140">처리기에서 throw 된 예외는 무시 되지만 각 처리기를 호출 하 여 오류를 처리 하는지 여부를 나타낼 수는 <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> 메서드 이벤트의 인수에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-140">Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> method for the event arguments.</span></span> <span data-ttu-id="d08ec-141">메서드가 반환 하는 경우 모든 처리기에서 오류 처리를 설정 `null` 추가 작업이 없으므로 맡습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-141">If any handler sets the failure as handled, the method returns `null` and no further action is taken.</span></span> <span data-ttu-id="d08ec-142">처리기를 호출할 수 있습니다 또는 <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> 해제 하는 코드를 지시 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="d08ec-142">Alternatively, handlers can call the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> method to instruct the code to unwind.</span></span> <span data-ttu-id="d08ec-143">이 경우 모든 처리기가 실행 된 후 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-143">In that case, an exception is thrown after all handlers have executed.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d08ec-144">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-144">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d08ec-145">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-145">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="EndContractBlock">
      <MemberSignature Language="C#" Value="public static void EndContractBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndContractBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EndContractBlock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndContractBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndContractBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d08ec-146">메서드의 계약에 <see langword="if" />-<see langword="then" />-<see langword="throw" /> 형태의 사전 조건만 포함되어 있을 때 계약 섹션의 끝을 표시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-146">Marks the end of the contract section when a method's contracts contain only preconditions in the <see langword="if" />-<see langword="then" />-<see langword="throw" /> form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-147">대부분의 코드 형태의 일부 매개 변수 유효성 검사를 이미 포함 되어 `if` - `then` - `throw` 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-147">Most code already contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="d08ec-148">계약 도구는 달리 `if` - `then` - `throw` 메서드 내에서 첫 번째 문이 표시 하 고 이러한 문의 전체 집합 뒤에 명시적 사전조건으로문<xref:System.Diagnostics.Contracts.Contract> 와 같은 메서드 호출을 <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, 또는 <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-148">The contract tools recognize `if`-`then`-`throw` statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span></span>  
  
 <span data-ttu-id="d08ec-149">때 `if` - `then` - `throw` 계약 도구 레거시 인식 문이이 형태로 표시-문이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-149">When `if`-`then`-`throw` statements appear in this form, the contract tools recognize them as legacy-require statements.</span></span> <span data-ttu-id="d08ec-150"><xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> 양식은 뒤에 나오는 다른 계약이 없는 경우에 사용 됩니다.는 `if` - `then` - `throw` 시퀀스, 있지만 여전히 태그를 지정 해야 레거시-필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-150">The <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> form is used only if no other contracts follow the `if`-`then`-`throw` sequences, but they should still be tagged as legacy-requires.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ensures">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d08ec-151">바깥쪽 메서드 또는 속성에 대한 사후 조건 계약을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-151">Specifies a postcondition contract for the enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="d08ec-152">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-152">The conditional expression to test.</span>
          </span>
          <span data-ttu-id="d08ec-153">식에는 <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" /> 및 <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> 값이 포함될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-153">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />, and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-154">바깥쪽 메서드 또는 속성에 대한 사후 조건 계약을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-154">Specifies a postcondition contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-155">`condition` 매개 변수 지정 되도록 예상 되는 사후 조건 `true` 바깥쪽 메서드나 속성 반환 하는 경우 일반적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-155">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="d08ec-156">이 메서드 호출은 메서드 또는 다른 코드 보다 먼저 속성의 시작 부분에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-156">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="d08ec-157">이진 재작성 기를 사용 해야 합니다 (//go.microsoft.com/fwlink/ [코드 계약](http://go.microsoft.com/fwlink/?LinkId=152461) MSDN DevLabs 웹 사이트에서)이이 사후 조건의 런타임 적용에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-157">You must use the binary rewriter (available at [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d08ec-158">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> 메서드를 예상 된 값이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-158">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method to ensure that an expected value is returned.</span></span> <span data-ttu-id="d08ec-159">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Diagnostics.Contracts.ContractClassAttribute> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-159">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="d08ec-160">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-160">The conditional expression to test.</span>
          </span>
          <span data-ttu-id="d08ec-161">식에는 <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> 및 <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> 값이 포함될 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-161">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="d08ec-162">식이 <see langword="true" />가 아니면 표시할 메시지입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-162">The message to display if the expression is not <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-163">제공된 종료 조건에 대한 사후 조건 계약과 조건이 <see langword="false" />인 경우 표시할 메시지를 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-163">Specifies a postcondition contract for a provided exit condition and a message to display if the condition is <see langword="false" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-164">`condition` 매개 변수 지정 되도록 예상 되는 사후 조건 `true` 바깥쪽 메서드나 속성 반환 하는 경우 일반적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-164">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="d08ec-165">이 메서드 호출은 메서드 또는 다른 코드 보다 먼저 속성의 시작 부분에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-165">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="d08ec-166">이 계약은 클라이언트에 노출 됩니다. 따라서 바깥쪽 메서드로 표시 되는 참조 멤버만을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-166">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="d08ec-167">이진 재작성 기를 사용 해야 합니다 (//go.microsoft.com/fwlink/ [코드 계약](http://go.microsoft.com/fwlink/?LinkId=152461) MSDN DevLabs 웹 사이트에서)이이 사후 조건의 런타임 적용에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-167">You must use the binary rewriter (available at [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="d08ec-168">경우 `userMessage` 은 상수 문자열 리터럴, 도구에서 계약을 인식 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-168">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnsuresOnThrow&lt;TException&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d08ec-169">제공된 예외와 조건에 따라 바깥쪽 메서드 또는 속성에 대한 사후 조건 계약을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-169">Specifies a postcondition contract for the enclosing method or property based on the provided exception and condition.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="d08ec-170">사후 조건 확인을 호출하는 예외의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-170">The type of exception that invokes the postcondition check.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="d08ec-171">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-171">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-172">제공된 예외와 조건에 따라 바깥쪽 메서드 또는 속성에 대한 사후 조건 계약을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-172">Specifies a postcondition contract for the enclosing method or property, based on the provided exception and condition.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-173">`condition` 매개 변수 지정 되도록 예상 되는 사후 조건 `true` 바깥쪽 메서드 또는 속성의 비정상적으로 종료 될 때 및 형식의 예외가 `TException` throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-173">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span>  
  
-   <span data-ttu-id="d08ec-174">이 메서드 호출은 메서드 또는 다른 코드 보다 먼저 속성의 시작 부분에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-174">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="d08ec-175">이 계약은 클라이언트에 노출 됩니다. 따라서 바깥쪽 메서드로 표시 되는 참조 멤버만을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-175">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="d08ec-176">이 사후 조건의 런타임 적용에 대 한 이진 재작성 기를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-176">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="d08ec-177">사후 조건 확인을 호출하는 예외의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-177">The type of exception that invokes the postcondition check.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="d08ec-178">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-178">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="d08ec-179">식이 <see langword="false" />이면 표시할 메시지입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-179">The message to display if the expression is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-180">제공된 예외와 조건에 따라 바깥쪽 메서드 또는 속성에 대한 해당 조건이 <see langword="false" />인 경우 표시할 사후 조건 계약과 메시지를 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-180">Specifies a postcondition contract and a message to display if the condition is <see langword="false" /> for the enclosing method or property, based on the provided exception and condition.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-181">`condition` 매개 변수 지정 되도록 예상 되는 사후 조건 `true` 바깥쪽 메서드 또는 속성의 비정상적으로 종료 될 때 및 형식의 예외가 `TException` throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-181">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span> <span data-ttu-id="d08ec-182">`message` 조건이 표시 하는 메시지를 지정 하는 매개 변수 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-182">The `message` parameter specifies a message to display if the condition is `false`.</span></span>  
  
-   <span data-ttu-id="d08ec-183">이 메서드 호출은 메서드 또는 다른 코드 보다 먼저 속성의 시작 부분에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-183">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="d08ec-184">이 계약은 클라이언트에 노출 됩니다. 따라서 바깥쪽 메서드로 표시 되는 참조 멤버만을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-184">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="d08ec-185">이 사후 조건의 런타임 적용에 대 한 이진 재작성 기를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-185">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="d08ec-186">경우 `userMessage` 은 상수 문자열 리터럴, 도구에서 계약을 인식 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-186">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="d08ec-187">
            <c>predicate</c>에 전달할 첫 번째 정수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-187">The first integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="d08ec-188">
            <c>predicate</c>에 전달할 마지막 정수보다 1 더 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-188">One more than the last integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="d08ec-189">지정된 범위에 있는 정수의 값을 평가하기 위한 함수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-189">The function to evaluate for any value of the integer in the specified range.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-190">정수 범위 내의 정수에 대해 지정된 테스트가 true인지를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-190">Determines whether a specified test is true for any integer within a range of integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d08ec-191">
            <paramref name="predicate" />가 <paramref name="fromInclusive" />부터 <paramref name="toExclusive" /> - 1 사이의 정수에 대해 <see langword="true" />를 반환하면 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-191">
              <see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for any integer starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-192">`toExclusive` 매개 변수는 0부터 시작 하는 정수 범위 길이 사용 하는 마지막 정수 보다 더 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-192">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="d08ec-193">예를 들어 정수 0-4에 대 한 5로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-193">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d08ec-194">
            <paramref name="predicate" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-194">
              <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d08ec-195">
            <paramref name="toExclusive" />가 <paramref name="fromInclusive" />보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-195">
              <paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="d08ec-196">에 포함 된 유형을 <c>컬렉션</c>합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-196">The type that is contained in <c>collection</c>.</span>
          </span>
        </typeparam>
        <param name="collection">
          <span data-ttu-id="d08ec-197">
            <c>T</c> 형식의 요소를 <c>predicate</c>로 전달할 컬렉션입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-197">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="d08ec-198">
            <c>컬렉션</c>에 있는 요소를 평가하기 위한 함수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-198">The function to evaluate for an element in <c>collection</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-199">요소 컬렉션에 속하는 요소가 함수에 존재하는지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-199">Determines whether an element within a collection of elements exists within a function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d08ec-200">
            <paramref name="predicate" />가 <paramref name="T" />에서 <paramref name="collection" /> 형식의 요소에 대해 <see langword="true" />를 반환하는 경우에만 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-200">
              <see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for any element of type <paramref name="T" /> in <paramref name="collection" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d08ec-201">
            <paramref name="collection" /> 또는 <paramref name="predicate" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-201">
              <paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll">
      <MemberSignature Language="C#" Value="public static bool ForAll (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForAll(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="d08ec-202">
            <c>predicate</c>에 전달할 첫 번째 정수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-202">The first integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="d08ec-203">
            <c>predicate</c>에 전달할 마지막 정수보다 1 더 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-203">One more than the last integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="d08ec-204">지정된 범위의 정수가 존재하는지 확인할 함수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-204">The function to evaluate for the existence of the integers in the specified range.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-205">지정된 범위의 모든 정수에 대해 특정 조건이 유효한지를 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-205">Determines whether a particular condition is valid for all integers in a specified range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d08ec-206">
            <paramref name="predicate" />가 <paramref name="fromInclusive" />에서 <paramref name="toExclusive" /> - 1 사이의 모든 정수에 대해 <see langword="true" />를 반환하면 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-206">
              <see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for all integers starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-207">`toExclusive` 매개 변수는 0부터 시작 하는 정수 범위 길이 사용 하는 마지막 정수 보다 더 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-207">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="d08ec-208">예를 들어 정수 0-4에 대 한 5로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-208">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d08ec-209">다음 예제에서는 사용 하는 방법을 <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> 메서드를 배열에 null 요소가 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-209">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether an array has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d08ec-210">
            <paramref name="predicate" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-210">
              <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d08ec-211">
            <paramref name="toExclusive" />가 <paramref name="fromInclusive" />보다 작은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-211">
              <paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool ForAll(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="d08ec-212">에 포함 된 유형을 <c>컬렉션</c>합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-212">The type that is contained in <c>collection</c>.</span>
          </span>
        </typeparam>
        <param name="collection">
          <span data-ttu-id="d08ec-213">
            <c>T</c> 형식의 요소를 <c>predicate</c>로 전달할 컬렉션입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-213">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="d08ec-214">
            <c>컬렉션</c>에 모든 요소가 존재하는지 확인할 함수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-214">The function to evaluate for the existence of all the elements in <c>collection</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-215">컬렉션의 모든 요소가 함수에 존재하는지 확인합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-215">Determines whether all the elements in a collection exist within a function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d08ec-216">
            <paramref name="predicate" />가 <paramref name="T" />에 있는 모든 <paramref name="collection" /> 형식 요소에 대해 <see langword="true" />를 반환하는 경우에만 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-216">
              <see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for all elements of type <paramref name="T" /> in <paramref name="collection" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d08ec-217">다음 예제에서는 사용 하는 방법을 <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> 메서드를 컬렉션에 null 요소가 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-217">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether a collection has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d08ec-218">
            <paramref name="collection" /> 또는 <paramref name="predicate" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-218">
              <paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invariant">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d08ec-219">바깥쪽 메서드 또는 속성에 대한 계약을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-219">Specifies a contract for an enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="d08ec-220">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-220">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-221">바깥쪽 메서드 또는 속성에 대한 고정 계약을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-221">Specifies an invariant contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> 계약으로 식별 되는 메서드 내에 포함 되는 <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> 특성; 메서드 이름은 일반적으로 `ObjectInvariant`합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="d08ec-223">이 계약 클래스에 선언 된 전용된 고정 메서드가에 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-223">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span> <span data-ttu-id="d08ec-224">메서드가 봉인 서브 클래스를 고정 된 상태를 유지할 수 있도록 보호 된 멤버를 private 멤버에만 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-224">If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.</span></span>  
  
-   <span data-ttu-id="d08ec-225">이 계약은 클라이언트에 노출 되지 않습니다. 따라서 그는 바깥쪽 메서드가 보다 표시 수준이 있는 멤버를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-225">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="d08ec-226">이 런타임 적용에 대 한 이진 재작성 기를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-226">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="d08ec-227">고정 조건부로의 존재 여부에 따라 정의 됩니다는 `CONTRACTS FULL` 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-227">Invariants are conditionally defined based on the presence of the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="d08ec-228">런타임 검사 중에 고정은 각 public 메서드의 끝에서 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-228">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="d08ec-229">동일한 클래스의 public 메서드를 언급 하는 고정, 해당 public 메서드의 끝에서 정상적으로 이루어져야 하는 고정 검사는 사용 하지 않도록 설정 하 고 해당 클래스에 대 한 가장 바깥쪽 메서드 호출의 끝에만 선택 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-229">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="d08ec-230">이 검사는 다른 클래스의 메서드 호출로 인해 클래스에 재진입하는 경우에도 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-230">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="d08ec-231">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-231">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="d08ec-232">조건이 <see langword="false" />인 경우 표시할 메시지입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-232">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-233">바깥쪽 메서드나 속성에 대한 고정 계약을 지정하고 계약의 조건이 실패한 경우 메시지를 표시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-233">Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> 계약으로 식별 되는 메서드 내에 포함 되는 <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> 특성; 메서드 이름은 일반적으로 `ObjectInvariant`합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="d08ec-235">이 계약 클래스에 선언 된 전용된 고정 메서드가에 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-235">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span>  
  
-   <span data-ttu-id="d08ec-236">이 계약은 클라이언트에 노출 되지 않습니다. 따라서 그는 바깥쪽 메서드가 보다 표시 수준이 있는 멤버를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-236">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="d08ec-237">이 런타임 적용에 대 한 이진 재작성 기를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-237">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="d08ec-238">고정에 조건부로 정의 `CONTRACTS FULL` 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-238">Invariants are conditionally defined on the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="d08ec-239">런타임 검사 중에 고정은 각 public 메서드의 끝에서 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-239">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="d08ec-240">동일한 클래스의 public 메서드를 언급 하는 고정, 해당 public 메서드의 끝에서 정상적으로 이루어져야 하는 고정 검사는 사용 하지 않도록 설정 하 고 해당 클래스에 대 한 가장 바깥쪽 메서드 호출의 끝에만 선택 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-240">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="d08ec-241">이 검사는 다른 클래스의 메서드 호출로 인해 클래스에 재진입하는 경우에도 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-241">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OldValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T OldValue&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T OldValue&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OldValue(Of T) (value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T OldValue(T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="d08ec-242">값의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-242">The type of value.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="d08ec-243">나타낼 값(필드 또는 매개 변수)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-243">The value to represent (field or parameter).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-244">값을 메서드나 속성의 시작 위치에 있었던 그대로 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-244">Represents values as they were at the start of a method or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d08ec-245">메서드나 속성의 시작 위치에 있는 필드 또는 매개 변수의 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-245">The value of the parameter or field at the start of a method or property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-246">이 메서드는에 대 한 조건 식에만 사용할 수는 <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> 계약입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-246">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d08ec-247">다음 예제에서는 사용을 보여 줍니다.는 <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> 메서드를 개수 업데이트 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-247">The following example shows the use of the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method to ensure that a count has been updated.</span></span> <span data-ttu-id="d08ec-248">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Diagnostics.Contracts.ContractClassAttribute> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-248">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#5](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#5)]
 [!code-vb[ContractExample#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Requires">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d08ec-249">바깥쪽 메서드 또는 속성에 대한 사전 조건 계약을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-249">Specifies a precondition contract for an enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="d08ec-250">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-250">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-251">바깥쪽 메서드 또는 속성에 대한 사전 조건 계약을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-251">Specifies a precondition contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="d08ec-252">이 메서드 호출은 메서드 또는 다른 코드 보다 먼저 속성의 시작 부분에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-252">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="d08ec-253">이 계약은 클라이언트에 노출 됩니다. 따라서 바깥쪽 메서드로 표시 되는 참조 멤버만을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-253">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="d08ec-254">대신이 메서드를 사용 하 여는 <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> 이전 버전과 호환성 강제로 특정 예외를 throw 하지 않을 때 메서드.</span><span class="sxs-lookup"><span data-stu-id="d08ec-254">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="d08ec-255">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-255">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="d08ec-256">조건이 <see langword="false" />인 경우 표시할 메시지입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-256">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-257">바깥쪽 메서드나 속성에 대한 사전 조건 계약을 지정하고 계약의 조건이 실패한 경우 메시지를 표시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-257">Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="d08ec-258">이 메서드 호출은 메서드 또는 다른 코드 보다 먼저 속성의 시작 부분에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-258">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="d08ec-259">이 계약은 클라이언트에 노출 됩니다. 따라서 바깥쪽 메서드로 표시 되는 참조 멤버만을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-259">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="d08ec-260">대신이 메서드를 사용 하 여는 <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> 이전 버전과 호환성 강제로 특정 예외를 throw 하지 않을 때 메서드.</span><span class="sxs-lookup"><span data-stu-id="d08ec-260">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="d08ec-261">조건이 <see langword="false" />인 경우 throw할 예외입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-261">The exception to throw if the condition is <see langword="false" />.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="d08ec-262">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-262">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-263">바깥쪽 메서드나 속성에 대한 사전 조건 계약을 지정하고 계약의 조건이 실패한 경우 예외를 throw합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-263">Specifies a precondition contract for the enclosing method or property, and throws an exception if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="d08ec-264">런타임 검사 사용 하도록 설정 해야는 <xref:System.Diagnostics.Contracts.Contract.Requires%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="d08ec-264">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="d08ec-265">런타임 검사는 해제 되어 프로세스가 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-265">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="d08ec-266">런타임 검사에 대 한 도구를 얻으려면 참조 [코드 계약](http://go.microsoft.com/fwlink/?LinkId=152461) MSDN DevLabs 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-266">To obtain the tools for runtime checking, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
-   <span data-ttu-id="d08ec-267">이 메서드 호출은 메서드 또는 다른 코드 보다 먼저 속성의 시작 부분에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-267">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="d08ec-268">이 계약은 클라이언트에 노출 됩니다. 따라서 바깥쪽 메서드로 표시 되는 참조 멤버만을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-268">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="d08ec-269">대신이 메서드를 사용 하 여는 <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> 메서드 전제 조건이 실패 한 경우 예외를 throw 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="d08ec-269">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="d08ec-270">조건이 <see langword="false" />인 경우 throw할 예외입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-270">The exception to throw if the condition is <see langword="false" />.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="d08ec-271">테스트할 조건식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-271">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="d08ec-272">조건이 <see langword="false" />인 경우 표시할 메시지입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-272">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-273">바깥쪽 메서드 또는 속성에 대한 사전 조건 계약을 지정하고 계약의 조건이 실패할 경우 제공된 메시지와 함께 예외를 throw합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-273">Specifies a precondition contract for the enclosing method or property, and throws an exception with the provided message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   > [!IMPORTANT]
    >  <span data-ttu-id="d08ec-274">런타임 검사 사용 하도록 설정 해야는 <xref:System.Diagnostics.Contracts.Contract.Requires%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="d08ec-274">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="d08ec-275">런타임 검사는 해제 되어 프로세스가 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-275">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="d08ec-276">런타임 검사에 대 한 도구를 얻으려면 참조 [코드 계약](http://go.microsoft.com/fwlink/?LinkId=152461) MSDN DevLabs 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-276">To obtain the tools for runtime checking, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
     <span data-ttu-id="d08ec-277">이 메서드 호출은 메서드 또는 다른 코드 보다 먼저 속성의 시작 부분에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-277">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="d08ec-278">이 계약은 클라이언트에 노출 됩니다. 따라서 바깥쪽 메서드로 표시 되는 참조 멤버만을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-278">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="d08ec-279">대신이 메서드를 사용 하 여는 <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> 메서드 전제 조건이 실패 한 경우 예외를 throw 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="d08ec-279">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Result&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Result&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Result``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Result(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Result();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="d08ec-280">바깥쪽 메서드나 속성의 반환 값 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-280">Type of return value of the enclosing method or property.</span>
          </span>
        </typeparam>
        <summary>
          <span data-ttu-id="d08ec-281">메서드나 속성의 반환 값을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-281">Represents the return value of a method or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d08ec-282">바깥쪽 메서드나 속성의 반환 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-282">Return value of the enclosing method or property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-283">이 메서드는에 대 한 조건 식에만 사용할 수는 <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> 계약입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-283">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d08ec-284">사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Diagnostics.Contracts.Contract.Result%2A> 메서드를 예상된 반환 값을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-284">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Result%2A> method to specify an expected return value.</span></span> <span data-ttu-id="d08ec-285">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Diagnostics.Contracts.ContractClassAttribute> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-285">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueAtReturn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ValueAtReturn&lt;T&gt; (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ValueAtReturn&lt;T&gt;([out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueAtReturn(Of T) (ByRef value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ValueAtReturn([Runtime::InteropServices::Out] T % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="d08ec-286">
            <see langword="out" /> 매개 변수의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-286">The type of the <see langword="out" /> parameter.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="d08ec-287">
            <see langword="out" /> 매개 변수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-287">The <see langword="out" /> parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d08ec-288">메서드에서 반환되는 <see langword="out" /> 매개 변수의 최종(출력) 값을 나타냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-288">Represents the final (output) value of an <see langword="out" /> parameter when returning from a method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d08ec-289">
            <see langword="out" /> 매개 변수의 출력 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d08ec-289">The output value of the <see langword="out" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d08ec-290">이 메서드는에 대 한 조건 식에만 사용할 수는 <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> 계약입니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-290">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span> <span data-ttu-id="d08ec-291"><xref:System.Diagnostics.Contracts.Contract.OldValue%2A> 메서드와 마찬가지로, 컴파일러가 형식을 유추할 수 있는 경우 언제든지 제네릭 형식 매개 변수를 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-291">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="d08ec-292">계약 재작성기는 메서드 호출을 `out` 매개 변수의 값으로 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-292">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="d08ec-293"><xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> 메서드는 사후 조건에서만 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-293">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="d08ec-294">메서드에 대한 인수는 `out` 매개 변수 또는 구조체 필드 `out` 매개 변수여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-294">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="d08ec-295">후자는 구조체 생성자의 사후 조건에서 필드를 참조할 때에도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="d08ec-295">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>