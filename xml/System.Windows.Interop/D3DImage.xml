<Type Name="D3DImage" FullName="System.Windows.Interop.D3DImage">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="67a591e7f26a5181b8d03d81e8af4ab098e8eb98" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class D3DImage : System.Windows.Media.ImageSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi D3DImage extends System.Windows.Media.ImageSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Interop.D3DImage" />
  <TypeSignature Language="VB.NET" Value="Public Class D3DImage&#xA;Inherits ImageSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class D3DImage : System::Windows::Media::ImageSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.ImageSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="fa4b5-101">사용자가 만든 Direct3D 화면을 표시하는 <see cref="T:System.Windows.Media.ImageSource" />입니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="fa4b5-101">An <see cref="T:System.Windows.Media.ImageSource" /> that displays a user-created Direct3D surface.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-102">사용 하 여는 <xref:System.Windows.Interop.D3DImage> Windows Presentation Foundation (WPF) 응용 프로그램에서 Direct3D 콘텐츠를 호스트 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-102">Use the <xref:System.Windows.Interop.D3DImage> class to host Direct3D content in a Windows Presentation Foundation (WPF) application.</span></span>  
  
 <span data-ttu-id="fa4b5-103">호출 된 <xref:System.Windows.Interop.D3DImage.Lock%2A> 에 표시 된 Direct3D 내용을 변경 하려면 메서드는 <xref:System.Windows.Interop.D3DImage>합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-103">Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the Direct3D content displayed by the <xref:System.Windows.Interop.D3DImage>.</span></span> <span data-ttu-id="fa4b5-104">호출 된 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Direct3D 화면을 할당 하는 메서드는 <xref:System.Windows.Interop.D3DImage>합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-104">Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to a <xref:System.Windows.Interop.D3DImage>.</span></span> <span data-ttu-id="fa4b5-105">호출 된 <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> 메서드 Direct3D 화면에 업데이트를 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-105">Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to track updates to the Direct3D surface.</span></span> <span data-ttu-id="fa4b5-106">호출 된 <xref:System.Windows.Interop.D3DImage.Unlock%2A> 변경 된 영역을 표시 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-106">Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to display the changed areas.</span></span>  
  
 <span data-ttu-id="fa4b5-107"><xref:System.Windows.Interop.D3DImage> 클래스 라고 하는 두 디스플레이 버퍼 관리는 *백 버퍼* 및 *프런트 버퍼*합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-107">The <xref:System.Windows.Interop.D3DImage> class manages two display buffers, which are called the *back buffer* and the *front buffer*.</span></span> <span data-ttu-id="fa4b5-108">백 버퍼가 Direct3D 화면을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-108">The back buffer is your Direct3D surface.</span></span>  <span data-ttu-id="fa4b5-109">백 버퍼에 대 한 변경에 복사 됩니다 프런트 버퍼 호출 하는 경우는 <xref:System.Windows.Interop.D3DImage.Unlock%2A> 메서드를 하드웨어에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-109">Changes to the back buffer are copied forward to the front buffer when you call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method, where it is displayed on the hardware.</span></span> <span data-ttu-id="fa4b5-110">경우에 따라서는 프런트 버퍼 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-110">Occasionally, the front buffer becomes unavailable.</span></span> <span data-ttu-id="fa4b5-111">이 처럼 가용성 화면 잠금, 전체 화면 전용 Direct3D 응용 프로그램, 사용자 전환 또는 기타 시스템 작업에 의해 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-111">This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities.</span></span> <span data-ttu-id="fa4b5-112">WPF 응용 프로그램 처리를 통해 알림을 이러한 경우는 <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-112">When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.</span></span>  <span data-ttu-id="fa4b5-113">사용 하지 못하게 될 프런트 버퍼에 응용 프로그램의 응답으로 소프트웨어 렌더링 대체 WPF 사용 여부에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-113">How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.</span></span> <span data-ttu-id="fa4b5-114"><xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 메서드에 WPF 소프트웨어 렌더링으로 다시 속하는지 여부를 지정 하는 매개 변수를 사용 하는 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-114">The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.</span></span>  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-does-not-fall-back-to-software-rendering"></a><span data-ttu-id="fa4b5-115">WPF 대체 되지 않고 소프트웨어 렌더링을 사용할 수 없는 프런트 버퍼에 응답</span><span class="sxs-lookup"><span data-stu-id="fa4b5-115">Responding to an Unavailable Front Buffer when WPF Does not Fall Back to Software Rendering</span></span>  
 <span data-ttu-id="fa4b5-116">호출 하는 경우는 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> 오버 로드 또는 호출의 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> 오버 로드는 `enableSoftwareFallback` 매개 변수 설정 `false`, 프런트 버퍼를 사용할 수 없게 되 고 아무 것도 렌더링 시스템 백 버퍼에 대 한 참조를 해제 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-116">When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed.</span></span> <span data-ttu-id="fa4b5-117">프런트 버퍼를 사용할 수 있는 다시 렌더링 발생는 <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> WPF 응용 프로그램에 알리는 이벤트를 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-117">When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.</span></span>  <span data-ttu-id="fa4b5-118">에 대 한 이벤트 처리기를 만들 수는 <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> 유효한 Direct3D 화면을 사용 하 여 다시 렌더링을 다시 시작 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-118">You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface.</span></span> <span data-ttu-id="fa4b5-119">호출 해야 렌더링을 다시 시작 하려면 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-119">To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</span></span>  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-falls-back-to-software-rendering"></a><span data-ttu-id="fa4b5-120">WPF 위치 합니다. 소프트웨어 렌더링에 다시 사용할 수 없는 프런트 버퍼에 응답</span><span class="sxs-lookup"><span data-stu-id="fa4b5-120">Responding to an Unavailable Front Buffer when WPF Falls Back to Software Rendering</span></span>  
 <span data-ttu-id="fa4b5-121">호출 하는 경우는 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> 오버 로드는 `enableSoftwareFallback` 매개 변수 설정 `true`, 렌더링 시스템을 호출할 필요가 없습니다 이므로 프런트 버퍼를 사용할 수 없을 때 백 버퍼에 대 한 참조를 유지 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 때 앞 버퍼를 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-121">When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again.</span></span>  <span data-ttu-id="fa4b5-122">사용자의 장치 사용할 수 없게 되는 경우가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-122">There may be situations where the user’s device becomes unavailable.</span></span>  <span data-ttu-id="fa4b5-123">이 경우 호출 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 백 버퍼에 대 한 WPF의 참조를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-123">When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer.</span></span>  <span data-ttu-id="fa4b5-124">장치를 재설정 해야 할 경우 호출 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 와 `backBuffer` 매개 변수 설정 `null`, 한 다음 호출 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 사용 하 여 다시 `backBuffer` 유효한 Direct3D 화면으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-124">If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with the `backBuffer` parameter set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fa4b5-125">성능은은 Direct3D 화면 설정에 따라 크게 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-125">Performance depends greatly on the settings of the Direct3D surface.</span></span> <span data-ttu-id="fa4b5-126">자세한 내용은 참조 [Direct3D9 및 WPF 상호 운용성에 대 한 성능 고려 사항](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-126">For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fa4b5-127"><xref:System.Windows.Interop.D3DImage> 클래스 면 표시 되지 않습니다 Direct3D 콘텐츠 WPF 소프트웨어에서 렌더링와 같은 원격 데스크톱 연결을 통해 호출 하지 않으면 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> 지정 `true` 에 대 한는 `enableSoftwareFallback` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-127">The <xref:System.Windows.Interop.D3DImage> class does not display Direct3D content when WPF renders in software, such as over a Remote Desktop connection, unless you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> and specify `true` for the `enableSoftwareFallback` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fa4b5-128">다음 코드 예제에서는 선언 하는 방법을 보여 줍니다.는 <xref:System.Windows.Interop.D3DImage> XAML에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-128">The following code example shows how to declare a <xref:System.Windows.Interop.D3DImage> in XAML.</span></span> <span data-ttu-id="fa4b5-129">매핑해야는 <xref:System.Windows.Interop> 네임 스페이스, 기본 XAML 네임 스페이스에 포함 되어 있지 않으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-129">You must map the <xref:System.Windows.Interop> namespace, because it is not included in the default XAML namespaces.</span></span> <span data-ttu-id="fa4b5-130">자세한 내용은 참조 [연습: wpf에서 Direct3D9 콘텐츠 호스팅](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-130">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).</span></span>  
  
 [!code-xaml[System.Windows.Interop.D3DImage#10](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">
      <span data-ttu-id="fa4b5-131">관리 되지 않는 리소스에 액세스 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="fa4b5-131">for access to unmanaged resources.</span>
      </span>
      <span data-ttu-id="fa4b5-132">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="fa4b5-132">Security action: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</span>
      </span>
      <span data-ttu-id="fa4b5-133">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
      <span class="sxs-lookup">
        <span data-stu-id="fa4b5-133">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
      </span>
    </permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-134">
            <see cref="T:System.Windows.Interop.D3DImage" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-134">Initializes a new instance of the <see cref="T:System.Windows.Interop.D3DImage" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-135">
            <see cref="T:System.Windows.Interop.D3DImage" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-135">Initializes a new instance of the <see cref="T:System.Windows.Interop.D3DImage" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-136">기본 디스플레이 해상도 1/96 인치입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-136">The default display resolution is 1/96th inch.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="fa4b5-137">관리 되지 않는 리소스에 액세스 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-137">for access to unmanaged resources.</span>
          </span>
          <span data-ttu-id="fa4b5-138">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-138">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
          <span data-ttu-id="fa4b5-139">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-139">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage (double dpiX, double dpiY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 dpiX, float64 dpiY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dpiX As Double, dpiY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage(double dpiX, double dpiY);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="dpiX">
          <span data-ttu-id="fa4b5-140">X축에서의 디스플레이 해상도입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-140">The display resolution on the x-axis.</span>
          </span>
        </param>
        <param name="dpiY">
          <span data-ttu-id="fa4b5-141">Y축에서의 디스플레이 해상도입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-141">The display resolution on the y-axis.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fa4b5-142">지정된 디스플레이 해상도를 사용하여 <see cref="T:System.Windows.Interop.D3DImage" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-142">Initializes a new instance of the <see cref="T:System.Windows.Interop.D3DImage" /> class with the specified display resolution.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-143">기본 디스플레이 해상도 1/96 인치입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-143">The default display resolution is 1/96th inch.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="fa4b5-144">
            <paramref name="dpiX" /> 또는 <paramref name="dpiY" />가 0보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-144">
              <paramref name="dpiX" /> or <paramref name="dpiY" /> is less than zero.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="fa4b5-145">관리 되지 않는 리소스에 액세스 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-145">for access to unmanaged resources.</span>
          </span>
          <span data-ttu-id="fa4b5-146">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-146">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
          <span data-ttu-id="fa4b5-147">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-147">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDirtyRect (dirtyRect As Int32Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDirtyRect(System::Windows::Int32Rect dirtyRect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect">
          <span data-ttu-id="fa4b5-148">변경된 영역을 나타내는 <see cref="T:System.Windows.Int32Rect" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-148">An <see cref="T:System.Windows.Int32Rect" /> that represents the area that changed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fa4b5-149">변경된 백 버퍼 영역을 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-149">Specifies the area of the back buffer that changed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-150">호출의 <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> 메서드 코드가 백 버퍼에 수행한 변경 내용을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-150">Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer.</span></span> <span data-ttu-id="fa4b5-151">렌더링할 수 변경된 된 영역 백 버퍼에 해당 변경 된 영역에 있어야는 <xref:System.Windows.Interop.D3DImage>합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-151">To be rendered, the changed area on the back buffer must have a corresponding changed area on the <xref:System.Windows.Interop.D3DImage>.</span></span>  
  
 <span data-ttu-id="fa4b5-152">호출 된 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 및 <xref:System.Windows.Interop.D3DImage.Lock%2A> 메서드 호출 하기 전에 <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-152">Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> and <xref:System.Windows.Interop.D3DImage.Lock%2A> methods before calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method.</span></span>  
  
 <span data-ttu-id="fa4b5-153">호출 된 <xref:System.Windows.Interop.D3DImage.Unlock%2A> 프런트 버퍼에 변경된 된 영역을 복사 하려면.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-153">Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to copy the changed areas to the front buffer.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fa4b5-154">몇 번 호출 하는 <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> 메서드를 단일 영역으로 변경된 된 영역 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-154">After a few calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method, the changed areas are merged into a single area.</span></span> <span data-ttu-id="fa4b5-155">이 변경된 된 영역 외부 유효한 데이터가 있어야 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-155">This means you must have valid data outside of the changed areas.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fa4b5-156">다음 코드 예제에서는 호출 하는 방법을 보여 줍니다.는 <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> 백 버퍼에서 변경 된 영역을 지정 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-156">The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to specify the changed region in the back buffer.</span></span> <span data-ttu-id="fa4b5-157">자세한 내용은 참조 [연습: wpf에서 Direct3D9 콘텐츠 호스팅](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-157">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="fa4b5-158">
            <see cref="M:System.Windows.Interop.D3DImage.Lock" /> 또는 <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" /> 메서드를 호출하여 비트맵을 잠그지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-158">The bitmap has not been locked by a call to the <see cref="M:System.Windows.Interop.D3DImage.Lock" /> or <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" /> methods.</span>
          </span>
          <span data-ttu-id="fa4b5-159">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-159">-or-</span>
          </span>
          <span data-ttu-id="fa4b5-160">
            <see cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" /> 메서드를 호출하여 백 버퍼를 할당하지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-160">The back buffer has not been assigned by a call to the <see cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="fa4b5-161">다음 조건 중 하나 이상이 true인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-161">One or more of the following conditions is true.</span>
          </span>
          <span data-ttu-id="fa4b5-162">
            <paramref name="dirtyRect.X" /> &lt; 0</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-162">
              <paramref name="dirtyRect.X" /> &lt; 0</span>
          </span>
          <span data-ttu-id="fa4b5-163">
            <paramref name="dirtyRect.Y" /> &lt; 0</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-163">
              <paramref name="dirtyRect.Y" /> &lt; 0</span>
          </span>
          <span data-ttu-id="fa4b5-164">
            <paramref name="dirtyRect.Width" /> &lt; 0 또는 <paramref name="dirtyRect.Width" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelWidth" /><paramref name="dirtyRect.Height" /> &lt; 0 또는 <paramref name="dirtyRect.Height" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelHeight" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-164">
              <paramref name="dirtyRect.Width" /> &lt; 0 or <paramref name="dirtyRect.Width" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelWidth" /><paramref name="dirtyRect.Height" /> &lt; 0 or <paramref name="dirtyRect.Height" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelHeight" /></span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="fa4b5-165">관리 되지 않는 리소스에 액세스 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-165">for access to unmanaged resources.</span>
          </span>
          <span data-ttu-id="fa4b5-166">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-166">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
          <span data-ttu-id="fa4b5-167">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-167">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-168">이 개체 값의 전체 복사본을 만들어 이 <see cref="T:System.Windows.Interop.D3DImage" /> 개체의 수정 가능한 복제본을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-168">Creates a modifiable clone of this <see cref="T:System.Windows.Interop.D3DImage" /> object, making deep copies of this object's values.</span>
          </span>
          <span data-ttu-id="fa4b5-169">종속성 속성을 복사하는 경우 이 메서드는 리소스 참조와 데이터 바인딩을 복사하지만 이러한 요소는 더 이상 확인되지 않으며 애니메이션이나 해당 현재 값을 복사하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-169">When copying dependency properties, this method copies resource references and data bindings (which may no longer resolve), but not animations or their current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fa4b5-170">현재 개체의 수정 가능한 복제본입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-170">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="fa4b5-171">소스의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성이 <see langword="true." />인 경우에도 복제된 개체의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-171">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property will be <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property was <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-172">수정 가능한 복사본을 생성 하기 위해이 메서드는 고정 된 <xref:System.Windows.Freezable> 개체 (또는 모든 <xref:System.Windows.Freezable> 개체).</span><span class="sxs-lookup"><span data-stu-id="fa4b5-172">This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object).</span></span> <span data-ttu-id="fa4b5-173">편의 위해이 메서드는 강력한 형식의 구현이 포함 된 상속 된 버전을 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-173">For convenience, this method shadows the inherited version with a strongly typed implementation.</span></span>  
  
 <span data-ttu-id="fa4b5-174">자세한 내용은 <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-174">For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="fa4b5-175">복제할 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-175">The object to clone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fa4b5-176">기본(애니메이션이 적용되지 않은) 속성 값을 사용하여 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 복제본(전체 복사본)으로 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-176">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ CloneCurrentValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-177">
            <see cref="T:System.Windows.Interop.D3DImage" /> 개체의 현재 값에 대한 전체 복사본을 만들어 이 개체의 수정 가능한 복제본을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-177">Creates a modifiable clone of this <see cref="T:System.Windows.Interop.D3DImage" /> object, making deep copies of this object's current values.</span>
          </span>
          <span data-ttu-id="fa4b5-178">리소스 참조, 데이터 바인딩 및 애니메이션은 복사되지 않지만 이러한 요소의 현재 값은 복사됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-178">Resource references, data bindings, and animations are not copied, but their current values are copied.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fa4b5-179">현재 개체의 수정 가능한 복제본입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-179">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="fa4b5-180">소스의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성이 <see langword="true" />인 경우에도 복제된 개체의 <see cref="P:System.Windows.Freezable.IsFrozen" /> 속성은 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-180">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property will be <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property was <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-181">수정 가능한 복사본을 생성 하기 위해이 메서드는 고정 된 <xref:System.Windows.Freezable> 개체 (또는 모든 <xref:System.Windows.Freezable> 개체).</span><span class="sxs-lookup"><span data-stu-id="fa4b5-181">This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object).</span></span> <span data-ttu-id="fa4b5-182">편의 위해이 메서드는 강력한 형식의 구현이 포함 된 상속 된 버전을 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-182">For convenience, this method shadows the inherited version with a strongly typed implementation.</span></span>  
  
 <span data-ttu-id="fa4b5-183">자세한 내용은 <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-183">For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="fa4b5-184">복제할 <see cref="T:System.Windows.Freezable" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-184">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fa4b5-185">현재 속성 값을 사용하여 이 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 수정 가능한 클론(전체 복사본)으로 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-185">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CopyBackBuffer">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.Media.Imaging.BitmapSource CopyBackBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CopyBackBuffer" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CopyBackBuffer () As BitmapSource" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::Media::Imaging::BitmapSource ^ CopyBackBuffer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.BitmapSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-186">
            <see cref="T:System.Windows.Interop.D3DImage" />의 소프트웨어 복사본을 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-186">Creates a software copy of the <see cref="T:System.Windows.Interop.D3DImage" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fa4b5-187">백 버퍼의 현재 상태에 대한 소프트웨어 복사본인 <see cref="T:System.Windows.Media.Imaging.BitmapSource" />입니다. 백 버퍼를 읽을 수 없으면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-187">A <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> that is a software copy of the current state of the back buffer; otherwise, <see langword="null" /> if the back buffer cannot be read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-188"><xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> 인쇄 시스템 등의 클라이언트 메서드는 및 <xref:System.Windows.Media.Imaging.RenderTargetBitmap> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-188">The <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method is called by clients such as the printing system and the <xref:System.Windows.Media.Imaging.RenderTargetBitmap> class.</span></span>  
  
 <span data-ttu-id="fa4b5-189">필요에 따라 재정의 <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> 메서드를 사용자 지정 논리를 구현 하 고 다른 반환 <xref:System.Windows.Media.Imaging.BitmapSource>합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-189">Optionally override the <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method to implement custom logic and return a different <xref:System.Windows.Media.Imaging.BitmapSource>.</span></span> <span data-ttu-id="fa4b5-190">예를 들어 자리 표시자를 반환할 수 있습니다 <xref:System.Windows.Media.Imaging.BitmapSource> 경우 기본 <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> 구현은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-190">For example, you can return a placeholder <xref:System.Windows.Media.Imaging.BitmapSource> if the default <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> implementation returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="fa4b5-191">관리 되지 않는 리소스에 액세스 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-191">for access to unmanaged resources.</span>
          </span>
          <span data-ttu-id="fa4b5-192">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-192">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
          <span data-ttu-id="fa4b5-193">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-193">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Windows.Media.Imaging.BitmapSource" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-194">파생 클래스에서 구현되는 경우 <see cref="T:System.Windows.Interop.D3DImage" /> 파생 클래스의 새 인스턴스를 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-194">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Interop.D3DImage" /> derived class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fa4b5-195">새 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-195">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-196">파생 하는 경우는 <xref:System.Windows.Interop.D3DImage> 재정의 해야 클래스는 <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> 메서드 올바른 복제를 활성화 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-196">If you derive from the <xref:System.Windows.Interop.D3DImage> class, you must override the <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> method to enable correct cloning.</span></span> <span data-ttu-id="fa4b5-197">수행 하지 않습니다는 `return new D3DImage()`, 다른 클래스 인스턴스가 올바른 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-197">The default implementation performs a `return new D3DImage()`, which will not be correct if the instance is a different class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!D3DImage ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-198">가비지 컬렉션에 의해 <see cref="T:System.Windows.Interop.D3DImage" />가 회수되기 전에 리소스를 해제하고 기타 정리 작업을 수행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-198">Frees resources and performs other cleanup operations before the <see cref="T:System.Windows.Interop.D3DImage" /> is reclaimed by garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-199">이 메서드는 <xref:System.Object.Finalize%2A>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-199">This method overrides <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="fa4b5-200">응용 프로그램 코드,이 메서드를 호출 하지 않아야 개체의 `Finalize` 메서드를 호출 하 여 가비지 수집기의 종료를 사용 하지 않도록 설정 된 경우가 아니면 자동으로 가비지 수집 중 호출 됩니다는 <xref:System.GC.SuppressFinalize%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-200">Application code should not call this method; an object's `Finalize` method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="fa4b5-201">자세한 내용은 참조 [Finalize 메서드 및 소멸자](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md), 및 [Finalize 메서드를 재정의](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-201">For more information, see [Finalize Methods and Destructors](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md), and [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="fa4b5-202">관리 되지 않는 리소스에 액세스 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-202">for access to unmanaged resources.</span>
          </span>
          <span data-ttu-id="fa4b5-203">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-203">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
          <span data-ttu-id="fa4b5-204">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-204">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override sealed bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <span data-ttu-id="fa4b5-205">아무런 영향이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-205">Has no effect.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fa4b5-206">
            <see cref="T:System.Windows.Interop.D3DImage" />를 수정할 수 없게 만들거나, 수정할 수 없게 만들 수 있는지 여부를 결정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-206">Makes the <see cref="T:System.Windows.Interop.D3DImage" /> unmodifiable or determines whether it can be made unmodifiable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fa4b5-207">모든 경우에 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-207">
              <see langword="false" /> in all cases.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-208"><xref:System.Windows.Interop.D3DImage> 클래스 프런트 버퍼 가용성으로 인해 가능한 변경 내용이 항상 있으므로 고정을 허용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-208">The <xref:System.Windows.Interop.D3DImage> class does not allow freezing because changes are always possible due to front buffer availability.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="fa4b5-209">복사할 인스턴스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-209">The instance to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fa4b5-210">애니메이션이 적용되지 않은 기준 속성 값을 사용하여 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 고정된 복제본으로 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-210">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="fa4b5-211">복사 및 고정할 <see cref="T:System.Windows.Freezable" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-211">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fa4b5-212">현재 인스턴스를 지정된 <see cref="T:System.Windows.Freezable" />의 고정된 복제본으로 만듭니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-212">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="fa4b5-213">개체에 애니메이션 효과를 준 종속성 속성이 있는 경우 애니메이션 효과를 준 현재 값이 복사됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-213">If the object has animated dependency properties, their current animated values are copied.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public override sealed double Height { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Height" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-214">
            <see cref="T:System.Windows.Interop.D3DImage" />의 높이를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-214">Gets the height of the <see cref="T:System.Windows.Interop.D3DImage" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="fa4b5-215">
            <see cref="T:System.Windows.Interop.D3DImage" />의 높이(측정 단위)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-215">The height of the <see cref="T:System.Windows.Interop.D3DImage" />, in measure units.</span>
          </span>
          <span data-ttu-id="fa4b5-216">측정 단위는 1/96인치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-216">A measure unit is 1/96th inch.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-217">값 <xref:System.Windows.Interop.D3DImage.Height%2A> 새 백 버퍼에 대 한 호출에 의해 할당 된 경우에 변경할 수는 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-217">The value of <xref:System.Windows.Interop.D3DImage.Height%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailable">
      <MemberSignature Language="C#" Value="public bool IsFrontBufferAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrontBufferAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrontBufferAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrontBufferAvailable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-218">프런트 버퍼가 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-218">Gets a value that indicates whether a front buffer exists.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="fa4b5-219">프런트 버퍼가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-219">
              <see langword="true" /> if a front buffer exists; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-220">경우에 따라서는 프런트 버퍼 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-220">Occasionally, the front buffer becomes unavailable.</span></span> <span data-ttu-id="fa4b5-221">이 처럼 가용성 화면 잠금, 전체 화면 전용 Direct3D 응용 프로그램, 사용자 전환 또는 기타 시스템 작업에 의해 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-221">This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities.</span></span> <span data-ttu-id="fa4b5-222">WPF 응용 프로그램 처리를 통해 알림을 이러한 경우는 <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-222">When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.</span></span>  <span data-ttu-id="fa4b5-223">사용 하지 못하게 될 프런트 버퍼에 응용 프로그램의 응답으로 소프트웨어 렌더링 대체 WPF 사용 여부에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-223">How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.</span></span> <span data-ttu-id="fa4b5-224"><xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 메서드에 WPF 소프트웨어 렌더링으로 다시 속하는지 여부를 지정 하는 매개 변수를 사용 하는 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-224">The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.</span></span> <span data-ttu-id="fa4b5-225">자세한 내용은의 설명을 참조는 <xref:System.Windows.Interop.D3DImage> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-225">For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.</span></span>  
  
<a name="dependencyPropertyInfo_IsFrontBufferAvailable"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="fa4b5-226">종속성 속성 정보</span><span class="sxs-lookup"><span data-stu-id="fa4b5-226">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="fa4b5-227">식별자 필드</span><span class="sxs-lookup"><span data-stu-id="fa4b5-227">Identifier field</span></span>|<xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|  
|<span data-ttu-id="fa4b5-228">로 메타 데이터 속성 설정 `true`</span><span class="sxs-lookup"><span data-stu-id="fa4b5-228">Metadata properties set to `true`</span></span>|<span data-ttu-id="fa4b5-229">없음</span><span class="sxs-lookup"><span data-stu-id="fa4b5-229">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="fa4b5-230">다음 코드 예제를 확인 하는 방법을 보여 줍니다는 <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A> 컴퍼지션 대상이 렌더링 하는 경우에 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-230">The following code example shows how to check the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A> property when rendering the composition target.</span></span> <span data-ttu-id="fa4b5-231">자세한 내용은 참조 [연습: wpf에서 Direct3D9 콘텐츠 호스팅](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-231">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#2](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
        <altmember cref="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsFrontBufferAvailableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsFrontBufferAvailableChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-232">
            <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /> 속성이 변경되면 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-232">Occurs when the <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /> property changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-233">처리는 <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> 프런트 버퍼 상태가 변경 될 때 알림을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-233">Handle the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> to be notified when the status of the front buffer changes.</span></span> <span data-ttu-id="fa4b5-234">사용 하지 못하게 될 프런트 버퍼에 응용 프로그램의 응답으로 소프트웨어 렌더링 대체 WPF 사용 여부에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-234">How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.</span></span> <span data-ttu-id="fa4b5-235"><xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 메서드에 WPF 소프트웨어 렌더링으로 다시 속하는지 여부를 지정 하는 매개 변수를 사용 하는 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-235">The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.</span></span> <span data-ttu-id="fa4b5-236">자세한 내용은의 설명을 참조는 <xref:System.Windows.Interop.D3DImage> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-236">For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFrontBufferAvailableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFrontBufferAvailableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFrontBufferAvailableProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-237">
            <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /> 종속성 속성을 식별합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-237">Identifies the <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Lock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Lock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-238">
            <see cref="T:System.Windows.Interop.D3DImage" />를 잠그고 백 버퍼에 대한 작업을 사용할 수 있게 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-238">Locks the <see cref="T:System.Windows.Interop.D3DImage" /> and enables operations on the back buffer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-239">호출 된 <xref:System.Windows.Interop.D3DImage.Lock%2A> 메서드를 호출 하 여 백 버퍼를 변경할는 <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> 및 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-239">Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the back buffer by calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> and <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> methods.</span></span> <span data-ttu-id="fa4b5-240">동안는 <xref:System.Windows.Interop.D3DImage> 은 잠겨 있고 응용 프로그램에 렌더링할 수도 있습니다 Direct3D 화면 백 버퍼에 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-240">While the <xref:System.Windows.Interop.D3DImage> is locked, your application can also render to the Direct3D surface assigned to the back buffer.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fa4b5-241"><xref:System.Windows.Interop.D3DImage.Lock%2A> 렌더링 시스템 프런트 버퍼를 업데이트 하는 백 버퍼를 읽는 메서드가 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-241">The <xref:System.Windows.Interop.D3DImage.Lock%2A> method blocks when the rendering system is reading the back buffer to update the front buffer.</span></span> <span data-ttu-id="fa4b5-242">사용 된 <xref:System.Windows.Interop.D3DImage.TryLock%2A> 메서드를 무기한으로 차단 되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-242">Use the <xref:System.Windows.Interop.D3DImage.TryLock%2A> method to avoid blocking indefinitely.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fa4b5-243">다음 코드 예제에서는 호출 하는 방법을 보여 줍니다.는 <xref:System.Windows.Interop.D3DImage.Lock%2A> 메서드 백 버퍼에 업데이트할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-243">The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to enable updates to the back buffer.</span></span> <span data-ttu-id="fa4b5-244">자세한 내용은 참조 [연습: wpf에서 Direct3D9 콘텐츠 호스팅](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-244">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="fa4b5-245">잠금 횟수가 <see cref="F:System.UInt32.MaxValue" />와 동일한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-245">The lock count equals <see cref="F:System.UInt32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.Media.ImageMetadata Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageMetadata Metadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Metadata" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Metadata As ImageMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageMetadata ^ Metadata { System::Windows::Media::ImageMetadata ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-246">이미지 소스에 연결된 메타데이터를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-246">Gets the metadata associated with the image source.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="fa4b5-247">모든 경우에 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-247">
              <see langword="null" /> in all cases.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PixelHeight">
      <MemberSignature Language="C#" Value="public int PixelHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelHeight { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-248">
            <see cref="T:System.Windows.Interop.D3DImage" />의 높이(픽셀)를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-248">Gets the height of the <see cref="T:System.Windows.Interop.D3DImage" />, in pixels.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="fa4b5-249">
            <see cref="T:System.Windows.Interop.D3DImage" />의 높이(픽셀)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-249">The height of the <see cref="T:System.Windows.Interop.D3DImage" />, in pixels.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-250">값 <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> 새 백 버퍼에 대 한 호출에 의해 할당 된 경우에 변경할 수는 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-250">The value of <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fa4b5-251">다음 코드 예제를 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> 속성을 통해 백 버퍼에서 변경된 된 영역을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-251">The following code example shows how to use the <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> property to specify the changed region in the back buffer.</span></span> <span data-ttu-id="fa4b5-252">자세한 내용은 참조 [연습: wpf에서 Direct3D9 콘텐츠 호스팅](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-252">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelWidth" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PixelWidth">
      <MemberSignature Language="C#" Value="public int PixelWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelWidth { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-253">
            <see cref="T:System.Windows.Interop.D3DImage" />의 너비(픽셀)를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-253">Gets the width of the <see cref="T:System.Windows.Interop.D3DImage" />, in pixels.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="fa4b5-254">
            <see cref="T:System.Windows.Interop.D3DImage" />의 너비(픽셀 단위)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-254">The width of the <see cref="T:System.Windows.Interop.D3DImage" />, in pixels.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-255">값 <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> 새 백 버퍼에 대 한 호출에 의해 할당 된 경우에 변경할 수는 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-255">The value of <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fa4b5-256">다음 코드 예제를 사용 하는 방법을 보여 줍니다는 <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> 속성을 통해 백 버퍼에서 변경된 된 영역을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-256">The following code example shows how to use the <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> property to specify the changed region in the back buffer.</span></span> <span data-ttu-id="fa4b5-257">자세한 내용은 참조 [연습: wpf에서 Direct3D9 콘텐츠 호스팅](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-257">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelHeight" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBackBuffer">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-258">Direct3D 화면을 백 버퍼의 소스로 할당합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-258">Assigns a Direct3D surface as the source of the back buffer.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" />
        <Parameter Name="backBuffer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="backBufferType">
          <span data-ttu-id="fa4b5-259">Direct3D 화면의 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-259">The type of Direct3D surface.</span>
          </span>
          <span data-ttu-id="fa4b5-260">유효한 <see cref="T:System.Windows.Interop.D3DResourceType" />이어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-260">Must be a valid <see cref="T:System.Windows.Interop.D3DResourceType" />.</span>
          </span>
        </param>
        <param name="backBuffer">
          <span data-ttu-id="fa4b5-261">백 버퍼로 할당할 Direct3D 화면입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-261">The Direct3D surface to assign as the back buffer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fa4b5-262">Direct3D 화면을 백 버퍼의 소스로 할당합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-262">Assigns a Direct3D surface as the source of the back buffer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-263">호출 된 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Direct3D 화면 백 버퍼에 할당 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-263">Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to the back buffer.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fa4b5-264">성능은은 Direct3D 화면 설정에 따라 크게 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-264">Performance depends greatly on the settings of the Direct3D surface.</span></span> <span data-ttu-id="fa4b5-265">자세한 내용은 참조 [Direct3D9 및 WPF 상호 운용성에 대 한 성능 고려 사항](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-265">For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).</span></span>  
  
 <span data-ttu-id="fa4b5-266">호출의 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> 오버 로드는 호출 하는 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> 오버 로드는 `enableSoftwareFallback` 매개 변수 설정 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-266">Calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload is identical to calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`.</span></span> <span data-ttu-id="fa4b5-267">호출 하는 경우 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> 호출 또는 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> 와 `enableSoftwareFallback` 매개 변수 설정 `false`, 렌더링 시스템 프런트 버퍼를 사용할 수 없게 되며 아무 것도 표시 하는 경우 백 버퍼에 대 한 참조를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-267">When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> or call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when front buffer becomes unavailable and nothing is displayed.</span></span> <span data-ttu-id="fa4b5-268">프런트 버퍼를 사용할 수 있는 다시 렌더링 발생는 <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> WPF 응용 프로그램에 알리는 이벤트를 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-268">When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.</span></span>  <span data-ttu-id="fa4b5-269">에 대 한 이벤트 처리기를 만들 수는 <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> 유효한 Direct3D 화면을 사용 하 여 다시 렌더링을 다시 시작 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-269">You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface.</span></span> <span data-ttu-id="fa4b5-270">호출 해야 렌더링을 다시 시작 하려면 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-270">To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</span></span>  
  
 <span data-ttu-id="fa4b5-271">다음 목록에 대 한 필요한 백 버퍼 설정을 표시는 `IDirect3DSurface9` 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-271">The following list shows the required back buffer settings for the `IDirect3DSurface9` type.</span></span>  
  
-   <span data-ttu-id="fa4b5-272">`D3DFMT_A8R8G8B8` 또는 `D3DFMT_X8R8G8B8`</span><span class="sxs-lookup"><span data-stu-id="fa4b5-272">`D3DFMT_A8R8G8B8` or `D3DFMT_X8R8G8B8`</span></span>  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 <span data-ttu-id="fa4b5-273">샘플링에 사용할 수는 `IDirect3DSurface9Ex` 만 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-273">Multisampling is allowed on `IDirect3DSurface9Ex` surfaces only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fa4b5-274">다음 코드 예제에서는 호출 하는 방법을 보여 줍니다.는 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 메서드를 Direct3D 화면을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-274">The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface.</span></span> <span data-ttu-id="fa4b5-275">자세한 내용은 참조 [연습: wpf에서 Direct3D9 콘텐츠 호스팅](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-275">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="fa4b5-276">
            <see cref="T:System.Windows.Interop.D3DImage" /> 또는 <see cref="M:System.Windows.Interop.D3DImage.Lock" /> 메서드를 호출하여 <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />를 잠그지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-276">The <see cref="T:System.Windows.Interop.D3DImage" /> has not been locked by a call to the <see cref="M:System.Windows.Interop.D3DImage.Lock" /> or <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" /> methods.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="fa4b5-277">
            <paramref name="backBufferType" />은 유효한 <see cref="T:System.Windows.Interop.D3DResourceType" />이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-277">
              <paramref name="backBufferType" /> is not a valid <see cref="T:System.Windows.Interop.D3DResourceType" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="fa4b5-278">
            <paramref name="backBuffer" />의 생성 매개 변수가 <paramref name="backBufferType" />의 요구 사항에 부합되지 않거나 <paramref name="backBuffer" /> 장치가 유효하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-278">The creation parameters for <paramref name="backBuffer" /> do not meet the requirements for the <paramref name="backBufferType" />-or-The <paramref name="backBuffer" /> device is not valid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="fa4b5-279">관리 되지 않는 리소스에 액세스 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-279">for access to unmanaged resources.</span>
          </span>
          <span data-ttu-id="fa4b5-280">보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-280">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
          <span data-ttu-id="fa4b5-281">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-281">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer, bool enableSoftwareFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr, enableSoftwareFallback As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" />
        <Parameter Name="backBuffer" Type="System.IntPtr" />
        <Parameter Name="enableSoftwareFallback" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="backBufferType">
          <span data-ttu-id="fa4b5-282">Direct3D 화면의 유형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-282">The type of Direct3D surface.</span>
          </span>
          <span data-ttu-id="fa4b5-283">유효한 <see cref="T:System.Windows.Interop.D3DResourceType" />이어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-283">Must be a valid <see cref="T:System.Windows.Interop.D3DResourceType" />.</span>
          </span>
        </param>
        <param name="backBuffer">
          <span data-ttu-id="fa4b5-284">백 버퍼로 할당할 Direct3D 화면입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-284">The Direct3D surface to assign as the back buffer.</span>
          </span>
        </param>
        <param name="enableSoftwareFallback">
          <span data-ttu-id="fa4b5-285">소프트웨어 렌더링에서 폴백하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-285">
              <see langword="true" /> to fall back on software rendering; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fa4b5-286">Direct3D 화면을 백 버퍼의 소스로 할당합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-286">Assigns a Direct3D surface as the source of the back buffer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-287">호출 하는 경우는 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> 오버 로드 또는 호출의 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> 오버 로드는 `enableSoftwareFallback` 매개 변수 설정 `false`, 프런트 버퍼를 사용할 수 없게 되 고 아무 것도 렌더링 시스템 백 버퍼에 대 한 참조를 해제 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-287">When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed.</span></span> <span data-ttu-id="fa4b5-288">프런트 버퍼를 사용할 수 있는 다시 렌더링 발생는 <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> WPF 응용 프로그램에 알리는 이벤트를 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-288">When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.</span></span>  <span data-ttu-id="fa4b5-289">에 대 한 이벤트 처리기를 만들 수는 <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> 유효한 Direct3D 화면을 사용 하 여 다시 렌더링을 다시 시작 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-289">You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface.</span></span> <span data-ttu-id="fa4b5-290">호출 해야 렌더링을 다시 시작 하려면 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-290">To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</span></span>  
  
 <span data-ttu-id="fa4b5-291">호출 하는 경우 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> 와 `enableSoftwareFallback` 매개 변수 설정 `true`, 렌더링 시스템을 호출할 필요가 없습니다 이므로 프런트 버퍼를 사용할 수 없을 때 백 버퍼에 대 한 참조를 유지 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 프런트 버퍼가 사용 가능한 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-291">When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again.</span></span>  <span data-ttu-id="fa4b5-292">사용자의 장치 사용할 수 없게 되는 경우가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-292">There may be situations where the user’s device becomes unavailable.</span></span>  <span data-ttu-id="fa4b5-293">이 경우 호출 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 백 버퍼에 대 한 WPF의 참조를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-293">When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer.</span></span>  <span data-ttu-id="fa4b5-294">장치를 재설정 해야 할 경우 호출 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 와 `backBuffer` 로 설정 `null`, 한 다음 호출 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 사용 하 여 다시 `backBuffer` 유효한 Direct3D 화면으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-294">If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with `backBuffer` set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface.</span></span>  
  
 <span data-ttu-id="fa4b5-295">다음 목록에 대 한 필요한 백 버퍼 설정을 표시는 `IDirect3DSurface9` 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-295">The following list shows the required back buffer settings for the `IDirect3DSurface9` type.</span></span>  
  
-   <span data-ttu-id="fa4b5-296">`D3DFMT_A8R8G8B8` 또는 `D3DFMT_X8R8G8B8`</span><span class="sxs-lookup"><span data-stu-id="fa4b5-296">`D3DFMT_A8R8G8B8` or `D3DFMT_X8R8G8B8`</span></span>  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 <span data-ttu-id="fa4b5-297">샘플링에 사용할 수는 `IDirect3DSurface9Ex` 만 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-297">Multisampling is allowed on `IDirect3DSurface9Ex` surfaces only.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryLock (timeout As Duration) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryLock(System::Windows::Duration timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="fa4b5-298">잠금을 가져올 때까지 대기할 기간입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-298">The duration to wait for the lock to be acquired.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="fa4b5-299">
            <see cref="T:System.Windows.Interop.D3DImage" />를 잠그려고 하고 지정된 기간 동안 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-299">Attempts to lock the <see cref="T:System.Windows.Interop.D3DImage" /> and waits for the specified duration.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="fa4b5-300">잠금을 가져왔으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-300">
              <see langword="true" /> if the lock was acquired; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="fa4b5-301">
            <paramref name="timeout" />이 <see cref="P:System.Windows.Duration.Automatic" />로 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-301">
              <paramref name="timeout" /> is set to <see cref="P:System.Windows.Duration.Automatic" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="fa4b5-302">잠금 횟수가 <see cref="F:System.UInt32.MaxValue" />와 동일한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-302">The lock count equals <see cref="F:System.UInt32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Unlock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-303">
            <see cref="T:System.Windows.Interop.D3DImage" />의 잠금 횟수를 줄입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-303">Decrements the lock count for the <see cref="T:System.Windows.Interop.D3DImage" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-304">잠금 횟수를 <xref:System.Windows.Interop.D3DImage> 0는 <xref:System.Windows.Interop.D3DImage> 완전히 잠금 해제 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-304">When the lock count for the <xref:System.Windows.Interop.D3DImage> reaches zero, the <xref:System.Windows.Interop.D3DImage> is fully unlocked.</span></span> <span data-ttu-id="fa4b5-305"><xref:System.Windows.Interop.D3DImage> 이미지에 대 한 이전 호출에 지정 된 영역 변경 된 경우 렌더링에 대 한 표시는 <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-305">The <xref:System.Windows.Interop.D3DImage> is marked for rendering if the image has changed areas that were specified by previous calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method.</span></span>  
  
 <span data-ttu-id="fa4b5-306">변경 내용이 커밋되고 시점과 렌더링이 발생 대 한 추가 호출이 <xref:System.Windows.Interop.D3DImage.Lock%2A> 렌더링 스레드에 백 버퍼의 내용을 프런트 버퍼에 복사 될 때까지 메서드 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-306">When the changes are committed and rendering occurs, additional calls to the <xref:System.Windows.Interop.D3DImage.Lock%2A> method block until the render thread has copied the contents of the back buffer to the front buffer.</span></span> <span data-ttu-id="fa4b5-307">이 동기화 하는 데 필요한 같은 디스플레이 아티팩트를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-307">This synchronization avoids display artifacts, such as tearing.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fa4b5-308">동안 Direct3D 화면을 업데이트 하지 않으면는 <xref:System.Windows.Interop.D3DImage> 잠금 해제 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-308">Do not update the Direct3D surface while the <xref:System.Windows.Interop.D3DImage> is unlocked.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="fa4b5-309">다음 코드 예제에서는 호출 하는 방법을 보여 줍니다.는 <xref:System.Windows.Interop.D3DImage.Unlock%2A> 메서드를 업데이트 하는 백 버퍼 프런트 버퍼에 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-309">The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to copy the updated back buffer to the front buffer.</span></span> <span data-ttu-id="fa4b5-310">자세한 내용은 참조 [연습: wpf에서 Direct3D9 콘텐츠 호스팅](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-310">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public override sealed double Width { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Width" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="fa4b5-311">
            <see cref="T:System.Windows.Interop.D3DImage" />의 너비를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-311">Gets the width of the <see cref="T:System.Windows.Interop.D3DImage" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="fa4b5-312">
            <see cref="T:System.Windows.Interop.D3DImage" />의 너비(측정 단위)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-312">The width of the <see cref="T:System.Windows.Interop.D3DImage" />, in measure units.</span>
          </span>
          <span data-ttu-id="fa4b5-313">측정 단위는 1/96인치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="fa4b5-313">A measure unit is 1/96th inch.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="fa4b5-314">값 <xref:System.Windows.Interop.D3DImage.Width%2A> 새 백 버퍼에 대 한 호출에 의해 할당 된 경우에 변경할 수는 <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="fa4b5-314">The value of <xref:System.Windows.Interop.D3DImage.Width%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
  </Members>
</Type>