<Type Name="RoleProvider" FullName="System.Web.Security.RoleProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3757f1028efe51406cc012df7b30024bd71a31b6" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30550267" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class RoleProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit RoleProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.Security.RoleProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class RoleProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoleProvider abstract : System::Configuration::Provider::ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web.ApplicationServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Web, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ASP.NET에서 사용자 지정 역할 공급자를 사용하여 역할 관리 서비스를 제공하기 위해 구현하는 계약을 정의합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 역할 관리는 ASP.NET 응용 프로그램에 대 한 여러 가지 역할 공급자를 쉽게 사용할 수 있도록 설계 되었습니다. .NET Framework에 포함 되어 있는 제공 된 역할 공급자를 사용 하거나 사용자 고유의 공급자를 구현할 수 있습니다.  
  
 상속 해야 사용자 지정 역할 공급자를 구현할 때는 <xref:System.Web.Security.RoleProvider> 추상 클래스입니다.  
  
 사용자 지정 역할 공급자를 만드는 두 가지 주요 이유가 있습니다.  
  
-   FoxPro 데이터베이스, Oracle 데이터베이스 또는 다른 데이터 원본과 같은.NET Framework에 포함 된 역할 공급자에서 지원 되지 않는 데이터 원본에 역할 정보를 저장 해야 합니다.  
  
-   .NET Framework와 함께 제공 되는 공급자에서 사용 되는 데이터베이스 스키마와에서는 다른 데이터베이스 스키마를 사용 하 여 역할 정보를 관리 해야 합니다. 이 일반적인 예로 회사 또는 웹 사이트에 대 한 SQL Server 데이터베이스에 이미 있는 역할 데이터가 표시 됩니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected RoleProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.RoleProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; RoleProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.Security.RoleProvider" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상속 된 클래스에 대 한 생성자를 구현 하지 않아도 됩니다는 <xref:System.Web.Security.RoleProvider> 추상 클래스입니다. 초기화에 대 한 값을 <xref:System.Web.Security.RoleProvider> 구현에 전달 되는 <xref:System.Configuration.Provider.ProviderBase.Initialize%2A> 메서드 구현 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddUsersToRoles">
      <MemberSignature Language="C#" Value="public abstract void AddUsersToRoles (string[] usernames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddUsersToRoles(string[] usernames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.RoleProvider.AddUsersToRoles(System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub AddUsersToRoles (usernames As String(), roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void AddUsersToRoles(cli::array &lt;System::String ^&gt; ^ usernames, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="usernames">지정된 역할에 추가할 사용자 이름으로 이루어진 문자열 배열입니다.</param>
        <param name="roleNames">지정된 사용자 이름을 추가할 역할 이름으로 이루어진 문자열 배열입니다.</param>
        <summary>구성된 <see langword="applicationName" />의 특정 역할에 지정된 사용자 이름을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.RoleProvider.AddUsersToRoles%2A> 에 의해 호출 됩니다는 <xref:System.Web.Security.Roles> 데이터 소스에서 지정 된 역할에 지정된 된 사용자를 연결할 클래스입니다. 역할은 추가 구성 된에 <xref:System.Web.Security.RoleProvider.ApplicationName%2A>합니다.  
  
 구성 된 찾을 수 없습니다는 지정 된 역할 이름 중 하나가 `applicationName`, 공급자를 throw 하는 것이 좋습니다는 <xref:System.Configuration.Provider.ProviderException>합니다.  
  
 구성 된 지정 된 역할 이름 중 연결 된 경우 지정 된 사용자 이름 중 하나가 `applicationName`, 공급자를 throw 하는 것이 좋습니다는 <xref:System.Configuration.Provider.ProviderException>합니다.  
  
 지정된 된 사용자 이름 중 하나라도 `null` 은 빈 문자열 또는 공급자 예외를 throw 하는 것이 좋습니다.  
  
 지정된 된 역할 이름 중 하나라도 `null` 은 빈 문자열 또는 공급자 예외를 throw 하는 것이 좋습니다.  
  
 데이터 원본 트랜잭션을 지 원하는 경우 각각 포함 하는 것이 좋습니다 트랜잭션에서 작업을 추가 하 고 트랜잭션 및 추가 작업이 실패할 경우 예외를 throw 하는 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 샘플 구현을 보여 줍니다.는 <xref:System.Web.Security.RoleProvider.AddUsersToRoles%2A> 메서드.  
  
 [!code-csharp[System.Web.Security.IRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/CS/odbcroleprovidersnippets.cs#2)]
 [!code-vb[System.Web.Security.IRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/VB/odbcroleprovidersnippets.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.RoleProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>역할 정보를 저장하거나 검색할 응용 프로그램의 이름을 가져오거나 설정합니다.</summary>
        <value>역할 정보를 저장하거나 검색할 응용 프로그램의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.RoleProvider.ApplicationName%2A> 에서 사용 되는 <xref:System.Web.Security.Roles> 사용자 및 역할을 서로 다른 응용 프로그램과 연결 하는 클래스입니다. 이렇게 하면 여러 응용 프로그램이 동일한 데이터베이스를 사용 하 여 중복 된 사용자 이름이 나 역할 이름 간의 충돌을 일으키지 않고 사용자 및 역할 정보를 저장할 수 있습니다. 여러 ASP.NET 응용 프로그램에서 같은 값을 지정 하 여 동일한 데이터베이스를 사용할 수는 <xref:System.Web.Security.Roles.ApplicationName%2A> 속성입니다. <xref:System.Web.Security.Roles.ApplicationName%2A> 속성을 프로그래밍 방식으로 설정할 수 있습니다. 또는 사용 하 여 웹 응용 프로그램에 대 한 구성 파일에서 선언적으로 설정할 수 있습니다는 `applicationName` 특성입니다.  
  
 하지 않으면 <xref:System.Web.Security.RoleProvider.ApplicationName%2A> 속성을 지정 하는 것이 좋습니다는 <xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A> 속성 값이 사용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 샘플 구현을 보여 줍니다.는 <xref:System.Web.Security.RoleProvider.ApplicationName%2A> 속성입니다.  
  
 [!code-csharp[System.Web.Security.IRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/CS/odbcroleprovidersnippets.cs#1)]
 [!code-vb[System.Web.Security.IRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/VB/odbcroleprovidersnippets.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRole">
      <MemberSignature Language="C#" Value="public abstract void CreateRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.RoleProvider.CreateRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub CreateRole (roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void CreateRole(System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">만들 역할의 이름입니다.</param>
        <summary>구성된 <see langword="applicationName" />의 데이터 원본에 새 역할을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.RoleProvider.CreateRole%2A> 에 의해 호출 됩니다는 <xref:System.Web.Security.Roles.CreateRole%2A> 의 메서드는 <xref:System.Web.Security.Roles> 구성 된 데이터 원본에 지정된 된 역할을 추가 하려면 클래스 <xref:System.Web.Security.RoleProvider.ApplicationName%2A>합니다.  
  
 구성 된 지정된 된 역할 이름이 이미 있는 경우 `applicationName`은 `null`은 빈 문자열 또는 공급자 예외를 throw 하는 것이 좋습니다.  
  
 지정된 된 역할 이름이 쉼표를 포함 하는 경우 공급자는 예외를 throw를 하는 것이 좋습니다.  
  
 데이터 소스 역할 이름의 길이 제한 하는 경우 예를 들어 데이터베이스에 있는 테이블의 고정 길이 열을 통해 것이 좋습니다 역할 이름이 데이터 원본에 의해 허용 된 최대 길이 초과 하는 경우 예외를 throw 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 샘플 구현을 보여 줍니다.는 <xref:System.Web.Security.RoleProvider.CreateRole%2A> 메서드.  
  
 [!code-csharp[System.Web.Security.IRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/CS/odbcroleprovidersnippets.cs#3)]
 [!code-vb[System.Web.Security.IRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/VB/odbcroleprovidersnippets.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteRole">
      <MemberSignature Language="C#" Value="public abstract bool DeleteRole (string roleName, bool throwOnPopulatedRole);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool DeleteRole(string roleName, bool throwOnPopulatedRole) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.RoleProvider.DeleteRole(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function DeleteRole (roleName As String, throwOnPopulatedRole As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool DeleteRole(System::String ^ roleName, bool throwOnPopulatedRole);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="throwOnPopulatedRole" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="roleName">삭제할 역할의 이름입니다.</param>
        <param name="throwOnPopulatedRole">
          <see langword="true" />인 경우 <c>roleName</c>에 멤버가 하나 이상 있으면 예외를 throw하고 <c>roleName</c>을 삭제하지 않습니다.</param>
        <summary>구성된 <see langword="applicationName" />의 데이터 원본에서 역할을 제거합니다.</summary>
        <returns>
          역할을 삭제했으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.RoleProvider.DeleteRole%2A> 에 의해 호출 됩니다는 <xref:System.Web.Security.Roles.DeleteRole%2A> 및 <xref:System.Web.Security.Roles.DeleteRole%2A> 의 메서드는 <xref:System.Web.Security.Roles> 구성 된 데이터 원본에서 지정된 된 역할을 삭제 하는 클래스 <xref:System.Web.Security.RoleProvider.ApplicationName%2A>합니다.  
  
 데이터 소스에서 역할을 삭제 하는 경우 사용자 이름 및 구성 된 삭제 된 역할 간의 연결도 삭제 하는 확인 `applicationName`합니다.  
  
 경우 `throwOnPopulatedRole` 은 `true`,으로 식별 된 역할는 `roleName` 매개 변수 하나 또는 그 이상의 구성원이를 throw 한 <xref:System.Configuration.Provider.ProviderException> 와 역할을 삭제 하지 않습니다. 경우 `throwOnPopulatedRole` 은 `false`, 여부 비어 있는지 여부를 다음 역할을 삭제 합니다.  
  
 지정된 된 역할 이름이 존재 하지 않는 경우는 `null`은 빈 문자열 또는 공급자 예외를 throw 하는 것이 좋습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 샘플 구현을 보여 줍니다.는 <xref:System.Web.Security.RoleProvider.DeleteRole%2A> 메서드.  
  
 [!code-csharp[System.Web.Security.IRoleProvider#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/CS/odbcroleprovidersnippets.cs#4)]
 [!code-vb[System.Web.Security.IRoleProvider#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/VB/odbcroleprovidersnippets.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindUsersInRole">
      <MemberSignature Language="C#" Value="public abstract string[] FindUsersInRole (string roleName, string usernameToMatch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] FindUsersInRole(string roleName, string usernameToMatch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.RoleProvider.FindUsersInRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindUsersInRole (roleName As String, usernameToMatch As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ FindUsersInRole(System::String ^ roleName, System::String ^ usernameToMatch);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="usernameToMatch" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">검색할 역할입니다.</param>
        <param name="usernameToMatch">검색할 사용자 이름입니다.</param>
        <summary>지정된 사용자 이름과 일치하는 부분이 사용자 이름에 포함되어 있는 사용자 이름의 배열을 역할에서 가져옵니다.</summary>
        <returns>지정된 역할의 멤버이면서 사용자 이름이 <paramref name="usernameToMatch" />와 일치하는 모든 사용자의 이름이 포함된 문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.RoleProvider.FindUsersInRole%2A> 메서드는 <xref:System.Web.Security.Roles> 클래스 및 사용자 이름이 제공 된 일치 하는 항목에 포함 된 역할에 사용자의 목록을 반환 `usernameToMatch` 구성 된 `applicationName`합니다. 와일드 카드를 지원 데이터 원본에 따라 포함 되어 있습니다. 사용자는 사용자 이름으로 알파벳 순서로 반환 됩니다.  
  
 throw 하는 것이 좋습니다는 <xref:System.Configuration.Provider.ProviderException> 경우 `roleName` 데이터 원본에 존재 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 예제를 보여 줍니다. <xref:System.Web.Security.RoleProvider.FindUsersInRole%2A> 구현 합니다.  
  
 [!code-csharp[System.Web.Security.IRoleProvider#11](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/CS/odbcroleprovidersnippets.cs#11)]
 [!code-vb[System.Web.Security.IRoleProvider#11](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/VB/odbcroleprovidersnippets.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllRoles">
      <MemberSignature Language="C#" Value="public abstract string[] GetAllRoles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetAllRoles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.RoleProvider.GetAllRoles" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAllRoles () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetAllRoles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>구성된 <see langword="applicationName" />의 모든 역할 목록을 가져옵니다.</summary>
        <returns>구성된 <see langword="applicationName" />의 데이터 소스에 저장된 응용 프로그램의 모든 역할 이름이 포함된 문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.RoleProvider.GetAllRoles%2A> 에 의해 호출 됩니다는 <xref:System.Web.Security.Roles.GetAllRoles%2A> 의 메서드는 <xref:System.Web.Security.Roles> 역할 이름 목록을 데이터 원본에서 검색할 클래스입니다. 지정 된 역할에 대해서만 <xref:System.Web.Security.RoleProvider.ApplicationName%2A> 검색 됩니다.  
  
 구성 된 역할이 없으면 `applicationName`, 공급자에 요소가 없는 문자열 배열을 반환 하는 것이 좋습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 샘플 구현을 보여 줍니다.는 <xref:System.Web.Security.RoleProvider.GetAllRoles%2A> 메서드.  
  
 [!code-csharp[System.Web.Security.IRoleProvider#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/CS/odbcroleprovidersnippets.cs#5)]
 [!code-vb[System.Web.Security.IRoleProvider#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/VB/odbcroleprovidersnippets.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRolesForUser">
      <MemberSignature Language="C#" Value="public abstract string[] GetRolesForUser (string username);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetRolesForUser(string username) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.RoleProvider.GetRolesForUser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetRolesForUser (username As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetRolesForUser(System::String ^ username);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">역할 목록을 반환할 사용자입니다.</param>
        <summary>지정된 사용자가 속하는 구성된 <see langword="applicationName" />의 역할 목록을 가져옵니다.</summary>
        <returns>지정된 사용자가 속하는 구성된 <see langword="applicationName" />의 모든 역할 이름이 포함된 문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.RoleProvider.GetRolesForUser%2A> 에 의해 호출 됩니다는 <xref:System.Web.Security.Roles.GetRolesForUser%2A> 의 메서드는 <xref:System.Web.Security.Roles> 클래스를 데이터 소스에서 지정된 된 사용자가 연관 된 역할 이름을 검색 합니다. 구성 된 역할에 대해서만 <xref:System.Web.Security.RoleProvider.ApplicationName%2A> 검색 됩니다.  
  
 구성 된 지정 된 사용자 역할이 없으면 `applicationName`, 공급자에 요소가 없는 문자열 배열을 반환 하는 것이 좋습니다.  
  
 지정한 사용자 이름이 `null` 은 빈 문자열 또는 공급자 예외를 throw 하는 것이 좋습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 샘플 구현을 보여 줍니다.는 <xref:System.Web.Security.RoleProvider.GetRolesForUser%2A> 메서드.  
  
 [!code-csharp[System.Web.Security.IRoleProvider#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/CS/odbcroleprovidersnippets.cs#6)]
 [!code-vb[System.Web.Security.IRoleProvider#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/VB/odbcroleprovidersnippets.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUsersInRole">
      <MemberSignature Language="C#" Value="public abstract string[] GetUsersInRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetUsersInRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.RoleProvider.GetUsersInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetUsersInRole (roleName As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetUsersInRole(System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">사용자 목록을 가져올 역할의 이름입니다.</param>
        <summary>구성된 <see langword="applicationName" />의 지정된 역할에 있는 사용자 목록을 가져옵니다.</summary>
        <returns>구성된 <see langword="applicationName" />의 지정된 역할 멤버에 해당하는 모든 사용자의 이름이 포함된 문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.RoleProvider.GetUsersInRole%2A> 에 의해 호출 됩니다는 <xref:System.Web.Security.Roles.GetUsersInRole%2A> 의 메서드는 <xref:System.Web.Security.Roles> 클래스를 데이터 소스에서 역할에 연결 된 사용자 이름을 검색 합니다. 구성 된 역할에 대해서만 <xref:System.Web.Security.RoleProvider.ApplicationName%2A> 검색 됩니다.  
  
 지정된 된 역할 이름이 구성 된 존재 하지 않는 경우 `applicationName` 경우 `null` 또는 빈 문자열이 면 좋습니다 공급자 예외를 throw 합니다.  
  
 사용자가 구성 된 지정 된 역할에 연결 된 경우 `applicationName`, 공급자에 요소가 없는 문자열 배열을 반환 하는 것이 좋습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 샘플 구현을 보여 줍니다.는 <xref:System.Web.Security.RoleProvider.GetUsersInRole%2A> 메서드.  
  
 [!code-csharp[System.Web.Security.IRoleProvider#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/CS/odbcroleprovidersnippets.cs#7)]
 [!code-vb[System.Web.Security.IRoleProvider#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/VB/odbcroleprovidersnippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUserInRole">
      <MemberSignature Language="C#" Value="public abstract bool IsUserInRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsUserInRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.RoleProvider.IsUserInRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsUserInRole (username As String, roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsUserInRole(System::String ^ username, System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">검색할 사용자 이름입니다.</param>
        <param name="roleName">검색할 역할입니다.</param>
        <summary>구성된 <see langword="applicationName" />의 특정 역할에 지정된 사용자가 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns>
          구성된 <see langword="true" />의 특정 역할에 지정된 사용자가 있으면 <see langword="applicationName" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.RoleProvider.IsUserInRole%2A> 메서드는 <xref:System.Web.Security.Roles.IsUserInRole%2A> 의 메서드는 <xref:System.Web.Security.Roles> 구성 된 데이터 원본에서 역할에 연결 된 현재 로그온 한 사용자 인지 확인 하는 클래스 <xref:System.Web.Security.Roles.ApplicationName%2A>합니다.  
  
 지정한 사용자 이름이 `null` 은 빈 문자열 또는 공급자 예외를 throw 하는 것이 좋습니다.  
  
 지정 된 역할 이름이 `null` 은 빈 문자열 또는 공급자 예외를 throw 하는 것이 좋습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 샘플 구현을 보여 줍니다.는 <xref:System.Web.Security.RoleProvider.IsUserInRole%2A> 메서드.  
  
 [!code-csharp[System.Web.Security.IRoleProvider#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/CS/odbcroleprovidersnippets.cs#8)]
 [!code-vb[System.Web.Security.IRoleProvider#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/VB/odbcroleprovidersnippets.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveUsersFromRoles">
      <MemberSignature Language="C#" Value="public abstract void RemoveUsersFromRoles (string[] usernames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveUsersFromRoles(string[] usernames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.RoleProvider.RemoveUsersFromRoles(System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub RemoveUsersFromRoles (usernames As String(), roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void RemoveUsersFromRoles(cli::array &lt;System::String ^&gt; ^ usernames, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="usernames">지정된 역할에서 제거할 사용자 이름으로 이루어진 문자열 배열입니다.</param>
        <param name="roleNames">지정된 사용자 이름을 제거할 역할 이름으로 이루어진 문자열 배열입니다.</param>
        <summary>구성된 <see langword="applicationName" />의 특정 역할에서 지정된 사용자 이름을 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.RoleProvider.RemoveUsersFromRoles%2A> 호출한 <xref:System.Web.Security.Roles.RemoveUserFromRole%2A> , <xref:System.Web.Security.Roles.RemoveUsersFromRole%2A> , <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> , 및 <xref:System.Web.Security.Roles.RemoveUsersFromRoles%2A> 의 메서드는 <xref:System.Web.Security.Roles> 데이터 소스에서 지정된 된 역할에서 지정된 된 사용자를 제거 하는 클래스입니다. 구성 된 역할에 대해서만 <xref:System.Web.Security.RoleProvider.ApplicationName%2A> 수정 됩니다.  
  
 구성 된 찾을 수 없습니다는 지정 된 역할 이름 중 하나가 `applicationName`, 공급자를 throw 하는 것이 좋습니다는 <xref:System.Configuration.Provider.ProviderException>합니다.  
  
 구성 된 지정 된 역할 이름 중 연결 된 경우 지정 된 사용자 이름 중 하나가 `applicationName`, 공급자를 throw 하는 것이 좋습니다는 <xref:System.Configuration.Provider.ProviderException>합니다.  
  
 지정된 된 사용자 이름 중 하나라도 `null` 은 빈 문자열 또는 공급자 예외를 throw 하는 것이 좋습니다.  
  
 지정된 된 역할 이름 중 하나라도 `null` 은 빈 문자열 또는 공급자 예외를 throw 하는 것이 좋습니다.  
  
 데이터 원본에서 트랜잭션을 지원 트랜잭션에서 각 제거 작업을 포함 하 고 트랜잭션을 제거 작업이 실패할 경우 예외를 throw 하는 것이 좋습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 샘플 구현을 보여 줍니다.는 <xref:System.Web.Security.RoleProvider.RemoveUsersFromRoles%2A> 메서드.  
  
 [!code-csharp[System.Web.Security.IRoleProvider#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/CS/odbcroleprovidersnippets.cs#9)]
 [!code-vb[System.Web.Security.IRoleProvider#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/VB/odbcroleprovidersnippets.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RoleExists">
      <MemberSignature Language="C#" Value="public abstract bool RoleExists (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool RoleExists(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.RoleProvider.RoleExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function RoleExists (roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool RoleExists(System::String ^ roleName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.ApplicationServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">데이터 원본에서 검색할 역할의 이름입니다.</param>
        <summary>구성된 <see langword="applicationName" />의 역할 데이터 소스에 지정된 역할 이름이 이미 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns>
          역할 이름이 구성된 <see langword="true" />의 데이터 소스에 이미 있으면 <see langword="applicationName" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.RoleProvider.RoleExists%2A> 에 의해 호출 됩니다는 <xref:System.Web.Security.Roles.RoleExists%2A> 의 메서드는 <xref:System.Web.Security.Roles> 역할 이름이 구성 된 데이터 원본에 존재 하는지 확인 하려면 클래스 <xref:System.Web.Security.Roles.ApplicationName%2A>합니다.  
  
 지정 된 역할 이름이 `null` 은 빈 문자열 또는 공급자 예외를 throw 하는 것이 좋습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 샘플 구현을 보여 줍니다.는 <xref:System.Web.Security.RoleProvider.RoleExists%2A> 메서드.  
  
 [!code-csharp[System.Web.Security.IRoleProvider#10](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/CS/odbcroleprovidersnippets.cs#10)]
 [!code-vb[System.Web.Security.IRoleProvider#10](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.IRoleProvider/VB/odbcroleprovidersnippets.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>