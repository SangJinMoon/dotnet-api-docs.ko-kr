<Type Name="FormsAuthentication" FullName="System.Web.Security.FormsAuthentication">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b0ed0a6e65813100f358397ce81f86db5d981f0e" />
    <Meta Name="ms.sourcegitcommit" Value="e7865e39826e7aaf54da4c7042975153813a31c7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/16/2018" />
    <Meta Name="ms.locfileid" Value="31043503" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FormsAuthentication" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FormsAuthentication extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Security.FormsAuthentication" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FormsAuthentication" />
  <TypeSignature Language="C++ CLI" Value="public ref class FormsAuthentication sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>웹 응용 프로그램의 폼 인증 서비스를 관리합니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼 인증을 통해 사용자 및 Windows 인증 하지 않아도 되는 웹 응용 프로그램에 대 한 암호 유효성 검사. 폼 인증으로 사용자 정보에에서 저장 됩니다는 외부 데이터 원본에서와 같은 한 <xref:System.Web.Security.Membership> 데이터베이스 또는 응용 프로그램에 대 한 구성 파일입니다. 사용자가 인증 되 면 인증된 된 사용자는 각 요청과 함께 자격 증명을 제공 하지 않아도 되도록 폼 인증 쿠키 또는 URL에서 인증 티켓을 유지 합니다.  
  
 폼 인증을 설정 하 여 활성화는 `mode` 에 구성 요소의 특성 `Forms`합니다. 다음 예제와 같이 알 수 없는 사용자의 요청을 거부 하도록 구성 요소를 사용 하 여 유효한 사용자 인증 티켓을 포함 하는 응용 프로그램에 대 한 모든 요청을 요구할 수 있습니다.  
  
```  
<system.web>  
  <authentication mode="Forms">  
    <forms loginUrl="login.aspx" />  
  </authentication>  
  <authorization>  
    <deny users="?" />  
  </authorization>  
</system.web>  
```  
  
 앞의 예에서 응용 프로그램의 일부인 ASP.NET 페이지에 대 한 모든 요청에는 폼 인증에서 제공 되는 유효한 사용자 이름이 필요 합니다. 사용자 이름이 없으면 요청을 리디렉션할에 구성 된 <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A>합니다.  
  
 <xref:System.Web.Security.FormsAuthentication> 클래스는 사용자를 인증 하는 응용 프로그램에서 사용할 수 있는 메서드 및 속성에 대 한 액세스를 제공 합니다. <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드로 구성 된 브라우저를 리디렉션합니다 <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A> 사용자가 응용 프로그램에 로그인 합니다. <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드 또는 요청 된 원래 보호 된 URL로 다시 인증된 된 사용자를 리디렉션하는 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A>합니다. 필요한 경우에 폼 인증 티켓을 관리할 수 있습니다 사용할 수 있는 메서드가 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼 인증에 대 한 ASP.NET 멤버 자격 공급자를 사용 하 고 모든 사용자를 인증 하도록 요구 ASP.NET 응용 프로그램에 대 한 Web.config 파일을 보여 줍니다.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=MySqlServer;Integrated Security=SSPI;Initial Catalog=aspnetdb;" />  
  </connectionStrings>  
  <system.web>  
    <membership defaultProvider="SqlProvider" userIsOnlineTimeWindow="20">  
      <providers>  
        <add name="SqlProvider"  
          type="System.Web.Security.SqlMembershipProvider"  
          connectionStringName="SqlServices"  
          enablePasswordRetrieval="false"  
          enablePasswordReset="true"  
          requiresQuestionAndAnswer="true"  
          passwordFormat="Hashed"  
          applicationName="/" />  
      </providers>  
    </membership>  
  </system.web>  
</configuration>  
```  
  
 다음 코드 예제에서는 폼 인증 및 ASP.NET 멤버 자격을 사용 하 여 ASP.NET 응용 프로그램에 대 한 로그인 페이지를 보여 줍니다.  
  
> [!IMPORTANT]
>  이 예제에서는 잠재적인 보안 문제가 사용자 입력을 허용 하는 텍스트 상자가 포함 되어 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-aspx-csharp[System.Web.Security.SqlMembershipProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlMembershipProvider/CS/logincs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlMembershipProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlMembershipProvider/VB/loginvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Web.AspNetHostingPermission">사용 하 여 <see cref="T:System.Web.Security.FormsAuthentication" /> 호스팅된 환경에서 클래스입니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />합니다. 권한 값: <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />합니다.</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FormsAuthentication ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FormsAuthentication();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.Security.FormsAuthentication" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 사용자 코드에서 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public static bool Authenticate (string name, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Authenticate(string name, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.Authenticate(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Authenticate (name As String, password As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Authenticate(System::String ^ name, System::String ^ password);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is to use the Membership APIs, such as Membership.ValidateUser. For more information, see http://go.microsoft.com/fwlink/?LinkId=252463.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">사용자 이름입니다.</param>
        <param name="password">사용자 암호입니다.</param>
        <summary>응용 프로그램의 구성 파일에 저장된 자격 증명에 대해 사용자 이름과 암호의 유효성을 검사합니다.</summary>
        <returns>
          사용자 이름과 암호가 유효하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인증 메서드는 응용 프로그램 구성 파일의 섹션에 저장 된 사용자 자격 증명을 확인 합니다. 또는 사용자 자격 증명 및 호출 저장 하기 위해 ASP.NET 멤버 자격을 사용할 수 있습니다는 <xref:System.Web.Security.MembershipProvider.ValidateUser%2A> 는 자격 증명을 확인 합니다. 자세한 내용은 참조 [멤버 자격을 사용 하 여 사용자 관리](http://msdn.microsoft.com/library/824c3a24-f0af-427c-a652-0d2d1e9397cd)합니다.  
  
 보안 향상된을 위해 사용 하 여 응용 프로그램에 대 한 구성 파일에 저장 된 암호를 암호화할 수 있습니다는 <xref:System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 응용 프로그램에 대 한 Web.config 파일에 저장 된 사용자 자격 증명을 보여 줍니다. 사용 하 여 암호 값 해시 되었습니다는 <xref:System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile%2A> 메서드.  
  
 `<authentication mode="Forms">`  
  
 `<forms loginUrl="login.aspx">`  
  
 `<credentials passwordFormat="SHA1">`  
  
 `<user name="user1"   password="27CE4CA7FBF00685AF2F617E3F5BBCAFF7B7403C" />`  
  
 `<user name="user2"   password="D108F80936F78DFDD333141EBC985B0233A30C7A" />`  
  
 `<user name="user3" password="7BDB09781A3F23885CD43177C0508B375CB1B7E9"/>`  
  
 `</credentials>`  
  
 `</forms>`  
  
 `</authentication>`  
  
 다음 코드 예제를 사용 하는 로그인 페이지를 보여 줍니다.는 <xref:System.Web.Security.FormsAuthentication.Authenticate%2A> 메서드 사용자 자격 증명을 확인 합니다.  
  
> [!IMPORTANT]
>  이 예제에서는 잠재적인 보안 문제가 사용자 입력을 허용 하는 텍스트 상자가 포함 되어 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-aspx-csharp[System.Web.Security.FormsAuthentication#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/CS/logincs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.FormsAuthentication#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/VB/loginvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieDomain">
      <MemberSignature Language="C#" Value="public static string CookieDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CookieDomain" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.CookieDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieDomain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CookieDomain { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>폼 인증 쿠키의 도메인 값을 가져옵니다.</summary>
        <value>폼 인증 쿠키의 <see cref="P:System.Web.HttpCookie.Domain" />입니다. 기본값은 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.CookieDomain%2A> 속성 값이 사용 하 여 ASP.NET 응용 프로그램에 대 한 구성 파일에 설정 된 `domain` 구성 요소의 특성입니다. <xref:System.Web.Security.FormsAuthentication.CookieDomain%2A> 속성 값에 따라 결정 된 <xref:System.Web.HttpCookie.Domain%2A> 쿠키에 대 한 사용 될 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 `domain` Web.config 파일에는 특성입니다.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseCookies"  
    domain="contoso.com" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieMode">
      <MemberSignature Language="C#" Value="public static System.Web.HttpCookieMode CookieMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Web.HttpCookieMode CookieMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.CookieMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieMode As HttpCookieMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpCookieMode CookieMode { System::Web::HttpCookieMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>쿠키 없는 폼 인증에 대해 응용 프로그램이 구성되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>응용 프로그램이 쿠키 없는 폼 인증을 사용하도록 구성되었는지 여부를 나타내는 <see cref="T:System.Web.HttpCookieMode" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Web.HttpCookieMode.UseDeviceProfile" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> 속성에 대 한 값을 반영는 `cookieless` 구성 요소의 특성입니다. <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> 속성 결정 여부는 <xref:System.Web.Security.FormsAuthenticationTicket> 값은 브라우저에서 세션 쿠키에 저장 되거나에 저장 되는 <xref:System.Web.HttpRequest.QueryString%2A> 속성.  
  
> [!NOTE]
>  경우는 <xref:System.Web.Security.FormsAuthenticationTicket> URI에 값이 저장, 생성 된 URI의 길이가 허용 되는 최대 길이 보다 길 수 있습니다. 이것은 주로 발생 하는 경우는 <xref:System.Web.Security.FormsAuthentication.FormsCookiePath%2A> 응용 프로그램 이름에 속성이 설정 되어 있고 응용 프로그램 이름이 깁니다 (40 개 이상의 문자), 응용 프로그램의 사용자 이름이 깁니다, 또는 긴 <xref:System.Web.Security.FormsAuthenticationTicket.UserData%2A> 문자열에 저장 됩니다는 <xref:System.Web.Security.FormsAuthenticationTicket> 값입니다. 생성 된 URI가 너무 길면 웹 서버는 반환 되는 `400 - Bad Request` 오류입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 `cookieless` 특성을 `AutoDetect` Web.config 파일에 있습니다.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="AutoDetect" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieSameSite">
      <MemberSignature Language="C#" Value="public static System.Web.SameSiteMode CookieSameSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Web.SameSiteMode CookieSameSite" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.CookieSameSite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieSameSite As SameSiteMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::SameSiteMode CookieSameSite { System::Web::SameSiteMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SameSiteMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>쿠키의 SameSite 특성에 대한 값을 가져오거나 설정합니다.</summary>
        <value>쿠키의 적용 모드를 나타내는 열거형 값 중 하나입니다. 기본값은 <see cref="F:System.Web.SameSiteMode.Lax" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookiesSupported">
      <MemberSignature Language="C#" Value="public static bool CookiesSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CookiesSupported" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.CookiesSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookiesSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CookiesSupported { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 쿠키 없는 폼 인증을 지원하도록 구성되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          응용 프로그램이 쿠키 없는 폼 인증을 지원하도록 구성되었으면 <see langword="false" />이고, 그렇지 않으면 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 속성에 따라 값을 반환 된 <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> 값과 브라우저의 기능입니다.  
  
-   경우는 <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> 속성이 <xref:System.Web.HttpCookieMode.UseCookies>, <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 속성은 반환 `true`합니다.  
  
-   경우는 <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> 속성이 <xref:System.Web.HttpCookieMode.UseUri>, <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 속성은 반환 `false`합니다.  
  
-   경우는 <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> 속성이 <xref:System.Web.HttpCookieMode.AutoDetect>, <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 속성은 반환 `true` 브라우저에서 쿠키를 지원 하 고 그렇지 않으면 쿠키는는 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 속성은 반환 `false`합니다.  
  
-   경우는 <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> 속성이로 설정 되어 <xref:System.Web.HttpCookieMode.UseDeviceProfile>, <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 속성은 반환 `true` 경우는 <xref:System.Web.HttpRequest.Browser%2A> 현재 <xref:System.Web.HttpContext.Request%2A> 쿠키 및; 쿠키를 사용한 리디렉션을 지원 그렇지는 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 속성은 반환 `false`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 `cookieless` 특성을 <xref:System.Web.HttpCookieMode.UseUri> Web.config 파일에 있습니다. 이 구성이 됩니다는 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 반환 하는 속성 `false`합니다.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseUri" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public static System.Web.Security.FormsAuthenticationTicket Decrypt (string encryptedTicket);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Security.FormsAuthenticationTicket Decrypt(string encryptedTicket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.Decrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrypt (encryptedTicket As String) As FormsAuthenticationTicket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Security::FormsAuthenticationTicket ^ Decrypt(System::String ^ encryptedTicket);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.FormsAuthenticationTicket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encryptedTicket" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="encryptedTicket">암호화된 인증 티켓입니다.</param>
        <summary>메서드에 전달된 암호화된 폼 인증 티켓을 기반으로 <see cref="T:System.Web.Security.FormsAuthenticationTicket" /> 개체를 만듭니다.</summary>
        <returns>
          <see cref="T:System.Web.Security.FormsAuthenticationTicket" /> 개체입니다. <paramref name="encryptedTicket" /> 매개 변수가 유효한 티켓이 아닌 경우 <see langword="null" />이 반환됩니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="encryptedTicket" />가 <see langword="null" />인 경우  
  
 \- 또는 -  
  
 <paramref name="encryptedTicket" />가 빈 문자열("")인 경우  
  
 \- 또는 -  
  
 <paramref name="encryptedTicket" />의 길이가 4096자를 넘습니다.  
  
 \- 또는 -  
  
 <paramref name="encryptedTicket" />이 잘못된 형식인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultUrl">
      <MemberSignature Language="C#" Value="public static string DefaultUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string DefaultUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.DefaultUrl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ DefaultUrl { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>리디렉션 URL을 지정하지 않은 경우 <see cref="T:System.Web.Security.FormsAuthentication" /> 클래스에서 리디렉션할 URL을 가져옵니다.</summary>
        <value>리디렉션 URL을 지정하지 않은 경우 <see cref="T:System.Web.Security.FormsAuthentication" /> 클래스에서 리디렉션할 URL입니다. 기본값은 "default.aspx"입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> 속성 값이 사용 하 여 ASP.NET 응용 프로그램에 대 한 구성 파일에 설정 된 `defaultUrl` 구성 요소의 특성입니다. <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> 속성은 사용는 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드 반환 URL 요청에 포함 된 경우. 마찬가지로,는 <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> 메서드는 반환 된 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> 없는 반환 URL이 요청에 포함 하는 경우.  
  
   
  
## Examples  
 다음 코드 예제에서는 `defaultUrl` Web.config 파일에는 특성입니다.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    defaultUrl="index.aspx" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCrossAppRedirects">
      <MemberSignature Language="C#" Value="public static bool EnableCrossAppRedirects { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableCrossAppRedirects" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnableCrossAppRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableCrossAppRedirects { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>인증된 사용자를 다른 웹 응용 프로그램의 URL로 리디렉션할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          인증된 사용자를 다른 웹 응용 프로그램의 URL로 리디렉션할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 를 사용 하 여 속성 값이 설정 된 `enableCrossAppRedirects` 구성 요소의 특성입니다.  
  
 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 내에서 속성을 검사는 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드 리디렉션 URL 현재 응용 프로그램에 있는 페이지를 가리키지 않습니다. 경우 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 은 `true`, 경우; 리디렉션 수행 됩니다 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 은 `false`, 브라우저에 정의 된 페이지로 리디렉션됩니다는 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> 속성입니다.  
  
> [!NOTE]
>  응용 프로그램 간에 페이지를 리디렉션하는 경우에 구성 요소에서 특정 특성을 인증된 하는 응용 프로그램 간에 중복 됩니다 확인 해야 합니다. 자세한 내용 및 예제에 대 한 참조 [응용 프로그램 전체에서 폼 인증](http://msdn.microsoft.com/library/99e2f9e8-5b97-4a4d-a4ed-5f93276053b7)합니다.  
  
> [!IMPORTANT]
>  응용 프로그램 간 리디렉션은 허용 될 때 사이트는 악성 웹 사이트에 사용자 지정 되었지만 로그인 페이지를 사용 하 여 사이트에 대 한 악용에 취약 합니다. 항상 확인에서 반환 되는 리디렉션 URL은 <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> 메서드는 승인 된 웹 사이트에만 리디렉션을 허용 하는지으로 만들 수 있도록 예상 되는 URL입니다. 또한 리디렉션 URL 적절 한 프로토콜 (HTTP 또는 HTTPS)을 사용 하는지 확인 해야 합니다. 이러한 유효성 검사를 수행 하려면 로그인 페이지에 대 한 다시 게시 이벤트 처리기를 추가할 수 있습니다 또는 대 한 처리기를 추가할 수는 <xref:System.Web.UI.WebControls.Login.LoggedIn> 의 이벤트는 <xref:System.Web.UI.WebControls.Login> 제어 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 `enableCrossAppRedirects` 특성을 `true` ASP.NET 응용 프로그램에 대 한 Web.config 파일에 있습니다.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseUri"  
    requireSSL="true"   
    enableCrossAppRedirects="true" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableFormsAuthentication">
      <MemberSignature Language="C#" Value="public static void EnableFormsAuthentication (System.Collections.Specialized.NameValueCollection configurationData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableFormsAuthentication(class System.Collections.Specialized.NameValueCollection configurationData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.EnableFormsAuthentication(System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableFormsAuthentication (configurationData As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableFormsAuthentication(System::Collections::Specialized::NameValueCollection ^ configurationData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationData" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="configurationData">"defaultUrl" 및/또는 "loginUrl"의 값을 포함하는 이름-값 컬렉션입니다. 기본 URL이나 로그인 URL의 값이 없으면 매개 변수는 null일 수 있습니다.</param>
        <summary>폼 인증을 사용하도록 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> 속성은 `null`, 속성에서 기본 URL 값으로 설정 되어 있는지는 `configurationData` 매개 변수입니다. 경우는 <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A> 속성은 `null`, 속성에서 로그인 URL 값으로 설정 되어 있는지는 `configurationData` 매개 변수입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">응용 프로그램이 시작 전 초기화 단계가 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public static string Encrypt (System.Web.Security.FormsAuthenticationTicket ticket);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Encrypt(class System.Web.Security.FormsAuthenticationTicket ticket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.Encrypt(System.Web.Security.FormsAuthenticationTicket)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Encrypt (ticket As FormsAuthenticationTicket) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Encrypt(System::Web::Security::FormsAuthenticationTicket ^ ticket);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ticket" Type="System.Web.Security.FormsAuthenticationTicket" />
      </Parameters>
      <Docs>
        <param name="ticket">암호화된 폼 인증 티켓을 만들 <see cref="T:System.Web.Security.FormsAuthenticationTicket" /> 개체입니다.</param>
        <summary>HTTP 쿠키에서 사용하기에 적합한 암호화된 폼 인증 티켓이 들어 있는 문자열을 만듭니다.</summary>
        <returns>암호화된 폼 인증 티켓이 들어 있는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 결과 저장 하는 다음 코드 예제는 <xref:System.Web.Security.FormsAuthentication.Encrypt%2A> 메서드를 사용 하 여 쿠키에는 <xref:System.Web.Security.FormsAuthentication.FormsCookieName%2A> 속성과 리디렉션을에서 반환 된 URL로 사용자는 <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> 메서드.  
  
> [!IMPORTANT]
>  이 예제에서는 잠재적인 보안 문제가 사용자 입력을 허용 하는 텍스트 상자가 포함 되어 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-aspx-csharp[FormsAuthenticationTicketClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/FormsAuthenticationTicketClass/CS/formsauthenticationticketclasscs.aspx#1)]
 [!code-aspx-vb[FormsAuthenticationTicketClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/FormsAuthenticationTicketClass/VB/formsauthenticationticketclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ticket" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="FormsCookieName">
      <MemberSignature Language="C#" Value="public static string FormsCookieName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string FormsCookieName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.FormsCookieName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property FormsCookieName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ FormsCookieName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>폼 인증 티켓을 저장하는 데 사용되는 쿠키의 이름을 가져옵니다.</summary>
        <value>폼 인증 티켓을 저장하는 데 사용되는 쿠키의 이름입니다. 기본값은 ".ASPXAUTH"입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.FormsCookieName%2A> 속성 값이 사용 하 여 ASP.NET 응용 프로그램에 대 한 구성 파일에 설정 된 `name` 구성 요소의 특성입니다. <xref:System.Web.Security.FormsAuthentication.FormsCookieName%2A> 저장 하는 쿠키를 참조 하는 데 사용 되는 <xref:System.Web.Security.FormsAuthenticationTicket> 정보입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.Security.FormsAuthentication.FormsCookieName%2A> 를 사용 하 여 속성 값은 `name` Web.config 파일에는 특성입니다.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseCookies"  
    name=".ASPXFORMSAUTH" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FormsCookiePath">
      <MemberSignature Language="C#" Value="public static string FormsCookiePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string FormsCookiePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.FormsCookiePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property FormsCookiePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ FormsCookiePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>폼 인증 쿠키의 경로를 가져옵니다.</summary>
        <value>폼 인증 티켓 정보가 저장되는 쿠키의 경로입니다. 기본값은 "/"입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.FormsCookiePath%2A> 속성 값이 사용 하 여 ASP.NET 응용 프로그램 구성 파일에 설정 된 `path` 구성 요소의 특성입니다. <xref:System.Web.Security.FormsAuthentication.FormsCookiePath%2A> 지정는 <xref:System.Web.HttpCookie.Path%2A> 쿠키를 저장 하는 <xref:System.Web.Security.FormsAuthenticationTicket> 정보입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.Security.FormsAuthentication.FormsCookiePath%2A> 를 사용 하 여 속성 값은 `path` Web.config 파일에는 특성입니다.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseCookies"  
    path="/MyApplication" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAuthCookie">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>주어진 사용자 이름에 대한 인증 쿠키를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAuthCookie">
      <MemberSignature Language="C#" Value="public static System.Web.HttpCookie GetAuthCookie (string userName, bool createPersistentCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.HttpCookie GetAuthCookie(string userName, bool createPersistentCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.GetAuthCookie(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAuthCookie (userName As String, createPersistentCookie As Boolean) As HttpCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::HttpCookie ^ GetAuthCookie(System::String ^ userName, bool createPersistentCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="userName">인증된 사용자의 이름입니다.</param>
        <param name="createPersistentCookie">
          브라우저 세션 전체에 저장되는 영속적인 쿠키를 만들려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>주어진 사용자 이름에 대한 인증 쿠키를 만듭니다. 그러면 쿠키가 보내는 응답의 일부로 설정되지 않으므로 응용 프로그램에서는 쿠키를 발행하는 방법을 보다 세밀하게 제어할 수 있습니다.</summary>
        <returns>암호화된 폼 인증 티켓 정보가 들어 있는 <see cref="T:System.Web.HttpCookie" />입니다. <see cref="P:System.Web.Security.FormsAuthentication.FormsCookiePath" /> 속성의 기본값이 사용됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 쿠키의 경로 의해 결정 됩니다는 <xref:System.Web.Security.FormsAuthentication.FormsCookiePath%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAuthCookie">
      <MemberSignature Language="C#" Value="public static System.Web.HttpCookie GetAuthCookie (string userName, bool createPersistentCookie, string strCookiePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.HttpCookie GetAuthCookie(string userName, bool createPersistentCookie, string strCookiePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.GetAuthCookie(System.String,System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAuthCookie (userName As String, createPersistentCookie As Boolean, strCookiePath As String) As HttpCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::HttpCookie ^ GetAuthCookie(System::String ^ userName, bool createPersistentCookie, System::String ^ strCookiePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
        <Parameter Name="strCookiePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="userName">인증된 사용자의 이름입니다.</param>
        <param name="createPersistentCookie">
          브라우저 세션 전체에 저장되는 영속적인 쿠키를 만들려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="strCookiePath">인증 쿠키의 <see cref="P:System.Web.HttpCookie.Path" />입니다.</param>
        <summary>주어진 사용자 이름에 대한 인증 쿠키를 만듭니다. 이를 통해 쿠키가 나가는 응답의 일부로 설정되지는 않습니다.</summary>
        <returns>암호화된 폼 인증 티켓 정보가 들어 있는 <see cref="T:System.Web.HttpCookie" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRedirectUrl">
      <MemberSignature Language="C#" Value="public static string GetRedirectUrl (string userName, bool createPersistentCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRedirectUrl(string userName, bool createPersistentCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.GetRedirectUrl(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRedirectUrl (userName As String, createPersistentCookie As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRedirectUrl(System::String ^ userName, bool createPersistentCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="userName">인증된 사용자의 이름입니다.</param>
        <param name="createPersistentCookie">이 매개 변수는 무시됩니다.</param>
        <summary>로그인 페이지로 리디렉션하도록 만든 원래 요청의 리디렉션 URL을 반환합니다.</summary>
        <returns>리디렉션 URL이 들어 있는 문자열이거나, <paramref name="userName" />이 null인 경우 null입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 리디렉션을 사용 하는 대신 응용 프로그램 코드에서 수행 하려는 경우이 방법을 사용할 수 있습니다는 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드.  
  
 <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> 사용 하 여 쿼리 문자열에 지정 된 URL을 반환 하는 메서드는 `ReturnURL` 변수 이름입니다. 예를 들어 URL에에서 `http://www.contoso.com/login.aspx?ReturnUrl=caller.aspx`, <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> 반환 URL을 반환 하는 메서드 `caller.aspx`합니다. 경우는 `ReturnURL` 변수가 존재 하지는 <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> 의 URL을 반환 하는 메서드는 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> 속성입니다.  
  
 ASP.NET은 브라우저 로그인 페이지로 리디렉션된 경우 반환 URL을 자동으로 추가 합니다.  
  
 기본적으로는 `ReturnUrl` 현재 응용 프로그램의 페이지 변수를 참조 해야 합니다. 경우 `ReturnUrl` 다른 서버 또는 다른 응용 프로그램에서 페이지를 참조 하는 <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> 의 URL을 반환 하는 메서드는 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> 속성입니다. 현재 응용 프로그램 외부 페이지를 참조할 반환 URL을 허용 하려는 경우 설정 해야는 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 속성을 `true` 를 사용 하는 `enableCrossAppRedirects` 구성 요소의 특성입니다.  

이 메서드는 쿠키를 생성 하지 않습니다.
  
> [!IMPORTANT]
>  설정의 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 속성을 `true` 응용 프로그램 간 리디렉션은 보안 문제가 발생할 수 있도록 합니다. 자세한 내용은 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 속성을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 리디렉션을에서 반환 된 URL로 인증 된 사용자는 <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> 메서드.  
  
> [!IMPORTANT]
>  이 예제에서는 잠재적인 보안 문제가 사용자 입력을 허용 하는 텍스트 상자가 포함 되어 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-aspx-csharp[FormsAuthenticationTicketClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/FormsAuthenticationTicketClass/CS/formsauthenticationticketclasscs.aspx#1)]
 [!code-aspx-vb[FormsAuthenticationTicketClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/FormsAuthenticationTicketClass/VB/formsauthenticationticketclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashPasswordForStoringInConfigFile">
      <MemberSignature Language="C#" Value="public static string HashPasswordForStoringInConfigFile (string password, string passwordFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HashPasswordForStoringInConfigFile(string password, string passwordFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HashPasswordForStoringInConfigFile (password As String, passwordFormat As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HashPasswordForStoringInConfigFile(System::String ^ password, System::String ^ passwordFormat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is to use the Membership APIs, such as Membership.CreateUser. For more information, see http://go.microsoft.com/fwlink/?LinkId=252463.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="passwordFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="password">해시에 대한 암호입니다.</param>
        <param name="passwordFormat">사용할 해시 알고리즘입니다. <c>passwordFormat</c>은 <see cref="T:System.Web.Configuration.FormsAuthPasswordFormat" /> 열거형 값 중 하나를 나타내는 <see langword="String" />입니다.</param>
        <summary>지정된 암호와 해시 알고리즘을 기반으로 구성 파일에 저장하기에 적합한 해시 암호를 만듭니다.</summary>
        <returns>해시된 암호입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile%2A> 메서드는 응용 프로그램에 대 한 구성 파일에 자격 증명 폼 인증을 저장 하는 경우 사용할 수 있는 해시 된 암호 값을 만듭니다.  
  
 응용 프로그램에 대 한 구성 파일에 저장 된 인증 자격 증명에서 사용 되는 <xref:System.Web.Security.FormsAuthentication.Authenticate%2A> 응용 프로그램의 사용자에 대 한 암호를 확인 하는 메서드. 또는 사용자 자격 증명을 저장 ASP.NET 멤버 자격을 사용할 수 있습니다. 자세한 내용은 참조 [멤버 자격을 사용 하 여 사용자 관리](http://msdn.microsoft.com/library/824c3a24-f0af-427c-a652-0d2d1e9397cd)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용자 이름, 암호 및 해시 형식을 사용 하며 사용자 정 및 해시 된 암호를 포함 하는 구성 섹션.  
  
> [!IMPORTANT]
>  이 예제에서는 잠재적인 보안 문제가 사용자 입력을 허용 하는 텍스트 상자가 포함 되어 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-aspx-csharp[FormsAuthenticationHashPassword#1](~/samples/snippets/csharp/VS_Snippets_WebNet/FormsAuthenticationHashPassword/CS/formsauthenticationhashpasswordcs.aspx#1)]
 [!code-aspx-vb[FormsAuthenticationHashPassword#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/FormsAuthenticationHashPassword/VB/formsauthenticationhashpasswordvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="password" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="passwordFormat" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="passwordFormat" />은 유효한 <see cref="T:System.Web.Configuration.FormsAuthPasswordFormat" /> 값이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public static void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Initialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램의 구성 설정을 기반으로 <see cref="T:System.Web.Security.FormsAuthentication" /> 개체를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.Initialize%2A> 때이 메서드가 호출 되는 <xref:System.Web.Security.FormsAuthenticationModule> 의 인스턴스를 만듭니다는 <xref:System.Web.Security.FormsAuthentication> 클래스입니다. 이 메서드는 코드에서는 호출할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public static bool IsEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>폼 인증을 사용할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          폼 인증이 활성화된 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoginUrl">
      <MemberSignature Language="C#" Value="public static string LoginUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LoginUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.LoginUrl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LoginUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LoginUrl { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.Security.FormsAuthentication" /> 클래스에서 리디렉션할 로그인 페이지의 URL을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Web.Security.FormsAuthentication" /> 클래스에서 리디렉션할 로그인 페이지의 URL입니다. 기본값은 "login.aspx"입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A> 속성 값이 사용 하 여 ASP.NET 응용 프로그램에 대 한 구성 파일에 설정 된 `loginUrl` 구성 요소의 특성입니다. <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A> 에서 사용 되는 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 `loginUrl` Web.config 파일에는 특성입니다.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    defaultUrl="index.aspx" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectFromLoginPage">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>인증된 사용자를 원래 요청된 URL이나 기본 URL로 리디렉션합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectFromLoginPage">
      <MemberSignature Language="C#" Value="public static void RedirectFromLoginPage (string userName, bool createPersistentCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RedirectFromLoginPage(string userName, bool createPersistentCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.RedirectFromLoginPage(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RedirectFromLoginPage (userName As String, createPersistentCookie As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RedirectFromLoginPage(System::String ^ userName, bool createPersistentCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="userName">인증된 사용자 이름입니다.</param>
        <param name="createPersistentCookie">
          브라우저 세션 전체에 저장되는 영속적인 쿠키를 만들려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>인증된 사용자를 원래 요청된 URL이나 기본 URL로 리디렉션합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드 사용 하 여 쿼리 문자열에 지정 된 URL로 리디렉션하는 `ReturnURL` 변수 이름입니다. 예를 들어 URL에에서 `http://www.contoso.com/login.aspx?ReturnUrl=caller.aspx`, <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드 반환 URL로 리디렉션합니다 `caller.aspx`합니다. 경우는 `ReturnURL` 변수가 존재 하지는 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드의 URL로 리디렉션하는 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> 속성입니다.  
  
 ASP.NET은 브라우저 로그인 페이지로 리디렉션된 경우 반환 URL을 자동으로 추가 합니다.  
  
 기본적으로는 `ReturnUrl` 현재 응용 프로그램의 페이지 변수를 참조 해야 합니다. 경우 `ReturnUrl` 다른 서버 또는 다른 응용 프로그램에서 페이지를 참조 하는 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드의 URL로 리디렉션하는 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> 속성입니다. 현재 응용 프로그램 외부 페이지로 리디렉션합니다를 허용 하려는 경우 설정 해야는 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 속성을 `true` 를 사용 하는 `enableCrossAppRedirects` 구성 요소의 특성입니다.  
  
> [!IMPORTANT]
>  설정의 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 속성을 `true` 응용 프로그램 간 리디렉션은 보안 문제가 발생할 수 있도록 합니다. 자세한 내용은 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 속성을 참조하세요.  
  
 경우는 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 속성은 `true`, 및 중 하나는 `ReturnUrl` 변수는 현재 응용 프로그램 내 또는 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 속성은 `true`, 하면 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 인증 티켓을 발급 하 고에 배치 하는 메서드는 사용 하 여 기본 쿠키는 <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> 메서드.  
  
 경우 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 은 `false` 리디렉션 경로 현재 응용 프로그램에 있는 URL로, 리디렉션 URL의 일부로 티켓이 발급 되 고 있습니다. 경우 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 은 `false`, <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 은 `true`, 및 리디렉션 URL을 현재 응용 프로그램 내에서 페이지를 참조 하지 않습니다는 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 인증 티켓을 발급 하 고에 배치 하는 메서드는 <xref:System.Web.HttpRequest.QueryString%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 원래 요청 된 URL로 유효성이 검사 된 사용자를 리디렉션하는 또는 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A>합니다. 코드 예제에서는 확인 하므로 사용자가 ASP.NET 멤버 자격을 사용 합니다. ASP.NET 멤버 자격에 대 한 자세한 내용은 참조 [멤버 자격을 사용 하 여 사용자 관리](http://msdn.microsoft.com/library/824c3a24-f0af-427c-a652-0d2d1e9397cd)합니다.  
  
> [!IMPORTANT]
>  이 예제에서는 잠재적인 보안 문제가 사용자 입력을 허용 하는 텍스트 상자가 포함 되어 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-aspx-csharp[System.Web.Security.SqlMembershipProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlMembershipProvider/CS/logincs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlMembershipProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlMembershipProvider/VB/loginvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">쿼리 문자열에 지정된 반환 URL에 HTTP: 또는 HTTPS: 이외의 프로토콜이 포함된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectFromLoginPage">
      <MemberSignature Language="C#" Value="public static void RedirectFromLoginPage (string userName, bool createPersistentCookie, string strCookiePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RedirectFromLoginPage(string userName, bool createPersistentCookie, string strCookiePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.RedirectFromLoginPage(System.String,System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RedirectFromLoginPage (userName As String, createPersistentCookie As Boolean, strCookiePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RedirectFromLoginPage(System::String ^ userName, bool createPersistentCookie, System::String ^ strCookiePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
        <Parameter Name="strCookiePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="userName">인증된 사용자 이름입니다.</param>
        <param name="createPersistentCookie">
          브라우저 세션 전체에 저장되는 영속적인 쿠키를 만들려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="strCookiePath">폼 인증 티켓에 대한 쿠키 경로입니다.</param>
        <summary>인증된 사용자를 폼 인증 쿠키의 지정된 쿠키 경로를 사용하여 원래 요청된 URL이나 기본 URL로 리디렉션합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드 사용 하 여 쿼리 문자열에 지정 된 반환 URL로 리디렉션하는 `ReturnURL` 변수 이름입니다. 예를 들어 URL에에서 `http://www.contoso.com/login.aspx?ReturnUrl=caller.aspx`, <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드 반환 URL로 리디렉션합니다 `caller.aspx`합니다. 경우는 `ReturnURL` 변수가 존재 하지는 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드의 URL로 리디렉션하는 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> 속성입니다.  
  
 ASP.NET은 브라우저 로그인 페이지로 리디렉션된 경우 반환 URL을 자동으로 추가 합니다.  
  
 기본적으로는 `ReturnUrl` 현재 응용 프로그램의 페이지 변수를 참조 해야 합니다. 경우 `ReturnUrl` 다른 서버 또는 다른 응용 프로그램에서 페이지를 참조 하는 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 메서드의 URL로 리디렉션하는 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> 속성입니다. 현재 응용 프로그램 외부 페이지로 리디렉션합니다를 허용 하려는 경우 설정 해야는 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 속성을 `true` 를 사용 하는 `enableCrossAppRedirects` 구성 요소의 특성입니다.  
  
> [!IMPORTANT]
>  설정의 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 속성을 `true` 응용 프로그램 간 리디렉션은 보안 문제가 발생할 수 있도록 합니다. 자세한 내용은 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 속성을 참조하세요.  
  
 경우는 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 속성은 `true`, 및 중 하나는 `ReturnUrl` 변수는 현재 응용 프로그램 내 또는 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 속성은 `true`, 하면 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 인증 티켓을 발급 하 고에 배치 하는 메서드는 지정 된 쿠키는 `strCookiePath` 매개 변수를 사용 하는 <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> 메서드.  
  
 경우 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 은 `false` 리디렉션 경로 현재 응용 프로그램에 있는 URL로, 리디렉션 URL의 일부로 티켓이 발급 되 고 있습니다. 경우 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 은 `false`, <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> 은 `true`, 및 리디렉션 URL을 현재 응용 프로그램 내에서 페이지를 참조 하지 않습니다는 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> 인증 티켓을 발급 하 고에 배치 하는 메서드는 <xref:System.Web.HttpRequest.QueryString%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">쿼리 문자열에 지정된 반환 URL에 HTTP: 또는 HTTPS: 이외의 프로토콜이 포함된 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToLoginPage">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>브라우저를 로그인 URL로 리디렉션합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드 브라우저를 리디렉션하는 <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A>합니다.  
  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드는 폼 인증 쿠키를 삭제 하지 않습니다. 사용할 수는 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드와 함께 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> 메서드를 로그 아웃 하 고 다른 사용자가 로그인을 허용 합니다.  
  
 와 달리는 <xref:System.Web.HttpResponse.Redirect%2A?displayProperty=nameWithType> 메서드,이 메서드를 호출 하 여 요청을 끝내 지 않습니다 <xref:System.Web.HttpResponse.End%2A?displayProperty=nameWithType>합니다. 즉, 다음에 나오는 코드는 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드 호출이 실행 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 폼 인증 쿠키를 지우고는 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> 메서드 및 사용자를 로그인 페이지를 사용 하 여 리디렉션을 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드.  
  
 [!code-aspx-csharp[System.Web.Security.FormsAuthentication#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/CS/signoutcs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.FormsAuthentication#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/VB/signoutvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToLoginPage">
      <MemberSignature Language="C#" Value="public static void RedirectToLoginPage ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RedirectToLoginPage() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.RedirectToLoginPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RedirectToLoginPage ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RedirectToLoginPage();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>브라우저를 로그인 URL로 리디렉션합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드 브라우저를 리디렉션하는 <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A>합니다.  
  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드는 폼 인증 쿠키를 삭제 하지 않습니다. 사용할 수는 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드와 함께 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> 메서드를 로그 아웃 하 고 다른 사용자가 로그인을 허용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 폼 인증 쿠키를 지우고는 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> 메서드 및 사용자를 로그인 페이지를 사용 하 여 리디렉션을 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드.  
  
 [!code-aspx-csharp[System.Web.Security.FormsAuthentication#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/CS/signoutcs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.FormsAuthentication#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/VB/signoutvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RedirectToLoginPage">
      <MemberSignature Language="C#" Value="public static void RedirectToLoginPage (string extraQueryString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RedirectToLoginPage(string extraQueryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.RedirectToLoginPage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RedirectToLoginPage (extraQueryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RedirectToLoginPage(System::String ^ extraQueryString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extraQueryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extraQueryString">리디렉션 URL에 포함시킬 쿼리 문자열입니다.</param>
        <summary>지정된 쿼리 문자열을 사용하여 브라우저를 로그인 URL로 리디렉션합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드 브라우저를 리디렉션하는 <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A> 작성과 `extraQueryString` 값으로 <xref:System.Management.ManagementQuery.QueryString%2A> 리디렉션된 URL에 대 한 합니다.  
  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드는 폼 인증 쿠키를 삭제 하지 않습니다. 사용할 수는 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드와 함께 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> 메서드를 로그 아웃 하 고 다른 사용자가 로그인을 허용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 폼 인증 쿠키를 지우고는 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> 메서드 및 사용자를 로그인 페이지를 사용 하 여 리디렉션을 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드.  
  
 [!code-aspx-csharp[System.Web.Security.FormsAuthentication#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/CS/signout2cs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.FormsAuthentication#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/VB/signout2vb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenewTicketIfOld">
      <MemberSignature Language="C#" Value="public static System.Web.Security.FormsAuthenticationTicket RenewTicketIfOld (System.Web.Security.FormsAuthenticationTicket tOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Security.FormsAuthenticationTicket RenewTicketIfOld(class System.Web.Security.FormsAuthenticationTicket tOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.RenewTicketIfOld(System.Web.Security.FormsAuthenticationTicket)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RenewTicketIfOld (tOld As FormsAuthenticationTicket) As FormsAuthenticationTicket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Security::FormsAuthenticationTicket ^ RenewTicketIfOld(System::Web::Security::FormsAuthenticationTicket ^ tOld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.FormsAuthenticationTicket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tOld" Type="System.Web.Security.FormsAuthenticationTicket" />
      </Parameters>
      <Docs>
        <param name="tOld">업데이트할 폼 인증 티켓입니다.</param>
        <summary>
          <see cref="T:System.Web.Security.FormsAuthenticationTicket" />의 발행 날짜와 시간 및 만료 날짜와 시간을 조건부로 업데이트합니다.</summary>
        <returns>업데이트된 <see cref="T:System.Web.Security.FormsAuthenticationTicket" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RenewTicketIfOld%2A> 메서드 만료 날짜 및 시간을 제공 된 업데이트 <xref:System.Web.Security.FormsAuthenticationTicket> 경우 현재 날짜 및 시간을 뺀는 <xref:System.Web.Security.FormsAuthenticationTicket.IssueDate%2A> 값 보다 크면는 <xref:System.Web.Security.FormsAuthenticationTicket.Expiration%2A> 에서 현재 날짜 및 시간을 뺀 값입니다.  
  
 티켓으로 업데이트 됩니다는 <xref:System.Web.Security.FormsAuthenticationTicket.IssueDate%2A> 현재 날짜와 시간으로 설정 하는 속성 및 <xref:System.Web.Security.FormsAuthenticationTicket.Expiration%2A> 속성이 현재 날짜 및 시간 외에 원래로 설정 <xref:System.Web.Security.FormsAuthenticationTicket.Expiration%2A> 원래 뺀 값 <xref:System.Web.Security.FormsAuthenticationTicket.IssueDate%2A> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequireSSL">
      <MemberSignature Language="C#" Value="public static bool RequireSSL { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RequireSSL" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.RequireSSL" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RequireSSL As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RequireSSL { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버에 반환되기 위해 폼 인증 쿠키에 SSL이 필요한지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          SSL이 폼 인증 쿠키를 서버에 반환하는 데 필요하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RequireSSL%2A> 속성 값이 사용 하 여 ASP.NET 응용 프로그램에 대 한 구성 파일에 설정 된 `requireSSL` 구성 요소의 특성입니다. 지정할 수 있습니다는 Web.config 파일에 ASP.NET 응용 프로그램에 대 한 SSL (Secure Sockets Layer)는 서버에 설정 하 여 폼 인증 쿠키를 반환 해야 하는지 여부를 `requireSSL` 특성입니다. 자세한 내용은 <xref:System.Web.HttpCookie.Secure%2A>을 참조하세요.  
  
 것이 좋습니다 구성 하는 경우 `requireSSL` 으로 `false`, 구성할 수도 `slidingExpiration` 으로 `false`, 티켓은 유효한 시간을 줄일 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 `requireSSL` Web.config 파일에는 특성입니다.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseCookies"  
    requireSSL="true"  
    path="/MyApplication" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetAuthCookie">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>제공된 사용자 이름에 대한 인증 티켓을 만들어 응답의 쿠키 컬렉션이나 URL(쿠키 없는 인증을 사용하는 경우)에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> 메서드 경우 폼 인증 티켓 URL 또는 쿠키 컬렉션에 추가 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 은 `false`합니다. 폼 인증 티켓의 다음 요청은 브라우저에 폼 인증 정보를 제공 합니다. 폼 인증을 사용할 수 있습니다는 <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> 메서드는 사용자를 인증 하지만 여전히 리디렉션을 사용 하 여 탐색에 대 한 제어를 유지 하려는 경우.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetAuthCookie">
      <MemberSignature Language="C#" Value="public static void SetAuthCookie (string userName, bool createPersistentCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAuthCookie(string userName, bool createPersistentCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.SetAuthCookie(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetAuthCookie (userName As String, createPersistentCookie As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAuthCookie(System::String ^ userName, bool createPersistentCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="userName">인증된 사용자의 이름이며 Windows 계정에 매핑하지 않아도 됩니다.</param>
        <param name="createPersistentCookie">
          브라우저 세션 전체에 저장되는 영구 쿠키를 만들려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>제공된 사용자 이름에 대한 인증 티켓을 만들어 응답의 쿠키 컬렉션이나 URL(쿠키 없는 인증을 사용하는 경우)에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> 메서드는 폼 인증 티켓을 추가 쿠키 컬렉션을 URL로 경우 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 은 `false`합니다. 폼 인증 티켓의 다음 요청은 브라우저에 폼 인증 정보를 제공 합니다. 폼 인증을 사용할 수 있습니다는 <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> 메서드는 사용자를 인증 하지만 여전히 리디렉션을 사용 하 여 탐색에 대 한 제어를 유지 하려는 경우.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.Security.FormsAuthentication.RequireSSL" />가 <see langword="true" />이고 <see cref="P:System.Web.HttpRequest.IsSecureConnection" />이 <see langword="false" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuthCookie">
      <MemberSignature Language="C#" Value="public static void SetAuthCookie (string userName, bool createPersistentCookie, string strCookiePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAuthCookie(string userName, bool createPersistentCookie, string strCookiePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.SetAuthCookie(System.String,System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetAuthCookie (userName As String, createPersistentCookie As Boolean, strCookiePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAuthCookie(System::String ^ userName, bool createPersistentCookie, System::String ^ strCookiePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
        <Parameter Name="strCookiePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="userName">인증된 사용자의 이름이며</param>
        <param name="createPersistentCookie">
          브라우저 세션 전체에 저장되는 영속적인 쿠키를 만들려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="strCookiePath">폼 인증 티켓에 대한 쿠키 경로입니다.</param>
        <summary>제공된 사용자 이름에 대한 인증 티켓을 만들어 제공된 쿠키 경로를 사용하거나 URL(쿠키 없는 인증을 사용하는 경우)을 사용하여 응답의 쿠키 컬렉션에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> 메서드 경우 폼 인증 티켓 URL 또는 쿠키 컬렉션에 추가 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 은 `false`합니다. 폼 인증 티켓의 다음 요청은 브라우저에 폼 인증 정보를 제공 합니다. 폼 인증을 사용할 수 있습니다는 <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> 메서드는 사용자를 인증 하지만 여전히 리디렉션을 사용 하 여 탐색에 대 한 제어를 유지 하려는 경우.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.Security.FormsAuthentication.RequireSSL" />가 <see langword="true" />이고 <see cref="P:System.Web.HttpRequest.IsSecureConnection" />이 <see langword="false" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SignOut">
      <MemberSignature Language="C#" Value="public static void SignOut ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SignOut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.SignOut" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SignOut ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SignOut();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>브라우저에서 폼 인증 티켓을 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> 메서드 경우 쿠키 또는 URL에서 폼 인증 티켓 정보를 제거 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> 은 `false`합니다. 사용할 수는 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> 메서드와 함께 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드를 로그 아웃 하 고 다른 사용자가 로그인을 허용 합니다.  
  
 인증 되 고 익명 사용자가 지 원하는 경우 수행 해야 명시적으로 또는 쿠키 모드에만 실행 하는 경우 익명 식별자를 제거 함에 따라 실행할 특별 한 비즈니스 논리를 필요로 하는 경우 로그인 페이지에 대 한 리디렉션의 제어 합니다.  
  
 때는 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> 메서드가 호출 되 면 호출 하 여 응용 프로그램의 로그인 페이지 리디렉션 이루어집니다는 <xref:System.Web.HttpResponse.Redirect%2A> 메서드는 `endResponse` 매개 변수 설정 `false`합니다. 리디렉션 변경 내용이 발생 현재 페이지의 실행이 완료 되어 있으므로 추가 코드를 실행할 수 있습니다. 코드에는 다른 페이지에 대 한 명시적 리디렉션이 포함 되어 있지 않으면, 사용자가 응용 프로그램의 구성 파일에 구성 된 로그인 페이지로 리디렉션됩니다.  
  
 호출 된 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> 메서드는 폼 인증 쿠키를 제거 하기만 합니다. 웹 서버에서 나중에 비교에 대 한 유효 하 고 만료 된 인증 티켓을 저장 하지 않습니다. 이렇게 하면 사이트 재생 공격에 취약 한 악의적인 사용자가을 올바른 폼 인증 쿠키를 가져오면 됩니다. 보안을 개선 하기 폼 인증 쿠키를 사용 하는 경우 다음을 수행 해야 합니다.  
  
-   폼 인증 쿠키에 대 한 절대 만료를 사용 하 여 설정 하 여는 <xref:System.Web.Security.FormsAuthentication.SlidingExpiration%2A> 속성을 `false`합니다. 창이 도용된 쿠키를 재생할 수를 제한 합니다.  
  
-   발급만 하 고 설정 하 여 인증 쿠키를 통해 SSL Secure Sockets Layer (), 허용 된 <xref:System.Web.Security.FormsAuthentication.RequireSSL%2A> 속성을 `true` 및 SSL 전체 웹 사이트를 실행 하 여 합니다. 설정의 <xref:System.Web.Security.FormsAuthentication.RequireSSL%2A> 속성을 `true` 되도록 ASP.NET 전송 되지 것입니다는 인증 쿠키를 브라우저에는 비 SSL 연결을 통해; 하지만 클라이언트 쿠키에 보안 설정을 인식 하지 수도 있습니다. 즉, 클라이언트 보낼 수 있습니다는 폼 인증 쿠키 비 SSL 연결을 통해 따라서에 취약해 집니다 선택 합니다. 클라이언트 SSL 전체 웹 사이트를 실행 하 여 일반 텍스트에서 폼 인증 쿠키를 보내지 못하도록 방지할 수 있습니다.  
  
-   서버에서 영구 저장소를 사용 하 여 웹 사이트에서 사용자가을 기록 하 고 다음 응용 프로그램 이벤트와 같은 사용 <xref:System.Web.HttpApplication.PostAuthenticateRequest> 현재 사용자 폼 인증으로 인증 되었는지 여부를 결정 하는 이벤트입니다. 사용자가 폼 인증을 인증 하는 경우 사용자 로그 아웃 내용이 영구 저장소에 있는 경우 즉시 인증 쿠키 선택을 취소 하 고 브라우저 로그인 페이지로 리디렉션하십시오. 성공적으로 로그인 한 후 사용자가 로그인 되었음을 반영 하기 위해 저장소를 업데이트 합니다. 이 방법을 사용 하면 응용 프로그램에서 사용자의 로그인 상태를 추적 해야 하 고 유휴 사용자를 로그 아웃 하도록 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 폼 인증 쿠키를 지우고는 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> 메서드 및 사용자를 로그인 페이지를 사용 하 여 리디렉션을 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> 메서드.  
  
 [!code-aspx-csharp[System.Web.Security.FormsAuthentication#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/CS/signoutcs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.FormsAuthentication#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/VB/signoutvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SlidingExpiration">
      <MemberSignature Language="C#" Value="public static bool SlidingExpiration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SlidingExpiration" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.SlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SlidingExpiration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SlidingExpiration { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>상대(sliding) 만료를 사용하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          상대(sliding) 만료가 활성화된 경우에는 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.SlidingExpiration%2A> 를 사용 하 여 속성 값이 설정 된 `slidingExpiration` 구성 요소의 특성입니다.  
  
 상대 만료는 요청이 시간 제한 간격의 절반 이상이 경과 된 경우 유효한 인증 쿠키에 대 한 만료 시간 다시 설정 합니다. 쿠키가 만료 되 면 사용자 다시 인증 해야 합니다. 설정의 <xref:System.Web.Security.FormsAuthentication.SlidingExpiration%2A> 속성을 `false` 보안을 개선 하는 응용 프로그램의 인증 쿠키가 유효 시간을 제한 하 여 기반으로 구성 된 `timeout` 값입니다.  
  
 구성한 경우 좋습니다 `requireSSL` 으로 `false`를 구성할 수도 `slidingExpiration` 으로 `false`, 티켓은 유효한 시간을 줄이기 위해 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 `slidingExpiration` 특성을 `false` ASP.NET 응용 프로그램에 대 한 Web.config 파일에 있습니다.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    name=".ASPXFORMSAUTH"  
    cookieless="UseCookies"  
    requireSSL="true"   
    slidingExpiration="false" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TicketCompatibilityMode">
      <MemberSignature Language="C#" Value="public static System.Web.Configuration.TicketCompatibilityMode TicketCompatibilityMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Web.Configuration.TicketCompatibilityMode TicketCompatibilityMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.TicketCompatibilityMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TicketCompatibilityMode As TicketCompatibilityMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Configuration::TicketCompatibilityMode TicketCompatibilityMode { System::Web::Configuration::TicketCompatibilityMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.TicketCompatibilityMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>티켓 만료 날짜에 UTC(협정 세계시)를 사용할지 또는 현지 시간을 사용할지 나타내는 값을 가져옵니다.</summary>
        <value>티켓 만료 날짜에 UTC(협정 세계시)를 사용할지 또는 현지 시간을 사용할지 나타내는 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public static TimeSpan Timeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.TimeSpan Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Timeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeSpan Timeout { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>인증 티켓이 만료되기 전의 시간을 가져옵니다.</summary>
        <value>인증 티켓이 만료되기 전의 시간입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>