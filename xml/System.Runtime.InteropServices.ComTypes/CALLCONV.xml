<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CALLCONV.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b3240f5b89be87591569949bec693946db0c9289.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b3240f5b89be87591569949bec693946db0c9289</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>Identifies the calling convention used by a method described in a <bpt id="p1">[</bpt>METHODDATA<ept id="p1">](https://msdn.microsoft.com/library/85fd7121-3eed-4a83-9ba2-caa81fa1e048)</ept> structure.</source>
          <target state="translated"><bpt id="p1">[</bpt>METHODDATA<ept id="p1">](https://msdn.microsoft.com/library/85fd7121-3eed-4a83-9ba2-caa81fa1e048)</ept> 구조체에서 설명한 메서드에서 사용하는 호출 규칙을 식별합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>The calling conventions in this class describe how functions pass arguments and return values.</source>
          <target state="translated">이 클래스에서 호출 규칙 함수 인수를 전달 하 고 값을 반환 하는 방법을 설명 합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>They specify the order in which parameters are set up for the called functions, where the parameters are stored (in registers or in memory), and who (caller or called function) is responsible for cleaning up the stack after the function returns.</source>
          <target state="translated">순서를 지정 매개 변수는 호출된 되는 함수에 대해 설정, 매개 변수 저장 되는 위치 (레지스터 또는 메모리), 및 사용자 (호출자 또는 호출된 된 함수)은 반환 된 후에 스택을 정리 하는 일을 담당 합니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>For example:</source>
          <target state="translated">예:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>CC_CDECL uses the naming and calling conventions of the C language.</source>
          <target state="translated">CC_CDECL C 언어의 명명 및 호출 규칙을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>The caller pushes the parameters onto the stack in reverse (right-to-left) order, and cleans the stack after the function returns.</source>
          <target state="translated">호출자에 게 반대 (오른쪽에서 왼쪽) 순서로 매개 변수를 스택에 푸시하고 함수가 반환 되 면 스택을 정리 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>This calling convention enables you to call functions with <ph id="ph1">`varargs`</ph>, which makes it appropriate for use with methods that accept a variable number of parameters, such as the C run-time functions <bpt id="p1">[</bpt>printf, _printf_l, wprintf, _wprintf_l<ept id="p1">](https://docs.microsoft.com/cpp/c-runtime-library/reference/printf-printf-l-wprintf-wprintf-l)</ept>.</source>
          <target state="translated">이 호출 규칙을 사용 하면 사용 하 여 함수를 호출할 수 있습니다 <ph id="ph1">`varargs`</ph>,이 통해 사용 하기 위해 적합 한 다양 한 수의 C 런타임 함수 등의 매개 변수를 허용 하는 메서드에 <bpt id="p1">[</bpt>printf, _printf_l, wprintf, _wprintf_l<ept id="p1">](https://docs.microsoft.com/cpp/c-runtime-library/reference/printf-printf-l-wprintf-wprintf-l)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>CC_PASCAL uses the Pascal calling convention.</source>
          <target state="translated">CC_PASCAL Pascal 호출 규칙이 사용 합니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>The caller pushes the parameters onto the stack in left-to-right order.</source>
          <target state="translated">호출자에 게는 왼쪽에서 오른쪽 순서로 매개 변수를 스택에 푸시합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>The called function cleans the stack before returning.</source>
          <target state="translated">호출된 된 함수에 반환 하기 전에 스택을 정리 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>CC_STDCALL is the standard calling convention for Win32 functions.</source>
          <target state="translated">CC_STDCALL은 Win32 함수에 대 한 표준 호출 규칙입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>It is the default convention for calling unmanaged functions with platform invoke.</source>
          <target state="translated">그는 호출을 플랫폼 관리 되지 않는 함수 호출에 대 한 기본 규칙입니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>The caller pushes the parameters onto the stack in reverse (right to left) order, and the called function cleans the stack before returning.</source>
          <target state="translated">호출자 (오른쪽에서 왼쪽) 반대 순서로 매개 변수를 스택에 푸시하고 호출된 된 함수가 반환 되기 전에 스택을 정리 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>CC_SYSCALL is similar to CDECL in that arguments are pushed from right to left.</source>
          <target state="translated">CC_SYSCALL 인수는 오른쪽에서 왼쪽으로 푸시 한다는 점에서 CDECL와 비슷합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>The EAX, ECX, and EDX registers are not preserved.</source>
          <target state="translated">EAX, ECX 및 EDX 레지스터 유지 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>These calling convention identifiers are used by the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[wince](~/includes/wince-md.md)]</ph> platform, and by Automation.</source>
          <target state="translated">이러한 호출 규칙 식별자에서 사용 되는 <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, <ph id="ph2">[!INCLUDE[wince](~/includes/wince-md.md)]</ph> 플랫폼을 자동화 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>For additional information about <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_CDECL&gt;</ph>, see the MSDN Library.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_CDECL&gt;</ph>, MSDN Library를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>The common language runtime throws an exception when a COM method in native code returns an HRESULT.</source>
          <target state="translated">네이티브 코드에서 COM 메서드가 HRESULT를 반환 하는 경우 공용 언어 런타임 예외를 throw 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.ComTypes.CALLCONV">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>하는 방법: 지도 Hresult 및 예외<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_CDECL">
          <source>Indicates that the C declaration (CDECL) calling convention is used for a method.</source>
          <target state="translated">메서드에 대해 C 선언(CDECL) 호출 규칙이 사용됨을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_MACPASCAL">
          <source>Indicates that the Macintosh Pascal (MACPASCAL) calling convention is used for a method.</source>
          <target state="translated">메서드에 대해 Macintosh Pascal(MACPASCAL) 호출 규칙이 사용됨을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_MAX">
          <source>Indicates the end of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComTypes.CALLCONV" /&gt;</ph> enumeration.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComTypes.CALLCONV" /&gt;</ph> 열거형의 끝을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_MPWCDECL">
          <source>Indicates that the Macintosh Programmers' Workbench (MPW) CDECL calling convention is used for a method.</source>
          <target state="translated">메서드에 대해 Macintosh Programmers' Workbench(MPW) CDECL 호출 규칙이 사용됨을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_MPWPASCAL">
          <source>Indicates that the Macintosh Programmers' Workbench (MPW) PASCAL calling convention is used for a method.</source>
          <target state="translated">메서드에 대해 Macintosh Programmers' Workbench(MPW) PASCAL 호출 규칙이 사용됨을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_MSCPASCAL">
          <source>Indicates that the MSC Pascal (MSCPASCAL) calling convention is used for a method.</source>
          <target state="translated">메서드에 대해 MSC Pascal(MSCPASCAL) 호출 규칙이 사용됨을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_PASCAL">
          <source>Indicates that the Pascal calling convention is used for a method.</source>
          <target state="translated">메서드에 대해 Pascal 호출 규칙이 사용됨을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_RESERVED">
          <source>This value is reserved for future use.</source>
          <target state="translated">이 값은 나중에 사용할 수 있도록 예약되었습니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_STDCALL">
          <source>Indicates that the standard calling convention (STDCALL) is used for a method.</source>
          <target state="translated">메서드에 대해 표준 호출 규칙(STDCALL)이 사용됨을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.ComTypes.CALLCONV.CC_SYSCALL">
          <source>Indicates that the standard SYSCALL calling convention is used for a method.</source>
          <target state="translated">메서드에 대해 표준 SYSCALL 호출 규칙이 사용됨을 나타냅니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>