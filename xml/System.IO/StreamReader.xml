<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eaa27dae19046fabd638ca567a16e9b0c52a25ff" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420677" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamReader : System::IO::TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>특정 인코딩의 바이트 스트림에서 문자를 읽는 <see cref="T:System.IO.TextReader" />를 구현합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader> 반면를 특정 인코딩으로 문자 입력을 위해 설계 된 <xref:System.IO.Stream> 클래스는 바이트 입력 및 출력에 대 한 설계 되었습니다. 사용 하 여 <xref:System.IO.StreamReader> 표준 텍스트 파일에서 줄 정보를 읽기 위한 합니다.  
  
> [!IMPORTANT]
>  이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식을 사용 하 여 마쳤으면는 삭제 해야의 직접 또는 간접적으로 합니다. 직접 형식의 dispose를 호출 해당 <xref:System.IDisposable.Dispose%2A> 에서 메서드는 `try` / `catch` 블록입니다. 작업을 삭제할 하지 직접,를 사용 하 여 언어 구문와 같은 `using` (C#에서) 또는 `Using` (Visual Basic)에서는 합니다. 자세한 내용은의 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하십시오.는 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
 <xref:System.IO.StreamReader> 그렇지 않은 경우 현재 시스템의 ANSI 코드 페이지 대신 지정 하지 않으면 u t F-8 인코딩으로 기본값입니다. U t F-8 유니코드 문자를 올바르게 처리 하 고 운영 체제의 언어 버전에서 일관 된 결과 제공 합니다. 사용 하 여 현재 문자 인코딩을 가져오는 경우는 <xref:System.IO.StreamReader.CurrentEncoding%2A> 속성 값이 될 때까지 신뢰할 수 있는 첫 번째 후 <xref:System.IO.StreamReader.Read%2A> 되므로 인코딩 자동 감지를 처음 호출 될 때까지 메서드는 <xref:System.IO.StreamReader.Read%2A> 메서드.  
  
 기본적으로는 <xref:System.IO.StreamReader> 는 스레드로부터 안전 합니다. 참조 <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> 스레드로부터 안전한 래퍼에 대 한 합니다.  
  
 <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 및 <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드 한 읽기 및 쓰기 변수로 지정 된 문자 수는 `count` 매개 변수입니다. 고유 해야 하는 이러한 <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> 및 <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, 하 한 읽기 및 쓰기에 지정 된 바이트 수는 `count` 매개 변수입니다. 사용 하 여 <xref:System.IO.BufferedStream> 읽기 및 쓰기의 바이트 정수가 배열 요소에 대해서만 메서드.  
  
> [!NOTE]
>  읽을 때는 <xref:System.IO.Stream>,이 스트림 내부 버퍼와 같은 크기 버퍼를 사용 하는 것이 효율적입니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는의 인스턴스를 사용 하 여 <xref:System.IO.StreamReader> 파일에서 텍스트를 읽을 수 있습니다. 이 예에서 사용 된 생성자에서 사용 하기 위해 지원 되지 않습니다 [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] 앱.  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 다음 예제는 <xref:System.IO.StreamReader> 개체와 호출 해당 <xref:System.IO.StreamReader.ReadAsync%2A> 메서드를 비동기적으로 파일을 읽습니다.  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamWriter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 스트림에 대한 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">읽을 스트림입니다.</param>
        <summary>지정된 스트림에 대한 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자의 인코딩을 초기화 <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> 사용 하 여 속성의 `stream` 매개 변수 및 내부 버퍼 크기를 1024 바이트로 합니다.  
  
 <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.  
  
> [!CAUTION]
>  문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및를 throw 하면 예외가 발생 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 이러한 부하 분산 방식이 <xref:System.IO.StreamReader> 생성자입니다.  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />이 읽기를 지원하지 않는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">읽을 전체 파일 경로입니다.</param>
        <summary>지정된 파일 이름에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 의해 지정 된 전체 파일 경로 `path` 매개 변수입니다. 이 생성자의 인코딩을 초기화 <xref:System.Text.UTF8Encoding> 및 버퍼 크기를 1024 바이트로 합니다.  
  
 `path` 매개 변수는 파일 이름, 범용 명명 규칙 (UNC) 공유에 파일을 포함 될 수 있습니다.  
  
 `path` 매개 변수는 디스크에 저장 된 파일이 필요 하지 않으면 스트림을 사용 하 여 액세스를 지 원하는 시스템의 모든 일부가 될 수 있습니다.  
  
> [!CAUTION]
>  문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및를 throw 하면 예외가 발생 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 이러한 부하 분산 방식이 <xref:System.IO.StreamReader> 생성자입니다.  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열("")인 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />에 부정확하거나 올바르지 않은 파일 이름, 디렉터리 이름 또는 볼륨 레이블이 있는 경우</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">읽을 스트림입니다.</param>
        <param name="detectEncodingFromByteOrderMarks">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</param>
        <summary>지정한 바이트 순서 표시 검색 옵션을 사용하여 지정된 스트림에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자의 인코딩을 초기화 <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> 사용 하 여 속성의 `stream` 매개 변수 및 내부 버퍼 크기를 1024 바이트로 합니다.  
  
 `detectEncodingFromByteOrderMarks` 스트림의 첫 번째 3 바이트를 확인 하 여 인코딩을 매개 변수를 검색 합니다. U t F-8, little endian 유니코드를 자동으로 인식 하 고 big endian 유니코드 텍스트 파일 시작 적절 한 바이트 순서 표시 합니다. 자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 이러한 부하 분산 방식이 <xref:System.IO.StreamReader> 생성자입니다.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />이 읽기를 지원하지 않는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">읽을 스트림입니다.</param>
        <param name="encoding">사용할 문자 인코딩입니다.</param>
        <summary>지정된 문자 인코딩을 사용하여 지정된 스트림에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문자 인코딩은 의해 설정 되 고 `encoding` 매개 변수 및 버퍼 크기를 1024 바이트로 설정 됩니다. <xref:System.IO.StreamReader> 개체 스트림의 첫 번째 3 바이트를 검색 하 여 인코딩 검색을 시도 합니다. U t F-8, little endian 유니코드를 자동으로 인식 하 고 big endian 유니코드 텍스트 파일 시작 적절 한 바이트 순서 표시 합니다. 그렇지 않은 경우는 사용자가 제공한 인코딩은 사용 됩니다. 자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.  
  
> [!CAUTION]
>  문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및를 throw 하면 예외가 발생 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 이러한 부하 분산 방식이 <xref:System.IO.StreamReader> 생성자입니다.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />이 읽기를 지원하지 않는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, detectEncodingFromByteOrderMarks As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, bool detectEncodingFromByteOrderMarks);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">읽을 전체 파일 경로입니다.</param>
        <param name="detectEncodingFromByteOrderMarks">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</param>
        <summary>지정한 바이트 순서 표시 검색 옵션을 사용하여 지정한 파일 이름에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자의 인코딩을 초기화 <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> 사용 하 여 속성의 `stream` 매개 변수 및 내부 버퍼 크기를 1024 바이트로 합니다.  
  
 `path` 매개 변수는 파일 이름, 범용 명명 규칙 (UNC) 공유에 파일을 포함 될 수 있습니다.  
  
 `path` 매개 변수는 디스크에 저장 된 파일이 필요 하지 않으면 스트림을 사용 하 여 액세스를 지 원하는 시스템의 모든 일부가 될 수 있습니다.  
  
 `detectEncodingFromByteOrderMarks` 스트림의 첫 번째 3 바이트를 확인 하 여 인코딩을 매개 변수를 검색 합니다. U t F-8, little endian 유니코드를 자동으로 인식 하 고 big endian 유니코드 텍스트 파일 시작 적절 한 바이트 순서 표시 합니다. 그렇지 않은 경우는 <xref:System.Text.UTF8Encoding> 사용 됩니다. 자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 이러한 부하 분산 방식이 <xref:System.IO.StreamReader> 생성자입니다.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열("")인 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />에 부정확하거나 올바르지 않은 파일 이름, 디렉터리 이름 또는 볼륨 레이블이 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">읽을 전체 파일 경로입니다.</param>
        <param name="encoding">사용할 문자 인코딩입니다.</param>
        <summary>지정된 문자 인코딩을 사용하여 지정된 파일 이름에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에 지정 된 대로 인코딩 초기화는 `encoding` 매개 변수 및 내부 버퍼 크기를 1024 바이트로 합니다. <xref:System.IO.StreamReader> 개체 스트림의 첫 번째 3 바이트를 검색 하 여 인코딩 검색을 시도 합니다. U t F-8, little endian 유니코드를 자동으로 인식 하 고 big endian 유니코드 텍스트 파일 시작 적절 한 바이트 순서 표시 합니다. 그렇지 않은 경우는 사용자가 제공한 인코딩은 사용 됩니다. 자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 `path` 매개 변수는 파일 이름, 범용 명명 규칙 (UNC) 공유에 파일을 포함 될 수 있습니다.  
  
 `path` 매개 변수는 디스크에 저장 된 파일이 필요 하지 않으면 스트림을 사용 하 여 액세스를 지 원하는 시스템의 모든 일부가 될 수 있습니다.  
  
> [!CAUTION]
>  문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및를 throw 하면 예외가 발생 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 이러한 부하 분산 방식이 <xref:System.IO.StreamReader> 생성자입니다.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열("")인 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />에 부정확하거나 올바르지 않은 파일 이름, 디렉터리 이름 또는 볼륨 레이블이 있는 경우</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">읽을 스트림입니다.</param>
        <param name="encoding">사용할 문자 인코딩입니다.</param>
        <param name="detectEncodingFromByteOrderMarks">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</param>
        <summary>지정된 문자 인코딩과 바이트 순서 표시 검색 옵션을 사용하여 특정 스트림에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에 지정 된 대로 인코딩 초기화는 `encoding` 매개 변수는 <xref:System.IO.StreamReader.BaseStream%2A> 사용 하 여 속성의 `stream` 매개 변수 및 내부 버퍼 크기를 1024 바이트로 합니다.  
  
 `detectEncodingFromByteOrderMarks` 스트림의 첫 번째 3 바이트를 확인 하 여 인코딩을 매개 변수를 검색 합니다. U t F-8, little endian 유니코드를 자동으로 인식 하 고 big endian 유니코드 텍스트 파일 시작 적절 한 바이트 순서 표시 합니다. 그렇지 않은 경우는 사용자가 제공한 인코딩은 사용 됩니다. 자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.  
  
> [!CAUTION]
>  문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및를 throw 하면 예외가 발생 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 이러한 부하 분산 방식이 <xref:System.IO.StreamReader> 생성자입니다.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" />이 읽기를 지원하지 않는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">읽을 전체 파일 경로입니다.</param>
        <param name="encoding">사용할 문자 인코딩입니다.</param>
        <param name="detectEncodingFromByteOrderMarks">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</param>
        <summary>지정한 문자 인코딩과 바이트 순서 표시 검색 옵션을 사용하여 지정된 파일 이름에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에 지정 된 대로 인코딩 초기화는 `encoding` 매개 변수 및 내부 버퍼 크기를 1024 바이트로 합니다.  
  
 `detectEncodingFromByteOrderMarks` 스트림의 첫 번째 3 바이트를 확인 하 여 인코딩을 매개 변수를 검색 합니다. U t F-8, little endian 유니코드를 자동으로 인식 하 고 big endian 유니코드 텍스트 파일 시작 적절 한 바이트 순서 표시 합니다. 그렇지 않은 경우는 사용자가 제공한 인코딩은 사용 됩니다. 자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 `path` 매개 변수는 파일 이름, 범용 명명 규칙 (UNC) 공유에 파일을 포함 될 수 있습니다.  
  
 `path` 매개 변수는 디스크에 저장 된 파일이 필요 하지 않으면 스트림을 사용 하 여 액세스를 지 원하는 시스템의 모든 일부가 될 수 있습니다.  
  
> [!CAUTION]
>  문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및를 throw 하면 예외가 발생 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 이러한 부하 분산 방식이 <xref:System.IO.StreamReader> 생성자입니다.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열("")인 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />에 부정확하거나 올바르지 않은 파일 이름, 디렉터리 이름 또는 볼륨 레이블이 있는 경우</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">읽을 스트림입니다.</param>
        <param name="encoding">사용할 문자 인코딩입니다.</param>
        <param name="detectEncodingFromByteOrderMarks">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</param>
        <param name="bufferSize">최소 버퍼 크기입니다.</param>
        <summary>지정된 문자 인코딩과 바이트 순서 표시 검색 옵션, 버퍼 크기를 사용하여 특정 스트림에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 16 비트 문자 수에서를 사용 하는 버퍼 크기를 설정한는 `bufferSize` 매개 변수입니다. 경우 `bufferSize` 작으면 최소 허용 크기 (128 자), 보다 크기가 사용 됩니다.  
  
 이 생성자를 사용 하면 인코딩을에서 읽은 처음으로 변경할 수는 <xref:System.IO.StreamReader> 개체입니다. `detectEncodingFromByteOrderMarks` 스트림의 첫 번째 3 바이트를 확인 하 여 인코딩을 매개 변수를 검색 합니다. U t F-8, little endian 유니코드를 자동으로 인식 하 고 big endian 유니코드 텍스트 파일 시작 적절 한 바이트 순서 표시 합니다. 그렇지 않은 경우는 사용자가 제공한 인코딩은 사용 됩니다. 자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.  
  
> [!NOTE]
>  읽을 때는 <xref:System.IO.Stream>,이 스트림 내부 버퍼와 같은 크기 버퍼를 사용 하는 것이 효율적입니다.  
  
> [!CAUTION]
>  문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및를 throw 하면 예외가 발생 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 이러한 부하 분산 방식이 <xref:System.IO.StreamReader> 생성자입니다.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">스트림이 읽기를 지원하지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" />가 0보다 작거나 같은 경우</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">읽을 전체 파일 경로입니다.</param>
        <param name="encoding">사용할 문자 인코딩입니다.</param>
        <param name="detectEncodingFromByteOrderMarks">파일의 시작 부분에서 바이트 순서 표시를 찾을지 여부를 나타냅니다.</param>
        <param name="bufferSize">최소 버퍼 크기(16비트 문자 수)입니다.</param>
        <summary>지정된 문자 인코딩과 바이트 순서 표시 검색 옵션을 사용하여 지정된 파일 이름에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에 지정 된 대로 인코딩 초기화는 `encoding` 매개 변수입니다.  
  
 이 생성자를 사용 하면 인코딩을에서 읽은 처음으로 변경할 수는 <xref:System.IO.StreamReader> 개체입니다. `detectEncodingFromByteOrderMarks` 스트림의 첫 번째 3 바이트를 확인 하 여 인코딩을 매개 변수를 검색 합니다. U t F-8, little endian 유니코드를 자동으로 인식 하 고 big endian 유니코드 텍스트 파일 시작 적절 한 바이트 순서 표시 합니다. 그렇지 않은 경우는 사용자가 제공한 인코딩은 사용 됩니다. 자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 16 비트 문자 수에서를 사용 하는 버퍼 크기를 설정한는 `bufferSize` 매개 변수입니다. 경우 `bufferSize` 작으면 최소 허용 크기 (128 자), 보다 크기가 사용 됩니다.  
  
 `path` 매개 변수는 파일 이름, 범용 명명 규칙 (UNC) 공유에 파일을 포함 될 수 있습니다.  
  
 `path` 매개 변수는 디스크에 저장 된 파일이 필요 하지 않으면 스트림을 사용 하 여 액세스를 지 원하는 시스템의 모든 일부가 될 수 있습니다.  
  
> [!CAUTION]
>  문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및를 throw 하면 예외가 발생 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 이러한 부하 분산 방식이 <xref:System.IO.StreamReader> 생성자입니다.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열("")인 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 또는 <paramref name="encoding" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />에 부정확하거나 올바르지 않은 파일 이름, 디렉터리 이름 또는 볼륨 레이블이 있는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" />가 0보다 작거나 같은 경우</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">읽을 스트림입니다.</param>
        <param name="encoding">사용할 문자 인코딩입니다.</param>
        <param name="detectEncodingFromByteOrderMarks">
          파일의 시작 부분에서 바이트 순서 표시를 찾으려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="bufferSize">최소 버퍼 크기입니다.</param>
        <param name="leaveOpen">
          <see cref="T:System.IO.StreamReader" /> 개체를 삭제한 후 스트림을 열어 두려면 <see langword="true" />이고, 닫으려면 <see langword="false" />입니다.</param>
        <summary>지정된 문자 인코딩과 바이트 순서 표시 검색 옵션, 버퍼 크기를 기반으로 지정된 스트림에 대해 <see cref="T:System.IO.StreamReader" /> 클래스의 새 인스턴스를 초기화하고 스트림을 선택적으로 연 상태로 둡니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 하지 않으면는 `leaveOpen` 매개 변수를 `true`, <xref:System.IO.StreamReader> 호출 개체 <xref:System.IO.Stream.Dispose> 제공 된 <xref:System.IO.Stream> 개체 때 <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 라고 합니다.  
  
 16 비트 문자 수에서를 사용 하는 버퍼 크기를 설정한는 `bufferSize` 매개 변수입니다. 경우 `bufferSize` 작으면 최소 허용 크기 (128 자), 보다 크기가 사용 됩니다.  
  
 이 생성자를 사용 하는 인코딩에서 읽은 처음으로 변경할 수 있습니다는 <xref:System.IO.StreamReader> 개체입니다. 경우는 `detectEncodingFromByteOrderMarks` 매개 변수는 `true`, 생성자 스트림의 첫 번째 3 바이트를 확인 하 여 인코딩을 검색 합니다. U t F-8, little endian 유니코드를 자동으로 인식 하 고 big endian 유니코드 텍스트 파일 시작 적절 한 바이트 순서 표시 합니다. 그렇지 않은 경우는 사용자가 제공한 인코딩은 사용 됩니다. 자세한 내용은 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 메서드를 참조하세요.  
  
> [!NOTE]
>  읽을 때는 <xref:System.IO.Stream>,이 스트림 내부 버퍼와 같은 크기 버퍼를 사용 하는 것이 효율적입니다.  
  
> [!CAUTION]
>  문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자는 올바르게 해석 될 수 있습니다 및를 throw 하면 예외가 발생 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>내부 스트림을 반환합니다.</summary>
        <value>내부 스트림입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하 여 내부 스트림에 액세스할 수 있습니다. <xref:System.IO.StreamReader> 중 하나를 호출 하는 경우 원본 스트림에서 입력 버퍼 클래스는 <xref:System.IO.StreamReader.Read%2A> 메서드. 버퍼에 데이터를 읽은 후 기본 스트림 위치를 조작 하는 경우 기본 스트림의 위치 내부 버퍼의 위치를 다릅니다. 내부 버퍼를 다시 설정 하려면 호출의 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 메서드도 있습니다; 그러나이 인해 성능이 저하 메서드와 반드시 필요한 경우에 호출 해야 합니다. <xref:System.IO.StreamReader> 생성자가 포함 된는 `detectEncodingFromByteOrderMarks` 매개 변수 인코딩에서 읽은 처음으로 변경할 수는 <xref:System.IO.StreamReader> 개체입니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.IO.StreamReader" /> 개체와 내부 스트림을 닫고 판독기와 관련된 모든 시스템 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 재정의 <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> 메서드.  
  
 이 구현 <xref:System.IO.StreamReader.Close%2A> 호출은 <xref:System.IO.StreamReader.Dispose%2A> 전달 메서드는 `true` 값입니다.  
  
 명시적으로 호출 하지 않으면 스트림을 내부 인코더가 플러시되지 것입니다 <xref:System.IO.StreamReader.Close%2A>합니다. 설정 <xref:System.IO.StreamWriter.AutoFlush%2A> 를 `true` 스트림 버퍼에서 데이터를 플러시할 수는 있지만 인코더 상태 플러시되지 것입니다 있다는 것을 의미 합니다. 따라서 올바르게 문자의 다음 블록을 인코딩할 수 있도록 (부분 문자)의 상태를 유지 하기 위해 인코더 수 있습니다. 이 시나리오는 u t f 8와 UTF7, 인코더는 인접 한 문자를 받은 후에 특정 문자를 인코딩할 수 있는 위치에 적용 됩니다.  
  
 호출한 다음 <xref:System.IO.StreamReader.Close%2A>, 판독기에 대 한 모든 작업 예외를 발생 시킬 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ CurrentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.IO.StreamReader" /> 개체에서 사용 중인 현재 문자 인코딩을 가져옵니다.</summary>
        <value>현재 판독기에서 사용하는 문자 인코딩입니다. <see cref="Overload:System.IO.StreamReader.Read" /> 메서드를 처음으로 호출할 때 인코딩이 자동으로 검색되므로 <see cref="T:System.IO.StreamReader" />의 <see cref="Overload:System.IO.StreamReader.Read" /> 메서드를 처음으로 호출하면 값이 달라질 수 있습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정 된 인코딩을 가져옵니다 <xref:System.IO.StreamReader> 개체입니다.  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardBufferedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardBufferedData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>내부 버퍼를 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 에 대 한 내부 버퍼를 다시 설정 하는 메서드는 <xref:System.IO.StreamReader> 개체입니다. 이 메서드를 호출 해야 경우에만 내부 버퍼의 위치 및 <xref:System.IO.StreamReader.BaseStream%2A> 일치 하지 않습니다. 버퍼에 데이터를 읽고 다음 내부 스트림 내의 새 위치를 검색 하는 경우이 위치는 일치 하지 않는 될 수 있습니다. 이 인해 성능이 저하 메서드와 내용의의 일부를 읽을 경우와 같이 꼭 필요한 경우에 사용 해야는 <xref:System.IO.StreamReader> 개체를 한 번 이상.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제 시나리오를 보여 줍니다. 여기서는 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 내부 버퍼와 내부 스트림을 동기화 할 메서드를 호출 해야 합니다. 예제에서 파일 위치를 설명 하는 데 사용 되 고 텍스트의 구성 `abcdefghijklmnopqrstuvwxyz`합니다. 호출 하 여 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 예제 예상 대로 작동 하는 데이터를 읽은 다음 합니다. 처음 15 문자를 읽은 후 위치 2의 오프셋된 값 다시 설정 되 고 나머지 문자를 모두 읽습니다. 에 대 한 호출을 제거 하면 <xref:System.IO.StreamReader.DiscardBufferedData%2A>, 예제에는 예상 대로 작동 하지 않습니다. 처음 15 자를 읽었지만 내부 스트림의 위치에만 다시 설정 됩니다. 내부 버퍼는 <xref:System.IO.StreamReader> 개체가 16 번째 문자에 남아 있습니다. 따라서 <xref:System.IO.StreamReader.ReadToEnd%2A> 재설정 위치에서 시작 하 고 내부 스트림이의 문자는 버퍼의 모든 문자를 반환 합니다.  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary>내부 스트림을 닫고 <see cref="T:System.IO.StreamReader" />에서 사용하는 관리되지 않는 리소스를 해제하고 관리되는 리소스를 선택적으로 해제할 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 public <xref:System.IDisposable.Dispose%2A> 메서드 및 <xref:System.Object.Finalize%2A> 메서드. <xref:System.IDisposable.Dispose%2A> 보호 된 호출 <xref:System.IO.StreamReader.Dispose%2A> 메서드는 `disposing` 매개 변수가 true로 설정 합니다. <xref:System.Object.Finalize%2A> 호출 <xref:System.IO.StreamReader.Dispose%2A> 와 `disposing` false로 설정 합니다.  
  
 때는 `disposing` 매개 변수는 `true`,이 개체를 관리 되는 모든 리소스를 보유 하는 메서드 릴리스는 <xref:System.IO.StreamReader> 개체에서 참조 합니다. 이 메서드는 참조되는 각 개체의 <xref:System.IDisposable.Dispose%2A> 메서드를 호출합니다.  
  
 이어야 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Dispose 다른 개체에서 여러 번 호출할 수 있습니다. 재정의 하는 경우 <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />[cref,...] Dispose 호출 하 여 이전에 삭제 된 개체를 참조 하지 않도록 주의 하십시오. 구현 하는 방법에 대 한 자세한 내용은 <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> 참조 [Dispose 메서드를 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.  
  
 에 대 한 자세한 내용은 <see cref="M:System.IDisposable.Dispose" /> 및 <see cref="M:System.Object.Finalize" />, 참조 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md)합니다.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfStream As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfStream { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 스트림 위치가 스트림의 끝에 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          현재 스트림 위치가 스트림의 끝에 있으면 <see langword="true" />이고, 없으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">기본 스트림이 삭제되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamReader ^ Null;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>빈 스트림 주위의 <see cref="T:System.IO.StreamReader" /> 개체입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드는 호출을 읽을 때 <xref:System.IO.StreamReader.Null>, 항상 0이 반환 됩니다. 때 <xref:System.IO.StreamReader.ReadLine%2A> 에서 호출 되어 <xref:System.IO.StreamReader.Null>, `null` 반환 됩니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>사용할 수 있는 다음 문자를 반환하지만 사용하지는 않습니다.</summary>
        <returns>읽을 다음 문자를 나타내는 정수이거나, 읽을 문자가 없거나 스트림에서 검색을 지원하지 않을 경우 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader.Peek%2A> 메서드 끝은 파일 또는 다른 오류가 발생 했는지 확인 하기 위해 정수 값을 반환 합니다. 이렇게 하면 반환 된 값은-1로 캐스팅 하기 전에 먼저 확인 하려면 사용자는 <xref:System.Char> 유형입니다.  
  
 이 메서드는 <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>를 재정의합니다.  
  
 현재 위치는 <xref:System.IO.StreamReader> 의해 개체가 변경 되지 않습니다 <xref:System.IO.StreamReader.Peek%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파일의 끝에 도달할 때까지 파일에서 줄을 읽습니다.  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">I/O 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>입력 스트림에서 다음 문자 또는 다음 문자 집합을 읽습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>입력 스트림에서 다음 문자를 읽고 문자 위치를 한 문자씩 앞으로 이동합니다.</summary>
        <returns>
          <see cref="T:System.Int32" /> 개체로 표시되는 입력 스트림의 다음 문자이거나, 사용할 수 있는 문자가 더 이상 없는 경우에는 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>를 재정의합니다.  
  
 스트림의 끝에 도달한 경우-1을 반환 될 수 있도록이 메서드는 정수를 반환 합니다. 버퍼에 데이터를 읽은 후 기본 스트림 위치를 조작 하는 경우 기본 스트림의 위치 내부 버퍼의 위치를 다릅니다. 내부 버퍼를 다시 설정 하려면 호출의 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 메서드도 있습니다; 그러나이 인해 성능이 저하 메서드와 반드시 필요한 경우에 호출 해야 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 간단한 사용법을 설명 하는 다음 코드 예제는 <xref:System.IO.StreamReader.Read%2A> 메서드.  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 다음 코드 예제에서는 사용 하 여 단일 문자를 읽는 방법을 보여 줍니다는 <xref:System.IO.StreamReader.Read> ASCII 정수 10 진수 및 16 진수 출력 서식 지정 메서드 오버 로드 합니다.  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">I/O 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">이 메서드는 지정된 문자 배열의 값이 <c>인덱스</c>와 (<c>인덱스 + 카운트 - 1</c>) 사이에서 현재 소스로부터 읽어온 문자로 교체된 상태로 반환됩니다.</param>
        <param name="index">쓰기를 시작할 <c>버퍼</c>의 인덱스입니다.</param>
        <param name="count">읽을 최대 문자 수입니다.</param>
        <summary>현재 스트림에서 지정된 최대 문자를 지정된 인덱스부터 버퍼로 읽어 들입니다.</summary>
        <returns>읽은 문자 수를 반환하거나 스트림의 끝에 있고 읽은 데이터가 없으면 0을 반환합니다. 이 수는 스트림 내에서 데이터를 사용할 수 있는지 여부에 따라 <paramref name="count" /> 매개 변수보다 작거나 같습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>를 재정의합니다.  
  
 스트림의 끝에 도달한 경우 0을 반환할 수 있도록이 메서드는 정수를 반환 합니다.  
  
 사용 하는 경우는 <xref:System.IO.StreamReader.Read%2A> 메서드를 것이 버퍼는 내부 버퍼를 원하는 블록 크기 설정 되어 있는 스트림 내부 버퍼와 같은 크기를 사용 하 고 항상 블록 크기 보다 작은 읽을 더 효율적입니다. 스트림을 생성할 때 내부 버퍼의 크기를 지정 하지 않은, 해당 기본 크기는 4kb (4096 바이트)입니다. 버퍼에 데이터를 읽은 후 기본 스트림 위치를 조작 하는 경우 기본 스트림의 위치 내부 버퍼의 위치를 다릅니다. 내부 버퍼를 다시 설정 하려면 호출의 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 메서드도 있습니다; 그러나이 인해 성능이 저하 메서드와 반드시 필요한 경우에 호출 해야 합니다.  
  
 이 메서드가 반환 중에서 지정 된 문자 수는 `count` 매개 변수를 읽거나 파일의 끝에 도달 했습니다. <xref:System.IO.TextReader.ReadBlock%2A> 차단 버전이 <xref:System.IO.StreamReader.Read%2A>합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파일의 끝에 도달할 때까지 한 번에 5 개 문자를 읽습니다.  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">버퍼 길이에서 <paramref name="index" />를 빼면 <paramref name="count" />보다 작은 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 또는 <paramref name="count" />가 음수입니다.</exception>
        <exception cref="T:System.IO.IOException">I/O 오류(예: 스트림이 닫혀 있음)가 발생합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">이 메서드는 지정된 문자 배열의 값이 <c>인덱스</c>와 (<c>인덱스</c> + <c>카운트</c> - 1) 사이에서 현재 소스로부터 읽어온 문자로 교체된 상태로 반환됩니다.</param>
        <param name="index">쓰기를 시작할 <c>버퍼</c>의 위치입니다.</param>
        <param name="count">읽을 최대 문자 수입니다. 지정한 문자 수를 버퍼에 기록하기 전에 스트림의 끝에 도달하면 현재 메서드가 반환됩니다.</param>
        <summary>현재 스트림에서 지정된 최대 수의 문자를 비동기적으로 읽어 이 데이터를 지정된 인덱스에서 시작되는 버퍼에 씁니다.</summary>
        <returns>비동기 읽기 작업을 나타내는 작업입니다. <paramref name="TResult" /> 매개 변수의 값은 버퍼 안으로 읽어 들인 총 문자 수를 포함합니다. 현재 사용할 수 있는 문자 수가 요청된 수보다 작을 경우 결과 값이 요청된 문자 수보다 작을 수 있으며, 스트림의 끝에 도달한 경우에는 0이 될 수도 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 작업이 완료 중에서 지정 된 문자 수는 `count` 매개 변수를 읽거나 스트림의 끝에 도달 했습니다.  
  
   
  
## Examples  
 다음 예제를 사용 하 여 파일에 있는 모든 문자를 읽는 방법을 <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드. 각 문자는 문자, 숫자, 또는 공백 문자의 인스턴스를 추가 하기 전에 지 확인는 <xref:System.Text.StringBuilder> 클래스입니다.  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 또는 <paramref name="count" />가 음수입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="count" />의 합계가 버퍼 길이보다 큽니다.</exception>
        <exception cref="T:System.ObjectDisposedException">스트림이 삭제되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException">판독기가 현재 이전 읽기 작업에서 사용 중입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">이 메서드는 지정된 문자 배열의 값이 <c>인덱스</c>와 (<c>인덱스 + 카운트 - 1</c>) 사이에서 현재 소스로부터 읽어온 문자로 교체된 상태로 반환됩니다.</param>
        <param name="index">쓰기를 시작할 <c>버퍼</c>의 위치입니다.</param>
        <param name="count">읽을 최대 문자 수입니다.</param>
        <summary>현재 스트림에서 지정된 최대 수의 문자를 읽어 이 데이터를 지정된 인덱스에서 시작되는 버퍼에 씁니다.</summary>
        <returns>읽은 문자 수입니다. 이 문자 수는 모든 입력 문자를 읽었는지 여부에 따라 <paramref name="count" />보다 작거나 같습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 내부 스트림의 위치는로 읽은 문자 수 만큼 앞 `buffer`합니다.  
  
 될 때까지 메서드 블록 `count` 문자를 읽을 또는 스트림의 끝에 도달 했습니다. 차단 버전 이것이 <xref:System.IO.StreamReader.Read%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">버퍼 길이에서 <paramref name="index" />를 빼면 <paramref name="count" />보다 작은 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 또는 <paramref name="count" />가 음수입니다.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.StreamReader" />가 닫힌 경우</exception>
        <exception cref="T:System.IO.IOException">I/O 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">이 메서드는 지정된 문자 배열의 값이 <c>인덱스</c>와 (<c>인덱스</c> + <c>카운트</c> - 1) 사이에서 현재 소스로부터 읽어온 문자로 교체된 상태로 반환됩니다.</param>
        <param name="index">쓰기를 시작할 <c>버퍼</c>의 위치입니다.</param>
        <param name="count">읽을 최대 문자 수입니다. 지정한 문자 수를 버퍼에 기록하기 전에 스트림의 끝에 도달하면 메서드가 반환됩니다.</param>
        <summary>현재 스트림에서 지정된 최대 수의 문자를 비동기적으로 읽어 이 데이터를 지정된 인덱스에서 시작되는 버퍼에 씁니다.</summary>
        <returns>비동기 읽기 작업을 나타내는 작업입니다. <paramref name="TResult" /> 매개 변수의 값은 버퍼 안으로 읽어 들인 총 문자 수를 포함합니다. 현재 사용할 수 있는 문자 수가 요청된 수보다 작을 경우 결과 값이 요청된 문자 수보다 작을 수 있으며, 스트림의 끝에 도달한 경우에는 0이 될 수도 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 작업이 완료 되지 않을 때까지 변수에 지정 된 문자 수는 `count` 매개 변수를 읽거나 스트림의 끝에 도달 했습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 또는 <paramref name="count" />가 음수입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="count" />의 합계가 버퍼 길이보다 큽니다.</exception>
        <exception cref="T:System.ObjectDisposedException">스트림이 삭제되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException">판독기가 현재 이전 읽기 작업에서 사용 중입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 스트림에서 한 줄의 문자를 읽고 데이터를 문자열로 반환합니다.</summary>
        <returns>입력 스트림의 다음 줄을 반환하거나 입력 스트림의 끝에 도달한 경우 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 줄 다음에 줄 문자 시퀀스 ("\n") 피드, 캐리지 리턴 문자 ("\r") 또는 캐리지 리턴 뒤에 줄 바꿈 ("\r\n")으로 정의 됩니다. 반환 되는 문자열 종료 캐리지 리턴 또는 줄 바꿈 없습니다. 반환 된 값이 `null` 입력된 스트림의 끝에 도달 하는 경우.  
  
 이 메서드는 <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>를 재정의합니다.  
  
 현재 메서드가 throw 하는 경우는 <xref:System.OutOfMemoryException>, 판독기의 위치는 기본 <xref:System.IO.Stream> 개체는 문자를 읽으려면 메서드에서 못한 하지만 내부에 이미 읽은 문자 수 만큼 앞 <xref:System.IO.StreamReader.ReadLine%2A> 버퍼는 삭제 됩니다. . 버퍼에 데이터를 읽은 후 기본 스트림 위치를 조작 하는 경우 기본 스트림의 위치 내부 버퍼의 위치를 다릅니다. 내부 버퍼를 다시 설정 하려면 호출의 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 메서드도 있습니다; 그러나이 인해 성능이 저하 메서드와 반드시 필요한 경우에 호출 해야 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파일의 끝에 도달할 때까지 파일에서 줄을 읽습니다.  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족하여 반환된 문자열의 버퍼를 할당할 수 없습니다.</exception>
        <exception cref="T:System.IO.IOException">I/O 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 스트림에서 한 줄의 문자를 비동기적으로 읽고 데이터를 문자열로 반환합니다.</summary>
        <returns>비동기 읽기 작업을 나타내는 작업입니다. <paramref name="TResult" /> 매개 변수의 값은 스트림의 다음 줄을 포함하거나 모든 문자를 읽은 경우에는 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제를 사용 하 여 파일의 첫 번째 줄을 읽는 방법을 <xref:System.IO.StreamReader.ReadLineAsync> 메서드.  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">다음 줄의 문자 수가 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
        <exception cref="T:System.ObjectDisposedException">스트림이 삭제되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException">판독기가 현재 이전 읽기 작업에서 사용 중입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 위치부터 스트림 끝까지의 모든 문자를 읽습니다.</summary>
        <returns>현재 위치부터 끝까지의 나머지 스트림은 문자열입니다. 현재 위치가 스트림 끝에 있으면 빈 문자열("")을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>를 재정의합니다.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> 스트림의 끝에 현재 위치에서 모든 입력을 읽어야 하는 경우 가장 적합 합니다. 스트림에서 읽은 문자 수를 통해 더 많은 제어를 필요한 경우 사용 된 <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 일반적으로 성능 향상으로 인해 메서드 오버 로드 합니다.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> 스트림의 끝에 도달 하면 알고 있는 것으로 가정 합니다. 서버를 보내는 데이터 연결을 닫지 않습니다를 요청할 경우에 대화형 프로토콜에 대 한 <xref:System.IO.StreamReader.ReadToEnd%2A> 는 끝에 도달 하지 않도록 하 고 피해 야 하기 때문에 무기한으로 차단 될 수 있습니다.  
  
 사용할 때의 <xref:System.IO.StreamReader.Read%2A> 메서드를 것이 스트림 내부 버퍼와 같은 크기 버퍼를 사용 하는 것이 효율적입니다. 스트림을 생성할 때 버퍼의 크기를 지정 하지 않은, 해당 기본 크기는 4kb (4096 바이트)입니다.  
  
 현재 메서드가 throw 하는 경우는 <xref:System.OutOfMemoryException>, 판독기의 위치는 기본 <xref:System.IO.Stream> 개체는 문자를 읽으려면 메서드에서 못한 하지만 내부에 이미 읽은 문자 수 만큼 앞 <xref:System.IO.StreamReader.ReadLine%2A> 버퍼는 삭제 됩니다. . 버퍼에 데이터를 읽은 후 기본 스트림 위치를 조작 하는 경우 기본 스트림의 위치 내부 버퍼의 위치를 다릅니다. 내부 버퍼를 다시 설정 하려면 호출의 <xref:System.IO.StreamReader.DiscardBufferedData%2A> 메서드도 있습니다; 그러나이 인해 성능이 저하 메서드와 반드시 필요한 경우에 호출 해야 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 한 번에 파일의 끝까지 읽습니다.  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족하여 반환된 문자열의 버퍼를 할당할 수 없습니다.</exception>
        <exception cref="T:System.IO.IOException">I/O 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 위치부터 스트림 끝까지의 모든 문자를 비동기적으로 읽어서 이를 하나의 문자열로 반환합니다.</summary>
        <returns>비동기 읽기 작업을 나타내는 작업입니다. <paramref name="TResult" /> 매개 변수의 값은 현재 위치에서 스트림 끝까지 있는 문자로 이루어진 문자열을 포함합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 사용 하 여 파일의 내용을 읽을 수는 <xref:System.IO.StreamReader.ReadToEndAsync> 메서드.  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">문자 수가 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
        <exception cref="T:System.ObjectDisposedException">스트림이 삭제되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException">판독기가 현재 이전 읽기 작업에서 사용 중입니다.</exception>
      </Docs>
    </Member>
  </Members>
</Type>