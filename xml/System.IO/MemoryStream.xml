<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MemoryStream.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac556075c59b69c82be733ba11b25325ec6183d2c6a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56075c59b69c82be733ba11b25325ec6183d2c6a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.MemoryStream">
          <source>Creates a stream whose backing store is memory.</source>
          <target state="translated">백업 저장소가 메모리인 스트림을 만듭니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>The current position of a stream is the position at which the next read or write operation could take place.</source>
          <target state="translated">스트림의 현재 위치는 위치는 다음 읽기 또는 쓰기 작업을 수행할 수 있게 합니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>The current position can be retrieved or set through the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> method.</source>
          <target state="translated">현재 위치를 검색 하거나를 통해 설정할 수는 <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>When a new instance of <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> is created, the current position is set to zero.</source>
          <target state="translated">새 인스턴스가 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 만들어지면 현재 위치가 0으로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>Memory streams created with an unsigned byte array provide a non-resizable stream of the data.</source>
          <target state="translated">메모리 스트림을 만든 부호 없는 바이트 배열을 사용 하 여 데이터의 크기 조정이 불가능 스트림을 제공 합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>When using a byte array, you can neither append to nor shrink the stream, although you might be able to modify the existing contents depending on the parameters passed into the constructor.</source>
          <target state="translated">바이트 배열을 사용할 경우에 추가 하거나 수은 생성자에 전달 하는 매개 변수에 따라 기존 내용을 수정할 수 있지만, 스트림 축소 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>Empty memory streams are resizable, and can be written to and read from.</source>
          <target state="translated">빈 메모리 스트림 크기를 조정할 수에 기록 및에서 읽을 수 수 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>If a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is added to a ResX file or a .resources file, call the <ph id="ph2">&lt;xref:System.Resources.ResourceManager.GetStream%2A&gt;</ph> method at runtime to retrieve it.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 개체가 ResX 파일 또는.resources 파일에 추가 된, 호출의 <ph id="ph2">&lt;xref:System.Resources.ResourceManager.GetStream%2A&gt;</ph> 검색할 런타임 시 메서드.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>If a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is serialized to a resource file it will actually be serialized as an <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph>.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 으로 실제로 serialize 됩니다 리소스 파일에 개체를 직렬화 할는 <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>This behavior provides better performance, as well as the ability to get a pointer to the data directly, without having to go through <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> methods.</source>
          <target state="translated">이 문제를 거칠 필요 없이 데이터에 대 한 포인터를 직접 가져올 수 있는 기능 뿐 아니라 더 나은 성능을 제공 <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>The following code example shows how to read and write data using memory as a backing store.</source>
          <target state="translated">다음 코드 예제에서는 읽고 메모리를 사용 하 여 백업 저장소로 데이터를 쓰는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="T:System.IO.MemoryStream">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class with an expandable capacity initialized to zero.</source>
          <target state="translated">0으로 초기화된 확장 가능한 용량을 사용하여 <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> 속성을 모두 설정 되어 <ph id="ph4">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor">
          <source>The capacity of the current stream automatically increases when you use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> method to set the length to a value larger than the capacity of the current stream.</source>
          <target state="translated">현재 스트림의 용량을 사용 하는 경우 자동으로 증가 <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> 길이 현재 스트림의 용량 보다 큰 값으로 설정 하는 메서드.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor">
          <source>This constructor exposes the underlying stream, which <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> returns.</source>
          <target state="translated">이 생성자는 기본 제공 스트림는 <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> 반환 합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The array of unsigned bytes from which to create the current stream.</source>
          <target state="translated">현재 스트림을 만들 부호 없는 바이트의 배열입니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified byte array.</source>
          <target state="translated">지정된 바이트 배열을 기반으로 하는 <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> 클래스의 크기 조정이 불가능한 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> 속성을 모두 설정 되어 <ph id="ph4">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to the length of the specified byte array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> 지정 된 바이트 배열의 길이로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The new stream can be written to, but is not resizable.</source>
          <target state="translated">새 스트림 쓸 수 있지만 조정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">스트림의 길이 지정 된 바이트 배열의 초기 길이 보다 큰 값으로 설정 수 없습니다. 그러나, 스트림 잘릴 수 있습니다 (참조 <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">이 생성자에 내부 스트림을 노출 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throw <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>The initial size of the internal array in bytes.</source>
          <target state="translated">내부 배열의 초기 크기(바이트)입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class with an expandable capacity initialized as specified.</source>
          <target state="translated">지정된 대로 초기화된 확장 가능한 용량을 사용하여 <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> 속성을 모두 설정 되어 <ph id="ph4">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>The capacity automatically increases when you use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> method to set the length to a value larger than the capacity of the current stream.</source>
          <target state="translated">용량을 사용 하는 경우 자동으로 증가 <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> 길이 현재 스트림의 용량 보다 큰 값으로 설정 하는 메서드.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>Except for a <ph id="ph1">`MemoryStream`</ph> constructed with a byte[] parameter, write operations at the end of a <ph id="ph2">`MemoryStream`</ph> expand the <ph id="ph3">`MemoryStream`</ph>.</source>
          <target state="translated">제외 하 고는 <ph id="ph1">`MemoryStream`</ph> byte 매개 변수를 사용 하 여 생성, 쓰기 작업의 끝에는 <ph id="ph2">`MemoryStream`</ph> 확장는 <ph id="ph3">`MemoryStream`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>This constructor exposes the underlying stream that <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> returns.</source>
          <target state="translated">이 생성자는 기본 제공 하는 스트림 <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> 반환 합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph>가 음수입니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">이 스트림을 만들 부호 없는 바이트의 배열입니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The setting of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property, which determines whether the stream supports writing.</source>
          <target state="translated">스트림이 쓰기를 지원하는지 여부를 결정하는 <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> 속성의 설정입니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified byte array with the <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property set as specified.</source>
          <target state="translated">지정된 대로 설정된 <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> 속성을 사용하여 지정된 바이트 배열을 기반으로 하는 <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> 클래스의 크기 조정이 불가능한 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> properties are both set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> 속성 둘 다로 설정 <ph id="ph3">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to the length of the specified byte array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> 지정 된 바이트 배열의 길이로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">스트림의 길이 지정 된 바이트 배열의 초기 길이 보다 큰 값으로 설정 수 없습니다. 그러나, 스트림 잘릴 수 있습니다 (참조 <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">이 생성자에 내부 스트림을 노출 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throw <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">이 스트림을 만들 부호 없는 바이트의 배열입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The index into <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which the stream begins.</source>
          <target state="translated">스트림이 시작될 <bpt id="p1">&lt;c&gt;</bpt>버퍼<ept id="p1">&lt;/c&gt;</ept>의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The length of the stream in bytes.</source>
          <target state="translated">스트림의 길이(바이트)입니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified region (index) of a byte array.</source>
          <target state="translated">바이트 배열의 지정된 영역(인덱스)을 기반으로 하는 <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> 클래스의 크기 조정이 불가능한 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>, but the capacity cannot be changed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, 및 <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> 속성을 모두 설정 되어 <ph id="ph4">`true`</ph>, 되었지만 용량을 변경할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to <ph id="ph2">`count`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph>이 <ph id="ph2">`count`</ph>로 설정됩니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">스트림의 길이 지정 된 바이트 배열의 초기 길이 보다 큰 값으로 설정 수 없습니다. 그러나, 스트림 잘릴 수 있습니다 (참조 <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">이 생성자에 내부 스트림을 노출 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throw <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>However, you can write to the stream.</source>
          <target state="translated">그러나 스트림에 작성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 0보다 작습니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">버퍼 길이에서 <ph id="ph1">&lt;paramref name="index" /&gt;</ph>를 빼면 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>보다 작은 경우</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">이 스트림을 만들 부호 없는 바이트의 배열입니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The index in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which the stream begins.</source>
          <target state="translated">스트림이 시작될 <bpt id="p1">&lt;c&gt;</bpt>버퍼<ept id="p1">&lt;/c&gt;</ept>의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The length of the stream in bytes.</source>
          <target state="translated">스트림의 길이(바이트)입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The setting of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property, which determines whether the stream supports writing.</source>
          <target state="translated">스트림이 쓰기를 지원하는지 여부를 결정하는 <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> 속성의 설정입니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified region of a byte array, with the <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property set as specified.</source>
          <target state="translated">지정된 대로 설정된 <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> 속성을 사용하여 지정된 바이트 배열의 영역을 기반으로 하는 <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> 클래스의 크기 조정이 불가능한 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> properties are both set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> 속성 둘 다로 설정 <ph id="ph3">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to <ph id="ph2">`count`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph>이 <ph id="ph2">`count`</ph>로 설정됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">스트림의 길이 지정 된 바이트 배열의 초기 길이 보다 큰 값으로 설정 수 없습니다. 그러나, 스트림 잘릴 수 있습니다 (참조 <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">이 생성자에 내부 스트림을 노출 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throw <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>However, you can write to the stream if <ph id="ph1">`writable`</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">그러나 수는 스트림에 쓸 경우 <ph id="ph1">`writable`</ph> 은 <ph id="ph2">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> are negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 음수인 경우</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">버퍼 길이에서 <ph id="ph1">&lt;paramref name="index" /&gt;</ph>를 빼면 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>보다 작은 경우</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">이 스트림을 만들 부호 없는 바이트의 배열입니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The index into <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which the stream begins.</source>
          <target state="translated">스트림이 시작될 <bpt id="p1">&lt;c&gt;</bpt>버퍼<ept id="p1">&lt;/c&gt;</ept>의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The length of the stream in bytes.</source>
          <target state="translated">스트림의 길이(바이트)입니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The setting of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property, which determines whether the stream supports writing.</source>
          <target state="translated">스트림이 쓰기를 지원하는지 여부를 결정하는 <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> 속성의 설정입니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to enable <ph id="ph2">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph>, which returns the unsigned byte array from which the stream was created; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">스트림을 만든 부호 없는 바이트 배열을 반환하는 <ph id="ph2">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph>를 사용하도록 설정하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 설정하지 않으려면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified region of a byte array, with the <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property set as specified, and the ability to call <ph id="ph3">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph> set as specified.</source>
          <target state="translated">지정된 대로 설정된 <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> 속성과 지정된 대로 설정된 <ph id="ph3">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph> 호출 기능을 사용하여 지정된 바이트 배열의 영역을 기반으로 하는 <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> 클래스의 새 인스턴스를 초기화합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> properties are both set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> 속성 둘 다로 설정 <ph id="ph3">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to <ph id="ph2">`count`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph>이 <ph id="ph2">`count`</ph>로 설정됩니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The new stream instance can be written to, but the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> of the underlying byte array cannot be changed.</source>
          <target state="translated">새 스트림 인스턴스에 쓸 수는 있지만 <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> 기본 바이트의 배열을 변경할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">스트림의 길이 지정 된 바이트 배열의 초기 길이 보다 큰 값으로 설정 수 없습니다. 그러나, 스트림 잘릴 수 있습니다 (참조 <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 음수입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">버퍼 길이에서 <ph id="ph1">&lt;paramref name="index" /&gt;</ph>를 빼면 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>보다 작은 경우</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.CanRead">
          <source>Gets a value indicating whether the current stream supports reading.</source>
          <target state="translated">현재 스트림이 읽기를 지원하는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanRead">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream is open.</source>
          <target state="translated">스트림이 열려 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanRead">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support reading, calls to the <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> methods throw a <ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">클래스에서 파생 하는 경우 <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> 읽기를 지원 하지 않습니다에 대 한 호출이 <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> 및 <ph id="ph3">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> 메서드에서 throw 된 <ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanRead">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">이 속성은 반환 된 스트림이 닫혀 있는지 <ph id="ph1">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.CanSeek">
          <source>Gets a value indicating whether the current stream supports seeking.</source>
          <target state="translated">현재 스트림이 검색을 지원하는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanSeek">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream is open.</source>
          <target state="translated">스트림이 열려 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanSeek">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support seeking, calls to <ph id="ph2">&lt;xref:System.IO.MemoryStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> throw a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">클래스에서 파생 하는 경우 <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> 찾기를 지원 하지 않습니다에 대 한 호출이 <ph id="ph2">&lt;xref:System.IO.MemoryStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph>, 및 <ph id="ph5">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> throw 한 <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanSeek">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">이 속성은 반환 된 스트림이 닫혀 있는지 <ph id="ph1">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.CanWrite">
          <source>Gets a value indicating whether the current stream supports writing.</source>
          <target state="translated">현재 스트림이 쓰기를 지원하는지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanWrite">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports writing; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">스트림이 쓰기를 지원하면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 지원하지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanWrite">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support writing, a call to <ph id="ph2">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph> throws a <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">클래스에서 파생 하는 경우 <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> 쓰기 호출을 지원 하지 않는 <ph id="ph2">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>, 또는 <ph id="ph4">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph> throw 한 <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanWrite">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">이 속성은 반환 된 스트림이 닫혀 있는지 <ph id="ph1">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source>Gets or sets the number of bytes allocated for this stream.</source>
          <target state="translated">이 스트림에 할당된 바이트 수를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source>The length of the usable portion of the buffer for the stream.</source>
          <target state="translated">버퍼에서 스트림에 대해 사용할 수 있는 부분의 길이입니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source><ph id="ph1">`Capacity`</ph> is the buffer length for system-provided byte arrays.</source>
          <target state="translated"><ph id="ph1">`Capacity`</ph> 시스템에서 제공한 바이트 배열에 대 한 버퍼 길이입니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source><ph id="ph1">`Capacity`</ph> cannot be set to a value less than the current length of the stream.</source>
          <target state="translated"><ph id="ph1">`Capacity`</ph> 스트림의 현재 길이 보다 작은 값으로 설정할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source>A capacity is set that is negative or less than the current length of the stream.</source>
          <target state="translated">음수 또는 스트림의 현재 길이보다 작은 용량이 설정되어 있는 경우</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source>The current stream is closed.</source>
          <target state="translated">현재 스트림이 닫혀 있습니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source><ph id="ph1">&lt;see langword="set" /&gt;</ph> is invoked on a stream whose capacity cannot be modified.</source>
          <target state="translated">용량을 수정할 수 없는 스트림에 <ph id="ph1">&lt;see langword="set" /&gt;</ph>이 호출되는 경우</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The stream to which the contents of the current stream will be copied.</source>
          <target state="translated">현재 스트림의 내용을 복사할 스트림입니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The size, in bytes, of the buffer.</source>
          <target state="translated">버퍼의 크기(바이트)입니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>This value must be greater than zero.</source>
          <target state="translated">이 값은 0보다 커야 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">취소 요청을 모니터링할 토큰입니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously reads all the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</source>
          <target state="translated">현재 스트림에서 모든 바이트를 비동기적으로 읽어 지정된 버퍼 크기 및 취소 토큰을 사용하여 다른 스트림에 씁니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous copy operation.</source>
          <target state="translated">비동기 복사 작업을 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destination" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffersize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffersize" /&gt;</ph>가 음수이거나 0인 경우</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>Either the current stream or the destination stream is disposed.</source>
          <target state="translated">현재 스트림이나 대상 스트림이 삭제됩니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The current stream does not support reading, or the destination stream does not support writing.</source>
          <target state="translated">현재 스트림이 읽기를 지원하지 않거나 대상 스트림이 쓰기를 지원하지 않습니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>로 설정하고, 관리되지 않는 리소스만 해제하려면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>로 설정합니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class and optionally releases the managed resources.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> 클래스에 사용되는 관리되지 않는 리소스를 해제하고, 필요에 따라 관리되는 리소스를 해제합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">이 메서드는 public <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> 메서드 및 <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> invokes the protected <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> 보호 된 호출 <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> 메서드는 <ph id="ph3">`disposing`</ph> 매개 변수 설정 <ph id="ph4">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 호출 <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> 와 <ph id="ph3">`disposing`</ph> 로 설정 <ph id="ph4">`false`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.IO.MemoryStream&gt;</ph> references.</source>
          <target state="translated"><ph id="ph1">`disposing`</ph> 매개 변수가 <ph id="ph2">`true`</ph>인 경우 이 메서드는 이 <ph id="ph3">&lt;xref:System.IO.MemoryStream&gt;</ph>에서 참조하는 관리 개체가 보유하고 있는 리소스를 모두 해제합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method of each referenced object.</source>
          <target state="translated">이 메서드는 참조되는 각 개체의 <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> 메서드를 호출합니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>는 다른 개체에서 여러 번 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph> be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</source>
          <target state="translated">재정의 하는 경우 <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph> 이전 호출에서 삭제 된 개체를 참조 하지 않도록 주의 <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">구현 하는 방법에 대 한 자세한 내용은 <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph>, 참조 <bpt id="p1">[</bpt>Dispose 메서드를 구현<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">에 대 한 자세한 내용은 <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> 및 <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, 참조 <bpt id="p1">[</bpt>관리 되지 않는 리소스 정리<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Flush">
          <source>Overrides the <ph id="ph1">&lt;see cref="M:System.IO.Stream.Flush" /&gt;</ph> method so that no action is performed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.IO.Stream.Flush" /&gt;</ph> 메서드를 재정의하여 아무런 작업도 수행되지 않도록 합니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Flush">
          <source>This method overrides the <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">이 메서드를 재정의 <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Flush">
          <source>Because any data written to a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is written into RAM, this method is redundant.</source>
          <target state="translated">때문에에 쓴 데이터는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> RAM에이 메서드는 중복 하는 개체를 작성 합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">취소 요청을 모니터링할 토큰입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Asynchronously clears all buffers for this stream, and monitors cancellation requests.</source>
          <target state="translated">이 스트림에 대한 모든 버퍼를 비동기적으로 지우고 취소 요청을 모니터링합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous flush operation.</source>
          <target state="translated">비동기 플러시 작업을 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Because any data written to a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is written into RAM, this method is redundant.</source>
          <target state="translated">때문에에 쓴 데이터는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> RAM에이 메서드는 중복 하는 개체를 작성 합니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">반환된 된 작업에 포함 된 완료 되기 전에 작업이 취소 되는 경우는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 에 대 한 값은 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>You can create a cancellation token by creating an instance of the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class and passing the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property as the <ph id="ph3">`cancellationToken`</ph> parameter.</source>
          <target state="translated">인스턴스를 만들어 취소 토큰을 만들 수 있습니다는 <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> 클래스 및 전달 된 <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> 속성으로는 <ph id="ph3">`cancellationToken`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">스트림이 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>Returns the array of unsigned bytes from which this stream was created.</source>
          <target state="translated">이 스트림을 만드는 데 사용된 부호 없는 바이트의 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>The byte array from which this stream was created, or the underlying array if a byte array was not provided to the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> constructor during construction of the current instance.</source>
          <target state="translated">이 스트림을 만든 바이트 배열이거나 현재 인스턴스 생성 도중 <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> 생성자에게 바이트 배열이 제공되지 않은 경우 내부 배열입니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>Note that the buffer contains allocated bytes which might be unused.</source>
          <target state="translated">버퍼에 포함 하는 사용 될 수 있는 바이트를 할당 합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>For example, if the string "test" is written into the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object, the length of the buffer returned from <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> is 256, not 4, with 252 bytes unused.</source>
          <target state="translated">예를 들어, "test" 문자열에 기록 됩니다는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 개체에서 반환 되는 버퍼의 길이 <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> 256을 사용 하지 않는 252 바이트와 4 되지 됩니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>To obtain only the data in the buffer, use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> method; however, <ph id="ph2">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> creates a copy of the data in memory.</source>
          <target state="translated">버퍼의 데이터를 가져오려면는 <ph id="ph1">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> 메서드 소비량이 적어지지만 <ph id="ph2">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> 메모리에 데이터의 복사본을 만듭니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>The buffer can also be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">버퍼 될 수도 있습니다 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>To create a <ph id="ph1">`MemoryStream`</ph> instance with a publicly visible buffer, use <ph id="ph2">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Int32%29&gt;</ph>.</source>
          <target state="translated">만들려는 <ph id="ph1">`MemoryStream`</ph> 공개적으로 표시 되는 버퍼에 사용 하 여를 사용 하 여 인스턴스 <ph id="ph2">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>, 또는 <ph id="ph4">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Int32%29&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>If the current stream is resizable, two calls to this method do not return the same array if the underlying byte array is resized between calls.</source>
          <target state="translated">현재 스트림 크기를 조정할 수 있으면 호출 간에 내부 바이트 배열 크기를 조정 하는 경우이 메서드를 두 번 호출 동일한 배열을 반환 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph>을 참조하십시오.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>This method works when the memory stream is closed.</source>
          <target state="translated">메모리 스트림을 닫힐 때 사용할 수 있는이 방법입니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>The <ph id="ph1">&lt;see langword="MemoryStream" /&gt;</ph> instance was not created with a publicly visible buffer.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MemoryStream" /&gt;</ph> 인스턴스가 공개적으로 표시되는 버퍼로 만들어지지 않은 경우</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Length">
          <source>Gets the length of the stream in bytes.</source>
          <target state="translated">스트림의 길이(바이트)를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Length">
          <source>The length of the stream in bytes.</source>
          <target state="translated">스트림의 길이(바이트)입니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Length">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Length">
          <source>The stream is closed.</source>
          <target state="translated">스트림이 닫혔습니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Position">
          <source>Gets or sets the current position within the stream.</source>
          <target state="translated">스트림 내의 현재 위치를 가져오거나 설정합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Position">
          <source>The current position within the stream.</source>
          <target state="translated">스트림 내의 현재 위치입니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Position">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Position">
          <source>The position is set to a negative value or a value greater than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">위치가 음수 값이나 <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큰 값으로 설정된 경우</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Position">
          <source>The stream is closed.</source>
          <target state="translated">스트림이 닫혔습니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>When this method returns, contains the specified byte array with the values between <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> and (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1) replaced by the characters read from the current stream.</source>
          <target state="translated">이 메서드는 지정된 바이트 배열의 값이 <bpt id="p1">&lt;c&gt;</bpt>오프셋<ept id="p1">&lt;/c&gt;</ept>과 (<bpt id="p2">&lt;c&gt;</bpt>오프셋<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>카운트<ept id="p3">&lt;/c&gt;</ept> - 1) 사이에서 현재 스트림으로부터 읽어온 문자로 교체된 상태로 반환됩니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin storing data from the current stream.</source>
          <target state="translated">현재 스트림에서 데이터를 저장하기 시작할 <bpt id="p1">&lt;c&gt;</bpt>버퍼<ept id="p1">&lt;/c&gt;</ept>의 바이트 오프셋(0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">읽을 최대 바이트 수입니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Reads a block of bytes from the current stream and writes the data to a buffer.</source>
          <target state="translated">현재 스트림에서 바이트 블록을 읽어서 버퍼에 씁니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The total number of bytes written into the buffer.</source>
          <target state="translated">버퍼로 쓴 총 바이트 수입니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This can be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached before any bytes are read.</source>
          <target state="translated">해당 바이트 수를 현재 사용할 수 없는 경우 이 수는 요청된 바이트 수보다 작을 수 있으며 바이트를 읽기 전에 스트림의 끝에 도달한 경우에는 0이 될 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>를 재정의합니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the first byte in <ph id="ph2">`buffer`</ph> to which data from the current stream is written.</source>
          <target state="translated"><ph id="ph1">`offset`</ph> 첫 번째 바이트 오프셋을 제공 하는 매개 변수 <ph id="ph2">`buffer`</ph> 현재 스트림에서 데이터 기록 됩니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter gives the maximum number of bytes to read from the current stream.</source>
          <target state="translated"><ph id="ph1">`count`</ph> 매개 변수는 현재 스트림에서 읽을 바이트 수의 최대 수를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</source>
          <target state="translated">반환 된 값은 스트림의 끝에 도달 하면 0 또는 읽은 바이트의 실제 수 합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If the read operation is successful, the current position within the stream advances by the number of bytes read.</source>
          <target state="translated">읽기 작업이 성공적 이면 스트림 내의 현재 위치 읽은 바이트 수로 이동 합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position within the stream remains unchanged.</source>
          <target state="translated">예외가 발생 하는 경우는 스트림 내의 현재 위치 변경 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`Read`</ph> method will return zero only if the end of the stream is reached.</source>
          <target state="translated"><ph id="ph1">`Read`</ph> 메서드 스트림의 끝에 도달 하는 경우에 0이 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>In all other cases, <ph id="ph1">`Read`</ph> always reads at least one byte from the stream before returning.</source>
          <target state="translated">다른 모든 경우에 <ph id="ph1">`Read`</ph> 항상 스트림에서 반환 하기 전에 적어도 1 바이트를 읽습니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>By definition, if no data is available from the stream upon a call to <ph id="ph1">`Read`</ph>, the <ph id="ph2">`Read`</ph> method returns zero (the end of the stream is reached automatically).</source>
          <target state="translated">에 대 한 호출 시 스트림에서 데이터가 없는 경우 기본적으로 <ph id="ph1">`Read`</ph>, <ph id="ph2">`Read`</ph> 메서드 (자동으로 스트림의 끝에는 연결할) 0을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</source>
          <target state="translated">구현을 스트림의 끝에 도달 하지 하는 경우에 요청 된 것 보다 적은 바이트를 반환할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> for reading primitive data types.</source>
          <target state="translated">사용 하 여 <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> 기본 데이터 형식을 읽기 위한 합니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If the byte array specified in the <ph id="ph1">`buffer`</ph> parameter is the underlying buffer returned by the <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> method, the array contents are overwritten, and no exception is thrown.</source>
          <target state="translated">바이트 배열에 지정 된 경우는 <ph id="ph1">`buffer`</ph> 매개 변수는 내부 버퍼에서 반환 되는 <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> 배열 콘텐츠를 덮어쓸 메서드와 예외가 throw 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 음수입니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> subtracted from the buffer length is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">버퍼 길이에서 <ph id="ph1">&lt;paramref name="offset" /&gt;</ph>을 빼면 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>보다 작은 경우</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The current stream instance is closed.</source>
          <target state="translated">현재 스트림 인스턴스가 닫혀 있는 경우</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write the data into.</source>
          <target state="translated">데이터를 쓸 버퍼입니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing data from the stream.</source>
          <target state="translated">스트림의 데이터를 쓰기 시작할 <bpt id="p1">&lt;c&gt;</bpt>버퍼<ept id="p1">&lt;/c&gt;</ept>의 바이트 오프셋입니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">읽을 최대 바이트 수입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">취소 요청을 모니터링할 토큰입니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The default value is <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</source>
          <target state="translated">기본값은 <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</source>
          <target state="translated">현재 스트림에서 바이트의 시퀀스를 비동기적으로 읽고 읽은 바이트 수만큼 스트림 내에서 앞으로 이동하며 취소 요청을 모니터링합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">비동기 읽기 작업을 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains the total number of bytes read into the buffer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> 매개 변수의 값은 버퍼 안으로 읽어들인 총 바이트 수를 포함합니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</source>
          <target state="translated">현재 사용할 수 있는 바이트 수가 요청된 수보다 작을 경우 결과 값이 요청된 바이트 수보다 작을 수 있으며 스트림의 끝에 도달한 경우에는 0이 될 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">반환된 된 작업에 포함 된 완료 되기 전에 작업이 취소 되는 경우는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 에 대 한 값은 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>You can create a cancellation token by creating an instance of the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class and passing the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property as the <ph id="ph3">`cancellationToken`</ph> parameter.</source>
          <target state="translated">인스턴스를 만들어 취소 토큰을 만들 수 있습니다는 <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> 클래스 및 전달 된 <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> 속성으로는 <ph id="ph3">`cancellationToken`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 음수입니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>의 합계가 버퍼 길이보다 큽니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support reading.</source>
          <target state="translated">스트림이 읽기를 지원하지 않습니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">스트림이 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous read operation.</source>
          <target state="translated">스트림을 현재 이전 읽기 작업에서 사용 중입니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadByte">
          <source>Reads a byte from the current stream.</source>
          <target state="translated">현재 스트림에서 바이트를 읽습니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadByte">
          <source>The byte cast to a <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>, or -1 if the end of the stream has been reached.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>로 캐스팅된 바이트이거나 스트림의 끝에 도달한 경우 -1입니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>를 재정의합니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>If the read operation is successful, the current position within the stream is advanced by one byte.</source>
          <target state="translated">읽기 작업이 성공적 이면 스트림 내의 현재 위치는가 1 바이트 앞 합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>If an exception occurs, the current position within the stream is unchanged.</source>
          <target state="translated">예외가 발생 하면 스트림 내의 현재 위치는 변경 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadByte">
          <source>The current stream instance is closed.</source>
          <target state="translated">현재 스트림 인스턴스가 닫혀 있는 경우</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The new position within the stream.</source>
          <target state="translated">스트림 내의 새 위치입니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This is relative to the <bpt id="p1">&lt;c&gt;</bpt>loc<ept id="p1">&lt;/c&gt;</ept> parameter, and can be positive or negative.</source>
          <target state="translated">이 위치는 <bpt id="p1">&lt;c&gt;</bpt>loc<ept id="p1">&lt;/c&gt;</ept> 매개 변수와 관련되며 양수와 음수 모두 가능합니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>A value of type <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>, which acts as the seek reference point.</source>
          <target state="translated">검색 참조 지점 역할을 하는 <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph> 형식의 값입니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Sets the position within the current stream to the specified value.</source>
          <target state="translated">현재 스트림 내의 위치를 지정된 값으로 설정합니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The new position within the stream, calculated by combining the initial reference point and the offset.</source>
          <target state="translated">초기 참조 지점과 오프셋을 조합해서 계산한, 스트림 내의 새 위치입니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">이 메서드는 <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>를 재정의합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Seeking to any location beyond the length of the stream is supported.</source>
          <target state="translated">스트림의 길이 초과 하는 위치에 검색을 지원 됩니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Do not use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> method to determine the new position in the stream if the <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> was initialized with a non-zero offset.</source>
          <target state="translated">사용 하지 않는 <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> 경우 스트림 내의 새 위치를 결정 하는 <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> 0이 아닌 오프셋을 사용 하 여 초기화 되었습니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>If you do, <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> will return an inaccurate value.</source>
          <target state="translated">이렇게 하면 <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> 정확 하지 않은 값을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Instead, use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph> property to get the new position of the stream.</source>
          <target state="translated">대신를 사용 하 여는 <ph id="ph1">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph> 스트림의 새 위치를 가져올 속성입니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Seeking is attempted before the beginning of the stream.</source>
          <target state="translated">스트림의 시작 이전부터 검색이 시도되었습니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph>가 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>보다 큰 경우</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>There is an invalid <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>.</source>
          <target state="translated">잘못된 <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>이 있는 경우</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> caused an arithmetic overflow.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph>이 산술 연산 오버플로를 발생시킨 경우</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The current stream instance is closed.</source>
          <target state="translated">현재 스트림 인스턴스가 닫혀 있는 경우</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>The value at which to set the length.</source>
          <target state="translated">길이를 설정할 값입니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>Sets the length of the current stream to the specified value.</source>
          <target state="translated">현재 스트림의 길이를 지정된 값으로 설정합니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>를 재정의합니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If the specified value is less than the current length of the stream, the stream is truncated.</source>
          <target state="translated">지정된 된 값은 스트림의 현재 길이 보다 작은 경우는 스트림이 잘렸습니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If after the truncation the current position within the stream is past the end of the stream, the <ph id="ph1">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> method returns -1, the <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> method reads zero bytes into the provided byte array, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.Write%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.IO.MemoryStream.WriteByte%2A&gt;</ph> methods append specified bytes at the end of the stream, increasing its length.</source>
          <target state="translated">잘릴 스트림 내의 현재 위치, 스트림 끝을 지나서이 <ph id="ph1">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> -1을 반환 하는 메서드는 <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> 메서드는 제공 된 바이트 배열에 0 바이트를 읽고 및 <ph id="ph3">&lt;xref:System.IO.MemoryStream.Write%2A&gt;</ph> 및 <ph id="ph4">&lt;xref:System.IO.MemoryStream.WriteByte%2A&gt;</ph> 메서드 추가 스트림, 스트림 끝에 지정 된 바이트 수입니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If the specified value is larger than the current capacity and the stream is resizable, the capacity is increased, and the current position within the stream is unchanged.</source>
          <target state="translated">지정한 값은 현재 용량 보다 클 경우 스트림 크기를 조정할 수 용량을 증가 하 고는 스트림 내의 현재 위치는 변경 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If the length is increased, the contents of the stream between the old and the new length are initialized to zeros.</source>
          <target state="translated">길이 수는 증가 하는 경우 이전 클라이언트 암호 및 새 길이 사이의 스트림 콘텐츠가 0으로 초기화 됩니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>A <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> instance must support writing for this method to work.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 인스턴스는이 방법 사용 하려면에 대 한 쓰기를 지원 해야 합니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing.</source>
          <target state="translated">사용 하 여는 <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> 속성을 현재 인스턴스가 쓰기를 지원 하는지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>을 참조하십시오.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>The current stream is not resizable and <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is larger than the current capacity.</source>
          <target state="translated">현재 스트림의 크기를 조정할 수 없으며 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 현재 용량보다 큰 경우</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>The current stream does not support writing.</source>
          <target state="translated">현재 스트림이 쓰기를 지원하지 않는 경우</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is negative or is greater than the maximum length of the <ph id="ph2">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph>, where the maximum length is(<ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> - origin), and origin is the index into the underlying buffer at which the stream starts.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>가 음수이거나 <ph id="ph2">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph>의 최대 길이보다 큰 경우. 여기서 최대 길이는 <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> - origin입니다. origin은 스트림이 시작되는 내부 버퍼의 인덱스입니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ToArray">
          <source>Writes the stream contents to a byte array, regardless of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.Position" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.Position" /&gt;</ph> 속성에 관계없이 바이트 배열에 스트림 내용을 씁니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ToArray">
          <source>A new byte array.</source>
          <target state="translated">새 바이트 배열입니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>This method omits unused bytes in <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> from the array.</source>
          <target state="translated">이 메서드를 사용 되지 않는 바이트 생략 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 배열에서 합니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>To get the entire buffer, use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> method.</source>
          <target state="translated">전체 버퍼를 가져오려면는 <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>This method returns a copy of the contents of the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> as a byte array.</source>
          <target state="translated">내용의 복사본을 반환 하는이 메서드는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 바이트 배열입니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>If the current instance was constructed on a provided byte array, a copy of the section of the array to which this instance has access is returned.</source>
          <target state="translated">현재 인스턴스가 제공된 된 바이트 배열에서 생성 된,이 인스턴스에 액세스 권한을 있는 배열의 복사본이 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>See the <ph id="ph1">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph> constructor for details.</source>
          <target state="translated">참조는 <ph id="ph1">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph> 세부 정보에 대 한 생성자입니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>This method works when the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> is closed.</source>
          <target state="translated">이 방법을 사용할 때의 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 닫힙니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source>The byte array segment from which this stream was created.</source>
          <target state="translated">이 스트림을 만든 바이트 배열 세그먼트입니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source>Returns the array of unsigned bytes from which this stream was created.</source>
          <target state="translated">이 스트림을 만드는 데 사용된 부호 없는 바이트의 배열을 반환합니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source>The return value indicates whether the conversion succeeded.</source>
          <target state="translated">반환 값은 변환의 성공 여부를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the conversion was successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">성공적으로 변환되면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The buffer to write data from.</source>
          <target state="translated">데이터를 쓸 버퍼입니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin copying bytes to the current stream.</source>
          <target state="translated">현재 스트림으로 바이트를 복사하기 시작할 <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>의 바이트 오프셋(0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">쓸 최대 바이트 수입니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Writes a block of bytes to the current stream using data read from a buffer.</source>
          <target state="translated">버퍼에서 읽은 데이터를 사용하여 현재 스트림에 바이트 블록을 씁니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>를 재정의합니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the first byte in <ph id="ph2">`buffer`</ph> to write from, and the <ph id="ph3">`count`</ph> parameter gives the number of bytes to write.</source>
          <target state="translated"><ph id="ph1">`offset`</ph> 첫 번째 바이트 오프셋을 제공 하는 매개 변수 <ph id="ph2">`buffer`</ph> 에서 쓰는 및 <ph id="ph3">`count`</ph> 매개 변수 쓸 바이트 수를 제공 합니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If the write operation is successful, the current position within the stream is advanced by the number of bytes written.</source>
          <target state="translated">쓰기 작업이 완료 되는 스트림 내의 현재 위치는 쓴 바이트 수 만큼 앞 합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position within the stream is unchanged.</source>
          <target state="translated">예외가 발생 하면 스트림 내의 현재 위치는 변경 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Except for a <ph id="ph1">`MemoryStream`</ph> constructed with a byte[] parameter, write operations at the end of a <ph id="ph2">`MemoryStream`</ph> expand the <ph id="ph3">`MemoryStream`</ph>.</source>
          <target state="translated">제외 하 고는 <ph id="ph1">`MemoryStream`</ph> byte 매개 변수를 사용 하 여 생성, 쓰기 작업의 끝에는 <ph id="ph2">`MemoryStream`</ph> 확장는 <ph id="ph3">`MemoryStream`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The stream does not support writing.</source>
          <target state="translated">스트림이 쓰기를 지원하지 않습니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>For additional information see <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>를 참조하십시오.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The current position is closer than <ph id="ph1">&lt;paramref name="count" /&gt;</ph> bytes to the end of the stream, and the capacity cannot be modified.</source>
          <target state="translated">현재 위치가 스트림의 끝에서 <ph id="ph1">&lt;paramref name="count" /&gt;</ph> 바이트보다 가까우며 용량을 수정할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> subtracted from the buffer length is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">버퍼 길이에서 <ph id="ph1">&lt;paramref name="offset" /&gt;</ph>을 빼면 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>보다 작은 경우</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> are negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 음수인 경우</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>An I/O error occurs.</source>
          <target state="translated">I/O 오류가 발생했습니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The current stream instance is closed.</source>
          <target state="translated">현재 스트림 인스턴스가 닫혀 있는 경우</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write data from.</source>
          <target state="translated">데이터를 쓸 버퍼입니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> from which to begin copying bytes to the stream.</source>
          <target state="translated">스트림으로 바이트를 복사하기 시작할 <bpt id="p1">&lt;c&gt;</bpt>버퍼<ept id="p1">&lt;/c&gt;</ept>의 바이트 오프셋(0부터 시작)입니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">쓸 최대 바이트 수입니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">취소 요청을 모니터링할 토큰입니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The default value is <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</source>
          <target state="translated">기본값은 <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</source>
          <target state="translated">바이트의 시퀀스를 현재 스트림에 비동기적으로 쓰고 쓰여진 바이트 수만큼 이 스트림 내의 현재 위치를 앞으로 이동한 후 취소 요청을 모니터링합니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous write operation.</source>
          <target state="translated">비동기 쓰기 작업을 나타내는 작업입니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">반환된 된 작업에 포함 된 완료 되기 전에 작업이 취소 되는 경우는 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> 에 대 한 값은 <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>You can create a cancellation token by creating an instance of the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class and passing the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property as the <ph id="ph3">`cancellationToken`</ph> parameter.</source>
          <target state="translated">인스턴스를 만들어 취소 토큰을 만들 수 있습니다는 <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> 클래스 및 전달 된 <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> 속성으로는 <ph id="ph3">`cancellationToken`</ph> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>가 음수입니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 및 <ph id="ph2">&lt;paramref name="count" /&gt;</ph>의 합계가 버퍼 길이보다 큽니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support writing.</source>
          <target state="translated">스트림이 쓰기를 지원하지 않습니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">스트림이 삭제되었습니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous write operation.</source>
          <target state="translated">이전 쓰기 작업에서 현재 이 스트림을 사용하고 있습니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The byte to write.</source>
          <target state="translated">쓸 바이트입니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>Writes a byte to the current stream at the current position.</source>
          <target state="translated">현재 위치에서 현재 스트림에 바이트를 씁니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>.</source>
          <target state="translated">이 메서드는 <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>를 재정의합니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>Except for a <ph id="ph1">`MemoryStream`</ph> constructed with a byte[] parameter, write operations at the end of a <ph id="ph2">`MemoryStream`</ph> expand the <ph id="ph3">`MemoryStream`</ph>.</source>
          <target state="translated">제외 하 고는 <ph id="ph1">`MemoryStream`</ph> byte 매개 변수를 사용 하 여 생성, 쓰기 작업의 끝에는 <ph id="ph2">`MemoryStream`</ph> 확장는 <ph id="ph3">`MemoryStream`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The stream does not support writing.</source>
          <target state="translated">스트림이 쓰기를 지원하지 않습니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>For additional information see <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>.</source>
          <target state="translated">자세한 내용은 <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>를 참조하십시오.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The current position is at the end of the stream, and the capacity cannot be modified.</source>
          <target state="translated">현재 위치가 스트림의 끝에 있으며 용량을 수정할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The current stream is closed.</source>
          <target state="translated">현재 스트림이 닫혀 있습니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>The stream to write this memory stream to.</source>
          <target state="translated">이 메모리 스트림을 쓸 스트림입니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>Writes the entire contents of this memory stream to another stream.</source>
          <target state="translated">다른 스트림에 이 메모리 스트림의 전체 내용을 씁니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>When the current stream is open, this method is equivalent to calling <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A?displayProperty=nameWithType&gt;</ph> on the underlying buffer of this stream.</source>
          <target state="translated">이 메서드 호출에 해당 하는 현재 스트림이 열려 있으면 <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A?displayProperty=nameWithType&gt;</ph> 이 스트림의 내부 버퍼에 있습니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>The current or target stream is closed.</source>
          <target state="translated">현재 스트림이나 대상 스트림이 닫혀 있는 경우</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>