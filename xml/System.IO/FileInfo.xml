<Type Name="FileInfo" FullName="System.IO.FileInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e511612781980353b1d0ee39752729ee05251c79" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420487" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit FileInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileInfo sealed : System::IO::FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>파일을 만들고, 복사하고, 삭제하고, 이동하고, 열기 위한 속성 및 인스턴스 메서드를 제공하고, <see cref="T:System.IO.FileStream" /> 개체를 만드는 것을 도와줍니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.IO.FileInfo> 복사, 이동, 이름 바꾸기, 만들기, 열기, 삭제 하 고 파일에 추가 같은 일반적인 작업에 대 한 클래스입니다.  
  
 동일한 파일에 여러 개의 작업을 수행 하는 경우 보다 효율적으로 사용할 수 있습니다 <xref:System.IO.FileInfo> 인스턴스 메서드 대신 해당 정적 메서드는 <xref:System.IO.File> 클래스를 보안 검사를 항상 되지 않으므로 필요 합니다.  
  
 대부분의 <xref:System.IO.FileInfo> 메서드를 만들거나 파일을 열 때 다른 I/O 형식을 반환 합니다. 추가 파일을 조작 하기 위한 다른 형식을 이러한 사용할 수 있습니다. 자세한 내용은 참조 특정 <xref:System.IO.FileInfo> 멤버와 같은 <xref:System.IO.FileInfo.Open%2A>, <xref:System.IO.FileInfo.OpenRead%2A>, <xref:System.IO.FileInfo.OpenText%2A>, <xref:System.IO.FileInfo.CreateText%2A>, 또는 <xref:System.IO.FileInfo.Create%2A>합니다.  
  
 새 파일에 대 한 모든 읽기/쓰기 액세스는 기본적으로 모든 사용자에 게 부여 됩니다.  
  
 다음 표에서 다양 한의 동작을 사용자 지정 하는 데 사용 되는 열거형을 설명 <xref:System.IO.FileInfo> 메서드.  
  
|열거형|설명|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|읽기 및 쓰기 파일에 대 한 액세스를 지정합니다.|  
|<xref:System.IO.FileShare>|이미 사용 중인 파일에 대 한 허용 되는 액세스 수준을 지정 합니다.|  
|<xref:System.IO.FileMode>|기존 파일의 내용을 유지 여부를 덮어쓸 및 기존 파일을 만드는 요청 하면 예외가 발생 하는지 여부를 지정 합니다.|  
  
> [!NOTE]
>  가 경로 입력된 문자열을 허용 하는 멤버에 해당 경로 올바른 형식 이어야 합니다 또는 예외가 발생 합니다. 예를 들어 경로 정규화 된 표시 되지만 공백으로 시작 경로 클래스의 메서드에서 잘리지 않습니다. 따라서 경로 잘못 되었으며 예외가 발생 합니다. 마찬가지로, 경로 또는 경로의 조합 두 번 정규화 될 수 없습니다. 예를 들어 "c:\temp c:\windows"는 또한 대부분의 경우에서 예외가 발생합니다. 경로 문자열을 허용 하는 메서드를 사용 하는 경우 경로 형식이 있는지 확인 합니다.  
  
 경로 허용 하는 멤버를 파일이 나 디렉터리 경로 참조할 수 있습니다. 지정된 된 경로 상대 경로 또는 서버 및 공유 이름에 대 한 범용 명명 규칙 (UNC) 경로를 참조할 수도 있습니다. 예를 들어 다음은 허용 가능한 경로.  
  
-   "c:\\\MyDir\\\MyFile.txt" C# 또는 Visual Basic의 "c:\MyDir\MyFile.txt"입니다.  
  
-   "c:\\\MyDir" C# 또는 Visual Basic의 "c:\MyDir"입니다.  
  
-   "MyDir\\\MySubdir" C# 또는 Visual Basic의 "MyDir\MySubDir"입니다.  
  
-   "\\\\\\\MyServer\\\MyShare" C# 또는 "\\\MyServer\MyShare" Visual Basic의 합니다.  
  
 <xref:System.IO.FileInfo> 클래스 파일에 대 한 정보를 검색할 수 있도록 하는 속성을 제공 합니다. 각 속성을 사용 하는 방법의 예를 들어 속성 페이지를 참조 하십시오.  
  
-   <xref:System.IO.FileInfo.Directory%2A> 속성 파일의 부모 디렉터리를 나타내는 개체를 검색 합니다.  
  
-   <xref:System.IO.FileInfo.DirectoryName%2A> 속성 파일의 부모 디렉터리의 전체 경로 검색 합니다.  
  
-   <xref:System.IO.FileInfo.Exists%2A> 속성에 연산을 하기 전에 파일의 있는지 여부를 확인 합니다.  
  
-   <xref:System.IO.FileInfo.IsReadOnly%2A> 속성을 검색 하거나 파일을 수정할 수 있는지 여부를 지정 하는 값을 설정 합니다.  
  
-   <xref:System.IO.FileInfo.Length%2A> 파일의 크기를 검색 합니다.  
  
-   <xref:System.IO.FileInfo.Name%2A> 파일의 이름을 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 주 멤버 중 일부는 `FileInfo` 클래스입니다.  
  
 속성을 먼저 검색 하는 경우 <xref:System.IO.FileInfo> 호출은 <xref:System.IO.FileSystemInfo.Refresh%2A> 메서드 정보를 캐시 파일에 대 한 합니다. 후속 호출에서 호출 해야 <xref:System.IO.FileSystemInfo.Refresh%2A> 정보의 최신 복사본을 가져오려면 합니다.  
  
 [!code-cpp[FInfo Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Class/CPP/finfo class.cpp#1)]
 [!code-csharp[FInfo Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Class/CS/finfo class.cs#1)]
 [!code-vb[FInfo Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Class/VB/finfo class.vb#1)]  
  
 이 예에서는 다음과 유사한 출력을 생성합니다.  
  
```  
Hello  
And  
Welcome  
C:\Users\userName\AppData\Local\Temp\tmp70AB.tmp was copied to C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp.  
C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp was successfully deleted.  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.DriveInfo" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileInfo(System::String ^ fileName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">새 파일의 정규화된 이름이거나 상대적인 파일 이름입니다. 경로가 디렉터리 구분 기호 문자로 끝나서는 안 됩니다.</param>
        <summary>파일 경로의 래퍼 역할을 하는 <see cref="T:System.IO.FileInfo" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정규화 된 이름 또는 상대 파일 이름을 지정할 수 있지만 보안 검사는 정규화 된 이름을 가져옵니다.  
  
   
  
## Examples  
 다음 예제는 다음 쓰기에서 읽기, 복사 및 삭제 된 두 개의 파일을 만들려면이 생성자를 사용 합니다.  
  
 [!code-cpp[finfo ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Ctor/CPP/finfo ctor.cpp#1)]
 [!code-csharp[finfo ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Ctor/CS/finfo ctor.cs#1)]
 [!code-vb[finfo ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Ctor/VB/finfo ctor.vb#1)]  
  
 다음 예제에서는 기존 파일을 엽니다 또는 파일을 만듭니다, 그리고 파일, 텍스트를 추가 하 고 결과 표시 합니다.  
  
 [!code-cpp[fileinfomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfomain/CPP/fileinfomain.cpp#1)]
 [!code-csharp[fileinfomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfomain/CS/fileinfomain.cs#1)]
 [!code-vb[fileinfomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfomain/VB/fileinfomain.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">파일 이름이 비어 있거나, 공백만 포함하거나 잘못된 문자를 포함합니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="fileName" />에 대한 액세스가 거부된 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="fileName" />의 문자열 중간에 콜론(:)이 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 읽기입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter AppendText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter AppendText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.AppendText" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ AppendText();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.IO.StreamWriter" />의 이 인스턴스가 나타내는 파일에 텍스트를 추가하는 <see cref="T:System.IO.FileInfo" />를 만듭니다.</summary>
        <returns>새 <see langword="StreamWriter" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 텍스트 파일에 추가 하 고 파일에서 읽습니다.  
  
 [!code-cpp[finfo appendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo AppendText/CPP/finfo appendtext.cpp#1)]
 [!code-csharp[finfo appendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo AppendText/CS/finfo appendtext.cs#1)]
 [!code-vb[finfo appendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo AppendText/VB/finfo appendtext.vb#1)]  
  
 다음 예제에서는 파일의 끝에 추가할 텍스트를 보여 주고도 콘솔에 추가 작업의 결과 표시 합니다. 처음으로이 루틴이 호출 되는 파일이 존재 하지 않는 경우 만들어집니다. 그런 다음 지정된 된 텍스트 파일에 추가 됩니다.  
  
 [!code-cpp[fileinfoappendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoappendtext/CPP/fileinfoappendtext.cpp#1)]
 [!code-csharp[fileinfoappendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoappendtext/CS/fileinfoappendtext.cs#1)]
 [!code-vb[fileinfoappendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoappendtext/VB/fileinfoappendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">읽고 파일에 추가 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>새 파일에 기존 파일을 복사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">복사할 새 파일의 이름입니다.</param>
        <summary>새 파일에 기존 파일을 복사하고 기존 파일을 덮어쓸 수 없도록 합니다.</summary>
        <returns>정규화된 경로가 있는 새 파일입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.FileInfo.CopyTo%2A> 메서드를 기존 파일을 덮어쓸 수 있도록 합니다.  
  
> [!CAUTION]
>  가능 하면 항상 짧은 파일 이름 (예: XXXXXX~1.XXX)를 사용 하 여이 방법을 사용 하지 마십시오. 두 개의 파일이 짧은 해당 하는 경우 파일 이름은 다음이 메서드 수 실패와 예외를 발생 시키는 및/또는 인해 예기치 않은 동작이  
  
   
  
## Examples  
 다음 예제에서는 두 오버 로드는 `CopyTo` 메서드.  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 다음 예제에서는 한 파일 대상 파일이 이미 있는 경우 예외를 throw 하는 다른 파일을 복사 하는 방법을 보여 줍니다.  
  
 [!code-cpp[FileInfoCopyTo1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileInfoCopyTo1/CPP/fileinfocopyto1.cpp#1)]
 [!code-csharp[FileInfoCopyTo1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileInfoCopyTo1/CS/fileinfocopyto1.cs#1)]
 [!code-vb[FileInfoCopyTo1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileInfoCopyTo1/VB/fileinfocopyto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" />이 비어 있거나, 공백만 포함하거나 잘못된 문자를 포함합니다.</exception>
        <exception cref="T:System.IO.IOException">오류가 발생했거나 대상 파일이 이미 있습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">디렉터리 경로를 거치거나 파일이 다른 드라이브로 이동됩니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="destFileName" />에 지정된 디렉터리가 없습니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" />은 문자열 내에 콜론(:)을 포함하지만 볼륨을 지정하지는 않습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String, overwrite As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destFileName">복사할 새 파일의 이름입니다.</param>
        <param name="overwrite">
          기존 파일을 덮어쓸 수 있도록 하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>새 파일에 기존 파일을 복사하고 기존 파일을 덮어쓸 수 있도록 합니다.</summary>
        <returns>새 파일이 반환되거나, <paramref name="overwrite" />가 <see langword="true" />인 경우 기존 파일을 덮어씁니다. 파일이 있고 <paramref name="overwrite" />가 <see langword="false" />이면 <see cref="T:System.IO.IOException" />이 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여를 허용 하거나 기존 파일 덮어쓰지 않도록 합니다. 사용 된 <xref:System.IO.FileInfo.CopyTo%2A> 메서드를 기본적으로 기존 파일 덮어쓰지 않도록 합니다.  
  
> [!CAUTION]
>  가능 하면 항상 짧은 파일 이름 (예: XXXXXX~1.XXX)를 사용 하 여이 방법을 사용 하지 마십시오. 두 개의 파일이 짧은 해당 하는 경우 파일 이름은 다음이 메서드 수 실패와 예외를 발생 시키는 및/또는 인해 예기치 않은 동작이  
  
   
  
## Examples  
 다음 예제에서는 두 오버 로드는 `CopyTo` 메서드.  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 다음 예제에서는 한 파일을 이미 존재 하는 파일을 덮어쓸지 여부를 지정 하는 다른 파일을 복사 하는 방법을 보여 줍니다.  
  
 [!code-cpp[fileinfocopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfocopyto/CPP/fileinfocopyto.cpp#1)]
 [!code-csharp[fileinfocopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfocopyto/CS/fileinfocopyto.cs#1)]
 [!code-vb[fileinfocopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfocopyto/VB/fileinfocopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" />이 비어 있거나, 공백만 포함하거나 잘못된 문자를 포함합니다.</exception>
        <exception cref="T:System.IO.IOException">오류가 발생했거나 대상 파일이 이미 있으며 <paramref name="overwrite" />가 <see langword="false" />입니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="destFileName" />에 지정된 디렉터리가 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">디렉터리 경로를 거치거나 파일이 다른 드라이브로 이동됩니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" />의 문자열 중간에 콜론(:)이 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Function Create () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Create();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파일을 만듭니다.</summary>
        <returns>새 파일입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 파일에 대 한 모든 읽기/쓰기 액세스는 기본적으로 모든 사용자에 게 부여 됩니다.  
  
 이 메서드는에서 제공 하는 기능에 대 한 래퍼 <xref:System.IO.File.Create%2A?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 파일에 대 한 참조를 만들고 다음 사용 하 여 디스크에 파일을 만들고 `FileInfo.Create()`합니다.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 다음 예제에서는 파일을 만듭니다,에 일부 텍스트를 추가 하 고 해당 파일에서 읽습니다.  
  
 [!code-cpp[finfo create#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Create/CPP/finfo create.cpp#1)]
 [!code-csharp[finfo create#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Create/CS/finfo create.cs#1)]
 [!code-vb[finfo create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Create/VB/finfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter CreateText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter CreateText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CreateText" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ CreateText();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>새 텍스트 파일을 쓰는 <see cref="T:System.IO.StreamWriter" />를 만듭니다.</summary>
        <returns>새 <see langword="StreamWriter" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 파일에 대 한 모든 읽기/쓰기 액세스는 기본적으로 모든 사용자에 게 부여 됩니다.  
  
   
  
## Examples  
 다음 예제는 `CreateText` 메서드.  
  
 [!code-cpp[finfo createtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CreateText/CPP/finfo createtext.cpp#1)]
 [!code-csharp[finfo createtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CreateText/CS/finfo createtext.cs#1)]
 [!code-vb[finfo createtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CreateText/VB/finfo createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">파일 이름이 디렉터리입니다.</exception>
        <exception cref="T:System.IO.IOException">디스크가 읽기 전용입니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public void Decrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Decrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Decrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Decrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Decrypt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 계정으로 <see cref="M:System.IO.FileInfo.Encrypt" /> 메서드를 통해 암호화된 파일을 해독합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Decrypt%2A> 메서드를 사용 하 여 암호화 된 파일을 암호 해독할 수 있습니다는 <xref:System.IO.FileInfo.Encrypt%2A> 메서드.  <xref:System.IO.FileInfo.Decrypt%2A> 메서드는 현재 사용자 계정을 사용 하 여 암호화 된 파일에만 해독할 수 있습니다.  
  
 두는 <xref:System.IO.FileInfo.Encrypt%2A> 메서드 및 <xref:System.IO.FileInfo.Decrypt%2A> 메서드에서 컴퓨터와 메서드를 호출 하는 프로세스의 파일 암호화 키에 설치 된 암호화 서비스 공급자 (CSP)을 사용 합니다.  
  
 현재 파일 시스템 NTFS 및 현재 운영 체제가 Microsoft Windows NT 이루어야 서식이 지정 되거나 이상 이어야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.IO.FileInfo.Encrypt%2A> 메서드 및 <xref:System.IO.FileInfo.Decrypt%2A> 메서드를 암호화 한 다음 파일을 해독 합니다.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">잘못된 드라이브를 지정했습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">현재 <see cref="T:System.IO.FileInfo" /> 개체에 설명된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.IOException">파일을 여는 동안 I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.NotSupportedException">NTFS 파일 시스템이 아닙니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows NT 이상이 아닙니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 <see cref="T:System.IO.FileInfo" /> 개체가 설명하는 파일이 읽기 전용입니다.  
  
 또는  
  
 현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
 또는  
  
 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
 보안 동작: 요청 합니다.  
  
 읽고 현재에서 설명 하는 파일에 쓸 수 있는 권한 <see cref="T:System.IO.FileInfo" /> 개체입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파일을 영구적으로 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파일이 없으면이 메서드는 아무 작업도 수행 하지 않습니다.  
  
   
  
## Examples  
 다음 예제는 `Delete` 메서드.  
  
 [!code-cpp[finfo delete#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Delete/CPP/finfo delete.cpp#1)]
 [!code-csharp[finfo delete#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Delete/CS/finfo delete.cs#1)]
 [!code-vb[finfo delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Delete/VB/finfo delete.vb#1)]  
  
 다음 예제에서는 만듭니다, 그리고 닫히고 파일을 삭제 합니다.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Microsoft Windows NT를 실행하는 컴퓨터에서 대상 파일이 열려 있거나 메모리에 매핑되어 있습니다.  
  
 또는  
  
 파일에 대해 열린 핸들이 있고 운영 체제가 Windows XP 또는 이전 버전입니다. 이 열린 핸들은 디렉터리 및 파일을 열거하면 발생할 수 있습니다. 자세한 내용은 [방법: 디렉터리 및 파일 열거](~/docs/standard/io/how-to-enumerate-directories-and-files.md)를 참조하세요.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">경로가 디렉터리입니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Directory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Directory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Directory" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Directory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Directory As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Directory { System::IO::DirectoryInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>부모 디렉터리의 인스턴스를 가져옵니다.</summary>
        <value>이 파일의 부모 디렉터리를 나타내는 <see cref="T:System.IO.DirectoryInfo" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문자열로 서 부모 디렉터리를 가져오려면는 <xref:System.IO.FileInfo.DirectoryName%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 또는 파일을 만듭니다, 그리고 전체 경로 결정 하 고 결정 열리고 디렉터리의 전체 내용이 표시 됩니다.  
  
 [!code-cpp[fileinfodirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodirectory/CPP/fileinfodirectory.cpp#1)]
 [!code-csharp[fileinfodirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodirectory/CS/fileinfodirectory.cs#1)]
 [!code-vb[fileinfodirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodirectory/VB/fileinfodirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 읽기입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DirectoryName">
      <MemberSignature Language="C#" Value="public string DirectoryName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryName" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.DirectoryName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디렉터리의 전체 경로를 나타내는 문자열을 가져옵니다.</summary>
        <value>디렉터리의 전체 경로를 나타내는 문자열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부모 디렉터리는 <xref:System.IO.DirectoryInfo> 개체를 가져오려면는 <xref:System.IO.FileInfo.Directory%2A> 속성입니다.  
  
 처음 호출 될 때 <xref:System.IO.FileInfo> 호출 <xref:System.IO.FileSystemInfo.Refresh%2A> 파일에 대 한 정보를 캐시 합니다. 후속 호출에서 호출 해야 <xref:System.IO.FileSystemInfo.Refresh%2A> 정보의 최신 복사본을 가져오려면 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 파일의 전체 경로 검색 합니다.  
  
 [!code-cpp[System.IO.FileInfo members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileInfo members/CPP/fileinfomembers.cpp#3)]
 [!code-csharp[System.IO.FileInfo members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileInfo members/CS/fileinfomembers.cs#3)]
 [!code-vb[System.IO.FileInfo members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileInfo members/VB/fileinfomembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          디렉터리 이름에 대해 <see langword="null" />이 전달되었습니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">정규화된 경로가 260자 이상입니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 읽기입니다. 연결 된 열거형의 경우: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public void Encrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Encrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Encrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Encrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Encrypt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파일을 암호화하는 데 사용된 계정으로만 해독할 수 있도록 암호화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Encrypt%2A> 메서드를 사용 하면이 메서드를 호출 하는 데 사용 하는 계정 으로만 해독할 수 있도록 파일을 암호화할 수 있습니다.  사용 하 여는 <xref:System.IO.FileInfo.Decrypt%2A> 로 암호화 된 파일을 해독 하는 메서드는 <xref:System.IO.FileInfo.Encrypt%2A> 메서드.  
  
 두는 <xref:System.IO.FileInfo.Encrypt%2A> 메서드 및 <xref:System.IO.FileInfo.Decrypt%2A> 메서드에서 컴퓨터와 메서드를 호출 하는 프로세스의 파일 암호화 키에 설치 된 암호화 서비스 공급자 (CSP)을 사용 합니다.  
  
 현재 파일 시스템 NTFS 및 현재 운영 체제가 Microsoft Windows NT 이루어야 서식이 지정 되거나 이상 이어야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.IO.FileInfo.Encrypt%2A> 메서드 및 <xref:System.IO.FileInfo.Decrypt%2A> 파일을 암호화 하 여 암호를 해독할 메서드.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">잘못된 드라이브를 지정했습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">현재 <see cref="T:System.IO.FileInfo" /> 개체에 설명된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.IOException">파일을 여는 동안 I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.NotSupportedException">NTFS 파일 시스템이 아닙니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows NT 이상이 아닙니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 <see cref="T:System.IO.FileInfo" /> 개체가 설명하는 파일이 읽기 전용입니다.  
  
 또는  
  
 현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
 또는  
  
 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
 보안 동작: 요청 합니다.  
  
 읽고 현재에서 설명 하는 파일에 쓸 수 있는 권한 <see cref="T:System.IO.FileInfo" /> 개체입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파일이 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          파일이 있으면 <see langword="true" />이고, 파일이 없거나 파일이 디렉터리이면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처음 호출 될 때 <xref:System.IO.FileInfo> 호출 <xref:System.IO.FileSystemInfo.Refresh%2A> 파일에 대 한 정보를 캐시 합니다. 후속 호출에서 호출 해야 <xref:System.IO.FileSystemInfo.Refresh%2A> 정보의 최신 복사본을 가져오려면 합니다.  
  
 <xref:System.IO.FileInfo.Exists%2A> 속성에서 반환 `false` 지정한 파일이 있는지 확인 하는 동안 오류가 발생 하는 경우. 이 파일 이름에 잘못 된 문자 또는 실패 나 누락 된 디스크에 문자가 너무 많습니다. 전달할 때 예외를 발생 시키는 상황에서 발생할 수 있습니다 또는 호출자에 게 파일을 읽을 수 있는 사용 권한이 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.IO.FileInfo.Exists%2A> 속성 파일을 열기 전에 있는지 확인 합니다.  파일을 찾을 수 없을 때 사용자 지정 예외를 throw 하려면이 방법을 사용할 수 있습니다.  
  
 [!code-cpp[IO.FileInfo.Exists#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Exists/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Exists/cs/sample.cs#1)]
 [!code-vb[IO.FileInfo.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Exists/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체에서 설명하는 파일의 ACL(액세스 제어 목록) 항목을 캡슐화하는 <see cref="T:System.IO.FileInfo" /> 개체를 가져옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.FileInfo.GetAccessControl%2A> 액세스를 검색 하는 메서드 현재 파일에 대 한 목록 (ACL) 항목을 제어 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체에서 설명하는 파일의 ACL(액세스 제어 목록) 항목을 캡슐화하는 <see cref="T:System.IO.FileInfo" /> 개체를 가져옵니다.</summary>
        <returns>현재 파일의 액세스 제어 규칙을 캡슐화하는 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.IO.FileInfo.GetAccessControl%2A> 현재 파일에 대 한 액세스 제어 목록 (ACL) 항목을 검색 하는 메서드입니다.  
  
 개인 및/또는 나 갖지 않고에 지정된 된 파일에서 특정 작업을 수행할 권한을 그룹이 ACL에 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.IO.FileInfo.GetAccessControl%2A> 메서드 및 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드를 추가 하 고 파일에서 액세스 제어 목록 (ACL) 항목을 제거 하십시오.  이 예제를 실행하려면 유효한 사용자 또는 그룹 계정을 제공해야 합니다.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">파일을 여는 동안 I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows 2000 이상이 아닌 경우</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">현재 시스템 계정에 관리자 권한이 없습니다.</exception>
        <exception cref="T:System.SystemException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
 또는  
  
 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
 보안 동작: 요청 합니다.  
  
 액세스 제어 목록을 읽을 수 있는 권한입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">검색할 액세스 제어 항목 그룹을 지정하는 <see cref="T:System.Security.AccessControl.AccessControlSections" /> 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체에서 설명하는 파일의 지정된 ACL(액세스 제어 목록) 항목 형식을 캡슐화하는 <see cref="T:System.IO.FileInfo" /> 개체를 가져옵니다.</summary>
        <returns>현재 파일의 액세스 제어 규칙을 캡슐화하는 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.IO.FileInfo.GetAccessControl%2A> 현재 파일에 대 한 액세스 제어 목록 (ACL) 항목을 검색 하는 메서드입니다.  
  
 개인 및/또는 나 갖지 않고에 지정된 된 파일에서 특정 작업을 수행할 권한을 그룹이 ACL에 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">파일을 여는 동안 I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows 2000 이상이 아닌 경우</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">현재 시스템 계정에 관리자 권한이 없습니다.</exception>
        <exception cref="T:System.SystemException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
 또는  
  
 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
 보안 동작: 요청 합니다.  
  
 액세스 제어 목록을 읽을 수 있는 권한입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 파일이 읽기 전용인지를 결정하는 값을 가져오거나 설정합니다.</summary>
        <value>
          현재 파일이 읽기 전용이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.IO.FileInfo.IsReadOnly%2A> 속성을 신속 하 게 확인 또는 현재 파일이 읽기 전용인 지 여부를 변경 합니다.  
  
 처음 호출 될 때 <xref:System.IO.FileInfo> 호출 <xref:System.IO.FileSystemInfo.Refresh%2A> 파일에 대 한 정보를 캐시 합니다. 후속 호출에서 호출 해야 <xref:System.IO.FileSystemInfo.Refresh%2A> 정보의 최신 복사본을 가져오려면 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.FileInfo.IsReadOnly%2A> 속성을 읽기 전용으로 표시 하 고 읽기 / 쓰기 가능으로 표시 합니다.  
  
 [!code-cpp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.IsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.isReadOnly/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">현재 <see cref="T:System.IO.FileInfo" /> 개체에 설명된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.IOException">파일을 여는 동안 I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
 또는  
  
 호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">사용자에게 쓰기 권한이 없지만 이 속성을 <see langword="false" />로 설정하려고 한 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
 보안 동작: 요청 합니다.  
  
 읽고 현재에서 설명 하는 파일에 쓸 수 있는 권한 <see cref="T:System.IO.FileInfo" /> 개체입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 파일의 크기(바이트)를 가져옵니다.</summary>
        <value>현재 파일의 크기(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값은 <xref:System.IO.FileInfo.Length%2A> 경우 속성은 미리 캐시의 현재 인스턴스는 <xref:System.IO.FileInfo> 다음 중 하나에서 개체를 반환 했습니다 <xref:System.IO.DirectoryInfo> 메서드:  
  
-   <xref:System.IO.DirectoryInfo.GetDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>  
  
 최신 값을 가져오려면 호출에서 <xref:System.IO.FileSystemInfo.Refresh%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 파일의 크기를 표시합니다.  
  
 [!code-cpp[FileLength#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileLength/CPP/filelength.cpp#1)]
 [!code-csharp[FileLength#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileLength/CS/filelength.cs#1)]
 [!code-vb[FileLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileLength/VB/filelength.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <see cref="M:System.IO.FileSystemInfo.Refresh" />가 파일이나 디렉터리의 상태를 업데이트할 수 없는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일이 없습니다.  
  
 또는  
  
 <see langword="Length" /> 속성이 디렉터리에 대해 호출되는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">파일을 이동할 경로입니다. 이 경로에서 다른 파일 이름을 지정할 수 있습니다.</param>
        <summary>지정된 파일을 새 위치로 이동하고 새 파일의 이름을 지정할 수 있는 옵션을 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 디스크 볼륨에 걸쳐 작동합니다. 예를 들어 파일 c:\MyFile.txt d:\public로 이동할 수 있습니다 및 NewFile.txt 이름을 변경 합니다.  
  
   
  
## Examples  
 다음 예제 파일을 다른 위치로 이동 하 고 파일의 이름 바꾸기입니다.  
  
 [!code-csharp[IO.FileInfo.MoveTo#1](~/samples/snippets/csharp/VS_Snippets_Misc/IO.FileInfo.MoveTo/CS/Program.cs#1)]
 [!code-vb[IO.FileInfo.MoveTo#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/IO.FileInfo.MoveTo/VB/Program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">대상 파일이 이미 있거나 대상 장치가 준비되지 않은 것과 같은 I/O 오류가 발생합니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" />이 비어 있거나, 공백만 포함하거나 잘못된 문자를 포함합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="destFileName" />이 읽기 전용이거나 디렉터리인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" />의 문자열 중간에 콜론(:)이 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파일 이름을 가져옵니다.</summary>
        <value>파일의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처음 호출 될 때 <xref:System.IO.FileInfo> 호출 <xref:System.IO.FileSystemInfo.Refresh%2A> 파일에 대 한 정보를 캐시 합니다. 후속 호출에서 호출 해야 <xref:System.IO.FileSystemInfo.Refresh%2A> 정보의 최신 복사본을 가져오려면 합니다.  
  
 파일 확장명을 포함 하는 파일의 이름입니다.  
  
   
  
## Examples  
 다음 예제에서는 `Name` 속성을 현재 디렉터리에 파일의 이름을 표시 합니다.  
  
 [!code-cpp[fileinfoname#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoname/CPP/fileinfoname.cpp#1)]
 [!code-csharp[fileinfoname#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoname/CS/fileinfoname.cs#1)]
 [!code-vb[fileinfoname#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoname/VB/fileinfoname.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>다양한 읽기/쓰기 및 공유 권한으로 파일을 엽니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">파일을 여는 모드(예: <see cref="T:System.IO.FileMode" /> 또는 <see langword="Open" />)를 지정하는 <see langword="Append" /> 상수입니다.</param>
        <summary>지정된 모드로 파일을 엽니다.</summary>
        <returns>공유 권한 없이 읽기/쓰기 권한을 사용하여 지정된 모드로 연 파일입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 파일을 엽니다 파일을에 몇 가지 정보를 추가 하 고 파일을 읽습니다.  
  
 [!code-cpp[finfo open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open1/CPP/finfo open1.cpp#1)]
 [!code-csharp[finfo open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open1/CS/finfo open1.cs#1)]
 [!code-vb[finfo open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open1/VB/finfo open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">파일이 읽기 전용 또는 디렉터리입니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">파일이 이미 열려 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">쓰는 데 필요한 파일에서 읽기입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">파일을 여는 모드(예: <see cref="T:System.IO.FileMode" /> 또는 <see langword="Open" />)를 지정하는 <see langword="Append" /> 상수입니다.</param>
        <param name="access">
          <see cref="T:System.IO.FileAccess" />, <see langword="Read" /> 또는 <see langword="Write" /> 파일 액세스 권한 중 어떤 권한으로 파일을 열지를 지정하는 <see langword="ReadWrite" /> 상수입니다.</param>
        <summary>읽기, 쓰기 또는 읽기/쓰기 권한을 사용하여 지정된 모드로 파일을 엽니다.</summary>
        <returns>공유 권한 없이 지정된 액세스 권한 및 모드로 연 <see cref="T:System.IO.FileStream" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예에서는 읽기 전용으로 파일을 열고 파일에서 읽습니다.  
  
 [!code-cpp[finfo open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open2/CPP/finfo open2.cpp#1)]
 [!code-csharp[finfo open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open2/CS/finfo open2.cs#1)]
 [!code-vb[finfo open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open2/VB/finfo open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" />이 읽기 전용이거나 디렉터리인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">파일이 이미 열려 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">쓰는 데 필요한 파일에서 읽기입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="mode">파일을 여는 모드(예: <see cref="T:System.IO.FileMode" /> 또는 <see langword="Open" />)를 지정하는 <see langword="Append" /> 상수입니다.</param>
        <param name="access">
          <see cref="T:System.IO.FileAccess" />, <see langword="Read" /> 또는 <see langword="Write" /> 파일 액세스 권한 중 어떤 권한으로 파일을 열지를 지정하는 <see langword="ReadWrite" /> 상수입니다.</param>
        <param name="share">이 파일에 대해 다른 <see cref="T:System.IO.FileShare" /> 개체의 액세스 형식을 지정하는 <see langword="FileStream" /> 상수입니다.</param>
        <summary>읽기, 쓰기 또는 읽기/쓰기 권한과 지정된 공유 옵션을 사용하여 특정 모드로 파일을 엽니다.</summary>
        <returns>지정된 액세스 권한 및 공유 옵션을 사용하여 특정 모드로 연 <see cref="T:System.IO.FileStream" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 파일에 읽기 및 쓰기, 하지만 다른 사용자 또는 프로세스에 대 한 액세스를 허용 하지 않습니다.  
  
 [!code-cpp[fileinfoopen#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoopen/CPP/fileinfoopen.cpp#1)]
 [!code-csharp[fileinfoopen#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoopen/CS/fileinfoopen.cs#1)]
 [!code-vb[fileinfoopen#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoopen/VB/fileinfoopen.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" />이 읽기 전용이거나 디렉터리인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">파일이 이미 열려 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">쓰는 데 필요한 파일에서 읽기입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenRead" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenRead () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>읽기 전용 <see cref="T:System.IO.FileStream" />을 만듭니다.</summary>
        <returns>새 읽기 전용 <see cref="T:System.IO.FileStream" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 읽기 전용 <xref:System.IO.FileStream> 개체는 <xref:System.IO.FileShare> 모드가 설정 <xref:System.IO.FileShare.Read>합니다.  
  
   
  
## Examples  
 다음 예에서는 읽기 전용으로 파일을 열고에서 읽습니다.  
  
 [!code-cpp[finfo openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenRead/CPP/finfo openread.cpp#1)]
 [!code-csharp[finfo openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenRead/CS/finfo openread.cs#1)]
 [!code-vb[finfo openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenRead/VB/finfo openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" />이 읽기 전용이거나 디렉터리인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">파일이 이미 열려 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 읽기입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamReader OpenText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenText" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenText () As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenText();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>UTF8 인코딩 방식으로 기존 텍스트 파일에서 읽는 <see cref="T:System.IO.StreamReader" />를 만듭니다.</summary>
        <returns>UTF8 인코딩 방식을 사용하는 새 <see langword="StreamReader" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 파일에서 텍스트를 읽습니다.  
  
 [!code-cpp[finfo opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[finfo opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenText/CS/file opentext.cs#1)]
 [!code-vb[finfo opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" />이 읽기 전용이거나 디렉터리인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenWrite ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenWrite() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenWrite" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenWrite () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenWrite();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>쓰기 전용 <see cref="T:System.IO.FileStream" />을 만듭니다.</summary>
        <returns>새 파일 또는 기존 파일의 공유되지 않는 쓰기 전용 <see cref="T:System.IO.FileStream" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.OpenWrite%2A> 메서드 하나 이미 파일 경로 대 한 존재 하거나 존재 하지 않는 경우 새 파일을 만듭니다는 파일을 엽니다. 기존 파일에 대 한 추가 하지 않습니다 새 텍스트를 기존 텍스트입니다. 대신, 새 문자를 사용한 기존 문자를 덮어씁니다. 파일에 문자열을 혼합 하 여 포함 됩니다을 덮어쓴 경우 긴 문자열 (예: "있는 그대로"이 OpenWrite 메서드의 테스트) (예: "두 번째 실행") 짧은 문자열 ("OpenWrite 메서드의 두 번째 runtest").  
  
   
  
## Examples  
 다음 예제에서는 파일을 쓰기용으로을 열고 파일에서 읽습니다.  
  
 [!code-cpp[finfo openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[finfo openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[finfo openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:System.IO.FileInfo" /> 개체의 인스턴스를 만들 때 지정된 경로는 읽기 전용이거나 디렉터리입니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see cref="T:System.IO.FileInfo" /> 개체의 인스턴스를 만들 때 지정한 경로가 유효하지 않은 경우(예: 매핑되지 않은 드라이브의 경로에 해당하는 경우)</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 파일 읽기 및 쓰기입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 파일의 내용을 현재 <see cref="T:System.IO.FileInfo" /> 개체에서 설명하는 파일로 대체합니다. 이때 원본 파일을 삭제하고 대체된 파일의 백업을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.IO.FileInfo.Replace%2A> 메서드 신속 하 게 파일을 현재 설명 하는 파일의 내용으로 교체 해야 할 때 <xref:System.IO.FileInfo> 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">현재 파일로 대체할 파일의 이름입니다.</param>
        <param name="destinationBackupFileName">
          <c>destFileName</c> 매개 변수에 설명된 파일의 백업을 만드는 데 사용할 파일 이름입니다.</param>
        <summary>지정된 파일의 내용을 현재 <see cref="T:System.IO.FileInfo" /> 개체에서 설명하는 파일로 대체합니다. 이때 원본 파일을 삭제하고 대체된 파일의 백업을 만듭니다.</summary>
        <returns>
          <see cref="T:System.IO.FileInfo" /> 매개 변수에 설명된 파일에 대한 정보를 캡슐화하는 <paramref name="destFileName" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Replace%2A> 메서드는 현재 설명 하는 파일의 내용이 지정된 된 파일의 내용을 바꿉니다 <xref:System.IO.FileInfo> 개체입니다.  또한 대체 된 파일의 백업을 만듭니다.  마지막으로 새 반환 <xref:System.IO.FileInfo> 덮어쓴된 파일을 설명 하는 개체입니다.  
  
> [!CAUTION]
>  이 메서드는 경우 Windows 2000 환경에서 성공 합니다는 `destFileName` 읽기 전용 이며 예외가 발생 하지 것입니다. 사용 하 여는 <xref:System.IO.FileInfo.IsReadOnly%2A> 경우 대상 파일은 읽기 전용 교체를 시도 하기 전에 확인할 속성입니다.  
  
 전달 `null` 에 `destBackupFileName` 교체 중인 파일의 백업을 만드는 하지 않을 경우 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.File.Replace%2A> 메서드 다른 파일과 파일을 대체 하 고 대체 된 파일의 백업을 만듭니다.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> 매개 변수에 의해 설명된 경로의 형식이 잘못되었습니다.  
  
 또는  
  
 <paramref name="destBackupFileName" /> 매개 변수에 의해 설명된 경로의 형식이 잘못되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">현재 <see cref="T:System.IO.FileInfo" /> 개체에 설명된 파일을 찾을 수 없습니다.  
  
 또는  
  
 <paramref name="destinationFileName" /> 매개 변수에 설명된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows NT 이상이 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />  
  
 보안 동작: 요청 합니다.  
  
 쓰는 데 필요한 권한에서 설명 파일에는 <paramref name="destBackupFileName" /> 매개 변수 하나를 지정 하는 경우.</permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">현재 파일로 대체할 파일의 이름입니다.</param>
        <param name="destinationBackupFileName">
          <c>destFileName</c> 매개 변수에 설명된 파일의 백업을 만드는 데 사용할 파일 이름입니다.</param>
        <param name="ignoreMetadataErrors">
          대체된 파일과 대체 파일 사이에 발생하는 병합 오류(예: 특성 및 ACL)를 무시하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 파일의 내용을 현재 <see cref="T:System.IO.FileInfo" /> 개체에서 설명하는 파일로 대체합니다. 이때 원본 파일을 삭제하고 대체된 파일의 백업을 만듭니다.  병합 오류를 무시할지 여부도 지정합니다.</summary>
        <returns>
          <see cref="T:System.IO.FileInfo" /> 매개 변수에 설명된 파일에 대한 정보를 캡슐화하는 <paramref name="destFileName" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Replace%2A> 메서드는 현재 설명 하는 파일의 내용이 지정된 된 파일의 내용을 바꿉니다 <xref:System.IO.FileInfo> 개체입니다.  또한 대체 된 파일의 백업을 만듭니다.  마지막으로 새 반환 <xref:System.IO.FileInfo> 덮어쓴된 파일을 설명 하는 개체입니다.  
  
> [!CAUTION]
>  이 메서드는 경우 Windows 2000 환경에서 성공 합니다는 `destFileName` 읽기 전용 이며 예외가 발생 하지 것입니다. 사용 하 여는 <xref:System.IO.FileInfo.IsReadOnly%2A> 경우 대상 파일은 읽기 전용 교체를 시도 하기 전에 확인할 속성입니다.  
  
 전달 `null` 에 `destBackupFileName` 교체 중인 파일의 백업을 만드는 하지 않을 경우 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.File.Replace%2A> 메서드 다른 파일과 파일을 대체 하 고 대체 된 파일의 백업을 만듭니다.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> 매개 변수에 의해 설명된 경로의 형식이 잘못되었습니다.  
  
 또는  
  
 <paramref name="destBackupFileName" /> 매개 변수에 의해 설명된 경로의 형식이 잘못되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">현재 <see cref="T:System.IO.FileInfo" /> 개체에 설명된 파일을 찾을 수 없습니다.  
  
 또는  
  
 <paramref name="destinationFileName" /> 매개 변수에 설명된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows NT 이상이 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />  
  
 보안 동작: 요청 합니다.  
  
 쓰는 데 필요한 권한에서 설명 파일에는 <paramref name="destBackupFileName" /> 매개 변수 하나를 지정 하는 경우.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">현재 파일에 적용할 ACL(액세스 제어 목록) 항목을 설명하는 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체입니다.</param>
        <summary>
          <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체에서 설명하는 ACL(액세스 제어 목록) 항목을 현재 <see cref="T:System.IO.FileInfo" /> 개체에서 설명하는 파일에 적용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드는 상속 되지 않은 ACL 목록을 표시 하는 현재 파일에 액세스 제어 목록 (ACL) 항목을 적용 됩니다.  
  
 사용 된 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드를 추가 하거나 파일에서 ACL 항목을 제거 해야 할 경우.  
  
> [!CAUTION]
>  에 대해 지정 된 ACL은 `fileSecurity` 매개 변수는 파일에 대 한 기존 ACL을 대체 합니다. 새 사용자에 대 한 권한을 추가 하려면 사용는 <xref:System.IO.Directory.GetAccessControl%2A> 메서드를 추가 하려면 수정 하 고 다음 사용 하 여 <xref:System.IO.FileInfo.SetAccessControl%2A> 파일에 다시 적용 합니다.  
  
 개인 및/또는 나 갖지 않고에 지정된 된 파일에서 특정 작업을 수행할 권한을 그룹이 ACL에 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드만 계속 되 면 <xref:System.Security.AccessControl.FileSecurity> 개체를 만든 후 수정 된 개체입니다.  경우는 <xref:System.Security.AccessControl.FileSecurity> 개체가 수정 되지 않은, 파일에 유지 되지 것입니다.  검색할 수 없으면 따라서는 <xref:System.Security.AccessControl.FileSecurity> 한 파일에서 개체를 다른 파일에 동일한 개체를 다시 적용 합니다.  
  
 다른 파일에서 ACL 정보를 복사 합니다.  
  
1.  사용 하 여는 <xref:System.IO.FileInfo.GetAccessControl%2A> 를 검색할 메서드는 <xref:System.Security.AccessControl.FileSecurity> 소스 파일에서 개체입니다.  
  
2.  새 <xref:System.Security.AccessControl.FileSecurity> 대상 파일에 대 한 개체입니다.  
  
3.  사용 하 여는 <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> 또는 <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> 원본의 메서드 <xref:System.Security.AccessControl.FileSecurity> ACL 정보를 검색 하는 개체입니다.  
  
4.  사용 하 여는 <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> 또는 <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> 대상에 3 단계에서 검색 메서드 정보를 복사 하려면 <xref:System.Security.AccessControl.FileSecurity> 개체입니다.  
  
5.  대상을 설정 <xref:System.Security.AccessControl.FileSecurity> 개체를 사용 하 여 대상 파일의 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.IO.FileInfo.GetAccessControl%2A> 메서드 및 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드를 추가 하 고 파일에서 ACL 항목을 제거 하십시오.  이 예제를 실행하려면 유효한 사용자 또는 그룹 계정을 제공해야 합니다.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileSecurity" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.SystemException">파일을 찾을 수 없거나 수정할 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 프로세스에 파일을 열 수 있는 액세스 권한이 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows 2000 이상이 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" />  
  
 보안 동작: 요청  
  
 파일에 액세스할 수 있는 권한입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>경로를 문자열로 반환합니다.</summary>
        <returns>경로를 나타내는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 되는 문자열은 <xref:System.IO.FileInfo.ToString%2A> 메서드는 생성자에 전달 된 경로 나타냅니다.  만들 때 한 <xref:System.IO.FileInfo> 개체의 생성자를 사용 하 여는 <xref:System.IO.FileInfo.ToString%2A> 메서드 정규화 된 경로 반환 합니다.  그러나 여러 가지 의해 반환 된 문자열은 <xref:System.IO.FileInfo.ToString%2A> 메서드는 정규화 된 경로 나타내지 않습니다.  만들 때 예를 들어는 <xref:System.IO.FileInfo> 를 사용 하 여 개체는 <xref:System.IO.DirectoryInfo.GetFiles%2A> 메서드는 <xref:System.IO.FileInfo.ToString%2A> 메서드는 정규화 된 경로 나타내지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>