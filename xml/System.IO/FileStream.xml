<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8370257646c33b469b93d94d16ed3800001654b9" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39732601" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="f20a1-101">파일에 대해 <see cref="T:System.IO.Stream" />을 제공하여 동기 및 비동기 읽기/쓰기 작업을 모두 지원합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f20a1-101">Provides a <see cref="T:System.IO.Stream" /> for a file, supporting both synchronous and asynchronous read and write operations.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-102">사용 된 <xref:System.IO.FileStream> 클래스의 읽기, 쓰기, 파일 시스템에는 파일, 열기 및 닫기에 파이프, 표준 입력 및 표준 출력을 포함 하 여 다른 파일 관련 운영 체제 핸들 조작 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-102">Use the <xref:System.IO.FileStream> class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output.</span></span> <span data-ttu-id="f20a1-103">사용할 수는 <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, 및 <xref:System.IO.FileStream.Flush%2A> 동기 작업을 수행 하는 방법 또는 <xref:System.IO.FileStream.ReadAsync%2A>를 <xref:System.IO.FileStream.WriteAsync%2A>를 <xref:System.IO.Stream.CopyToAsync%2A>, 및 <xref:System.IO.FileStream.FlushAsync%2A> 비동기 수행 하는 메서드 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-103">You can use the <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations.</span></span> <span data-ttu-id="f20a1-104">비동기 메서드를 사용 하 여 주 스레드를 차단 하지 않고 리소스 집중형 파일 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-104">Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread.</span></span> <span data-ttu-id="f20a1-105">이 성능 고려 사항은 특히 시간이 소비되는 스트림 작업이 UI 스레드를 차단하고 응용 프로그램이 작동하지 않는 것처럼 표시할 수 있는 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 응용 프로그램 또는 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 응용 프로그램에서 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-105">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="f20a1-106"><xref:System.IO.FileStream> 입력 버퍼와 성능 향상을 위해 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-106"><xref:System.IO.FileStream> buffers input and output for better performance.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f20a1-107">이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-107">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="f20a1-108">형식을 사용 하 여 마쳤으면 직접 또는 간접적으로의 삭제 해야 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-108">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="f20a1-109">직접 형식의 dispose 호출 해당 <xref:System.IDisposable.Dispose%2A> 의 메서드를 `try` / `catch` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-109">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="f20a1-110">삭제 하지 직접, 언어 구문 같은 사용 `using` (C#에서) 또는 `Using` (Visual Basic에서는).</span><span class="sxs-lookup"><span data-stu-id="f20a1-110">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="f20a1-111">자세한 내용은 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하세요.를 <xref:System.IDisposable> 인터페이스 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-111">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="f20a1-112"><xref:System.IO.FileStream.IsAsync%2A> 속성 파일 핸들을 비동기식으로 열렸을 여부를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-112">The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously.</span></span> <span data-ttu-id="f20a1-113">인스턴스를 만들 때이 값을 지정 하는 <xref:System.IO.FileStream> 클래스에 생성자를 사용 하는 `isAsync`를 `useAsync`, 또는 `options` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-113">You specify this value when you create an instance of the <xref:System.IO.FileStream> class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter.</span></span> <span data-ttu-id="f20a1-114">속성이 `true`를 스트림에 비동기적으로 파일 작업을 수행 하려면의 겹쳐진된 I/O를 활용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-114">When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously.</span></span> <span data-ttu-id="f20a1-115">그러나를 <xref:System.IO.FileStream.IsAsync%2A> 속성에 수 없습니다 `true` 를 호출 하는 <xref:System.IO.FileStream.ReadAsync%2A>를 <xref:System.IO.FileStream.WriteAsync%2A>, 또는 <xref:System.IO.Stream.CopyToAsync%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f20a1-115">However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method.</span></span> <span data-ttu-id="f20a1-116">경우는 <xref:System.IO.FileStream.IsAsync%2A> 속성은 `false` 및 비동기 읽기를 호출 하 고 쓰기 작업, 여전히 UI 스레드가 차단 되지 않지만 실제 I/O 작업이 동기적으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-116">When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</span></span>  
  
 <span data-ttu-id="f20a1-117"><xref:System.IO.FileStream.Seek%2A> 메서드는 임의 파일 액세스를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-117">The <xref:System.IO.FileStream.Seek%2A> method supports random access to files.</span></span> <span data-ttu-id="f20a1-118"><xref:System.IO.FileStream.Seek%2A> 읽기/쓰기 위치를를 파일 내에서 임의 위치로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-118"><xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file.</span></span> <span data-ttu-id="f20a1-119">바이트 오프셋된 참조 매개 변수를 사용 하 여 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-119">This is done with byte offset reference point parameters.</span></span> <span data-ttu-id="f20a1-120">세 멤버에 의해 표시 된 대로 시작, 현재 위치 또는 기본 파일의 끝 일 수 있는 검색 참조 지점에 상대적인 바이트 오프셋은는 <xref:System.IO.SeekOrigin> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-120">The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-121">디스크 파일은 항상 임의 액세스를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-121">Disk files always support random access.</span></span> <span data-ttu-id="f20a1-122">생성 시 합니다 <xref:System.IO.FileStream.CanSeek%2A> 속성 값으로 설정 됩니다 `true` 또는 `false` 내부 파일 형식에 따라 합니다. 기본 파일 형식이 면 FILE_TYPE_DISK, winbase.h에에 정의 된 대로 합니다 <xref:System.IO.FileStream.CanSeek%2A> 속성 값이 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-122">At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`.</span></span> <span data-ttu-id="f20a1-123">그렇지 않으면 합니다 <xref:System.IO.FileStream.CanSeek%2A> 속성 값이 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-123">Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.</span></span>  
  
 <span data-ttu-id="f20a1-124">프로세스를 잠근 파일의 일부를 사용 하 여 종료 되거나 처리 되지 않은 잠금에 있는 파일을 닫습니다, 경우 동작이 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-124">If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.</span></span>  
  
 <span data-ttu-id="f20a1-125">디렉터리 작업 및 다른 파일 작업에 대 한 참조를 <xref:System.IO.File>, <xref:System.IO.Directory>, 및 <xref:System.IO.Path> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-125">For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes.</span></span> <span data-ttu-id="f20a1-126">합니다 <xref:System.IO.File> 클래스의 생성을 위해 정적 메서드를 사용 하는 유틸리티 클래스는 <xref:System.IO.FileStream> 파일 경로 기반으로 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-126">The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of <xref:System.IO.FileStream> objects based on file paths.</span></span> <span data-ttu-id="f20a1-127"><xref:System.IO.MemoryStream> 클래스는 바이트 배열에서 스트림을 만듭니다와 유사 합니다 <xref:System.IO.FileStream> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-127">The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the <xref:System.IO.FileStream> class.</span></span>  
  
 <span data-ttu-id="f20a1-128">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-128">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## <a name="detection-of-stream-position-changes"></a><span data-ttu-id="f20a1-129">Stream 위치 변경 내용 검색</span><span class="sxs-lookup"><span data-stu-id="f20a1-129">Detection of Stream Position Changes</span></span>  
 <span data-ttu-id="f20a1-130">경우는 <xref:System.IO.FileStream> 개체 핸들에는 배타적 보류 없는, 다른 스레드가 파일 핸들을 동시에 액세스 및 파일 핸들을 사용 하 여 연결 된 운영 체제의 파일 포인터의 위치를 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-130">When a <xref:System.IO.FileStream> object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle.</span></span> <span data-ttu-id="f20a1-131">이 경우 캐시 위치는 <xref:System.IO.FileStream> 개체 및 버퍼에 캐시 된 데이터가 손상 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-131">In this case, the cached position in the <xref:System.IO.FileStream> object and the cached data in the buffer could be compromised.</span></span> <span data-ttu-id="f20a1-132">합니다 <xref:System.IO.FileStream> 되도록 운영 체제의 핸들 위치에서 사용 하는 캐시 된 위치와 동일한 캐시 된 버퍼에 액세스 하는 방법에 대 한 검사를 정기적으로 수행 하는 개체는 <xref:System.IO.FileStream> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-132">The <xref:System.IO.FileStream> object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="f20a1-133">핸들 위치 예기치 않게 변경에 대 한 호출에서 검색 된 경우는 <xref:System.IO.FileStream.Read%2A> 메서드를.NET Framework는 버퍼의 내용을 삭제 및 다시 파일에서 스트림을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-133">If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again.</span></span> <span data-ttu-id="f20a1-134">이 크기는 파일 및 파일 스트림 위치에 영향을 줄 수 있는 다른 프로세스에 따라 성능에 영향을 줄 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-134">This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.</span></span>  
  
 <span data-ttu-id="f20a1-135">에 대 한 호출에서 핸들 위치를 예기치 않은 변경이 감지 될 경우는 <xref:System.IO.FileStream.Write%2A> 메서드는 버퍼의 내용이 삭제 됩니다와 <xref:System.IO.IOException> 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-135">If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.</span></span>  
  
 <span data-ttu-id="f20a1-136"><xref:System.IO.FileStream> 개체는 없습니다 단독으로 보유 해당 핸들을 경우 중 하나는 <xref:System.IO.FileStream.SafeFileHandle%2A> 핸들을 노출 하려면 속성에 액세스 또는 <xref:System.IO.FileStream> 개체에 지정 됩니다는 <xref:System.IO.FileStream.SafeFileHandle%2A> 생성자에서 속성.</span><span class="sxs-lookup"><span data-stu-id="f20a1-136">A <xref:System.IO.FileStream> object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the <xref:System.IO.FileStream> object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-137">다음 예제에서는 몇 가지를 보여 줍니다는 <xref:System.IO.FileStream> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-137">The following example demonstrates some of the <xref:System.IO.FileStream> constructors.</span></span>  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 <span data-ttu-id="f20a1-138">다음 예제에서는 파일에 비동기적으로 작성 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-138">The following example shows how to write to a file asynchronously.</span></span> <span data-ttu-id="f20a1-139">이 코드는 /userinput&gt 및 Button_Click 이라고 하는 Click 이벤트 처리기를 연결 하는 단추 라는 TextBlock에는 WPF 앱에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-139">This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click.</span></span> <span data-ttu-id="f20a1-140">파일 경로 컴퓨터의 종료 보다 파일로 변경 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-140">The file path needs to be changed to a file than exits on the computer.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-141">
            <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-141">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="f20a1-142">현재 <see langword="FileStream" /> 개체가 캡슐화할 파일에 대한 파일 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-142">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-143">
            <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성을 설정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-143">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-144">지정된 읽기/쓰기 권한을 사용하여 지정된 파일 핸들에 대한 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-144">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-145">때 <xref:System.IO.Stream.Close%2A> 가 호출 된 핸들을 닫을 수도 및 파일의 핸들 수가 감소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-145">When <xref:System.IO.Stream.Close%2A> is called, the handle is also closed and the file's handle count is decremented.</span></span>  
  
 <span data-ttu-id="f20a1-146">`FileStream` 핸들에 대 한 독점적인 제어권을 가진다 고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-146">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="f20a1-147">읽기, 쓰기 또는 검색 하는 동안 작업을 `FileStream` 유지 되는 핸들을 데이터가 손상 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-147">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="f20a1-148">데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A> 핸들을 사용 하 여 전과 이외의 메서드를 호출 하지 마십시오. `Close` 수행한 후 핸들을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-148">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-149">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-149">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-150">`FileShare.Read` 해당 기본값인 <xref:System.IO.FileStream> 없이 생성자를 `FileShare` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-150">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
 <span data-ttu-id="f20a1-151">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-151">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-152">
            <paramref name="access" />가 <see cref="T:System.IO.FileAccess" />의 필드가 아닌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-152">
              <paramref name="access" /> is not a field of <see cref="T:System.IO.FileAccess" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-153">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-153">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-154">I/O 오류(예: 디스크 오류)가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-154">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-155">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-155">-or-</span>
          </span>
          <span data-ttu-id="f20a1-156">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-156">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-157">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 핸들이 읽기 전용 액세스로 설정된 경우처럼, 지정된 파일 핸들에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-157">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-158">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-158">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-159">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-159">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="f20a1-160">현재 <see langword="FileStream" /> 개체가 캡슐화할 파일에 대한 파일 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-160">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-161">
            <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성을 설정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-161">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-162">지정된 읽기/쓰기 권한을 사용하여 지정된 파일 핸들에 대한 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-162">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-163">때 <xref:System.IO.Stream.Close%2A> 가 호출 된 핸들을 닫을 수도 및 파일의 핸들 수가 감소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-163">When <xref:System.IO.Stream.Close%2A> is called, the handle is also closed and the file's handle count is decremented.</span></span>  
  
 <span data-ttu-id="f20a1-164">`FileStream` 핸들에 대 한 독점적인 제어권을 가진다 고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-164">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="f20a1-165">읽기, 쓰기 또는 검색 하는 동안 작업을 `FileStream` 유지 되는 핸들을 데이터가 손상 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-165">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="f20a1-166">데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A> 핸들을 사용 하 여 전과 이외의 메서드를 호출 하지 마십시오. `Close` 수행한 후 핸들을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-166">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-167">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-167">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-168">`FileShare.Read` 해당 기본값인 <xref:System.IO.FileStream> 없이 생성자를 `FileShare` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-168">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
 <span data-ttu-id="f20a1-169">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-169">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-170">
            <paramref name="access" />가 <see cref="T:System.IO.FileAccess" />의 필드가 아닌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-170">
              <paramref name="access" /> is not a field of <see cref="T:System.IO.FileAccess" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-171">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-171">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-172">I/O 오류(예: 디스크 오류)가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-172">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-173">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-173">-or-</span>
          </span>
          <span data-ttu-id="f20a1-174">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-174">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-175">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 핸들이 읽기 전용 액세스로 설정된 경우처럼, 지정된 파일 핸들에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-175">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-176">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-176">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-177">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-177">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f20a1-178">현재 <see langword="FileStream" /> 개체가 캡슐화할 파일의 상대 또는 절대 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-178">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="f20a1-179">파일을 열거나 만드는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-179">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-180">지정된 경로 및 생성 모드들 사용하여 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-180">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path and creation mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-181">.NET Framework와 같은 장치 이름에는 경로 통해 실제 디스크에 직접 액세스를 지원 하지 않습니다 "\\\\. \PHYSICALDRIVE0"입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-181">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="f20a1-182">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-182">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="f20a1-183">생성자는 파일에 읽기/쓰기 액세스를 부여 하 고 읽기 권한을 공유 것이 열려 (또는 다른 프로세스에 의해 작성 될 때까지 실패에 대 한 파일을 열려는 요청,는 `FileStream` 개체가 닫혔는지를 하지만 읽기 시도 성공).</span><span class="sxs-lookup"><span data-stu-id="f20a1-183">The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).</span></span>  
  
 <span data-ttu-id="f20a1-184">읽기 전용 파일을 열려면이 생성자를 사용할 수 없습니다. 허용 하는 생성자를 사용 해야 하는 대신 한 `FileAccess` 에 설정 된 값을 사용 하 여 매개 변수 `FileAccess.Read`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-184">You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.</span></span>  
  
 <span data-ttu-id="f20a1-185">버퍼 크기는 4096 바이트 (4KB)의 기본 크기로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-185">The buffer size is set to the default size of 4096 bytes (4 KB).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-186">`path` 디스크에 저장 된 파일이 필요 하지 않습니다. 스트림을 통해 액세스를 지 원하는 시스템의 일부가 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-186">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="f20a1-187">예를 들어 시스템에 따라이 클래스는 물리적 장치를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-187">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="f20a1-188"><xref:System.IO.Stream.CanSeek%2A> 됩니다 `true` 모든 <xref:System.IO.FileStream> 파일 캡슐화 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-188"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="f20a1-189">경우 `path` 검색을 지원 하지 않는 장치를 나타냄 합니다 <xref:System.IO.FileStream.CanSeek%2A> 결과 속성 <xref:System.IO.FileStream> 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-189">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="f20a1-190">자세한 내용은 <xref:System.IO.Stream.CanSeek%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-190">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-191">`FileShare.Read` 해당 기본값인 <xref:System.IO.FileStream> 없이 생성자를 `FileShare` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-191">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
 <span data-ttu-id="f20a1-192">없는 생성자는 <xref:System.IO.FileAccess> 매개 변수를 경우 합니다 `mode` 매개 변수는 설정 <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> 기본 액세스는 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-192">For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> is the default access.</span></span> <span data-ttu-id="f20a1-193">액세스로이 고, 그렇지 <xref:System.IO.FileAccess.ReadWrite>합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-193">Otherwise, the access is set to <xref:System.IO.FileAccess.ReadWrite>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-194">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-194">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-195">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-195">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-196">다음 코드 예제에서는 바이트 단위로 파일에 데이터를 쓰고 다음 데이터 쓰여졌는지 확인 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-196">The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-197">
            <paramref name="path" />가 빈 문자열("")이거나 공백만 포함하거나 하나 이상의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-197">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="f20a1-198">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-198">-or-</span>
          </span>
          <span data-ttu-id="f20a1-199">
            <paramref name="path" />가 NTFS 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-199">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-200">
            <paramref name="path" />가 NTFS 이외의 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-200">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-201">
            <paramref name="path" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-201">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-202">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-202">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f20a1-203">예를 들어, <paramref name="mode" />가 <see langword="FileMode.Truncate" /> 또는 <see langword="FileMode.Open" />인 경우 파일을 찾을 수 없으며 <paramref name="path" />로 지정된 파일이 없는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-203">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="f20a1-204">이러한 모드에는 이 파일이 이미 있어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-204">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-205">
            <paramref name="path" />로 지정한 파일이 이미 있는 경우에 <see langword="FileMode.CreateNew" />를 지정하는 등의 I/O 오류가 발생한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-205">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-206">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-206">-or-</span>
          </span>
          <span data-ttu-id="f20a1-207">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-207">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="f20a1-208">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-208">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="f20a1-209">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-209">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-210">
            <paramref name="mode" />에 잘못된 값이 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-210">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-211">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-211">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-212">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-212">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="f20a1-213">현재 <see langword="FileStream" /> 개체가 캡슐화할 파일에 대한 파일 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-213">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-214">
            <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성을 설정하는 <see cref="T:System.IO.FileAccess" /> 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-214">A <see cref="T:System.IO.FileAccess" /> constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="f20a1-215">버퍼 크기를 나타내는 0보다 큰 양의 <see cref="T:System.Int32" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-215">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="f20a1-216">기본 버퍼 크기는 4,096입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-216">The default buffer size is 4096.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-217">지정된 읽기/쓰기 권한 및 버퍼 크기를 사용하여 지정된 파일 핸들에 대해 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-217">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, and buffer size.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-218">`FileStream` 핸들에 대 한 독점적인 제어권을 가진다 고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-218">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="f20a1-219">읽기, 쓰기 또는 검색 하는 동안 작업을 `FileStream` 유지 되는 핸들을 데이터가 손상 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-219">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="f20a1-220">데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A> 핸들을 사용 하 여 전과 이외의 메서드를 호출 하지 마십시오. `Close` 수행한 후 핸들을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-220">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="f20a1-221">또는 읽고 핸들에이 호출 하기 전에 `FileStream` 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-221">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="f20a1-222">`FileShare.Read` 해당 기본값인 <xref:System.IO.FileStream> 없이 생성자를 `FileShare` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-222">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-223">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-223">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-224">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-224">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-225">
            <paramref name="handle" /> 매개 변수가 잘못된 핸들인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-225">The <paramref name="handle" /> parameter is an invalid handle.</span>
          </span>
          <span data-ttu-id="f20a1-226">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-226">-or-</span>
          </span>
          <span data-ttu-id="f20a1-227">
            <paramref name="handle" /> 매개 변수가 동기식 핸들인데 비동기식으로 사용된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-227">The <paramref name="handle" /> parameter is a synchronous handle and it was used asynchronously.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-228">
            <paramref name="bufferSize" /> 매개 변수가 음수인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-228">The <paramref name="bufferSize" /> parameter is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-229">I/O 오류(예: 디스크 오류)가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-229">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-230">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-230">-or-</span>
          </span>
          <span data-ttu-id="f20a1-231">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-231">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-232">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-232">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-233">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 핸들이 읽기 전용 액세스로 설정된 경우처럼, 지정된 파일 핸들에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-233">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-234">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-234">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-235">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-235">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f20a1-236">관리 되지 않는 코드를 호출할 수 있는 권한입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-236">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="f20a1-237">연관 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-237">Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="f20a1-238">현재 <see langword="FileStream" /> 개체가 캡슐화할 파일에 대한 파일 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-238">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-239">
            <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성을 설정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-239">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <param name="ownsHandle">
          <span data-ttu-id="f20a1-240">이 <see langword="FileStream" />인스턴스가 파일 핸들을 소유하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-240">
              <see langword="true" /> if the file handle will be owned by this <see langword="FileStream" /> instance; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-241">지정된 읽기/쓰기 권한 및 <see langword="FileStream" /> 인스턴스 소유권을 사용하여 지정된 파일 핸들에 대해 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-241">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission and <see langword="FileStream" /> instance ownership.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-242">`FileStream` 개체 파일에 지정된 된 액세스에 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-242">The `FileStream` object is given the specified access to the file.</span></span> <span data-ttu-id="f20a1-243">소유권 핸들의 수로 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-243">The ownership of the handle will be as specified.</span></span> <span data-ttu-id="f20a1-244">이 프로세스 핸들에 대 한 호출을 소유 하는 경우는 <xref:System.IO.Stream.Close%2A> 메서드 핸들을 닫습니다도 및 파일의 핸들 수가 감소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-244">If this process owns the handle, a call to the <xref:System.IO.Stream.Close%2A> method will also close the handle and the file's handle count is decremented.</span></span> <span data-ttu-id="f20a1-245">`FileStream` 개체 기본 버퍼 크기인 4096 바이트에 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-245">The `FileStream` object is given the default buffer size of 4096 bytes.</span></span>  
  
 <span data-ttu-id="f20a1-246">`FileStream` 핸들에 대 한 독점적인 제어권을 가진다 고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-246">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="f20a1-247">읽기, 쓰기 또는 검색 하는 동안 작업을 `FileStream` 유지 되는 핸들을 데이터가 손상 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-247">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="f20a1-248">데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A> 핸들을 사용 하 여 전과 이외의 메서드를 호출 하지 마십시오. `Close` 수행한 후 핸들을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-248">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling methods other than `Close` after you are done using the handle.</span></span>  
  
 <span data-ttu-id="f20a1-249">`FileShare.Read` 해당 기본값인 <xref:System.IO.FileStream> 없이 생성자를 `FileShare` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-249">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-250">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-250">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-251">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-251">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-252">
            <paramref name="access" />가 <see cref="T:System.IO.FileAccess" />의 필드가 아닌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-252">
              <paramref name="access" /> is not a field of <see cref="T:System.IO.FileAccess" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-253">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-253">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-254">I/O 오류(예: 디스크 오류)가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-254">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-255">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-255">-or-</span>
          </span>
          <span data-ttu-id="f20a1-256">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-256">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-257">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 핸들이 읽기 전용 액세스로 설정된 경우처럼, 지정된 파일 핸들에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-257">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-258">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-258">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-259">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-259">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f20a1-260">현재 <see langword="FileStream" /> 개체가 캡슐화할 파일의 상대 또는 절대 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-260">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="f20a1-261">파일을 열거나 만드는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-261">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-262">
            <see langword="FileStream" /> 개체에서 파일에 액세스할 수 있는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-262">A constant that determines how the file can be accessed by the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="f20a1-263">또한 <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성에서 반환하는 값을 결정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-263">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="f20a1-264">
            <c>path</c>가 디스크 파일을 지정하면 <see cref="P:System.IO.FileStream.CanSeek" />는 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-264">
              <see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <c>path</c> specifies a disk file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-265">지정된 경로, 생성 모드 및 읽기/쓰기 권한을 사용하여 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-265">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, and read/write permission.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-266">.NET Framework와 같은 장치 이름에는 경로 통해 실제 디스크에 직접 액세스를 지원 하지 않습니다 "\\\\. \PHYSICALDRIVE0"입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-266">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="f20a1-267">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-267">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="f20a1-268">생성자는 파일에 읽기/쓰기 액세스를 부여 하 고 읽기 권한을 공유 것이 열려 (또는 다른 프로세스에 의해 작성 될 때까지 실패에 대 한 파일을 열려는 요청,는 `FileStream` 개체가 닫혔는지를 하지만 읽기 시도 성공).</span><span class="sxs-lookup"><span data-stu-id="f20a1-268">The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).</span></span> <span data-ttu-id="f20a1-269">버퍼 크기는 4096 바이트 (4KB)의 기본 크기로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-269">The buffer size is set to the default size of 4096 bytes (4 KB).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-270">`path` 디스크에 저장 된 파일이 필요 하지 않습니다. 스트림을 통해 액세스를 지 원하는 시스템의 일부가 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-270">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="f20a1-271">예를 들어 시스템에 따라이 클래스는 물리적 장치를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-271">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="f20a1-272"><xref:System.IO.Stream.CanSeek%2A> 됩니다 `true` 모든 <xref:System.IO.FileStream> 파일 캡슐화 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-272"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="f20a1-273">경우 `path` 검색을 지원 하지 않는 장치를 나타냄 합니다 <xref:System.IO.FileStream.CanSeek%2A> 결과 속성 <xref:System.IO.FileStream> 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-273">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="f20a1-274">자세한 내용은 <xref:System.IO.Stream.CanSeek%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-274">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-275">`FileShare.Read` 해당 기본값인 <xref:System.IO.FileStream> 없이 생성자를 `FileShare` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-275">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-276">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-276">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-277">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-277">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-278">
            <paramref name="path" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-278">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-279">
            <paramref name="path" />가 빈 문자열("")이거나 공백만 포함하거나 하나 이상의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-279">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="f20a1-280">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-280">-or-</span>
          </span>
          <span data-ttu-id="f20a1-281">
            <paramref name="path" />가 NTFS 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-281">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-282">
            <paramref name="path" />가 NTFS 이외의 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-282">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f20a1-283">예를 들어, <paramref name="mode" />가 <see langword="FileMode.Truncate" /> 또는 <see langword="FileMode.Open" />인 경우 파일을 찾을 수 없으며 <paramref name="path" />로 지정된 파일이 없는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-283">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="f20a1-284">이러한 모드에는 이 파일이 이미 있어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-284">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-285">
            <paramref name="path" />로 지정한 파일이 이미 있는 경우에 <see langword="FileMode.CreateNew" />를 지정하는 등의 I/O 오류가 발생한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-285">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-286">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-286">-or-</span>
          </span>
          <span data-ttu-id="f20a1-287">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-287">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-288">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-288">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="f20a1-289">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-289">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-290">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 또는 디렉터리가 읽기 전용 액세스로 설정된 경우처럼, 지정된 <paramref name="path" />에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-290">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="f20a1-291">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-291">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-292">
            <paramref name="mode" />에 잘못된 값이 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-292">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-293">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-293">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-294">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-294">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="f20a1-295">이 <see langword="FileStream" /> 개체가 캡슐화할 파일에 대한 파일 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-295">A file handle for the file that this <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-296">
            <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성을 설정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-296">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="f20a1-297">버퍼 크기를 나타내는 0보다 큰 양의 <see cref="T:System.Int32" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-297">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="f20a1-298">기본 버퍼 크기는 4,096입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-298">The default buffer size is 4096.</span>
          </span>
        </param>
        <param name="isAsync">
          <span data-ttu-id="f20a1-299">겹쳐진 I/O 모드에서 핸들이 비동기적으로 열렸으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-299">
              <see langword="true" /> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-300">지정된 읽기/쓰기 권한, 버퍼 크기 및 동기/비동기 상태를 사용하여 지정된 파일 핸들에 대해 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-300">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, buffer size, and synchronous or asynchronous state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-301">설정한 합니다 `isAsync` 매개 변수를 `true` 를 비동기적으로 파일 핸들을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-301">You set the `isAsync` parameter to `true` to open the file handle asynchronously.</span></span> <span data-ttu-id="f20a1-302">매개 변수는 경우 `true`를 스트림에 비동기적으로 파일 작업을 수행 하려면의 겹쳐진된 I/O를 활용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-302">When the parameter is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously.</span></span> <span data-ttu-id="f20a1-303">그러나 매개 변수 없는 되도록 `true` 를 호출 하는 <xref:System.IO.FileStream.ReadAsync%2A>를 <xref:System.IO.FileStream.WriteAsync%2A>, 또는 <xref:System.IO.Stream.CopyToAsync%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f20a1-303">However, the parameter does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method.</span></span> <span data-ttu-id="f20a1-304">경우는 `isAsync` 매개 변수는 `false` 및 비동기 읽기를 호출 하 고 쓰기 작업, 여전히 UI 스레드가 차단 되지 않지만 실제 I/O 작업이 동기적으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-304">When the `isAsync` parameter is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</span></span>  
  
 <span data-ttu-id="f20a1-305">`FileStream` 핸들에 대 한 독점적인 제어권을 가진다 고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-305">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="f20a1-306">읽기, 쓰기 또는 검색 하는 동안 작업을 `FileStream` 유지 되는 핸들을 데이터가 손상 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-306">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="f20a1-307">데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A> 핸들을 사용 하 여 전과 이외의 메서드를 호출 하지 마십시오. `Close` 수행한 후 핸들을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-307">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="f20a1-308">또는 읽고 핸들에이 호출 하기 전에 `FileStream` 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-308">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="f20a1-309">`FileShare.Read` 해당 기본값인 <xref:System.IO.FileStream> 없이 생성자를 `FileShare` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-309">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-310">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-310">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-311">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-311">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-312">
            <paramref name="handle" /> 매개 변수가 잘못된 핸들인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-312">The <paramref name="handle" /> parameter is an invalid handle.</span>
          </span>
          <span data-ttu-id="f20a1-313">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-313">-or-</span>
          </span>
          <span data-ttu-id="f20a1-314">
            <paramref name="handle" /> 매개 변수가 동기식 핸들인데 비동기식으로 사용된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-314">The <paramref name="handle" /> parameter is a synchronous handle and it was used asynchronously.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-315">
            <paramref name="bufferSize" /> 매개 변수가 음수인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-315">The <paramref name="bufferSize" /> parameter is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-316">I/O 오류(예: 디스크 오류)가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-316">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-317">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-317">-or-</span>
          </span>
          <span data-ttu-id="f20a1-318">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-318">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-319">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-319">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-320">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 핸들이 읽기 전용 액세스로 설정된 경우처럼, 지정된 파일 핸들에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-320">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-321">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-321">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-322">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-322">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f20a1-323">관리 되지 않는 코드를 호출할 수 있는 권한입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-323">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="f20a1-324">연관 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-324">Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="f20a1-325">이 <see langword="FileStream" /> 개체가 캡슐화할 파일에 대한 파일 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-325">A file handle for the file that this <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-326">
            <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성을 설정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-326">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <param name="ownsHandle">
          <span data-ttu-id="f20a1-327">이 <see langword="FileStream" />인스턴스가 파일 핸들을 소유하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-327">
              <see langword="true" /> if the file handle will be owned by this <see langword="FileStream" /> instance; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="f20a1-328">버퍼 크기를 나타내는 0보다 큰 양의 <see cref="T:System.Int32" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-328">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="f20a1-329">기본 버퍼 크기는 4,096입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-329">The default buffer size is 4096.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-330">지정된 읽기/쓰기 권한, <see langword="FileStream" /> 인스턴스 소유권 및 버퍼 크기를 사용하여 지정된 파일 핸들에 대해 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-330">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, <see langword="FileStream" /> instance ownership, and buffer size.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-331">`FileStream` 개체 파일에 지정된 된 액세스에 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-331">The `FileStream` object is given the specified access to the file.</span></span> <span data-ttu-id="f20a1-332">소유권 핸들의 수로 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-332">The ownership of the handle will be as specified.</span></span> <span data-ttu-id="f20a1-333">이 `FileStream` 소유 된 핸들에 대 한 호출을 <xref:System.IO.Stream.Close%2A> 메서드 핸들을 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-333">If this `FileStream` owns the handle, a call to the <xref:System.IO.Stream.Close%2A> method will also close the handle.</span></span> <span data-ttu-id="f20a1-334">특히, 파일의 핸들 수는 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-334">In particular, the file's handle count is decremented.</span></span> <span data-ttu-id="f20a1-335">`FileStream` 개체에는 지정 된 버퍼 크기를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-335">The `FileStream` object is given the specified buffer size.</span></span>  
  
 <span data-ttu-id="f20a1-336">`FileStream` 핸들에 대 한 독점적인 제어권을 가진다 고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-336">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="f20a1-337">읽기, 쓰기 또는 검색 하는 동안 작업을 `FileStream` 유지 되는 핸들을 데이터가 손상 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-337">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="f20a1-338">데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A> 핸들을 사용 하 여 전과 이외의 메서드를 호출 하지 마십시오. `Close` 수행한 후 핸들을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-338">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="f20a1-339">또는 읽고 핸들에이 호출 하기 전에 `FileStream` 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-339">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="f20a1-340">`FileShare.Read` 해당 기본값인 <xref:System.IO.FileStream> 없이 생성자를 `FileShare` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-340">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-341">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-341">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-342">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-342">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-343">
            <paramref name="bufferSize" />가 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-343">
              <paramref name="bufferSize" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-344">I/O 오류(예: 디스크 오류)가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-344">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-345">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-345">-or-</span>
          </span>
          <span data-ttu-id="f20a1-346">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-346">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-347">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-347">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-348">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 핸들이 읽기 전용 액세스로 설정된 경우처럼, 지정된 파일 핸들에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-348">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-349">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-349">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-350">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-350">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f20a1-351">현재 <see langword="FileStream" /> 개체가 캡슐화할 파일의 상대 또는 절대 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-351">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="f20a1-352">파일을 열거나 만드는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-352">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-353">
            <see langword="FileStream" /> 개체에서 파일에 액세스할 수 있는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-353">A constant that determines how the file can be accessed by the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="f20a1-354">또한 <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성에서 반환하는 값을 결정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-354">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="f20a1-355">
            <c>path</c>가 디스크 파일을 지정하면 <see cref="P:System.IO.FileStream.CanSeek" />는 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-355">
              <see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <c>path</c> specifies a disk file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="f20a1-356">프로세스에서 파일을 공유하는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-356">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-357">지정된 경로, 생성 모드, 읽기/쓰기 권한 및 공유 권한을 사용하여 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-357">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write permission, and sharing permission.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-358">.NET Framework와 같은 장치 이름에는 경로 통해 실제 디스크에 직접 액세스를 지원 하지 않습니다 "\\\\. \PHYSICALDRIVE0"입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-358">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="f20a1-359">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-359">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="f20a1-360">생성자는 파일에 읽기/쓰기 액세스를 부여 하 고 읽기 권한을 공유 것이 열려 (또는 다른 프로세스에 의해 작성 될 때까지 실패에 대 한 파일을 열려는 요청,는 `FileStream` 개체가 닫혔는지를 하지만 읽기 시도 성공).</span><span class="sxs-lookup"><span data-stu-id="f20a1-360">The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).</span></span> <span data-ttu-id="f20a1-361">버퍼 크기는 4096 바이트 (4KB)의 기본 크기로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-361">The buffer size is set to the default size of 4096 bytes (4 KB).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-362">`path` 디스크에 저장 된 파일이 필요 하지 않습니다. 스트림을 통해 액세스를 지 원하는 시스템의 일부가 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-362">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="f20a1-363">예를 들어 시스템에 따라이 클래스는 물리적 장치를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-363">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="f20a1-364"><xref:System.IO.Stream.CanSeek%2A> 됩니다 `true` 모든 <xref:System.IO.FileStream> 파일 캡슐화 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-364"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="f20a1-365">경우 `path` 검색을 지원 하지 않는 장치를 나타냄 합니다 <xref:System.IO.FileStream.CanSeek%2A> 결과 속성 <xref:System.IO.FileStream> 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-365">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="f20a1-366">자세한 내용은 <xref:System.IO.Stream.CanSeek%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-366">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-367">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-367">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-368">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-368">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-369">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.IO.FileStream.Lock%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f20a1-369">This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-370">
            <paramref name="path" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-370">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-371">
            <paramref name="path" />가 빈 문자열("")이거나 공백만 포함하거나 하나 이상의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-371">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="f20a1-372">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-372">-or-</span>
          </span>
          <span data-ttu-id="f20a1-373">
            <paramref name="path" />가 NTFS 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-373">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-374">
            <paramref name="path" />가 NTFS 이외의 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-374">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f20a1-375">예를 들어, <paramref name="mode" />가 <see langword="FileMode.Truncate" /> 또는 <see langword="FileMode.Open" />인 경우 파일을 찾을 수 없으며 <paramref name="path" />로 지정된 파일이 없는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-375">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="f20a1-376">이러한 모드에는 이 파일이 이미 있어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-376">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-377">
            <paramref name="path" />로 지정한 파일이 이미 있는 경우에 <see langword="FileMode.CreateNew" />를 지정하는 등의 I/O 오류가 발생한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-377">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-378">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-378">-or-</span>
          </span>
          <span data-ttu-id="f20a1-379">시스템에서 Windows 98 또는 Windows 98 Second Edition을 실행 중이고 <paramref name="share" />가 <see langword="FileShare.Delete" />로 설정된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-379">The system is running Windows 98 or Windows 98 Second Edition and <paramref name="share" /> is set to <see langword="FileShare.Delete" />.</span>
          </span>
          <span data-ttu-id="f20a1-380">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-380">-or-</span>
          </span>
          <span data-ttu-id="f20a1-381">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-381">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-382">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-382">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="f20a1-383">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-383">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-384">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 또는 디렉터리가 읽기 전용 액세스로 설정된 경우처럼, 지정된 <paramref name="path" />에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-384">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="f20a1-385">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-385">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-386">
            <paramref name="mode" />에 잘못된 값이 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-386">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-387">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-387">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-388">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-388">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="f20a1-389">이 <see langword="FileStream" /> 개체가 캡슐화할 파일에 대한 파일 핸들입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-389">A file handle for the file that this <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-390">
            <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성을 설정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-390">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <param name="ownsHandle">
          <span data-ttu-id="f20a1-391">이 <see langword="FileStream" />인스턴스가 파일 핸들을 소유하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-391">
              <see langword="true" /> if the file handle will be owned by this <see langword="FileStream" /> instance; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="f20a1-392">버퍼 크기를 나타내는 0보다 큰 양의 <see cref="T:System.Int32" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-392">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="f20a1-393">기본 버퍼 크기는 4,096입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-393">The default buffer size is 4096.</span>
          </span>
        </param>
        <param name="isAsync">
          <span data-ttu-id="f20a1-394">겹쳐진 I/O 모드에서 핸들이 비동기적으로 열렸으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-394">
              <see langword="true" /> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-395">지정된 읽기/쓰기 권한, <see langword="FileStream" /> 인스턴스 소유권, 버퍼 크기 및 동기/비동기 상태를 사용하여 지정된 파일 핸들에 대해 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-395">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, <see langword="FileStream" /> instance ownership, buffer size, and synchronous or asynchronous state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-396">`FileStream` 개체 파일에 지정된 된 액세스에 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-396">The `FileStream` object is given the specified access to the file.</span></span> <span data-ttu-id="f20a1-397">소유권 핸들의 수로 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-397">The ownership of the handle will be as specified.</span></span> <span data-ttu-id="f20a1-398">이 `FileStream` 소유 된 핸들에 대 한 호출을 <xref:System.IO.Stream.Close%2A> 메서드 핸들을 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-398">If this `FileStream` owns the handle, a call to the <xref:System.IO.Stream.Close%2A> method will also close the handle.</span></span> <span data-ttu-id="f20a1-399">특히, 파일의 핸들 수는 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-399">In particular, the file's handle count is decremented.</span></span> <span data-ttu-id="f20a1-400">`FileStream` 개체에는 지정 된 버퍼 크기를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-400">The `FileStream` object is given the specified buffer size.</span></span>  
  
 <span data-ttu-id="f20a1-401">`FileStream` 핸들에 대 한 독점적인 제어권을 가진다 고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-401">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="f20a1-402">읽기, 쓰기 또는 검색 하는 동안 작업을 `FileStream` 유지 되는 핸들을 데이터가 손상 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-402">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="f20a1-403">데이터 보안을 위해 호출 <xref:System.IO.FileStream.Flush%2A> 핸들을 사용 하 여 전과 이외의 메서드를 호출 하지 마십시오. `Close` 수행한 후 핸들을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-403">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="f20a1-404">또는 읽고 핸들에이 호출 하기 전에 `FileStream` 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-404">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="f20a1-405">`FileShare.Read` 해당 기본값인 <xref:System.IO.FileStream> 없이 생성자를 `FileShare` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-405">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-406">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-406">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-407">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-407">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-408">
            <paramref name="access" />가 <see langword="FileAccess.Read" />보다 작거나 <see langword="FileAccess.ReadWrite" />보다 큰 경우. 또는 <paramref name="bufferSize" />가 0보다 작거나 같은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-408">
              <paramref name="access" /> is less than <see langword="FileAccess.Read" /> or greater than <see langword="FileAccess.ReadWrite" /> or <paramref name="bufferSize" /> is less than or equal to 0.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-409">핸들이 잘못되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-409">The handle is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-410">I/O 오류(예: 디스크 오류)가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-410">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-411">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-411">-or-</span>
          </span>
          <span data-ttu-id="f20a1-412">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-412">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-413">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-413">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-414">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 핸들이 읽기 전용 액세스로 설정된 경우처럼, 지정된 파일 핸들에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-414">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f20a1-415">비관리 코드에 액세스 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-415">for access to unmanaged code.</span>
          </span>
          <span data-ttu-id="f20a1-416">연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-416">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f20a1-417">현재 <see langword="FileStream" /> 개체가 캡슐화할 파일의 상대 또는 절대 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-417">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="f20a1-418">파일을 열거나 만드는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-418">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-419">
            <see langword="FileStream" /> 개체에서 파일에 액세스할 수 있는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-419">A constant that determines how the file can be accessed by the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="f20a1-420">또한 <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성에서 반환하는 값을 결정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-420">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="f20a1-421">
            <c>path</c>가 디스크 파일을 지정하면 <see cref="P:System.IO.FileStream.CanSeek" />는 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-421">
              <see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <c>path</c> specifies a disk file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="f20a1-422">프로세스에서 파일을 공유하는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-422">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="f20a1-423">버퍼 크기를 나타내는 0보다 큰 양의 <see cref="T:System.Int32" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-423">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="f20a1-424">기본 버퍼 크기는 4,096입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-424">The default buffer size is 4096.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-425">지정된 경로, 생성 모드, 읽기/쓰기 및 공유 권한, 버퍼 크기를 사용하여 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-425">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, and buffer size.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-426">.NET Framework와 같은 장치 이름에는 경로 통해 실제 디스크에 직접 액세스를 지원 하지 않습니다 "\\\\. \PHYSICALDRIVE0"입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-426">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="f20a1-427">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-427">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-428">`path` 디스크에 저장 된 파일이 필요 하지 않습니다. 스트림을 통해 액세스를 지 원하는 시스템의 일부가 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-428">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="f20a1-429">예를 들어 시스템에 따라이 클래스는 물리적 장치를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-429">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="f20a1-430"><xref:System.IO.Stream.CanSeek%2A> 됩니다 `true` 모든 <xref:System.IO.FileStream> 파일 캡슐화 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-430"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="f20a1-431">경우 `path` 검색을 지원 하지 않는 장치를 나타냄 합니다 <xref:System.IO.FileStream.CanSeek%2A> 결과 속성 <xref:System.IO.FileStream> 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-431">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="f20a1-432">자세한 내용은 <xref:System.IO.Stream.CanSeek%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-432">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-433">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-433">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-434">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-434">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-435">
            <paramref name="path" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-435">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-436">
            <paramref name="path" />가 빈 문자열("")이거나 공백만 포함하거나 하나 이상의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-436">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="f20a1-437">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-437">-or-</span>
          </span>
          <span data-ttu-id="f20a1-438">
            <paramref name="path" />가 NTFS 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-438">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-439">
            <paramref name="path" />가 NTFS 이외의 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-439">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-440">
            <paramref name="bufferSize" />가 음수이거나 0인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-440">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="f20a1-441">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-441">-or-</span>
          </span>
          <span data-ttu-id="f20a1-442">
            <paramref name="mode" />, <paramref name="access" /> 또는 <paramref name="share" />에 잘못된 값이 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-442">
              <paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f20a1-443">예를 들어, <paramref name="mode" />가 <see langword="FileMode.Truncate" /> 또는 <see langword="FileMode.Open" />인 경우 파일을 찾을 수 없으며 <paramref name="path" />로 지정된 파일이 없는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-443">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="f20a1-444">이러한 모드에는 이 파일이 이미 있어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-444">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-445">
            <paramref name="path" />로 지정한 파일이 이미 있는 경우에 <see langword="FileMode.CreateNew" />를 지정하는 등의 I/O 오류가 발생한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-445">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-446">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-446">-or-</span>
          </span>
          <span data-ttu-id="f20a1-447">시스템에서 Windows 98 또는 Windows 98 Second Edition을 실행 중이고 <paramref name="share" />가 <see langword="FileShare.Delete" />로 설정된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-447">The system is running Windows 98 or Windows 98 Second Edition and <paramref name="share" /> is set to <see langword="FileShare.Delete" />.</span>
          </span>
          <span data-ttu-id="f20a1-448">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-448">-or-</span>
          </span>
          <span data-ttu-id="f20a1-449">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-449">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-450">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-450">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="f20a1-451">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-451">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-452">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 또는 디렉터리가 읽기 전용 액세스로 설정된 경우처럼, 지정된 <paramref name="path" />에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-452">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="f20a1-453">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-453">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-454">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-454">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-455">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-455">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f20a1-456">현재 <see langword="FileStream" /> 개체가 캡슐화할 파일의 상대 또는 절대 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-456">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="f20a1-457">파일을 열거나 만드는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-457">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-458">
            <see langword="FileStream" /> 개체에서 파일에 액세스할 수 있는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-458">A constant that determines how the file can be accessed by the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="f20a1-459">또한 <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성에서 반환하는 값을 결정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-459">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="f20a1-460">
            <c>path</c>가 디스크 파일을 지정하면 <see cref="P:System.IO.FileStream.CanSeek" />는 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-460">
              <see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <c>path</c> specifies a disk file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="f20a1-461">프로세스에서 파일을 공유하는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-461">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="f20a1-462">버퍼 크기를 나타내는 0보다 큰 양의 <see cref="T:System.Int32" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-462">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="f20a1-463">기본 버퍼 크기는 4,096입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-463">The default buffer size is 4096..</span>
          </span>
        </param>
        <param name="useAsync">
          <span data-ttu-id="f20a1-464">비동기 I/O 또는 동기 I/O를 사용할지를 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-464">Specifies whether to use asynchronous I/O or synchronous I/O.</span>
          </span>
          <span data-ttu-id="f20a1-465">그러나 내부 운영 체제에서 비동기 I/O가 지원되지 않을 수도 있으므로 <see langword="true" />를 지정해도 플랫폼에 따라 핸들이 동기적으로 열릴 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-465">However, note that the underlying operating system might not support asynchronous I/O, so when specifying <see langword="true" />, the handle might be opened synchronously depending on the platform.</span>
          </span>
          <span data-ttu-id="f20a1-466">비동기적으로 열린 경우 <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 및 <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 메서드는 대량의 데이터를 읽거나 쓸 때는 보다 효과적이지만 소량의 데이터를 읽거나 쓸 경우 작업 속도가 훨씬 느려질 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-466">When opened asynchronously, the <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> and <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> methods perform better on large reads or writes, but they might be much slower for small reads or writes.</span>
          </span>
          <span data-ttu-id="f20a1-467">응용 프로그램이 비동기 I/O를 사용하도록 디자인된 경우 <c>useAsync</c> 매개 변수를 <see langword="true" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-467">If the application is designed to take advantage of asynchronous I/O, set the <c>useAsync</c> parameter to <see langword="true" />.</span>
          </span>
          <span data-ttu-id="f20a1-468">비동기 I/O를 올바르게 사용하면 응용 프로그램의 속도가 10배 정도 향상될 수 있지만 응용 프로그램을 비동기 I/O에 맞도록 다시 디자인하지 않고 사용하면 성능이 10배 정도 감소될 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-468">Using asynchronous I/O correctly can speed up applications by as much as a factor of 10, but using it without redesigning the application for asynchronous I/O can decrease performance by as much as a factor of 10.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-469">지정된 경로, 생성 모드, 읽기/쓰기 및 공유 권한, 버퍼 크기 및 동기/비동기 상태를 사용하여 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-469">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, buffer size, and synchronous or asynchronous state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-470">.NET Framework와 같은 장치 이름에는 경로 통해 실제 디스크에 직접 액세스를 지원 하지 않습니다 "\\\\. \PHYSICALDRIVE0"입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-470">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="f20a1-471">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-471">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-472">`path` 디스크에 저장 된 파일이 필요 하지 않습니다. 스트림을 통해 액세스를 지 원하는 시스템의 일부가 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-472">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="f20a1-473">예를 들어 시스템에 따라이 클래스는 물리적 장치를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-473">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="f20a1-474"><xref:System.IO.Stream.CanSeek%2A> 됩니다 `true` 모든 <xref:System.IO.FileStream> 파일 캡슐화 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-474"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="f20a1-475">경우 `path` 검색을 지원 하지 않는 장치를 나타냄 합니다 <xref:System.IO.FileStream.CanSeek%2A> 결과 속성 <xref:System.IO.FileStream> 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-475">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="f20a1-476">자세한 내용은 <xref:System.IO.Stream.CanSeek%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-476">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-477">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-477">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-478">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-478">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-479">다음 코드 예제에서는 비동기적으로 파일에 쓸 데이터는 데이터가 제대로 기록 되었는지 확인 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-479">The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly.</span></span> <span data-ttu-id="f20a1-480">A `State` 는 주 스레드가에서 정보를 전달 하기 개체를 만드는 합니다 `EndReadCallback` 및 `EndWriteCallback` 메서드.</span><span class="sxs-lookup"><span data-stu-id="f20a1-480">A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-481">
            <paramref name="path" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-481">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-482">
            <paramref name="path" />가 빈 문자열("")이거나 공백만 포함하거나 하나 이상의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-482">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="f20a1-483">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-483">-or-</span>
          </span>
          <span data-ttu-id="f20a1-484">
            <paramref name="path" />가 NTFS 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-484">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-485">
            <paramref name="path" />가 NTFS 이외의 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-485">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-486">
            <paramref name="bufferSize" />가 음수이거나 0인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-486">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="f20a1-487">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-487">-or-</span>
          </span>
          <span data-ttu-id="f20a1-488">
            <paramref name="mode" />, <paramref name="access" /> 또는 <paramref name="share" />에 잘못된 값이 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-488">
              <paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f20a1-489">예를 들어, <paramref name="mode" />가 <see langword="FileMode.Truncate" /> 또는 <see langword="FileMode.Open" />인 경우 파일을 찾을 수 없으며 <paramref name="path" />로 지정된 파일이 없는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-489">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="f20a1-490">이러한 모드에는 이 파일이 이미 있어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-490">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-491">
            <paramref name="path" />로 지정한 파일이 이미 있는 경우에 <see langword="FileMode.CreateNew" />를 지정하는 등의 I/O 오류가 발생한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-491">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-492">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-492">-or-</span>
          </span>
          <span data-ttu-id="f20a1-493">시스템에서 Windows 98 또는 Windows 98 Second Edition을 실행 중이고 <paramref name="share" />가 <see langword="FileShare.Delete" />로 설정된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-493">The system is running Windows 98 or Windows 98 Second Edition and <paramref name="share" /> is set to <see langword="FileShare.Delete" />.</span>
          </span>
          <span data-ttu-id="f20a1-494">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-494">-or-</span>
          </span>
          <span data-ttu-id="f20a1-495">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-495">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-496">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-496">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="f20a1-497">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-497">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-498">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 또는 디렉터리가 읽기 전용 액세스로 설정된 경우처럼, 지정된 <paramref name="path" />에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-498">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="f20a1-499">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-499">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-500">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-500">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-501">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-501">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.IO.File" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f20a1-502">현재 <see langword="FileStream" /> 개체가 캡슐화할 파일의 상대 또는 절대 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-502">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="f20a1-503">파일을 열거나 만드는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-503">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f20a1-504">
            <see langword="FileStream" /> 개체에서 파일에 액세스할 수 있는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-504">A constant that determines how the file can be accessed by the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="f20a1-505">또한 <see langword="FileStream" /> 개체의 <see cref="P:System.IO.FileStream.CanRead" /> 및 <see cref="P:System.IO.FileStream.CanWrite" /> 속성에서 반환하는 값을 결정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-505">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="f20a1-506">
            <c>path</c>가 디스크 파일을 지정하면 <see cref="P:System.IO.FileStream.CanSeek" />는 <see langword="true" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-506">
              <see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <c>path</c> specifies a disk file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="f20a1-507">프로세스에서 파일을 공유하는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-507">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="f20a1-508">버퍼 크기를 나타내는 0보다 큰 양의 <see cref="T:System.Int32" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-508">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="f20a1-509">기본 버퍼 크기는 4,096입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-509">The default buffer size is 4096.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="f20a1-510">추가 파일 옵션을 지정하는 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-510">A value that specifies additional file options.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-511">지정된 경로, 생성 모드, 읽기/쓰기 및 공유 권한, 같은 파일에 대한 다른 FileStream의 액세스 권한, 버퍼 크기 및 추가 파일 옵션을 사용하여 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-511">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, the access other FileStreams can have to the same file, the buffer size, and additional file options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-512">.NET Framework와 같은 장치 이름에는 경로 통해 실제 디스크에 직접 액세스를 지원 하지 않습니다 "\\\\. \PHYSICALDRIVE0"입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-512">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="f20a1-513">합니다 `fileOptions` 매개 변수를 만들 때 활용할 수 있는 고급 작업에 대 한 액세스를 제공 하는 한 <xref:System.IO.FileStream> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-513">The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="f20a1-514">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-514">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-515">`path` 디스크에 저장 된 파일이 필요 하지 않습니다. 스트림을 통해 액세스를 지 원하는 시스템의 일부가 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-515">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="f20a1-516">예를 들어 시스템에 따라이 클래스는 물리적 장치를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-516">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="f20a1-517"><xref:System.IO.Stream.CanSeek%2A> 됩니다 `true` 모든 <xref:System.IO.FileStream> 파일 캡슐화 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-517"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="f20a1-518">경우 `path` 검색을 지원 하지 않는 장치를 나타냄 합니다 <xref:System.IO.FileStream.CanSeek%2A> 결과 속성 <xref:System.IO.FileStream> 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-518">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="f20a1-519">자세한 내용은 <xref:System.IO.Stream.CanSeek%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-519">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-520">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-520">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-521">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-521">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-522">다음 예제에서는 파일에 데이터를 쓰고 다음 사용 하 여 데이터를 읽습니다는 <xref:System.IO.FileStream> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-522">The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.</span></span>  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-523">
            <paramref name="path" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-523">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-524">
            <paramref name="path" />가 빈 문자열("")이거나 공백만 포함하거나 하나 이상의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-524">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="f20a1-525">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-525">-or-</span>
          </span>
          <span data-ttu-id="f20a1-526">
            <paramref name="path" />가 NTFS 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-526">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-527">
            <paramref name="path" />가 NTFS 이외의 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-527">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-528">
            <paramref name="bufferSize" />가 음수이거나 0인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-528">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="f20a1-529">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-529">-or-</span>
          </span>
          <span data-ttu-id="f20a1-530">
            <paramref name="mode" />, <paramref name="access" /> 또는 <paramref name="share" />에 잘못된 값이 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-530">
              <paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f20a1-531">예를 들어, <paramref name="mode" />가 <see langword="FileMode.Truncate" /> 또는 <see langword="FileMode.Open" />인 경우 파일을 찾을 수 없으며 <paramref name="path" />로 지정된 파일이 없는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-531">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="f20a1-532">이러한 모드에는 이 파일이 이미 있어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-532">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-533">
            <paramref name="path" />로 지정한 파일이 이미 있는 경우에 <see langword="FileMode.CreateNew" />를 지정하는 등의 I/O 오류가 발생한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-533">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-534">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-534">-or-</span>
          </span>
          <span data-ttu-id="f20a1-535">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-535">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-536">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-536">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="f20a1-537">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-537">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-538">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 또는 디렉터리가 읽기 전용 액세스로 설정된 경우처럼, 지정된 <paramref name="path" />에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-538">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
          <span data-ttu-id="f20a1-539">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-539">-or-</span>
          </span>
          <span data-ttu-id="f20a1-540">
            <paramref name="options" />에 <see cref="F:System.IO.FileOptions.Encrypted" />가 지정되었고 현재 플랫폼에서 파일 암호화가 지원되지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-540">
              <see cref="F:System.IO.FileOptions.Encrypted" /> is specified for <paramref name="options" />, but file encryption is not supported on the current platform.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="f20a1-541">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-541">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-542">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-542">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-543">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-543">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f20a1-544">현재 <see cref="T:System.IO.FileStream" /> 개체가 캡슐화할 파일의 상대 또는 절대 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-544">A relative or absolute path for the file that the current <see cref="T:System.IO.FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="f20a1-545">파일을 열거나 만드는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-545">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="f20a1-546">파일에 대한 액세스 및 감사 규칙을 만드는 데 사용할 액세스 권한을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-546">A constant that determines the access rights to use when creating access and audit rules for the file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="f20a1-547">프로세스에서 파일을 공유하는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-547">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="f20a1-548">버퍼 크기를 나타내는 0보다 큰 양의 <see cref="T:System.Int32" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-548">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="f20a1-549">기본 버퍼 크기는 4,096입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-549">The default buffer size is 4096.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="f20a1-550">추가 파일 옵션을 지정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-550">A constant that specifies additional file options.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-551">지정된 경로, 생성 모드, 액세스 및 공유 권한, 버퍼 크기 및 추가 파일 옵션을 사용하여 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-551">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, access rights and sharing permission, the buffer size, and additional file options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-552">.NET Framework와 같은 장치 이름에는 경로 통해 실제 디스크에 직접 액세스를 지원 하지 않습니다 "\\\\. \PHYSICALDRIVE0"입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-552">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="f20a1-553">이 사용 하 여 <xref:System.IO.FileStream.%23ctor%2A> 파일을 만드는 권한 액세스를 적용 하는 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-553">Use this <xref:System.IO.FileStream.%23ctor%2A> constructor to apply access rights at the point of creation of a file.</span></span> <span data-ttu-id="f20a1-554">를 액세스 하거나 기존 파일에 대 한 권한을 수정 하려면 사용을 고려 합니다 <xref:System.IO.File.GetAccessControl%2A> 고 <xref:System.IO.File.SetAccessControl%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f20a1-554">To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="f20a1-555">합니다 `fileOptions` 매개 변수를 만들 때 활용할 수 있는 고급 작업에 대 한 액세스를 제공 하는 한 <xref:System.IO.FileStream> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-555">The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="f20a1-556">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-556">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-557">`path` 디스크에 저장 된 파일이 필요 하지 않습니다. 스트림을 통해 액세스를 지 원하는 시스템의 일부가 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-557">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="f20a1-558">예를 들어 시스템에 따라이 클래스는 물리적 장치를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-558">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="f20a1-559"><xref:System.IO.Stream.CanSeek%2A> 됩니다 `true` 모든 <xref:System.IO.FileStream> 파일 캡슐화 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-559"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="f20a1-560">경우 `path` 검색을 지원 하지 않는 장치를 나타냄 합니다 <xref:System.IO.FileStream.CanSeek%2A> 결과 속성 <xref:System.IO.FileStream> 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-560">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="f20a1-561">자세한 내용은 <xref:System.IO.Stream.CanSeek%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-561">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-562">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-562">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-563">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-563">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-564">
            <paramref name="path" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-564">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-565">
            <paramref name="path" />가 빈 문자열("")이거나 공백만 포함하거나 하나 이상의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-565">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="f20a1-566">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-566">-or-</span>
          </span>
          <span data-ttu-id="f20a1-567">
            <paramref name="path" />가 NTFS 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-567">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-568">
            <paramref name="path" />가 NTFS 이외의 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-568">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-569">
            <paramref name="bufferSize" />가 음수이거나 0인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-569">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="f20a1-570">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-570">-or-</span>
          </span>
          <span data-ttu-id="f20a1-571">
            <paramref name="mode" />, <paramref name="access" /> 또는 <paramref name="share" />에 잘못된 값이 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-571">
              <paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f20a1-572">예를 들어, <paramref name="mode" />가 <see langword="FileMode.Truncate" /> 또는 <see langword="FileMode.Open" />인 경우 파일을 찾을 수 없으며 <paramref name="path" />로 지정된 파일이 없는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-572">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="f20a1-573">이러한 모드에는 이 파일이 이미 있어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-573">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="f20a1-574">현재 운영 체제가 Windows NT 이상이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-574">The current operating system is not Windows NT or later.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-575">
            <paramref name="path" />로 지정한 파일이 이미 있는 경우에 <see langword="FileMode.CreateNew" />를 지정하는 등의 I/O 오류가 발생한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-575">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-576">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-576">-or-</span>
          </span>
          <span data-ttu-id="f20a1-577">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-577">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-578">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-578">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="f20a1-579">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-579">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-580">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 또는 디렉터리가 읽기 전용 액세스로 설정된 경우처럼, 지정된 <paramref name="path" />에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-580">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
          <span data-ttu-id="f20a1-581">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-581">-or-</span>
          </span>
          <span data-ttu-id="f20a1-582">
            <paramref name="options" />에 <see cref="F:System.IO.FileOptions.Encrypted" />가 지정되었고 현재 플랫폼에서 파일 암호화가 지원되지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-582">
              <see cref="F:System.IO.FileOptions.Encrypted" /> is specified for <paramref name="options" />, but file encryption is not supported on the current platform.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="f20a1-583">지정된 <paramref name="path" />나 파일 이름 또는 둘 모두가 시스템에 정의된 최대 길이를 초과하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-583">The specified <paramref name="path" />, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-584">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-584">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-585">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-585">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f20a1-586">현재 <see cref="T:System.IO.FileStream" /> 개체가 캡슐화할 파일의 상대 또는 절대 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-586">A relative or absolute path for the file that the current <see cref="T:System.IO.FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="f20a1-587">파일을 열거나 만드는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-587">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="f20a1-588">파일에 대한 액세스 및 감사 규칙을 만드는 데 사용할 액세스 권한을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-588">A constant that determines the access rights to use when creating access and audit rules for the file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="f20a1-589">프로세스에서 파일을 공유하는 방법을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-589">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="f20a1-590">버퍼 크기를 나타내는 0보다 큰 양의 <see cref="T:System.Int32" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-590">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="f20a1-591">기본 버퍼 크기는 4,096입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-591">The default buffer size is 4096.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="f20a1-592">추가 파일 옵션을 지정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-592">A constant that specifies additional file options.</span>
          </span>
        </param>
        <param name="fileSecurity">
          <span data-ttu-id="f20a1-593">파일에 대한 액세스 제어 및 감사 보안을 결정하는 상수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-593">A constant that determines the access control and audit security for the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-594">지정된 경로, 생성 모드, 액세스 및 공유 권한, 버퍼 크기, 추가 파일 옵션, 액세스 제어 및 감사 보안을 사용하여 <see cref="T:System.IO.FileStream" /> 클래스의 새 인스턴스를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-594">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, access rights and sharing permission, the buffer size, additional file options, access control and audit security.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-595">.NET Framework와 같은 장치 이름에는 경로 통해 실제 디스크에 직접 액세스를 지원 하지 않습니다 "\\\\. \PHYSICALDRIVE0"입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-595">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="f20a1-596">이 사용 하 여 <xref:System.IO.FileStream.%23ctor%2A> 파일을 만드는 권한 액세스를 적용 하는 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-596">Use this <xref:System.IO.FileStream.%23ctor%2A> constructor to apply access rights at the point of creation of a file.</span></span> <span data-ttu-id="f20a1-597">를 액세스 하거나 기존 파일에 대 한 권한을 수정 하려면 사용을 고려 합니다 <xref:System.IO.File.GetAccessControl%2A> 고 <xref:System.IO.File.SetAccessControl%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f20a1-597">To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="f20a1-598">합니다 `fileOptions` 매개 변수를 만들 때 활용할 수 있는 고급 작업에 대 한 액세스를 제공 하는 한 <xref:System.IO.FileStream> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-598">The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="f20a1-599">`path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-599">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-600">`path` 디스크에 저장 된 파일이 필요 하지 않습니다. 스트림을 통해 액세스를 지 원하는 시스템의 일부가 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-600">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="f20a1-601">예를 들어 시스템에 따라이 클래스는 물리적 장치를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-601">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="f20a1-602"><xref:System.IO.Stream.CanSeek%2A> 됩니다 `true` 모든 <xref:System.IO.FileStream> 파일 캡슐화 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-602"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="f20a1-603">경우 `path` 검색을 지원 하지 않는 장치를 나타냄 합니다 <xref:System.IO.FileStream.CanSeek%2A> 결과 속성 <xref:System.IO.FileStream> 는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-603">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="f20a1-604">자세한 내용은 <xref:System.IO.Stream.CanSeek%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-604">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-605">문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-605">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="f20a1-606">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-606">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-607">다음 예제에서는 파일에 데이터를 쓰고 다음 사용 하 여 데이터를 읽습니다는 <xref:System.IO.FileStream> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-607">The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.</span></span>  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-608">
            <paramref name="path" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-608">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-609">
            <paramref name="path" />가 빈 문자열("")이거나 공백만 포함하거나 하나 이상의 잘못된 문자를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-609">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="f20a1-610">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-610">-or-</span>
          </span>
          <span data-ttu-id="f20a1-611">
            <paramref name="path" />가 NTFS 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-611">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-612">
            <paramref name="path" />가 NTFS 이외의 환경에서 파일이 아닌 장치(예: "con:", "com1:", "lpt1:" 등)를 참조하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-612">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-613">
            <paramref name="bufferSize" />가 음수이거나 0인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-613">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="f20a1-614">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-614">-or-</span>
          </span>
          <span data-ttu-id="f20a1-615">
            <paramref name="mode" />, <paramref name="access" /> 또는 <paramref name="share" />에 잘못된 값이 포함된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-615">
              <paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f20a1-616">예를 들어, <paramref name="mode" />가 <see langword="FileMode.Truncate" /> 또는 <see langword="FileMode.Open" />인 경우 파일을 찾을 수 없으며 <paramref name="path" />로 지정된 파일이 없는 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-616">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="f20a1-617">이러한 모드에는 이 파일이 이미 있어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-617">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-618">
            <paramref name="path" />로 지정한 파일이 이미 있는 경우에 <see langword="FileMode.CreateNew" />를 지정하는 등의 I/O 오류가 발생한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-618">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="f20a1-619">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-619">-or-</span>
          </span>
          <span data-ttu-id="f20a1-620">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-620">The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-621">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-621">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="f20a1-622">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-622">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-623">
            <paramref name="access" />가 <see langword="Write" /> 또는 <see langword="ReadWrite" />이고 파일 또는 디렉터리가 읽기 전용 액세스로 설정된 경우처럼, 지정된 <paramref name="path" />에 대해 운영 체제에서 <paramref name="access" /> 요청을 허용하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-623">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
          <span data-ttu-id="f20a1-624">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-624">-or-</span>
          </span>
          <span data-ttu-id="f20a1-625">
            <paramref name="options" />에 <see cref="F:System.IO.FileOptions.Encrypted" />가 지정되었고 현재 플랫폼에서 파일 암호화가 지원되지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-625">
              <see cref="F:System.IO.FileOptions.Encrypted" /> is specified for <paramref name="options" />, but file encryption is not supported on the current platform.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="f20a1-626">지정된 <paramref name="path" />나 파일 이름 또는 둘 모두가 시스템에 정의된 최대 길이를 초과하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-626">The specified <paramref name="path" />, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="f20a1-627">현재 운영 체제가 Windows NT 이상이 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-627">The current operating system is not Windows NT or later.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-628">에 대해 읽기, 쓰기 및 파일에 추가 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-628">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="f20a1-629">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />하십시오 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-629">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="f20a1-630">데이터를 읽어올 버퍼입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-630">The buffer to read data into.</span>
          </span>
        </param>
        <param name="buffer">To be added.</param>
        <param name="offset">
          <span data-ttu-id="f20a1-631">읽기를 시작할 <c>배열</c>의 바이트 오프셋입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-631">The byte offset in <c>array</c> at which to begin reading.</span>
          </span>
        </param>
        <param name="numBytes">
          <span data-ttu-id="f20a1-632">읽을 최대 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-632">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="count">To be added.</param>
        <param name="userCallback">
          <span data-ttu-id="f20a1-633">비동기 읽기 작업이 완료되면 호출될 메서드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-633">The method to be called when the asynchronous read operation is completed.</span>
          </span>
        </param>
        <param name="callback">To be added.</param>
        <param name="stateObject">
          <span data-ttu-id="f20a1-634">다른 요청에서 특정 비동기 읽기 요청을 구별하는 사용자 제공 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-634">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span>
          </span>
        </param>
        <param name="state">To be added.</param>
        <summary>
          <span data-ttu-id="f20a1-635">비동기 읽기 작업을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-635">Begins an asynchronous read operation.</span>
          </span>
          <span data-ttu-id="f20a1-636">대신 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />를 사용하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-636">(Consider using <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f20a1-637">비동기 읽기를 참조하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-637">An object that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-638">.NET Framework 4 및 이전 버전에서와 같은 메서드를 사용 해야 <xref:System.IO.FileStream.BeginRead%2A> 고 <xref:System.IO.FileStream.EndRead%2A> 비동기 파일 작업을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-638">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.FileStream.BeginRead%2A> and <xref:System.IO.FileStream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="f20a1-639">그러나 이러한 메서드는에서 계속 제공 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드를 같은 <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, 및 <xref:System.IO.FileStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 하는 도움말.</span><span class="sxs-lookup"><span data-stu-id="f20a1-639">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="f20a1-640"><xref:System.IO.FileStream.EndRead%2A> 호출할 때마다 한 번씩 호출 해야 <xref:System.IO.FileStream.BeginRead%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-640"><xref:System.IO.FileStream.EndRead%2A> must be called exactly once for every call to <xref:System.IO.FileStream.BeginRead%2A>.</span></span> <span data-ttu-id="f20a1-641">다른 읽기를 시작 하기 전에 읽기 프로세스를 종료 하지 못하면 교착 상태 같은 바람직하지 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-641">Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</span></span>  
  
 <span data-ttu-id="f20a1-642"><xref:System.IO.FileStream> 작업의 두 가지 모드를 제공 합니다: 동기 I/O와 비동기 I/O입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-642"><xref:System.IO.FileStream> provides two different modes of operation: synchronous I/O and asynchronous I/O.</span></span> <span data-ttu-id="f20a1-643">하거나 사용할 수 있지만, 기본 운영 체제 리소스 이러한 모드 중 하나에 액세스할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-643">While either can be used, the underlying operating system resources might allow access in only one of these modes.</span></span> <span data-ttu-id="f20a1-644">기본적으로 <xref:System.IO.FileStream> 동기적으로 운영 체제 핸들을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-644">By default, <xref:System.IO.FileStream> opens the operating system handle synchronously.</span></span> <span data-ttu-id="f20a1-645">Windows, 비동기 메서드 느려집니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-645">In Windows, this slows down asynchronous methods.</span></span> <span data-ttu-id="f20a1-646">비동기 메서드를 사용 하는 경우 사용 된 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-646">If asynchronous methods are used, use the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-647">사용 된 <xref:System.IO.FileStream.CanRead%2A> 현재 인스턴스가 읽기를 지원 하는지 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-647">Use the <xref:System.IO.FileStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="f20a1-648">자세한 내용은 <xref:System.IO.Stream.CanRead%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-648">For additional information, see <xref:System.IO.Stream.CanRead%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-649">스트림이 닫혀 있거나를 잘못 된 인수를 전달 하는 경우 예외가 즉시에서 <xref:System.IO.FileStream.BeginRead%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-649">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <xref:System.IO.FileStream.BeginRead%2A>.</span></span> <span data-ttu-id="f20a1-650">IO 요청 중의 디스크 오류 등 비동기 읽기 요청을 하는 동안 발생 하는 오류는 스레드 풀 스레드에서 발생 하 고 호출 시 표시 될 <xref:System.IO.FileStream.EndRead%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-650">Errors that occur during an asynchronous read request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <xref:System.IO.FileStream.EndRead%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-651"><xref:System.IO.Stream.EndRead%2A> 이 사용 하 여 호출 해야 <xref:System.IAsyncResult> 읽은 바이트 수는 방법을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-651"><xref:System.IO.Stream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 <span data-ttu-id="f20a1-652">여러 개의 비동기 요청 확실 하지 않은 요청 완료 순서를 렌더링합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-652">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="f20a1-653">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-653">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-654">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-654">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-655">배열 길이에서 <paramref name="offset" />을 빼면 <paramref name="numBytes" />보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-655">The array length minus <paramref name="offset" /> is less than <paramref name="numBytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-656">
            <paramref name="array" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-656">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-657">
            <paramref name="offset" /> 또는 <paramref name="numBytes" />가 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-657">
              <paramref name="offset" /> or <paramref name="numBytes" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-658">파일의 끝을 지나 비동기 읽기를 시도했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-658">An asynchronous read was attempted past the end of the file.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="f20a1-659">현재 스트림에 쓸 데이터를 포함하는 버퍼입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-659">The buffer containing data to write to the current stream.</span>
          </span>
        </param>
        <param name="buffer">To be added.</param>
        <param name="offset">
          <span data-ttu-id="f20a1-660">현재 스트림으로 바이트를 복사하기 시작할 <c>배열</c>의 바이트 오프셋(0부터 시작)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-660">The zero-based byte offset in <c>array</c> at which to begin copying bytes to the current stream.</span>
          </span>
        </param>
        <param name="numBytes">
          <span data-ttu-id="f20a1-661">쓸 최대 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-661">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="count">To be added.</param>
        <param name="userCallback">
          <span data-ttu-id="f20a1-662">비동기 쓰기 작업이 완료되면 호출될 메서드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-662">The method to be called when the asynchronous write operation is completed.</span>
          </span>
        </param>
        <param name="callback">To be added.</param>
        <param name="stateObject">
          <span data-ttu-id="f20a1-663">다른 요청에서 특정 비동기 쓰기 요청을 구별하는 사용자 제공 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-663">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span>
          </span>
        </param>
        <param name="state">To be added.</param>
        <summary>
          <span data-ttu-id="f20a1-664">비동기 쓰기 작업을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-664">Begins an asynchronous write operation.</span>
          </span>
          <span data-ttu-id="f20a1-665">대신 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />를 사용하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-665">(Consider using <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f20a1-666">비동기 쓰기를 참조하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-666">An object that references the asynchronous write.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-667">.NET Framework 4 및 이전 버전에서와 같은 메서드를 사용 해야 <xref:System.IO.FileStream.BeginWrite%2A> 고 <xref:System.IO.FileStream.EndWrite%2A> 비동기 파일 작업을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-667">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.FileStream.BeginWrite%2A> and <xref:System.IO.FileStream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="f20a1-668">그러나 이러한 메서드는에서 계속 제공 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드를 같은 <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, 및 <xref:System.IO.FileStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 하는 도움말.</span><span class="sxs-lookup"><span data-stu-id="f20a1-668">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="f20a1-669"><xref:System.IO.FileStream.EndWrite%2A> 정확히 한 번만 호출 해야 모든 <xref:System.IAsyncResult> 에서 <xref:System.IO.FileStream.BeginWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-669"><xref:System.IO.FileStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.FileStream.BeginWrite%2A>.</span></span> <span data-ttu-id="f20a1-670"><xref:System.IO.FileStream.EndWrite%2A> I/O 작업이 완료 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-670"><xref:System.IO.FileStream.EndWrite%2A> will block until the I/O operation has completed.</span></span>  
  
 <span data-ttu-id="f20a1-671">이 메서드는 <xref:System.IO.Stream.BeginWrite%2A>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-671">This method overrides <xref:System.IO.Stream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-672"><xref:System.IO.FileStream> 작업의 두 가지 모드를 제공 합니다: 동기 I/O와 비동기 I/O입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-672"><xref:System.IO.FileStream> provides two different modes of operation: synchronous I/O and asynchronous I/O.</span></span> <span data-ttu-id="f20a1-673">하거나 사용할 수 있지만, 기본 운영 체제 리소스 이러한 모드 중 하나에 액세스할을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-673">While either can be used, the underlying operating system resources might allow access in only one of these modes.</span></span> <span data-ttu-id="f20a1-674">기본적으로 <xref:System.IO.FileStream> 동기적으로 운영 체제 핸들을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-674">By default, <xref:System.IO.FileStream> opens the operating system handle synchronously.</span></span> <span data-ttu-id="f20a1-675">Windows, 비동기 메서드 느려집니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-675">In Windows, this slows down asynchronous methods.</span></span> <span data-ttu-id="f20a1-676">비동기 메서드를 사용 하는 경우 사용 된 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-676">If asynchronous methods are used, use the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 <span data-ttu-id="f20a1-677">스트림이 닫혀 있거나를 잘못 된 인수를 전달 하는 경우 예외가 즉시에서 <xref:System.IO.FileStream.BeginWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-677">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <xref:System.IO.FileStream.BeginWrite%2A>.</span></span> <span data-ttu-id="f20a1-678">IO 요청 중의 디스크 오류 등 비동기 쓰기 요청을 하는 동안 발생 하는 오류는 스레드 풀 스레드에서 발생 하 고 호출 시 표시 될 <xref:System.IO.FileStream.EndWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-678">Errors that occur during an asynchronous write request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <xref:System.IO.FileStream.EndWrite%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-679">여러 개의 비동기 요청 확실 하지 않은 요청 완료 순서를 렌더링합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-679">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="f20a1-680">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-680">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-681">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-681">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-682">
            <paramref name="array" /> 길이에서 <paramref name="offset" />을 뺀 값이 <paramref name="numBytes" />보다 작습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-682">
              <paramref name="array" /> length minus <paramref name="offset" /> is less than <paramref name="numBytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-683">
            <paramref name="array" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-683">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-684">
            <paramref name="offset" /> 또는 <paramref name="numBytes" />가 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-684">
              <paramref name="offset" /> or <paramref name="numBytes" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-685">스트림이 쓰기를 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-685">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-686">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-686">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-687">I/O 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-687">An I/O error occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-688">현재 스트림이 읽기를 지원하는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-688">Gets a value indicating whether the current stream supports reading.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f20a1-689">스트림이 읽기를 지원하면 <see langword="true" />이고, 스트림이 닫혀 있거나 쓰기 전용 권한으로 열렸으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-689">
              <see langword="true" /> if the stream supports reading; <see langword="false" /> if the stream is closed or was opened with write-only access.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-690">클래스에서 파생 하는 경우 <xref:System.IO.Stream> 읽기를 지원 하지 않습니다, 호출 하는 <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, 및 <xref:System.IO.FileStream.BeginRead%2A> 메서드는 throw를 <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="f20a1-690">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, and <xref:System.IO.FileStream.BeginRead%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="f20a1-691">이 속성을 반환 하는 경우 스트림이 닫혀, `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-691">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-692">다음 예제에서는 사용 하 여 `CanRead` 속성.</span><span class="sxs-lookup"><span data-stu-id="f20a1-692">The following example demonstrates a use of the `CanRead` property.</span></span> <span data-ttu-id="f20a1-693">이 코드의 출력은 "MyFile.txt 쓰기 가능한 아닙니다."</span><span class="sxs-lookup"><span data-stu-id="f20a1-693">The output of this code is "MyFile.txt is not writable."</span></span> <span data-ttu-id="f20a1-694">출력 메시지가 "MyFile.txt 수 모두 쓰고에서 읽을."를 변경 하는 `FileAccess` 매개 변수를 `ReadWrite` 에 `FileStream` 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-694">To get the output message "MyFile.txt can be both written to and read from.", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.</span></span>  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-695">현재 스트림이 검색을 지원하는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-695">Gets a value indicating whether the current stream supports seeking.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f20a1-696">스트림이 검색을 지원하면 <see langword="true" />이고, 스트림이 닫혔거나 <see langword="FileStream" />이 콘솔에 대한 출력 또는 파이프와 같은 운영 체제 핸들로부터 생성된 경우에는 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-696">
              <see langword="true" /> if the stream supports seeking; <see langword="false" /> if the stream is closed or if the <see langword="FileStream" /> was constructed from an operating-system handle such as a pipe or output to the console.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-697">파생 된 클래스가 <xref:System.IO.Stream> 검색을 지원 하지 않습니다, 호출 하는 <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, 및 <xref:System.IO.FileStream.Seek%2A> throw를 <xref:System.NotSupportedException>입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-697">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, and <xref:System.IO.FileStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="f20a1-698">이 속성을 반환 하는 경우 스트림이 닫혀, `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-698">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-699">다음 예제에서는 `CanSeek` 스트림이 검색을 지원 하는지 여부를 확인할 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-699">The following example uses the `CanSeek` property to check whether a stream supports seeking.</span></span>  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-700">현재 스트림이 쓰기를 지원하는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-700">Gets a value indicating whether the current stream supports writing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f20a1-701">스트림이 쓰기를 지원하면 <see langword="true" />이고, 스트림이 닫혀 있거나 읽기 전용 권한으로 열렸으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-701">
              <see langword="true" /> if the stream supports writing; <see langword="false" /> if the stream is closed or was opened with read-only access.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-702">파생 된 클래스가 <xref:System.IO.Stream> 에 대 한 호출을 작성 하는 것을 지원 하지 않습니다 <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, 또는 <xref:System.IO.FileStream.WriteByte%2A> throw를 <xref:System.NotSupportedException>입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-702">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, or <xref:System.IO.FileStream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="f20a1-703">이 속성을 반환 하는 경우 스트림이 닫혀, `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-703">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-704">다음 예제에서는 `CanWrite` 스트림이 쓰기를 지원 하는지 여부를 확인할 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-704">The following example uses the `CanWrite` property to check whether a stream supports writing.</span></span>  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 <span data-ttu-id="f20a1-705">다음은 예제를 사용 하는 `CanWrite` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-705">The following is an example using the `CanWrite` property.</span></span> <span data-ttu-id="f20a1-706">이 코드의 출력은 "MyFile.txt 쓰기 가능 합니다."</span><span class="sxs-lookup"><span data-stu-id="f20a1-706">The output of this code is "MyFile.txt is writable."</span></span> <span data-ttu-id="f20a1-707">출력 메시지가 "MyFile.txt 수 모두 쓰고에서 읽을."를 변경 하는 `FileAccess` 매개 변수를 `ReadWrite` 에 `FileStream` 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-707">To get the output message "MyFile.txt can be both written to and read from.", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.</span></span>  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="f20a1-708">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-708">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-709">
            <see cref="T:System.IO.FileStream" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-709">Releases the unmanaged resources used by the <see cref="T:System.IO.FileStream" /> and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-710">이 메서드는 공용 <xref:System.ComponentModel.Component.Dispose%2A> 메서드 및 <xref:System.Object.Finalize%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f20a1-710">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="f20a1-711"><xref:System.ComponentModel.Component.Dispose%2A> 보호 된 호출 <xref:System.IO.FileStream.Dispose%2A> 메서드를 `disposing` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-711"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.FileStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="f20a1-712"><xref:System.Object.Finalize%2A> 호출 <xref:System.IO.FileStream.Dispose%2A> 사용 하 여 `disposing` 로 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-712"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.FileStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="f20a1-713">`disposing` 매개 변수가 `true`인 경우 이 메서드는 이 <xref:System.IO.FileStream>에서 참조하는 관리 개체가 보유하고 있는 리소스를 모두 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-713">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.FileStream> references.</span></span> <span data-ttu-id="f20a1-714">이 메서드는 참조되는 각 개체의 <xref:System.ComponentModel.Component.Dispose%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-714">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="f20a1-715">
            <para>
              <see cref="M:System.ComponentModel.Component.Dispose" /> 다른 개체에서 여러 번 호출할 수 있습니다. 재정의 하는 경우 <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> 대 한 이전 호출에서 삭제 된 개체를 참조 하지 않도록 주의 해야 <see cref="M:System.ComponentModel.Component.Dispose" />합니다. 구현 하는 방법에 대 한 자세한 내용은 <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />를 참조 하세요 [Dispose 메서드 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.  에 대 한 자세한 내용은 <see cref="M:System.ComponentModel.Component.Dispose" /> 하 고 <see cref="M:System.Object.Finalize" />를 참조 하세요 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md)합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-715">
              <para>
                <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects. When overriding <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />. For more information about how to implement <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="f20a1-716">대기할 보류 중인 비동기 요청에 대한 참조입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-716">The reference to the pending asynchronous request to wait for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-717">보류 중인 비동기 읽기 작업이 완료되기를 기다립니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-717">Waits for the pending asynchronous read operation to complete.</span>
          </span>
          <span data-ttu-id="f20a1-718">대신 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />를 사용하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-718">(Consider using <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f20a1-719">0과 요청한 바이트 수 사이의 스트림에서 읽은 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-719">The number of bytes read from the stream, between 0 and the number of bytes you requested.</span>
          </span>
          <span data-ttu-id="f20a1-720">스트림은 스트림의 끝에서 0만을 반환하며 그렇지 않으면 최소한 1바이트를 사용할 수 있을 때까지 차단됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-720">Streams only return 0 at the end of the stream, otherwise, they should block until at least 1 byte is available.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-721">.NET Framework 4 및 이전 버전에서와 같은 메서드를 사용 해야 <xref:System.IO.FileStream.BeginRead%2A> 고 <xref:System.IO.FileStream.EndRead%2A> 비동기 파일 작업을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-721">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.FileStream.BeginRead%2A> and <xref:System.IO.FileStream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="f20a1-722">그러나 이러한 메서드는에서 계속 제공 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드를 같은 <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, 및 <xref:System.IO.FileStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 하는 도움말.</span><span class="sxs-lookup"><span data-stu-id="f20a1-722">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="f20a1-723"><xref:System.IO.FileStream.EndRead%2A> 호출할 때마다 한 번씩 호출 해야 <xref:System.IO.FileStream.BeginRead%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-723"><xref:System.IO.FileStream.EndRead%2A> must be called exactly for every call to <xref:System.IO.FileStream.BeginRead%2A>.</span></span> <span data-ttu-id="f20a1-724">다른 읽기를 시작 하기 전에 읽기 프로세스를 종료 하지 못하면 교착 상태 같은 바람직하지 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-724">Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</span></span>  
  
 <span data-ttu-id="f20a1-725">이 메서드는 <xref:System.IO.Stream.EndRead%2A>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-725">This method overrides <xref:System.IO.Stream.EndRead%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-726"><xref:System.IO.FileStream.EndRead%2A> 호출할 수 마다 <xref:System.IAsyncResult> 에서 <xref:System.IO.FileStream.BeginRead%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-726"><xref:System.IO.FileStream.EndRead%2A> can be called on every <xref:System.IAsyncResult> from <xref:System.IO.FileStream.BeginRead%2A>.</span></span> <span data-ttu-id="f20a1-727">호출 <xref:System.IO.FileStream.EndRead%2A> 스트림에서 읽은 바이트 수는 방법을 알려 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-727">Calling <xref:System.IO.FileStream.EndRead%2A> tells you how many bytes were read from the stream.</span></span> <span data-ttu-id="f20a1-728"><xref:System.IO.FileStream.EndRead%2A> I/O 작업이 완료 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-728"><xref:System.IO.FileStream.EndRead%2A> will block until the I/O operation has completed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-729">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-729">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-730">
            <paramref name="asyncResult" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-730">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-731">이 <see cref="T:System.IAsyncResult" /> 개체는 이 클래스에 대해 <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />를 호출하여 만들어진 개체가 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-731">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f20a1-732">
            <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />가 여러 번 호출됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-732">
              <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> is called multiple times.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-733">스트림이 닫혔거나 내부 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-733">The stream is closed or an internal error has occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="f20a1-734">보류 중인 비동기 I/O 요청입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-734">The pending asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-735">비동기 쓰기 작업을 종료하고 I/O 작업이 완료될 때까지 차단시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-735">Ends an asynchronous write operation and blocks until the I/O operation is complete.</span>
          </span>
          <span data-ttu-id="f20a1-736">대신 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />를 사용하세요.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-736">(Consider using <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-737">.NET Framework 4 및 이전 버전에서와 같은 메서드를 사용 해야 <xref:System.IO.FileStream.BeginWrite%2A> 고 <xref:System.IO.FileStream.EndWrite%2A> 비동기 파일 작업을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-737">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.FileStream.BeginWrite%2A> and <xref:System.IO.FileStream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="f20a1-738">그러나 이러한 메서드는에서 계속 제공 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 레거시 코드를 지원 하기 위해 새로운 비동기 메서드를 같은 <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, 및 <xref:System.IO.FileStream.FlushAsync%2A>, 비동기 파일 작업을 보다 쉽게 구현 하는 도움말.</span><span class="sxs-lookup"><span data-stu-id="f20a1-738">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="f20a1-739">이 메서드는 <xref:System.IO.Stream.EndWrite%2A>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-739">This method overrides <xref:System.IO.Stream.EndWrite%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-740"><xref:System.IO.FileStream.EndWrite%2A> 정확히 한 번만 호출 해야 모든 <xref:System.IAsyncResult> 에서 <xref:System.IO.FileStream.BeginWrite%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-740"><xref:System.IO.FileStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.FileStream.BeginWrite%2A>.</span></span> <span data-ttu-id="f20a1-741"><xref:System.IO.FileStream.EndWrite%2A> I/O 작업이 완료 될 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-741"><xref:System.IO.FileStream.EndWrite%2A> will block until the I/O operation has completed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-742">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-742">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-743">
            <paramref name="asyncResult" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-743">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-744">이 <see cref="T:System.IAsyncResult" /> 개체는 이 클래스에 대해 <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />를 호출하여 만들어진 개체가 아닙니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-744">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f20a1-745">
            <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />가 여러 번 호출됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-745">
              <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> is called multiple times.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-746">스트림이 닫혔거나 내부 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-746">The stream is closed or an internal error has occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-747">가비지 수집기에서 <see langword="FileStream" />을 회수할 때 리소스가 해제되고 다른 정리 작업이 수행되도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-747">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see langword="FileStream" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-748">가비지 수집기를 호출 하 여 `Finalize` 종료 준비가 된 경우.</span><span class="sxs-lookup"><span data-stu-id="f20a1-748">The garbage collector calls `Finalize` when the current object is ready to be finalized.</span></span> <span data-ttu-id="f20a1-749">`Finalize` 닫습니다는 `FileStream`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-749">`Finalize` closes the `FileStream`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-750">이 스트림의 버퍼를 지우고 버퍼링된 모든 데이터가 파일에 쓰여지도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-750">Clears buffers for this stream and causes any buffered data to be written to the file.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-751">이 스트림의 버퍼를 지우고 버퍼링된 모든 데이터가 파일에 쓰여지도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-751">Clears buffers for this stream and causes any buffered data to be written to the file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-752">이 메서드는 <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-752">This method overrides <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f20a1-753">호출 하는 경우는 <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> 메서드, 운영 체제 I/O 버퍼는도 플러시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-753">When you call the <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> method, the operating system I/O buffer is also flushed.</span></span>  
  
 <span data-ttu-id="f20a1-754">스트림 인코더 명시적으로 호출 하지 않으면 플러시되지 않습니다 <xref:System.IO.FileStream.Flush%2A> 또는 개체를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-754">A stream’s encoder is not flushed unless you explicitly call <xref:System.IO.FileStream.Flush%2A> or dispose of the object.</span></span> <span data-ttu-id="f20a1-755">설정 <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> 에 `true` 스트림 버퍼에서 데이터를 플러시할 수는 있지만 인코더 상태는 플러시되지 있다는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-755">Setting <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> to `true` means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="f20a1-756">이 수는 다음 문자 블록을 올바르게 인코딩할 수 있도록 상태로 (부분 자)를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-756">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="f20a1-757">이 시나리오는 UTF8 및 UTF7 인코더는 인접 한 문자를 받은 후 특정 문자를 인코딩된만 수 있는 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-757">This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</span></span>  
  
 <span data-ttu-id="f20a1-758">읽기 또는 쓰기에 대 한 버퍼를 사용할 수 있으므로 <xref:System.IO.FileStream.Flush> 다음 두 가지 기능을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-758">Because a buffer can be used for either reading or writing, <xref:System.IO.FileStream.Flush> performs the following two functions:</span></span>  
  
-   <span data-ttu-id="f20a1-759">이전에 버퍼에 기록 된 모든 데이터가 파일에 복사 됩니다 하 고 버퍼 인코더 상태로 제외 하 고 선택을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-759">Any data previously written to the buffer is copied to the file and the buffer is cleared except for its encoder state.</span></span>  
  
-   <span data-ttu-id="f20a1-760">하는 경우 <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> 는 `true` 및 데이터 읽기 위해 파일에서 이전에 복사 되었는지, 파일 내에서 현재 위치가 버퍼에 읽지 않은 바이트의 수로 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-760">If <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> is `true` and data was previously copied from the file to the buffer for reading, the current position within the file is decremented by the number of unread bytes in the buffer.</span></span> <span data-ttu-id="f20a1-761">버퍼는 지워집니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-761">The buffer is then cleared.</span></span>  
  
 <span data-ttu-id="f20a1-762">사용 하 여는 <xref:System.IO.FileStream.Flush%28System.Boolean%29> 메서드 오버 로드는 중간 파일 버퍼에서 버퍼링 된 모든 데이터를 확인 하려고 할 때 작성 된 디스크.</span><span class="sxs-lookup"><span data-stu-id="f20a1-762">Use the <xref:System.IO.FileStream.Flush%28System.Boolean%29> method overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-763">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.IO.FileStream.Lock%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f20a1-763">This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-764">I/O 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-764">An I/O error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-765">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-765">The stream is closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <span data-ttu-id="f20a1-766">모든 중간 파일 버퍼를 플러시하려면 <see langword="true" />이고, 플러시하지 않으려면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-766">
              <see langword="true" /> to flush all intermediate file buffers; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-767">이 스트림에 대한 버퍼를 지우고 버퍼링된 모든 데이터가 파일에 쓰여지도록 하며 모든 중간 파일 버퍼도 지웁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-767">Clears buffers for this stream and causes any buffered data to be written to the file, and also clears all intermediate file buffers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-768">중간 파일 버퍼에서 버퍼링 된 모든 데이터를 확인 하려는 경우이 오버 로드에 씌 사용 하 여 디스크에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-768">Use this overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</span></span>  
  
 <span data-ttu-id="f20a1-769">호출 하는 경우는 <xref:System.IO.FileStream.Flush%2A> 메서드, 운영 체제 I/O 버퍼는도 플러시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-769">When you call the <xref:System.IO.FileStream.Flush%2A> method, the operating system I/O buffer is also flushed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
          <span data-ttu-id="f20a1-770">취소 요청을 모니터링할 토큰입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-770">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-771">이 스트림에 대해 모든 버퍼를 비동기적으로 지우고 버퍼링된 데이터가 내부 장치에 쓰여지도록 하고 취소 요청을 모니터링합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-771">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f20a1-772">비동기 플러시 작업을 나타내는 작업입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-772">A task that represents the asynchronous flush operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-773">호출 하는 경우는 <xref:System.IO.FileStream.FlushAsync%2A> 메서드, 운영 체제 I/O 버퍼는도 플러시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-773">When you call the <xref:System.IO.FileStream.FlushAsync%2A> method, the operating system I/O buffer is also flushed.</span></span>  
  
 <span data-ttu-id="f20a1-774">완료 되기 전에 작업이 취소 되 면 반환 된 작업이 포함 된 <xref:System.Threading.Tasks.TaskStatus.Canceled> 에 대 한 값는 <xref:System.Threading.Tasks.Task.Status%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="f20a1-774">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="f20a1-775">파일 핸들을 삭제 하는 경우 반환 된 작업이 포함 된 <xref:System.ObjectDisposedException> 예외를 <xref:System.Threading.Tasks.Task.Exception%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="f20a1-775">If the handle to the file is disposed, the returned task contains the <xref:System.ObjectDisposedException> exception in the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-776">스트림이 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-776">The stream has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-777">현재 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체에서 설명하는 파일의 ACL(액세스 제어 목록) 항목을 캡슐화하는 <see cref="T:System.IO.FileStream" /> 개체를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-777">Gets a <see cref="T:System.Security.AccessControl.FileSecurity" /> object that encapsulates the access control list (ACL) entries for the file described by the current <see cref="T:System.IO.FileStream" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f20a1-778">현재 <see cref="T:System.IO.FileStream" /> 개체에서 설명하는 파일의 액세스 제어 설정을 캡슐화하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-778">An object that encapsulates the access control settings for the file described by the current <see cref="T:System.IO.FileStream" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-779">동안 합니다 <xref:System.IO.FileStream> 클래스 및 <xref:System.IO.FileStream.GetAccessControl%2A> 기존 파일의 액세스 제어 목록 (ACL) 항목을 검색을 사용 하 여 사용할 수 있습니다 <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> 메서드를 사용 하기가 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-779">While the <xref:System.IO.FileStream> class and <xref:System.IO.FileStream.GetAccessControl%2A> can be used to retrieve the access control list (ACL) entries of an existing file, consider using <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> method, as it is easier to use.</span></span>  
  
 <span data-ttu-id="f20a1-780">사용 된 <xref:System.IO.FileStream.GetAccessControl%2A> 파일에 대 한 ACL 항목을 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-780">Use the <xref:System.IO.FileStream.GetAccessControl%2A> method to retrieve the ACL entries for a file.</span></span>  
  
 <span data-ttu-id="f20a1-781">ACL에는 개인 및/또는 그룹 했거나 권한이 없는, 지정된 된 파일에서 특정 작업을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-781">An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</span></span> <span data-ttu-id="f20a1-782">자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f20a1-782">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-783">파일이 닫혀 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-783">The file is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-784">파일을 여는 동안 I/O 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-784">An I/O error occurred while opening the file.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="f20a1-785">파일을 찾을 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-785">The file could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-786">현재 플랫폼이 해당 작업을 지원하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-786">This operation is not supported on the current platform.</span>
          </span>
          <span data-ttu-id="f20a1-787">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-787">-or-</span>
          </span>
          <span data-ttu-id="f20a1-788">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-788">The caller does not have the required permission.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-789">현재 <see langword="FileStream" /> 개체가 캡슐화할 파일에 대한 운영 체제 파일 핸들을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-789">Gets the operating system file handle for the file that the current <see langword="FileStream" /> object encapsulates.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f20a1-790">이 <see langword="FileStream" /> 개체가 캡슐화할 파일에 대한 운영 체제 파일 핸들입니다. <see langword="FileStream" />이 닫혀 있는 경우에는 -1입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-790">The operating system file handle for the file encapsulated by this <see langword="FileStream" /> object, or -1 if the <see langword="FileStream" /> has been closed.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-791">이 속성은 운영 체제에서 제공 하는 시스템 호출에 사용할 운영 체제 핸들 (같은 `ReadFile` Windows에서).</span><span class="sxs-lookup"><span data-stu-id="f20a1-791">This property is an operating system handle for use with operating-system-provided system calls (such as `ReadFile` on Windows).</span></span> <span data-ttu-id="f20a1-792">파일 설명자와 같은 예상 하는 C 라이브러리 함수를 사용 하 여 작동 하지 것입니다 `fread`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-792">It will not work with C library functions that expect a file descriptor, such as `fread`.</span></span>  
  
 <span data-ttu-id="f20a1-793">운영 체제 핸들을 있습니다 열었던 동기적 또는 비동기적인지에 따라 `FileStream` 생성자를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-793">The operating system handle might have been opened synchronously or asynchronously, depending on which `FileStream` constructor was called.</span></span> <span data-ttu-id="f20a1-794">사용 된 <xref:System.IO.FileStream.IsAsync%2A> 이 핸들 비동기식으로 열렸을 여부를 검색 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-794">Use the <xref:System.IO.FileStream.IsAsync%2A> property to discover whether this handle was opened asynchronously.</span></span> <span data-ttu-id="f20a1-795">Win32, 즉, 겹친된 IO에 대 한 핸들이 열린 및 다른 매개 변수를 필요 `ReadFile` 고 `WriteFile`입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-795">In Win32, this means the handle was opened for overlapped IO, and it requires different parameters to `ReadFile` and `WriteFile`.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-796">데이터 손상이 발생할 수 있습니다는 `FileStream` 는 해당 핸들을 전달, 일부 작업 핸들의 파일 포인터를 이동 생성 차례로 `FileStream` 다시 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-796">Data corruption might occur if a `FileStream` is created, its handle is passed, some operation moves the handle's file pointer, and then the `FileStream` is used again.</span></span> <span data-ttu-id="f20a1-797">여러 스레드 수 없습니다. 동일한 파일에 동시에 쓸 안전 하 게 하 고 `FileStream` 핸들을 단독으로 제어 하는 것을 가정 코드를 버퍼링 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-797">Multiple threads cannot safely write to the same file simultaneously, and `FileStream` buffering code assumes that it exclusively controls the handle.</span></span> <span data-ttu-id="f20a1-798">`FileStream` throw 할 수는 <xref:System.IO.IOException> 경우 `FileStream` 다른 프로세스는 파일 포인터를 옮겨 졌음을 감지 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-798">`FileStream` might throw an <xref:System.IO.IOException> if `FileStream` detects that some other process has moved the file pointer.</span></span> <span data-ttu-id="f20a1-799">이 방지 하려면 쓰지 마십시오. 모든 데이터 파일의 부분에 있는 `FileStream` 수 버퍼링 했 고 파일 포인터 위치에 복원에 마지막으로 메서드 호출 되었을 때 `FileStream`합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-799">To avoid this, do not write any data into a portion of the file that `FileStream` might have buffered, and restore the file pointer to the location it had when methods were last called on `FileStream`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f20a1-800">호출자에게 필요한 권한이 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-800">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f20a1-801">비관리 코드에 액세스할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-801">for the ability to access unmanaged code.</span>
          </span>
          <span data-ttu-id="f20a1-802">연관 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 보안 작업: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-802">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Security action: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f20a1-803">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-803">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f20a1-804">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-804">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-805">
            <see langword="FileStream" />이 동기적으로 열렸는지 또는 비동기적으로 열렸는지를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-805">Gets a value indicating whether the <see langword="FileStream" /> was opened asynchronously or synchronously.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f20a1-806">
            <see langword="FileStream" />이 비동기적으로 열렸으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-806">
              <see langword="true" /> if the <see langword="FileStream" /> was opened asynchronously; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-807">`IsAsync` 속성 검색 여부를 합니다 `FileStream` 사용 하도록 코드를 사용 하도록 설정 하면 핸들이 비동기적으로 열린를 <xref:System.IO.FileStream.Handle%2A> 속성 올바르게.</span><span class="sxs-lookup"><span data-stu-id="f20a1-807">The `IsAsync` property detects whether the `FileStream` handle was opened asynchronously, enabling your code to use the <xref:System.IO.FileStream.Handle%2A> property correctly.</span></span> <span data-ttu-id="f20a1-808">Win32에서는 `IsAsync` 핸들 겹쳐진된 I/O에 대 한 열린으로 필요한 다른 매개 변수를 true로 설정 되 `ReadFile` 고 `WriteFile`입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-808">In Win32, `IsAsync` being true means the handle was opened for overlapped I/O, and thus requires different parameters to `ReadFile` and `WriteFile`.</span></span>  
  
 <span data-ttu-id="f20a1-809">인스턴스를 만들 때이 값을 지정 하는 <xref:System.IO.FileStream> 클래스에 생성자를 사용 하는 `isAsync`를 `useAsync`, 또는 `options` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-809">You specify this value when you create an instance of the <xref:System.IO.FileStream> class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter.</span></span> <span data-ttu-id="f20a1-810">속성이 `true`를 스트림에 비동기적으로 파일 작업을 수행 하려면의 겹쳐진된 I/O를 활용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-810">When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously.</span></span> <span data-ttu-id="f20a1-811">그러나를 <xref:System.IO.FileStream.IsAsync%2A> 속성에 수 없습니다 `true` 를 호출 하는 <xref:System.IO.FileStream.ReadAsync%2A>를 <xref:System.IO.FileStream.WriteAsync%2A>, 또는 <xref:System.IO.Stream.CopyToAsync%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f20a1-811">However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method.</span></span> <span data-ttu-id="f20a1-812">경우는 <xref:System.IO.FileStream.IsAsync%2A> 속성은 `false` 및 비동기 읽기를 호출 하 고 쓰기 작업, 여전히 UI 스레드가 차단 되지 않지만 실제 I/O 작업이 동기적으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-812">When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-813">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-813">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-814">스트림의 길이(바이트)를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-814">Gets the length in bytes of the stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f20a1-815">스트림 길이(바이트)를 나타내는 long 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-815">A long value representing the length of the stream in bytes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-816">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-816">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-817">다음 예제에서는 합니다 `Length` 고 `Position` 파일 끝 조건을 확인 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-817">The following example uses the `Length` and `Position` properties to check for an end-of-file condition.</span></span>  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-818">이 스트림에 대한 <see cref="P:System.IO.FileStream.CanSeek" />가 <see langword="false" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-818">
              <see cref="P:System.IO.FileStream.CanSeek" /> for this stream is <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-819">I/O 오류가(예: 파일 닫기 오류) 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-819">An I/O error, such as the file being closed, occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">
          <span data-ttu-id="f20a1-820">잠글 범위의 시작 부분입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-820">The beginning of the range to lock.</span>
          </span>
          <span data-ttu-id="f20a1-821">이 매개 변수의 값은 0보다 크거나 같아야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-821">The value of this parameter must be equal to or greater than zero (0).</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="f20a1-822">잠글 범위입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-822">The range to be locked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-823">다른 프로세스가 <see cref="T:System.IO.FileStream" />을 읽거나 쓰지 못하게 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-823">Prevents other processes from reading from or writing to the <see cref="T:System.IO.FileStream" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-824">파일 스트림의 범위를 잠그면 파일 스트림의 해당 범위에 스레드가 잠금 프로세스 단독 액세스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-824">Locking a range of a file stream gives the threads of the locking process exclusive access to that range of the file stream.</span></span>  
  
 <span data-ttu-id="f20a1-825">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-825">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-826">다음 코드 예제에는 파일의 일부를 파일에 읽기/쓰기 액세스를 포함 하더라도 다른 프로세스에서 파일의 해당 파트를 액세스할 수 없도록 차단 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-826">The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file.</span></span> <span data-ttu-id="f20a1-827">다른 명령 창에서 프로그램을 동시에 실행 하 고 다른 콘솔 입력된 옵션을 사용 하 여 조사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-827">Run the program simultaneously in different command windows and investigate using the different console input options.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-828">
            <paramref name="position" /> 또는 <paramref name="length" />가 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-828">
              <paramref name="position" /> or <paramref name="length" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-829">파일이 닫혀 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-829">The file is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-830">다른 프로세스에서 파일의 부분을 잠갔으므로 이 프로세스에서 해당 파일에 액세스할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-830">The process cannot access the file because another process has locked a portion of the file.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-831">생성자에 전달된 <see langword="FileStream" />의 이름을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-831">Gets the name of the <see langword="FileStream" /> that was passed to the constructor.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f20a1-832">
            <see langword="FileStream" />의 이름인 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-832">A string that is the name of the <see langword="FileStream" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-833">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-833">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-834">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-834">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f20a1-835">경로에 액세스 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-835">for access to the path.</span>
          </span>
          <span data-ttu-id="f20a1-836">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-836">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-837">이 스트림의 현재 위치를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-837">Gets or sets the current position of this stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f20a1-838">이 스트림의 현재 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-838">The current position of this stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-839">스트림의 길이 초과 하는 위치 검색을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-839">Seeking to any location beyond the length of the stream is supported.</span></span>  <span data-ttu-id="f20a1-840">파일의 길이 넘어서 검색 하면 파일 크기가 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-840">When you seek beyond the length of the file, the file size grows.</span></span>  <span data-ttu-id="f20a1-841">Microsoft Windows NT에서 이상 버전에서는 파일의 끝에 추가 된 모든 데이터를 0으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-841">In Microsoft Windows NT and newer, any data added to the end of the file is set to zero.</span></span>  <span data-ttu-id="f20a1-842">Microsoft Windows 98에서 또는 이전 버전에서는 파일의 끝에 추가 된 모든 데이터를 0으로 이전에 데이터를 삭제 하는 스트림에 표시 하지 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-842">In Microsoft Windows 98 or earlier, any data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</span></span> <span data-ttu-id="f20a1-843">Windows 98 또는 이전 스트림의 끝을 큰 값으로 스트림의 위치를 설정 하면 예외가 발생할 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-843">Setting the position of the stream to a large value beyond the end of the stream in Windows 98 or earlier may result in an exception being raised.</span></span>  
  
 <span data-ttu-id="f20a1-844">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-844">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-845">다음 예제에서는 합니다 `Length` 고 `Position` 파일 끝 조건을 확인 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-845">The following example uses the `Length` and `Position` properties to check for an end-of-file condition.</span></span>  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-846">스트림이 검색을 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-846">The stream does not support seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-847">I/O 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-847">An I/O error occurred.</span>
          </span>
          <span data-ttu-id="f20a1-848">\- 또는 -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-848">\- or -</span>
          </span>
          <span data-ttu-id="f20a1-849">Windows 98 이전 버전에서 위치가 스트림 끝을 벗어나는 매우 큰 값으로 설정되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-849">The position was set to a very large value beyond the end of the stream in Windows 98 or earlier.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-850">위치를 음수 값으로 설정하려고 했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-850">Attempted to set the position to a negative value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <span data-ttu-id="f20a1-851">스트림의 끝을 벗어나는 검색을 시도했으며 이 작업은 지원되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-851">Attempted seeking past the end of a stream that does not support this.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="f20a1-852">이 메서드는 지정된 바이트 배열의 값이 <c>오프셋</c>과 (<c>오프셋</c> + <c>카운트</c> - 1<c>)</c> 사이에서 현재 소스로부터 읽어온 바이트로 교체된 상태로 반환됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-852">When this method returns, contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c> - 1<c>)</c> replaced by the bytes read from the current source.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="f20a1-853">읽기 바이트를 넣을 <c>배열</c>의 바이트 오프셋입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-853">The byte offset in <c>array</c> at which the read bytes will be placed.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="f20a1-854">읽을 최대 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-854">The maximum number of bytes to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-855">스트림에서 바이트 블록을 읽어서 해당 데이터를 제공된 버퍼에 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-855">Reads a block of bytes from the stream and writes the data in a given buffer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f20a1-856">버퍼로 읽어온 총 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-856">The total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="f20a1-857">이 바이트 수는 사용 가능한 바이트 수가 부족한 경우 요청된 바이트 수보다 작을 수 있으며, 스트림의 끝에 도달하면 0이 됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-857">This might be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-858">이 메서드는 <xref:System.IO.Stream.Read%2A>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-858">This method overrides <xref:System.IO.Stream.Read%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-859">`offset` 의 바이트 오프셋을 제공 하는 매개 변수 `array` (버퍼 인덱스)를 읽기 시작할 위치의 및 `count` 매개 변수는이 스트림에서 읽을 바이트의 최대 수를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-859">The `offset` parameter gives the offset of the byte in `array` (the buffer index) at which to begin reading, and the `count` parameter gives the maximum number of bytes to be read from this stream.</span></span> <span data-ttu-id="f20a1-860">반환된 된 값은 0 또는 읽은 바이트 수가 실제 스트림의 맨 끝에 도달한 경우</span><span class="sxs-lookup"><span data-stu-id="f20a1-860">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span> <span data-ttu-id="f20a1-861">읽기 작업이 성공 하면 스트림의 현재 위치는 읽은 바이트 수 만큼 앞 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-861">If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</span></span> <span data-ttu-id="f20a1-862">예외가 발생 하는 경우 스트림의 현재 위치가 변경 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-862">If an exception occurs, the current position of the stream is unchanged.</span></span>  
  
 <span data-ttu-id="f20a1-863"><xref:System.IO.FileStream.Read%2A> 메서드가 스트림의 끝에 도달한 후에 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-863">The <xref:System.IO.FileStream.Read%2A> method returns zero only after reaching the end of the stream.</span></span> <span data-ttu-id="f20a1-864">그렇지 않으면 <xref:System.IO.FileStream.Read%2A> 항상 스트림에서 반환 하기 전에 최소한 1 바이트를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-864">Otherwise, <xref:System.IO.FileStream.Read%2A> always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="f20a1-865">호출 시 스트림에서 없는 데이터를 사용할 수 있으면 <xref:System.IO.FileStream.Read%2A>, 메서드는 최소한 1 바이트의 데이터를 반환할 수 있습니다 때까지 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-865">If no data is available from the stream upon a call to <xref:System.IO.FileStream.Read%2A>, the method will block until at least one byte of data can be returned.</span></span> <span data-ttu-id="f20a1-866">구현을 스트림의 맨 끝에 도달 하지 않은 경우에 요청 된 것 보다 적은 바이트를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-866">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="f20a1-867">사용 하 여 <xref:System.IO.BinaryReader> 읽기 기본 데이터 형식에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-867">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
 <span data-ttu-id="f20a1-868">읽기 작업을 수행 하는 스레드를 중단 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-868">Do not interrupt a thread that is performing a read operation.</span></span> <span data-ttu-id="f20a1-869">응용 프로그램 스레드가 차단 해제 되 면 성공적으로 실행 하려면 나타날 수 있습니다 하지만 응용 프로그램의 성능 및 안정성 중단 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-869">Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</span></span>  
  
 <span data-ttu-id="f20a1-870">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-870">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-871">다음 예제에서는 콘텐츠를 <xref:System.IO.FileStream> 및 다른 쓰기 <xref:System.IO.FileStream>합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-871">The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.</span></span>  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-872">
            <paramref name="array" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-872">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-873">
            <paramref name="offset" /> 또는 <paramref name="count" />가 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-873">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-874">스트림이 읽기를 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-874">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-875">I/O 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-875">An I/O error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-876">
            <paramref name="offset" /> 및 <paramref name="count" />가 <paramref name="array" />에서 잘못된 범위를 설명하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-876">
              <paramref name="offset" /> and <paramref name="count" /> describe an invalid range in <paramref name="array" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-877">스트림이 닫힌 후에 메서드가 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-877">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="f20a1-878">데이터를 쓸 버퍼입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-878">The buffer to write the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="f20a1-879">스트림의 데이터를 쓰기 시작할 <c>버퍼</c>의 바이트 오프셋입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-879">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="f20a1-880">읽을 최대 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-880">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="f20a1-881">취소 요청을 모니터링할 토큰입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-881">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-882">현재 스트림에서 바이트의 시퀀스를 비동기적으로 읽고 읽은 바이트 수만큼 스트림 내에서 앞으로 이동하며 취소 요청을 모니터링합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-882">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f20a1-883">비동기 읽기 작업을 나타내는 작업입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-883">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="f20a1-884">
            <paramref name="TResult" /> 매개 변수의 값은 버퍼 안으로 읽어들인 총 바이트 수를 포함합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-884">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="f20a1-885">현재 사용할 수 있는 바이트 수가 요청된 수보다 작을 경우 결과 값이 요청된 바이트 수보다 작을 수 있으며 스트림의 끝에 도달한 경우에는 0이 될 수도 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-885">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-886"><xref:System.IO.FileStream.ReadAsync%2A> 메서드를 사용 하면 주 스레드를 차단 하지 않고 리소스를 많이 사용 파일 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-886">The <xref:System.IO.FileStream.ReadAsync%2A> method enables you to perform resource-intensive file operations without blocking the main thread.</span></span> <span data-ttu-id="f20a1-887">이 성능 고려 사항은 특히 시간이 소비되는 스트림 작업이 UI 스레드를 차단하고 응용 프로그램이 작동하지 않는 것처럼 표시할 수 있는 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 응용 프로그램 또는 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 응용 프로그램에서 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-887">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="f20a1-888">비동기 메서드를 함께에서 사용 합니다 `async` 고 `await` Visual Basic 및 C# 키워드입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-888">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="f20a1-889">사용 된 <xref:System.IO.FileStream.CanRead%2A> 현재 인스턴스가 읽기를 지원 하는지 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-889">Use the <xref:System.IO.FileStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="f20a1-890">완료 되기 전에 작업이 취소 되 면 반환 된 작업이 포함 된 <xref:System.Threading.Tasks.TaskStatus.Canceled> 에 대 한 값는 <xref:System.Threading.Tasks.Task.Status%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="f20a1-890">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="f20a1-891">파일 핸들을 삭제 하는 경우 반환 된 작업이 포함 된 <xref:System.ObjectDisposedException> 예외를 <xref:System.Threading.Tasks.Task.Exception%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="f20a1-891">If the handle to the file is disposed, the returned task contains the <xref:System.ObjectDisposedException> exception in the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-892">다음 예제에서는 비동기적으로 파일을 읽는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-892">The following example shows how to read from a file asynchronously.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-893">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-893">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-894">
            <paramref name="offset" /> 또는 <paramref name="count" />가 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-894">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-895">
            <paramref name="offset" /> 및 <paramref name="count" />의 합계가 버퍼 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-895">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-896">스트림이 읽기를 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-896">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-897">스트림이 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-897">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f20a1-898">스트림을 현재 이전 읽기 작업에서 사용 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-898">The stream is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-899">파일에서 1바이트를 읽고 읽기 위치를 1바이트만큼 앞으로 이동합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-899">Reads a byte from the file and advances the read position one byte.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f20a1-900">
            <see cref="T:System.Int32" />로 캐스팅된 바이트이거나 스트림의 끝에 도달한 경우 -1입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-900">The byte, cast to an <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-901">이 메서드는 <xref:System.IO.Stream.ReadByte%2A>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-901">This method overrides <xref:System.IO.Stream.ReadByte%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-902">사용 된 <xref:System.IO.FileStream.CanRead%2A> 현재 인스턴스가 읽기를 지원 하는지 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-902">Use the <xref:System.IO.FileStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="f20a1-903">자세한 내용은 <xref:System.IO.Stream.CanRead%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-903">For additional information, see <xref:System.IO.Stream.CanRead%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-904">다음 코드 예제에서는 바이트 단위로 파일에 데이터를 쓰고 다음 데이터 쓰여졌는지 확인 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-904">The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-905">현재 스트림이 읽기를 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-905">The current stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-906">현재 스트림이 닫혀 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-906">The current stream is closed.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="f20a1-907">
            <para>기본 구현을 <see langword="Stream" /> 새 싱글바이트 배열을 만들고 호출 <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />합니다. 공식적으로 올바른 중일 것은 비효율적입니다. 내부 버퍼를 사용 하 여 스트림을이 메서드를 재정의 하 고 버퍼에 대 한 모든 호출 추가 배열 할당 방지를 직접 읽는 훨씬 더 효율적으로 버전을 제공 해야 합니다.  일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-907">
              <para>The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.  For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f20a1-908">현재 <see cref="T:System.IO.FileStream" /> 개체가 캡슐화하는 파일에 대한 운영 체제 파일 핸들을 나타내는 <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> 개체를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-908">Gets a <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> object that represents the operating system file handle for the file that the current <see cref="T:System.IO.FileStream" /> object encapsulates.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f20a1-909">현재 <see cref="T:System.IO.FileStream" /> 개체가 캡슐화하는 파일에 대한 운영 체제 파일 핸들을 나타내는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-909">An object that represents the operating system file handle for the file that the current <see cref="T:System.IO.FileStream" /> object encapsulates.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-910"><xref:System.IO.FileStream.SafeFileHandle%2A> 자동으로 스트림을 플러시합니다 속성과 현재 스트림 위치를 0으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-910">The <xref:System.IO.FileStream.SafeFileHandle%2A> property automatically flushes the stream and sets the current stream position to 0.</span></span>  <span data-ttu-id="f20a1-911">이렇게 하면 이동할 파일 또는 스트림 위치를 사용 하 여 다른 stream으로 다시 설정할 수는 <xref:System.IO.FileStream.SafeFileHandle%2A> 이 속성에서 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-911">This allows the file to be moved or the stream position to be reset by another stream using the <xref:System.IO.FileStream.SafeFileHandle%2A> returned by this property.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f20a1-912">관리 되지 않는 코드를 호출할 수 있는 권한입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-912">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="f20a1-913">보안 작업: 링크 요청</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-913">Security action: Link Demand</span>
          </span>
          <span data-ttu-id="f20a1-914">연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-914">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f20a1-915">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-915">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f20a1-916">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-916">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">
          <span data-ttu-id="f20a1-917">검색을 시작할 <c>원본</c>에 상대적인 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-917">The point relative to <c>origin</c> from which to begin seeking.</span>
          </span>
        </param>
        <param name="origin">
          <span data-ttu-id="f20a1-918">
            <see cref="T:System.IO.SeekOrigin" /> 형식의 값을 사용하여 시작, 끝 또는 현재 위치를 <c>오프셋</c>에 대한 참조 지점으로 지정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-918">Specifies the beginning, the end, or the current position as a reference point for <c>offset</c>, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-919">이 스트림의 현재 위치를 제공된 값으로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-919">Sets the current position of this stream to the given value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f20a1-920">스트림 내의 새 위치입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-920">The new position in the stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-921">이 메서드는 <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-921">This method overrides <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-922">사용 된 <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> 현재 인스턴스 검색을 지원 하는지 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-922">Use the <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> property to determine whether the current instance supports seeking.</span></span> <span data-ttu-id="f20a1-923">자세한 내용은 <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-923">For additional information, see <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f20a1-924">스트림의 길이 초과 하는 위치를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-924">You can seek to any location beyond the length of the stream.</span></span> <span data-ttu-id="f20a1-925">파일의 길이 넘어서 검색 하면 파일 크기가 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-925">When you seek beyond the length of the file, the file size grows.</span></span> <span data-ttu-id="f20a1-926">Windows NT 및 이상 버전에서 파일의 끝에 추가 된 데이터를 0으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-926">In Windows NT and later versions, data added to the end of the file is set to zero.</span></span> <span data-ttu-id="f20a1-927">Windows 98 또는 이전 버전에서 파일의 끝에 추가 된 데이터를 0으로 이전에 데이터를 삭제 하는 스트림에 표시 하지 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-927">In Windows 98 or earlier versions, data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</span></span>  
  
 <span data-ttu-id="f20a1-928">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-928">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-929">다음 예제에서는 바이트 단위로 파일에 데이터를 쓰고 다음 데이터 쓰여졌는지 확인 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-929">The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 <span data-ttu-id="f20a1-930">다음 예제에서는 다양 한를 사용 하 여 파일의 시작 부분에 파일의 끝에서는 반대 방향으로 텍스트를 읽고 <xref:System.IO.SeekOrigin> 값을 <xref:System.IO.FileStream.Seek%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f20a1-930">The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the <xref:System.IO.FileStream.Seek%2A> method.</span></span>  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-931">I/O 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-931">An I/O error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-932">
            <see langword="FileStream" />이 파이프 또는 콘솔 출력에서 생성되는 경우와 같이 스트림이 검색을 지원하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-932">The stream does not support seeking, such as if the <see langword="FileStream" /> is constructed from a pipe or console output.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-933">스트림의 시작 이전부터 검색이 시도되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-933">Seeking is attempted before the beginning of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-934">스트림이 닫힌 후에 메서드가 호출되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-934">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">
          <span data-ttu-id="f20a1-935">현재 파일에 적용할 ACL 항목을 설명하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-935">An object that describes an ACL entry to apply to the current file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-936">
            <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체에서 설명하는 ACL(액세스 제어 목록) 항목을 현재 <see cref="T:System.IO.FileStream" /> 개체에서 설명하는 파일에 적용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-936">Applies access control list (ACL) entries described by a <see cref="T:System.Security.AccessControl.FileSecurity" /> object to the file described by the current <see cref="T:System.IO.FileStream" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-937">하는 동안를 <xref:System.IO.FileStream> 클래스 및 <xref:System.IO.FileStream.SetAccessControl%2A> 기존 파일에서 사용할 수 있습니다를 사용 하는 것이 좋습니다는 <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> 메서드를 사용 하기가 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-937">While the <xref:System.IO.FileStream> class and <xref:System.IO.FileStream.SetAccessControl%2A> can be used on an existing file, consider using the <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> method as it is easier to use.</span></span>  
  
 <span data-ttu-id="f20a1-938"><xref:System.IO.FileStream.SetAccessControl%2A> 메서드 상속 되지 않은 ACL 목록을 표시 하는 파일에 액세스 제어 목록 (ACL) 항목을 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-938">The <xref:System.IO.FileStream.SetAccessControl%2A> method applies access control list (ACL) entries to a file that represents the noninherited ACL list.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f20a1-939">에 대해 지정 된 ACL을 `fileSecurity` 매개 변수 파일에 대 한 기존 ACL을 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-939">The ACL specified for the `fileSecurity` parameter replaces the existing ACL for the file.</span></span> <span data-ttu-id="f20a1-940">에 새 사용자에 대 한 권한을 추가 하려면 사용 합니다 <xref:System.IO.FileStream.GetAccessControl%2A> 메서드를 추가 하려면, 수정 및 사용 하 여 <xref:System.IO.FileStream.SetAccessControl%2A> 파일에 다시 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-940">To add permissions for a new user, use the <xref:System.IO.FileStream.GetAccessControl%2A> method to obtain the existing ACL, modify it, and then use <xref:System.IO.FileStream.SetAccessControl%2A> to apply it back to the file.</span></span>  
  
 <span data-ttu-id="f20a1-941">ACL에는 개인 및/또는 그룹 했거나 권한이 없는, 지정된 된 파일에서 특정 작업을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-941">An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</span></span> <span data-ttu-id="f20a1-942">자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f20a1-942">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-943">파일이 닫혀 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-943">The file is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-944">
            <paramref name="fileSecurity" /> 매개 변수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-944">The <paramref name="fileSecurity" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="f20a1-945">파일을 찾을 수 없거나 수정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-945">The file could not be found or modified.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="f20a1-946">현재 프로세스에 파일을 열 수 있는 액세스 권한이 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-946">The current process does not have access to open the file.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="f20a1-947">스트림의 새 길이입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-947">The new length of the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-948">이 스트림의 길이를 제공된 값으로 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-948">Sets the length of this stream to the given value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-949">이 메서드는 <xref:System.IO.Stream.SetLength%2A>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-949">This method overrides <xref:System.IO.Stream.SetLength%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-950">지정된 된 값을 사용 하면 스트림의 현재 길이 보다 작으면, 스트림을 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-950">If the given value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="f20a1-951">이 시나리오에서는 현재 위치에 새 길이 보다 크면 스트림의 마지막 바이트를 현재 위치 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-951">In this scenario, if the current position is greater than the new length, the current position is moved to the last byte of the stream.</span></span> <span data-ttu-id="f20a1-952">지정된 된 값이 스트림의 현재 길이 보다 크면 스트림의 확장 되 고 현재 위치는 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-952">If the given value is larger than the current length of the stream, the stream is expanded, and the current position remains the same.</span></span> <span data-ttu-id="f20a1-953">스트림을 확장 하는 경우에 이전부터 새 길이 스트림의 내용을 정의 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-953">If the stream is expanded, the contents of the stream between the old and the new length are undefined.</span></span>  
  
 <span data-ttu-id="f20a1-954">스트림이 쓰기와 검색을 모두 지원 해야 `SetLength` 작동 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-954">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-955">사용 된 <xref:System.IO.FileStream.CanWrite%2A> 현재 인스턴스가 쓰기를 지원 하는지 여부를 결정 하는 속성 및 <xref:System.IO.FileStream.CanSeek%2A> 속성 검색을 지원 하는지 여부를 확인 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-955">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing, and the <xref:System.IO.FileStream.CanSeek%2A> property to determine whether seeking is supported.</span></span> <span data-ttu-id="f20a1-956">자세한 내용은 <xref:System.IO.Stream.CanWrite%2A> 및 <xref:System.IO.Stream.CanSeek%2A>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f20a1-956">For additional information, see <xref:System.IO.Stream.CanWrite%2A> and <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-957">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-957">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-958">I/O 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-958">An I/O error has occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-959">스트림이 쓰기 및 검색 둘 다를 지원하지는 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-959">The stream does not support both writing and seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-960">
            <paramref name="value" /> 매개 변수를 0 미만으로 설정하려 한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-960">Attempted to set the <paramref name="value" /> parameter to less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">
          <span data-ttu-id="f20a1-961">잠금을 해제할 범위의 시작입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-961">The beginning of the range to unlock.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="f20a1-962">잠금을 해제할 범위입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-962">The range to be unlocked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-963">다른 프로세스에서 이전에 잠근 파일의 일부 또는 전부에 액세스할 수 있도록 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-963">Allows access by other processes to all or part of a file that was previously locked.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-964">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-964">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-965">다음 코드 예제에는 다른 프로세스 수 없습니다. 파일에 읽기/쓰기 액세스를 포함 하더라도 파일의 해당 부분에 액세스 하 고 지정된 된 부분 파일 잠금을 해제 한 다음 파일의 일부를 차단 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-965">The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file .</span></span> <span data-ttu-id="f20a1-966">다른 명령 창에서 프로그램을 동시에 실행 하 고 다른 콘솔 입력된 옵션을 사용 하 여 조사 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-966">Run the program simultaneously in different command windows and investigate using the different console input options.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-967">
            <paramref name="position" /> 또는 <paramref name="length" />가 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-967">
              <paramref name="position" /> or <paramref name="length" /> is negative.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="f20a1-968">스트림에 쓸 데이터를 포함하는 버퍼입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-968">The buffer containing data to write to the stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="f20a1-969">스트림으로 바이트를 복사하기 시작할 <c>배열</c>의 바이트 오프셋(0부터 시작)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-969">The zero-based byte offset in <c>array</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="f20a1-970">쓸 최대 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-970">The maximum number of bytes to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-971">바이트 블록을 파일 스트림에 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-971">Writes a block of bytes to the file stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-972">이 메서드는 <xref:System.IO.Stream.Write%2A>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-972">This method overrides <xref:System.IO.Stream.Write%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-973">합니다 `offset` 의 바이트 오프셋을 제공 하는 매개 변수 `array` (버퍼 인덱스) 복사를 시작 하는 및 `count` 매개 변수는 스트림에 쓸 바이트 수를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-973">The `offset` parameter gives the offset of the byte in `array` (the buffer index) at which to begin copying, and the `count` parameter gives the number of bytes that will be written to the stream.</span></span> <span data-ttu-id="f20a1-974">쓰기 작업이 성공한 경우 스트림의 현재 위치는 쓴 바이트 수 만큼 앞 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-974">If the write operation is successful, the current position of the stream is advanced by the number of bytes written.</span></span> <span data-ttu-id="f20a1-975">예외가 발생 하는 경우 스트림의 현재 위치가 변경 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-975">If an exception occurs, the current position of the stream is unchanged.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-976">사용 된 <xref:System.IO.FileStream.CanWrite%2A> 현재 인스턴스가 쓰기를 지원 하는지 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-976">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="f20a1-977">자세한 내용은 <xref:System.IO.Stream.CanWrite%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-977">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-978">쓰기 작업을 수행 하는 스레드를 중단 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-978">Do not interrupt a thread that is performing a write operation.</span></span> <span data-ttu-id="f20a1-979">응용 프로그램 스레드가 차단 해제 되 면 성공적으로 실행 하려면 나타날 수 있습니다 하지만 응용 프로그램의 성능 및 안정성 중단 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-979">Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</span></span>  
  
 <span data-ttu-id="f20a1-980">일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-980">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-981">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.IO.FileStream.Lock%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="f20a1-981">This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-982">
            <paramref name="array" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-982">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-983">
            <paramref name="offset" /> 및 <paramref name="count" />가 <paramref name="array" />에서 잘못된 범위를 설명하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-983">
              <paramref name="offset" /> and <paramref name="count" /> describe an invalid range in <paramref name="array" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-984">
            <paramref name="offset" /> 또는 <paramref name="count" />가 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-984">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="f20a1-985">I/O 오류가 발생했습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-985">An I/O error occurred.</span>
          </span>
          <span data-ttu-id="f20a1-986">\- 또는 -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-986">\- or -</span>
          </span>
          <span data-ttu-id="f20a1-987">다른 스레드가 운영 체제 파일 핸들의 위치를 예기치 않게 변경했을 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-987">Another thread may have caused an unexpected change in the position of the operating system's file handle.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-988">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-988">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-989">현재 스트림 인스턴스가 쓰기를 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-989">The current stream instance does not support writing.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="f20a1-990">데이터를 쓸 버퍼입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-990">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="f20a1-991">스트림으로 바이트를 복사하기 시작할 <c>버퍼</c>의 바이트 오프셋(0부터 시작)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-991">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="f20a1-992">쓸 최대 바이트 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-992">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="f20a1-993">취소 요청을 모니터링할 토큰입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-993">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-994">바이트의 시퀀스를 현재 스트림에 비동기적으로 쓰고 쓰여진 바이트 수만큼 이 스트림 내의 현재 위치를 앞으로 이동한 후 취소 요청을 모니터링합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-994">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f20a1-995">비동기 쓰기 작업을 나타내는 작업입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-995">A task that represents the asynchronous write operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-996"><xref:System.IO.FileStream.WriteAsync%2A> 메서드를 사용 하면 주 스레드를 차단 하지 않고 리소스를 많이 사용 파일 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-996">The <xref:System.IO.FileStream.WriteAsync%2A> method enables you to perform resource-intensive file operations without blocking the main thread.</span></span> <span data-ttu-id="f20a1-997">이 성능 고려 사항은 특히 시간이 소비되는 스트림 작업이 UI 스레드를 차단하고 응용 프로그램이 작동하지 않는 것처럼 표시할 수 있는 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 응용 프로그램 또는 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 응용 프로그램에서 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-997">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="f20a1-998">비동기 메서드를 함께에서 사용 합니다 `async` 고 `await` Visual Basic 및 C# 키워드입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-998">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="f20a1-999">사용 된 <xref:System.IO.FileStream.CanWrite%2A> 현재 인스턴스가 쓰기를 지원 하는지 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-999">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="f20a1-1000">완료 되기 전에 작업이 취소 되 면 반환 된 작업이 포함 된 <xref:System.Threading.Tasks.TaskStatus.Canceled> 에 대 한 값는 <xref:System.Threading.Tasks.Task.Status%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="f20a1-1000">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="f20a1-1001">파일 핸들을 삭제 하는 경우 반환 된 작업이 포함 된 <xref:System.ObjectDisposedException> 예외를 <xref:System.Threading.Tasks.Task.Exception%2A> 속성.</span><span class="sxs-lookup"><span data-stu-id="f20a1-1001">If the handle to the file is disposed, the returned task contains the <xref:System.ObjectDisposedException> exception in the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-1002">다음 예제에서는 파일에 비동기적으로 작성 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-1002">The following example shows how to write asynchronously to a file.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f20a1-1003">
            <paramref name="buffer" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-1003">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f20a1-1004">
            <paramref name="offset" /> 또는 <paramref name="count" />가 음수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-1004">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f20a1-1005">
            <paramref name="offset" /> 및 <paramref name="count" />의 합계가 버퍼 길이보다 큽니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-1005">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-1006">스트림이 쓰기를 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-1006">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-1007">스트림이 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-1007">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f20a1-1008">이전 쓰기 작업에서 현재 이 스트림을 사용하고 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-1008">The stream is currently in use by a previous write operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="f20a1-1009">스트림에 쓸 바이트입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-1009">A byte to write to the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f20a1-1010">파일 스트림의 현재 위치에 바이트를 씁니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-1010">Writes a byte to the current position in the file stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f20a1-1011">이 메서드는 <xref:System.IO.Stream.WriteByte%2A>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-1011">This method overrides <xref:System.IO.Stream.WriteByte%2A>.</span></span>  
  
 <span data-ttu-id="f20a1-1012">사용 하 여 `WriteByte` 바이트를 쓸 수는 `FileStream` 효율적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-1012">Use `WriteByte` to write a byte to a `FileStream` efficiently.</span></span> <span data-ttu-id="f20a1-1013">스트림이 닫혔거나 쓸 수 없는 경우 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-1013">If the stream is closed or not writable, an exception will be thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f20a1-1014">사용 된 <xref:System.IO.FileStream.CanWrite%2A> 현재 인스턴스가 쓰기를 지원 하는지 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-1014">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="f20a1-1015">자세한 내용은 <xref:System.IO.Stream.CanWrite%2A>을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f20a1-1015">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f20a1-1016">다음 코드 예제에서는 바이트 단위로 파일에 데이터를 쓰고 다음 데이터 쓰여졌는지 확인 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f20a1-1016">The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f20a1-1017">스트림이 닫혔습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-1017">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f20a1-1018">스트림이 쓰기를 지원하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-1018">The stream does not support writing.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="f20a1-1019">
            <para>기본 구현을 <see langword="Stream" /> 새 싱글바이트 배열을 만들고 호출 <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />합니다. 공식적으로 올바른 중일 것은 비효율적입니다. 내부 버퍼를 사용 하 여 스트림을이 메서드를 재정의 하 고 버퍼에 대 한 모든 호출 추가 배열 할당 방지를 직접 읽는 훨씬 더 효율적으로 버전을 제공 해야 합니다.  일반적인 파일 및 디렉터리 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="f20a1-1019">
              <para>The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.  For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>