<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b474f106190397a69a4a6774dad7dd7746d74071" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52606340" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="0208b-101">파일이나 디렉터리 경로 정보를 포함하는 <see cref="T:System.String" /> 인스턴스에 대한 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="0208b-102">이러한 작업은 플랫폼 간에 호환되는 방식으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="0208b-103">경로가 파일 또는 디렉터리의 위치를 제공 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="0208b-104">디스크의 위치로 경로 반드시 가리키지 않습니다 예를 들어, 경로 메모리에 또는 장치에서 위치를 매핑할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="0208b-105">패스의 정확한 형식은 현재 플랫폼에 의해 결정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="0208b-106">예를 들어 일부 시스템 경로 시작할 수 드라이브 또는 볼륨 문자를 사용 하 여이 요소를 다른 시스템에 없을 때.</span><span class="sxs-lookup"><span data-stu-id="0208b-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="0208b-107">일부 시스템에서는 파일 경로 파일에 저장 된 정보 유형을 지정 하는 확장을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="0208b-108">파일 이름 확장명의 형식은 플랫폼에 따라 다릅니다. 예를 들어 일부 시스템 3 자에 대 한 확장을 제한 하 고 없기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="0208b-109">현재 플랫폼에는 또한 경로의 요소를 구분 하는 데 사용 되는 문자 집합 및 경로 지정 하는 경우에 사용할 수 없는 문자 집합을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="0208b-110">필드 이러한 차이로 인해 합니다 `Path` 클래스의 일부 멤버의 정확한 동작 뿐만 아니라는 `Path` 클래스는 플랫폼에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="0208b-111">경로 절대 또는 상대 위치 정보를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="0208b-112">위치를 완벽 하 게 지정 하는 절대 경로: 파일 또는 디렉터리 고유 하 게 식별할 수 현재 위치에 관계 없이 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="0208b-113">상대 경로 부분 위치를 지정 합니다: 상대 경로 사용 하 여 지정 된 파일을 찾을 때 현재 위치가 시작 지점으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="0208b-114">현재 디렉터리를 확인 하려면 호출 <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="0208b-115">.NET core 1.1 및 이후 버전 및.NET Framework 4.6.2 이상와 같은 장치 이름에는 파일 시스템 개체에 대 한 액세스도 지원 "\\? \C:\"합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="0208b-116">Windows에서 파일 경로 형식에 대 한 자세한 내용은 참조 하세요. [Windows 시스템에서 파일 경로 형식](~/docs/standard/io/file-path-formats.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="0208b-117">멤버는 대부분의 `Path` 클래스와 파일 시스템으로 작용 하지 경로 문자열에서 지정 된 파일의 존재 여부를 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="0208b-118">`Path` 클래스와 같은 경로 문자열을 수정 하는 멤버 <xref:System.IO.Path.ChangeExtension%2A>, 파일 시스템의 파일 이름에 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="0208b-119">`Path` 하지만 멤버 않습니다, 지정 된 경로 문자열의 내용을 검사 및 throw를 <xref:System.ArgumentException> 문자열에서 반환 된 문자에 정의 된 경로 문자열에서 유효 하지 않은 문자를 포함 하는 경우 예외를 <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="0208b-120">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 포함 될 수 있습니다 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), (\0), null 및 18 번 및 20부터 25 통해 유니코드 문자 16입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="0208b-121">멤버는 `Path` 클래스를 사용 하면 쉽고 빠르게 파일 이름 확장명을 경로의 일부를 인지 여부를 확인 하 고 두 문자열을 하나의 경로 이름으로 결합 등 일반적인 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="0208b-122">모든 멤버는 `Path` 클래스는 정적이 고 경로의 인스턴스 없이 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0208b-123">입력 문자열로 경로 허용 하는 멤버를 해당 경로 올바른 형식 이어야 합니다. 또는 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="0208b-124">예를 들어, 경로 정규화 공백으로 시작 하지만 경로 클래스의 메서드에서 잘리지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="0208b-125">따라서 경로 잘못 되었으며 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="0208b-126">마찬가지로, 경로 또는 경로의 조합을 두 번 정규화 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="0208b-127">예를 들어, "c:\temp c:\windows"는 또한 대부분의 경우에서 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="0208b-128">경로 잘 구성 된 경우에 경로 문자열을 허용 하는 메서드를 사용 하 여 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="0208b-129">경로 허용 하는 멤버의 경로 파일 또는 디렉터리를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="0208b-130">지정된 된 경로 상대 경로 또는 서버 및 공유 이름에 대 한 범용 명명 규칙 (UNC) 경로 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="0208b-131">예를 들어, 다음은 허용 가능한 경로.</span><span class="sxs-lookup"><span data-stu-id="0208b-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="0208b-132">"c:\\\MyDir\\\MyFile.txt" C# 또는 Visual Basic의 "c:\MyDir\MyFile.txt"입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="0208b-133">"c:\\\MyDir" C# 또는 Visual Basic의 "c:\MyDir"입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="0208b-134">"MyDir\\\MySubdir" C# 또는 Visual Basic의 "MyDir\MySubDir"입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="0208b-135">"\\\\\\\MyServer\\\MyShare" C#에서 또는 "\\\MyServer\MyShare" Visual Basic의 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="0208b-136">문자열에서 이러한 모든 작업이 수행 되 되므로 모든 시나리오에서 결과가 올바른지 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="0208b-137">예를 들어를 <xref:System.IO.Path.GetExtension%2A> 메서드를 전달 하는 문자열을 구문 분석 하 고 해당 문자열에서 확장명을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="0208b-138">그러나 해당 확장을 사용 하 여 파일을 디스크에 있는지이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="0208b-139">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-140">다음 코드 예제에서는 기본 멤버 중 일부를 보여 줍니다는 `Path` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-140">The following code example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-141">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-142">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-143">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="0208b-144">방법: 새로 만든 데이터 파일 읽기 및 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-144">How to: Read and Write to a Newly Created Data File</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0208b-145">계층적 파일 시스템 구조를 반영하는 경로 문자열에서 디렉터리 수준을 구분하는 데 사용되는 플랫폼 특정 대체 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-145">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-146">이 필드에 저장 된 문자에 있을 수 없습니다 <xref:System.IO.Path.InvalidPathChars>합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-146">The character stored in this field cannot be in <xref:System.IO.Path.InvalidPathChars>.</span></span> <span data-ttu-id="0208b-147">이 필드는 동일한 값으로 설정할 수 있습니다 <xref:System.IO.Path.DirectorySeparatorChar>합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-147">This field can be set to the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="0208b-148">`AltDirectorySeparatorChar` 및 <xref:System.IO.Path.DirectorySeparatorChar> 은 모두 경로 문자열에서 디렉터리 수준을 구분 하는 것에 대 한 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
 <span data-ttu-id="0208b-149">이 필드의 값은 Windows, UNIX, Macintosh 운영 체제에서 슬래시 ('/').</span><span class="sxs-lookup"><span data-stu-id="0208b-149">The value of this field is a slash ('/') on Windows, UNIX and Macintosh operating systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-150">다음 코드 예제를 사용 하는 방법을 보여 줍니다는 `AltDirectorySeparatorChar` 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-150">The following code example demonstrates a use of the `AltDirectorySeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-151">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-151">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-152">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-152">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-153">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-153">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="0208b-154">수정할 경로 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-154">The path information to modify.</span></span> <span data-ttu-id="0208b-155">경로에는 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 문자가 포함될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-155">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="0208b-156">앞에 마침표가 있거나 없는 새 확장명입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-156">The new extension (with or without a leading period).</span></span> <span data-ttu-id="0208b-157"><paramref name="path" />에서 기존 확장명을 제거하려면 <see langword="null" />을(를) 지정하세요.</span><span class="sxs-lookup"><span data-stu-id="0208b-157">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="0208b-158">경로 문자열의 확장명을 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-158">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="0208b-159">수정된 경로 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-159">The modified path information.</span></span>  
  
<span data-ttu-id="0208b-160">Windows 기반 데스크톱 플랫폼에서 <paramref name="path" />이(가) <see langword="null" />이거나 빈 문자열("")이면 경로 정보가 수정되지 않고 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-160">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="0208b-161"><paramref name="extension" />이(가) <see langword="null" />이면 반환된 문자열에 확장명이 제거된 지정된 경로가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-161">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="0208b-162"><paramref name="path" />에 확장명이 없고 <paramref name="extension" />이(가) <see langword="null" />이 아니면 반환된 경로 문자열에는 <paramref name="extension" /> 끝에 추가된 <paramref name="path" />이(가) 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-162">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-163">모두 `path` 나 `extension` 마침표 (.) `ChangeExtension` 기간을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-163">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="0208b-164">`extension` 매개 변수는 여러 개의 마침표 및 올바른 경로 문자를 포함할 수 있습니다 및 길이 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-164">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="0208b-165">경우 `extension` 됩니다 `null`, 반환된 된 문자열의 내용이 들어 `path` 마지막 기간 및 그 다음에 모든 문자 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-165">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="0208b-166">하는 경우 `extension` 빈 문자열이 면 반환된 된 경로 문자열의 내용이 들어 `path` 마지막 마침표 다음 문자를 사용 하 여 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-166">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="0208b-167">하는 경우 `path` 확장 되지 않은 및 `extension` 아닙니다 `null`, 반환 된 문자열에 포함 되어 `path` 뒤에 `extension`입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-167">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="0208b-168">하는 경우 `extension` 아닙니다 `null` 앞에 마침표를 포함 하지 않습니다 마침표가 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-168">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="0208b-169">경우 `path` 여러 마침표로 구분 된 여러 확장을 포함 합니다. 반환된 된 문자열의 내용을 포함 `path` 마지막을 사용 하 여 기간 및 다음 문자만으로 대체 `extension`합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-169">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="0208b-170">예를 들어 경우 `path` "\Dir1\examples\pathtests.csx.txt"은 및 `extension` "cs" 이면 수정 된 경로 "\Dir1\examples\pathtests.csx.cs"입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-170">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="0208b-171">반환된 된 결과 모든 시나리오에서 유효한 지 확인 하는 것이 불가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-171">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="0208b-172">예를 들어 있으면 `path` 비어 `extension` 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-172">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="0208b-173">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-173">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-174">다음 코드 예제를 사용 하는 방법을 보여 줍니다는 `ChangeExtension` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-174">The following code example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-175"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-175"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-176">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-176">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-177">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-177">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-178">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-178">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0208b-179">여러 문자열을 한 경로로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-179">Combines strings into a path.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="0208b-180">경로 각 부분의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-180">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="0208b-181">문자열 배열을 한 경로로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-181">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="0208b-182">결합된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-182">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-183">`paths` 배열을 결합 하는 경로 부분을 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-183">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="0208b-184">후속 경로 중 하나를 절대 경로 결합 작업을 다시 결합 된 모든 이전 경로 삭제 하는 절대 경로 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-184">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  
  
 <span data-ttu-id="0208b-185">길이가 0 인 문자열 조합된 된 경로에서 생략 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-185">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="0208b-186">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-186">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="0208b-187">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-187">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="0208b-188">예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-188">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="0208b-189">성공적으로 해석 되므로 `Combine` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-189">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-190">다음 예제에서는 경로에 문자열 배열을 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-190">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-191">배열의 문자열 중 하나에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-191">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0208b-192">배열의 문자열 중 하나가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-192">One of the strings in the array is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="0208b-193">결합할 첫 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-193">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="0208b-194">결합할 두 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-194">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="0208b-195">두 문자열을 한 경로로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-195">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="0208b-196">결합된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-196">The combined paths.</span></span> <span data-ttu-id="0208b-197">지정된 경로 중 하나가 0 길이의 문자열이면 이 메서드는 다른 경로를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-197">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="0208b-198"><paramref name="path2" />에 절대 경로가 포함되어 있으면 이 메서드는 <paramref name="path2" />을(를) 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-198">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-199">하는 경우 `path1` (즉, "c:" 또는 "d:") 드라이브 참조가 아닌 경우 및에 정의 된 대로 유효한 구분 기호 문자로 끝나지 않습니다 <xref:System.IO.Path.DirectorySeparatorChar>를 <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar>를 <xref:System.IO.Path.DirectorySeparatorChar> 에 추가 됩니다 `path1` 연결 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-199">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span>  
  
 <span data-ttu-id="0208b-200">경우 `path2` 루트를 포함 하지 않습니다 (예를 들어 `path2` 시작 하지 않고 구분 기호 문자 또는 드라이브 지정), 결과 중간에 다른 구분 기호 문자로 두 경로 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-200">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="0208b-201">하는 경우 `path2` 루트가 포함 `path2` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-201">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="0208b-202">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-202">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="0208b-203">따라서 경우 `path2` 공백 (예: "\file.txt")를 포함 합니다 <xref:System.IO.Path.Combine%2A> 메서드를 추가 `path2` 에 `path1` 만 반환 하는 대신 `path2`합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-203">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="0208b-204">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-204">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="0208b-205">예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-205">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="0208b-206">성공적으로 해석 되므로 `Combine` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-206">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="0208b-207">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-207">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-208">다음 코드 예제는 `Combine` Windows 기반 데스크톱 플랫폼에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-208">The following code example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-209"><paramref name="path1" /> 또는 <paramref name="path2" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-209"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0208b-210"><paramref name="path1" /> 또는 <paramref name="path2" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-210"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-211">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-211">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-212">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-212">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-213">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-213">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
        <Parameter Name="path3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="0208b-214">결합할 첫 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-214">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="0208b-215">결합할 두 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-215">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="0208b-216">결합할 세 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-216">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="0208b-217">세 문자열을 한 경로로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-217">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="0208b-218">결합된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-218">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-219">`path1` 절대 경로 여야 합니다 (예를 들어, "d:\archives" 또는 "\\\archives\public").</span><span class="sxs-lookup"><span data-stu-id="0208b-219">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="0208b-220">하는 경우 `path2` 또는 `path3` 결합 작업 이전에 모두 무시 항목 경로 및 절대 경로를 다시 설정 합니다. 절대 경로 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-220">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="0208b-221">길이가 0 인 문자열 조합된 된 경로에서 생략 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-221">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="0208b-222">하는 경우 `path1` (즉, "c:" 또는 "d:") 드라이브 참조가 아닌 경우 및에 정의 된 대로 유효한 구분 기호 문자로 끝나지 않습니다 <xref:System.IO.Path.DirectorySeparatorChar>를 <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar>를 <xref:System.IO.Path.DirectorySeparatorChar> 에 추가 됩니다 `path1` 연결 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-222">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span>  
  
 <span data-ttu-id="0208b-223">경우 `path2` 루트를 포함 하지 않습니다 (예를 들어 `path2` 시작 하지 않고 구분 기호 문자 또는 드라이브 지정), 결과 중간에 다른 구분 기호 문자로 두 경로 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-223">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="0208b-224">하는 경우 `path2` 루트가 포함 `path2` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-224">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="0208b-225">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-225">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="0208b-226">따라서 경우 `path2` 공백 문자 (예: "\file.txt")를 포함 합니다 <xref:System.IO.Path.Combine%2A> 메서드 추가 `path2` 에 `path1`입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-226">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="0208b-227">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-227">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="0208b-228">예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-228">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="0208b-229">성공적으로 해석 되므로 `Combine` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-229">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-230">다음 예제에서는 세 개의 경로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-230">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-231"><paramref name="path1" />, <paramref name="path2" /> 또는 <paramref name="path3" />이 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자 중 하나 이상을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-231"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0208b-232"><paramref name="path1" />, <paramref name="path2" /> 또는 <paramref name="path3" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-232"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
        <Parameter Name="path3" Type="System.String" />
        <Parameter Name="path4" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="0208b-233">결합할 첫 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-233">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="0208b-234">결합할 두 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-234">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="0208b-235">결합할 세 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-235">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="0208b-236">결합할 네 번째 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-236">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="0208b-237">네 문자열을 한 경로로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-237">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="0208b-238">결합된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-238">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-239">`path1` 절대 경로 여야 합니다 (예를 들어, "d:\archives" 또는 "\\\archives\public"). 후속 경로 중 하나 이면 절대 경로 결합 작업은 이전에 결합 된 모든 경로 삭제 하 고 절대 경로를 다시 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-239">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="0208b-240">길이가 0 인 문자열 조합된 된 경로에서 생략 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-240">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="0208b-241">하는 경우 `path1` (즉, "c:" 또는 "d:") 드라이브 참조가 아닌 경우 및에 정의 된 대로 유효한 구분 기호 문자로 끝나지 않습니다 <xref:System.IO.Path.DirectorySeparatorChar>를 <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar>를 <xref:System.IO.Path.DirectorySeparatorChar> 에 추가 됩니다 `path1` 연결 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-241">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span>  
  
 <span data-ttu-id="0208b-242">경우 `path2` 루트를 포함 하지 않습니다 (예를 들어 `path2` 시작 하지 않고 구분 기호 문자 또는 드라이브 지정), 결과 중간에 다른 구분 기호 문자로 두 경로 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-242">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="0208b-243">하는 경우 `path2` 루트가 포함 `path2` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-243">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="0208b-244">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-244">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="0208b-245">따라서 경우 `path2` 공백 문자 (예: "\file.txt")를 포함 합니다 <xref:System.IO.Path.Combine%2A> 메서드 추가 `path2` 에 `path1`입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-245">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="0208b-246">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-246">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="0208b-247">예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-247">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="0208b-248">성공적으로 해석 되므로 `Combine` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-248">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-249">다음 예제에서는 네 개의 경로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-249">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-250"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> 또는 <paramref name="path4" />가 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자 중 하나 이상을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-250"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0208b-251"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> 또는 <paramref name="path4" />가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-251"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0208b-252">계층적 파일 시스템 구조를 반영하는 경로 문자열에서 디렉터리 수준을 구분하는 데 사용되는 플랫폼 특정 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-252">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-253">이 필드에 저장 된 문자에 있을 수 없습니다 <xref:System.IO.Path.InvalidPathChars>합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-253">The character stored in this field cannot be in <xref:System.IO.Path.InvalidPathChars>.</span></span> <span data-ttu-id="0208b-254"><xref:System.IO.Path.AltDirectorySeparatorChar> 및 `DirectorySeparatorChar` 은 모두 경로 문자열에서 디렉터리 수준을 구분 하는 것에 대 한 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-254"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-255">다음 코드 예제에서는 `DirectorySeparatorChar` 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-255">The following code example demonstrates the use of the `DirectorySeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-256">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-256">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-257">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-257">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-258">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-258">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="0208b-259">파일 또는 디렉터리의 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-259">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="0208b-260">지정된 경로 문자열에 대한 디렉터리 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-260">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="0208b-261"><paramref name="path" />에 대한 디렉터리 정보이며, <paramref name="path" />이(가) 루트 디렉터리를 나타내거나 null인 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-261">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="0208b-262"><paramref name="path" />에 디렉터리 정보가 포함되어 있지 않으면 <see cref="F:System.String.Empty" />이(가) 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-262">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-263">대부분의 경우에서이 메서드에서 반환 된 문자열 모든 문자로 구성 경로의 마지막 포함 되지 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-263">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="0208b-264">경로 구성 된 경우의 루트 디렉터리와 같은 "c:\\", null이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-264">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="0208b-265">이 메서드를 사용 하 여 경로 지원 하지 않습니다 "파일:".</span><span class="sxs-lookup"><span data-stu-id="0208b-265">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="0208b-266">반환 된 경로 포함 되어 있지 않으므로 합니다 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 다시 반환 된 경로 전달 합니다 <xref:System.IO.Path.GetDirectoryName%2A> 메서드는 결과 문자열에 대 한 후속 호출 당 하나의 폴더 수준의 잘림이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-266">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="0208b-267">예를 들어, "C:\Directory\SubDirectory\test.txt" 경로에 전달 된 <xref:System.IO.Path.GetDirectoryName%2A> 메서드는 "C:\Directory\SubDirectory"를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-267">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="0208b-268">해당 문자열이 "C:\Directory\SubDirectory" 전달 <xref:System.IO.Path.GetDirectoryName%2A> "C:\Directory" 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-268">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="0208b-269">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-269">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-270">다음 코드 예제는 `GetDirectoryName` Windows 기반 데스크톱 플랫폼에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-270">The following code example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-271"><paramref name="path" /> 매개 변수가 잘못된 문자를 포함하거나, 비어 있거나, 공백만 포함하는 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-271">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="0208b-272"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-272">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="0208b-273"><paramref name="path" /> 매개변수가 시스템에 정의된 최대 길이보다 깁니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-273">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-274">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-274">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-275">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-275">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-276">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-276">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="0208b-277">확장명을 가져올 경로 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-277">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="0208b-278">지정된 경로 문자열에서 확장명을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-278">Returns the extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="0208b-279">"."(마침표)를 포함한 지정된 경로의 확장명, <see langword="null" /> 또는 <see cref="F:System.String.Empty" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-279">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="0208b-280"><paramref name="path" />이(가) <see langword="null" />이면, <see cref="M:System.IO.Path.GetExtension(System.String)" />은(는) <see langword="null" />을(를) 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-280">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="0208b-281"><paramref name="path" />에 확장명 정보가 없는 경우 <see cref="M:System.IO.Path.GetExtension(System.String)" />은(는) <see cref="F:System.String.Empty" />을(를) 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-281">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-282">확장명 `path` 를 검색 하 여 가져온 `path` 경로의 시작까지의 마지막 문자를 사용 하 여 시작 마침표 (.).</span><span class="sxs-lookup"><span data-stu-id="0208b-282">The extension of `path` is obtained by searching `path` for a period (.), starting with the last character in path and continuing toward the start of path.</span></span> <span data-ttu-id="0208b-283">잠시 전에 발견 되는 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar> 뒤; 기간 및 문자를 포함 하는 반환 되는 문자열 문자이 고, 그렇지 <xref:System.String.Empty> 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-283">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty> is returned.</span></span>  
  
 <span data-ttu-id="0208b-284">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-284">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-285">다음 코드 예제는 `GetExtension` Windows 기반 데스크톱 플랫폼에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-285">The following code example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-286"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-286"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-287">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-287">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-288">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-288">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-289">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-289">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="0208b-290">파일 이름과 확장명을 가져올 경로 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-290">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="0208b-291">지정된 경로 문자열에서 파일 이름과 확장명을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-291">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="0208b-292"><paramref name="path" />에서 마지막 디렉터리 문자 다음의 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-292">The characters after the last directory character in <paramref name="path" />.</span></span> <span data-ttu-id="0208b-293"><paramref name="path" />의 마지막 문자가 디렉터리나 볼륨 구분 문자이면 이 메서드는 <see cref="F:System.String.Empty" />을(를) 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-293">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="0208b-294"><paramref name="path" />이(가) <see langword="null" />이면 이 메서드는 <see langword="null" />을(를) 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-294">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-295">반환된 된 값이 `null` 파일 경로 이면 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-295">The returned value is `null` if the file path is `null`.</span></span>  
  
 <span data-ttu-id="0208b-296">시작 파일 이름 부분을 확인 하는 데 구분 기호 문자 <xref:System.IO.Path.DirectorySeparatorChar> 고 <xref:System.IO.Path.AltDirectorySeparatorChar>입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-296">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  
  
 <span data-ttu-id="0208b-297">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-297">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-298">다음 코드 예제에서는 동작을 보여 줍니다.는 `GetFileName` Windows 기반 데스크톱 플랫폼에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-298">The following code example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-299"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-299"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-300">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-300">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-301">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-301">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-302">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-302">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="0208b-303">파일의 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-303">The path of the file.</span></span></param>
        <summary><span data-ttu-id="0208b-304">확장명 없이 지정된 경로 문자열의 파일 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-304">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="0208b-305">마지막 마침표(.)와 그 다음에 나오는 모든 문자인 <see cref="M:System.IO.Path.GetFileName(System.String)" />에서 반환한 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-305">The string returned by <see cref="M:System.IO.Path.GetFileName(System.String)" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-306">이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-306">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="0208b-307">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-307">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-308">다음 코드 예제를 사용 하는 방법을 보여 줍니다는 `GetFileNameWithoutExtension` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-308">The following code example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-309"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-309"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-310">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-310">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-311">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-311">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-312">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-312">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="0208b-313">절대 경로 정보를 가져올 파일 또는 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-313">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="0208b-314">지정된 경로 문자열에 대한 절대 경로를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-314">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="0208b-315">"C:\MyFile.txt"처럼 <paramref name="path" />의 정규화된 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-315">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="0208b-316">시스템에서 파일 또는 디렉터리를 찾는 데 필요한 모든 정보를 포함 하는 절대 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-316">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="0208b-317">파일 또는 지정 된 디렉터리가 `path` 있이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-317">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="0208b-318">C:\temp\newdir 현재 디렉터리 이면 호출 하는 예를 들어 `GetFullPath` 파일로 c:\temp\newdir\test.txt test.txt 같은 이름을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-318">For example, if c:\temp\newdir is the current directory, calling `GetFullPath` on a file name such as test.txt returns c:\temp\newdir\test.txt.</span></span> <span data-ttu-id="0208b-319">파일이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-319">The file need not exist.</span></span>  
  
 <span data-ttu-id="0208b-320">그러나 경우 `path` 없으면 호출자에 대 한 경로 정보를 얻을 수 있는 권한이 있어야 합니다. `path`합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-320">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="0208b-321">멤버는 대부분 달리는 <xref:System.IO.Path> 클래스,이 메서드는 파일 시스템에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-321">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="0208b-322">이 메서드는 현재 디렉터리와 현재 볼륨 정보를 완전히 정규화 사용 `path`합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-322">This method uses current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="0208b-323">파일을 지정 하는 경우에 이름을 `path`, `GetFullPath` 현재 디렉터리의 정규화 된 경로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-323">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="0208b-324">짧은 파일 이름에 전달 하는 경우 긴 파일 이름으로 확장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-324">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="0208b-325">경로 중요 한 문자가 없는 경우 사용할 수 없는 하나 이상 포함 되어 있지 않으면 "."문자 뒤에 공백 개수에 관계 없이 다음으로 구문 분석 됩니다"."또는"..".</span><span class="sxs-lookup"><span data-stu-id="0208b-325">If a path contains no significant characters it is invalid unless it contains one or more "." characters followed by any number of spaces, then it will be parsed as either "." or "..".</span></span>  

  <span data-ttu-id="0208b-326">.NET core 1.1 및 이후 버전 및.NET Framework 4.6.2 및 이상 버전도 같은 장치 이름을 포함 하는 경로 지원 "\\? \C:\"합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-326">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="0208b-327">Windows에서 파일 경로 형식에 대 한 자세한 내용은 참조 하세요. [Windows 시스템에서 파일 경로 형식](~/docs/standard/io/file-path-formats.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-327">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="0208b-328">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-328">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="0208b-329">다음 예제는 `GetFullPath` Windows 기반 데스크톱 플랫폼에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-329">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-330"><paramref name="path" />가 길이가 0인 문자열이거나 공백만 포함하거나 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 하나 이상의 잘못된 문자를 포함하는 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-330"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="0208b-331">또는</span><span class="sxs-lookup"><span data-stu-id="0208b-331">-or-</span></span> 
<span data-ttu-id="0208b-332">절대 경로를 검색할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-332">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0208b-333">호출자에게 필요한 사용 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-333">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0208b-334"><paramref name="path" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-334"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0208b-335"><paramref name="path" />에 볼륨 식별자(예: "c:\\")의 일부가 아닌 콜론(":")이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-335"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="0208b-336">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-336">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="0208b-337">경로에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-337">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-338">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-338">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-339">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-339">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-340">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-340">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="basePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="basePath">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0208b-341">파일 이름에 사용할 수 없는 문자가 포함된 배열을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-341">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="0208b-342">파일 이름에 사용할 수 없는 문자가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-342">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-343">이 메서드에서 반환 된 배열 전체 파일 및 디렉터리 이름에 잘못 된 문자 집합을 포함 하는 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-343">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="0208b-344">전체 집합이 잘못 된 문자는 파일 시스템에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-344">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="0208b-345">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 있습니다/유니코드 문자 1-31, 뿐만 아니라 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-345">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-346">다음 코드 예제는 <xref:System.IO.Path.GetInvalidFileNameChars%2A> 메서드 및 <xref:System.IO.Path.GetInvalidPathChars%2A> 잘못 된 문자를 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-346">The following code example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0208b-347">경로 이름에 사용할 수 없는 문자가 포함된 배열을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-347">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="0208b-348">파일 이름에 사용할 수 없는 문자가 포함된 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-348">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-349">이 메서드에서 반환 된 배열 전체 파일 및 디렉터리 이름에 잘못 된 문자 집합을 포함 하는 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-349">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="0208b-350">전체 집합이 잘못 된 문자는 파일 시스템에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-350">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="0208b-351">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 있습니다/유니코드 문자 1-31, 뿐만 아니라 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-351">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-352">다음 코드 예제는 <xref:System.IO.Path.GetInvalidFileNameChars%2A> 메서드 및 <xref:System.IO.Path.GetInvalidPathChars%2A> 잘못 된 문자를 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-352">The following code example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="0208b-353">루트 디렉터리 정보를 가져올 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-353">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="0208b-354">지정된 문자 범위에 포함된 경로에서 루트 디렉터리 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-354">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="0208b-355">`path`의 루트 디렉터리를 포함하는 문자 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-355">A character span containing the root directory of `path`.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="0208b-356">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="0208b-356">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="0208b-357">루트 디렉터리 정보를 가져올 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-357">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="0208b-358">지정된 경로의 루트 디렉터리 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-358">Gets the root directory information of the specified path.</span></span></summary>
        <returns><span data-ttu-id="0208b-359"><paramref name="path" />의 루트 디렉터리이며, <paramref name="path" />가 <see langword="null" />인 경우 <see langword="null" />이며 <paramref name="path" />에 루트 디렉터리 정보가 포함되어 있지 않은 경우 빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-359">The root directory of <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> is <see langword="null" />, or an empty string if <paramref name="path" /> does not contain root directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-360">이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-360">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="0208b-361">이 메서드에서 반환 된 문자열에 대 한 가능한 패턴은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-361">Possible patterns for the string returned by this method are as follows:</span></span>  
  
- <span data-ttu-id="0208b-362">빈 문자열 (`path` 현재 드라이브 또는 볼륨에 대 한 상대 경로 지정).</span><span class="sxs-lookup"><span data-stu-id="0208b-362">An empty string (`path` specified a relative path on the current drive or volume).</span></span>  
  
- <span data-ttu-id="0208b-363">"\" (`path` 현재 드라이브의 절대 경로 지정).</span><span class="sxs-lookup"><span data-stu-id="0208b-363">"\" (`path` specified an absolute path on the current drive).</span></span>  
  
- <span data-ttu-id="0208b-364">"X:" (`path` 여기서 X 나타냅니다 드라이브 또는 볼륨 문자를 드라이브에 대 한 상대 경로 지정).</span><span class="sxs-lookup"><span data-stu-id="0208b-364">"X:" (`path` specified a relative path on a drive, where X represents a drive or volume letter).</span></span>  
  
- <span data-ttu-id="0208b-365">"X:\" (`path` 절대 경로가 지정된 된 드라이브에서 지정).</span><span class="sxs-lookup"><span data-stu-id="0208b-365">"X:\" (`path` specified an absolute path on a given drive).</span></span>  
  
- <span data-ttu-id="0208b-366">"\\\ComputerName\SharedFolder" (UNC 경로).</span><span class="sxs-lookup"><span data-stu-id="0208b-366">"\\\ComputerName\SharedFolder" (a UNC path).</span></span>  
  
- <span data-ttu-id="0208b-367">"\\? \C:" (DOS 장치 경로.NET Core 1.1 이상 및.NET Framework 4.6.2 이상 버전에서 지원)</span><span class="sxs-lookup"><span data-stu-id="0208b-367">"\\?\C:" (a DOS device path, supported in .NET Core 1.1 and later versions and in .NET Framework 4.6.2 and later versions)</span></span>
   
 <span data-ttu-id="0208b-368">Windows에서 파일 경로에 대 한 자세한 내용은 참조 하세요. [Windows 시스템에서 파일 경로 형식](~/docs/standard/io/file-path-formats.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-368">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="0208b-369">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-369">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## Examples  
 <span data-ttu-id="0208b-370">다음 코드 예제를 사용 하는 방법을 보여 줍니다는 `GetPathRoot` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-370">The following code example demonstrates a use of the `GetPathRoot` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-371"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-371"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="0208b-372">또는</span><span class="sxs-lookup"><span data-stu-id="0208b-372">-or-</span></span> 
 <span data-ttu-id="0208b-373"><paramref name="path" />에 <see cref="F:System.String.Empty" />가 전달된 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-373"><see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="0208b-374">Windows 시스템의 파일 경로 형식</span><span class="sxs-lookup"><span data-stu-id="0208b-374">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-375">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-375">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-376">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-376">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-377">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-377">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0208b-378">임의의 폴더 이름 또는 파일 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-378">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="0208b-379">임의의 폴더 이름 또는 파일 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-379">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-380"><xref:System.IO.Path.GetRandomFileName%2A> 메서드는 폴더 이름 또는 파일 이름으로 사용할 수 있는 강력 하 게 암호화, 임의 문자열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-380">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="0208b-381">와 달리 <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> 파일을 만들지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-381">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="0208b-382">파일 시스템의 보안을 매우 중요 하지만,이 메서드 대신 사용 해야 <xref:System.IO.Path.GetTempFileName%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-382">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-383">다음 예제에서 출력 보기는 <xref:System.IO.Path.GetRandomFileName%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-383">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeTo">To be added.</param>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0208b-384">디스크에 크기가 0바이트인 고유한 이름의 임시 파일을 만들고 해당 파일의 전체 경로를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-384">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="0208b-385">임시 파일의 전체 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-385">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-386">이 방법을 사용 하 여 임시 파일을 만듭니다는 합니다. TMP 파일 확장명입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-386">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="0208b-387">사용자의 임시 폴더 경로 내에서 임시 파일을 만들 반환한는 <xref:System.IO.Path.GetTempPath%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-387">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="0208b-388">합니다 <xref:System.IO.Path.GetTempFileName%2A> 메서드를 발생 시킵니다는 <xref:System.IO.IOException> 이전 임시 파일을 삭제 하지 않고 65535 개 파일을 만들려면 사용 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="0208b-388">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="0208b-389">합니다 <xref:System.IO.Path.GetTempFileName%2A> 메서드를 발생 시킵니다는 <xref:System.IO.IOException> 고유한 임시 파일 이름은 사용할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="0208b-389">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="0208b-390">이 오류를 해결 하려면 모든 필요 없는 임시 파일을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-390">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="0208b-391">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-391">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="0208b-392">사용할 수 있는 고유한 임시 파일 이름이 없는 경우와 같은 I/O 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-392">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="0208b-393">\- 또는 -</span><span class="sxs-lookup"><span data-stu-id="0208b-393">\- or -</span></span> 
<span data-ttu-id="0208b-394">이 메서드로 임시 파일을 만들지 못한 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-394">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="0208b-395">임시 디렉터리에 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-395">for writing to the temporary directory.</span></span> <span data-ttu-id="0208b-396">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="0208b-396">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-397">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-397">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-398">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-398">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-399">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-399">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0208b-400">현재 사용자의 임시 폴더 경로를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-400">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="0208b-401">백슬래시로 끝나는 임시 폴더 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-401">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-402">이 메서드는 다음 순서 대로 환경 변수의 존재 유무를 확인 하 고 찾은 첫 번째 경로 사용 하 여:</span><span class="sxs-lookup"><span data-stu-id="0208b-402">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="0208b-403">TMP 환경 변수로 지정 된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-403">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="0208b-404">TEMP 환경 변수로 지정 된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-404">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="0208b-405">USERPROFILE 환경 변수로 지정 된 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-405">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="0208b-406">Windows 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-406">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-407">다음 코드에서는 <xref:System.IO.Path.GetTempPath%2A> 메서드를 호출하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-407">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="0208b-408">이 예제에서는 다음과 유사한 출력을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-408">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="0208b-409">호출자에게 필요한 사용 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-409">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="0208b-410">환경 변수를 무제한으로 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-410">for unrestricted access to environment variables.</span></span> <span data-ttu-id="0208b-411">연결 된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="0208b-411">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-412">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-412">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-413">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-413">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-414">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-414">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="0208b-415">확장명을 검색할 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-415">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="0208b-416">경로에 파일 확장명이 포함된지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-416">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="0208b-417">경로의 마지막 디렉터리 구분 문자(\\\ 또는 /) 또는 볼륨 구분 기호 문자(:) 다음에 나오는 문자에 마침표(.)와 하나 이상의 문자가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-417"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-418">끝에서 시작 `path`, 하나 이상의 문자 뒤에 마침표 (.)이이 메서드를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-418">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="0208b-419">이 패턴은 되기 전에 발견 되는 경우는 <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar> 문자가 발견 되는이 메서드가 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-419">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="0208b-420">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-420">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-421">다음 코드 예제에서는 `HasExtension` 메서드.</span><span class="sxs-lookup"><span data-stu-id="0208b-421">The following code example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-422"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-422"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-423">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-423">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-424">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-424">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-425">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-425">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0208b-426"><see cref="T:System.IO.Path" /> 클래스의 멤버에 전달되는 경로 문자열 인수에 사용할 수 없는 플랫폼 특정 문자 배열을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-426">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-427">이 메서드에서 반환 된 배열 전체 파일 및 디렉터리 이름에 잘못 된 문자 집합을 포함 하는 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-427">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="0208b-428">전체 집합이 잘못 된 문자는 파일 시스템에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-428">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="0208b-429">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 있습니다/유니코드 문자 1-31, 뿐만 아니라 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-429">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="0208b-430">사용 하지 않는 <xref:System.IO.Path.InvalidPathChars> 경우 코드는 신뢰할 수 없는 코드와 동일한 응용 프로그램 도메인에서 실행 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-430">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="0208b-431"><xref:System.IO.Path.InvalidPathChars> 배열 이므로 해당 요소를 덮어쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-431"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="0208b-432">신뢰할 수 없는 코드의 요소를 덮어쓰면 <xref:System.IO.Path.InvalidPathChars>, 악용 될 수 있는 방식으로 작동 하지 코드 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-432">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-433">다음 코드 예제에서는 `InvalidPathChars` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-433">The following code example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-434">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-434">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-435">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-435">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-436">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-436">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="0208b-437">테스트할 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-437">The path to test.</span></span></param>
        <summary><span data-ttu-id="0208b-438">지정된 경로 문자열에 루트가 포함된지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-438">Gets a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="0208b-439"><paramref name="path" />에 루트가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-439"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-440">합니다 <xref:System.IO.Path.IsPathRooted%2A> 메서드가 반환 `true` 첫 번째 문자 디렉터리 구분 기호 문자가 문자 인지와 같은 "\\", 경로 드라이브 문자와 콜론 (:)으로 시작 하는 경우 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-440">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="0208b-441">예를 들어 반환 `true` 에 대 한 `path` 와 같은 문자열 "\\\MyDir\\\MyFile.txt", "c:\\\MyDir", 또는 "C:MyDir"입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-441">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="0208b-442">반환 `false` 에 대 한 `path` "MyDir"와 같은 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-442">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="0208b-443">이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-443">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="0208b-444">공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-444">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-445">다음 코드 예제에서는 방법을 `IsPathRooted` 세 개의 문자열을 테스트 하려면 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-445">The following code example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0208b-446"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</span><span class="sxs-lookup"><span data-stu-id="0208b-446"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-447">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-447">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-448">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-448">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-449">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-449">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0208b-450">환경 변수에서 경로 문자열을 구분하는 데 사용되는 플랫폼 특정 구분 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-450">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-451">Windows 기반 데스크톱 플랫폼에서이 필드의 값에 세미콜론 (;) 기본적으로 하지만 다른 플랫폼에서 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-451">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-452">다음 코드 예제에서는 `PathSeparator` 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-452">The following code example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-453">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-453">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-454">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-454">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-455">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-455">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0208b-456">플랫폼 특정 볼륨 구분 기호 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-456">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0208b-457">이 필드의 값은 Windows 및 Macintosh 및 UNIX 운영 체제에서 슬래시 (/)에 콜론 (:).</span><span class="sxs-lookup"><span data-stu-id="0208b-457">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="0208b-458">예: "c:\windows" 또는 "MacVolume:System 폴더" 경로 구문 분석에 가장 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-458">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0208b-459">다음 코드 예제에서는 `VolumeSeparatorChar` 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="0208b-459">The following code example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="0208b-460">파일 및 스트림 I/O</span><span class="sxs-lookup"><span data-stu-id="0208b-460">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="0208b-461">방법: 파일의 텍스트 읽기</span><span class="sxs-lookup"><span data-stu-id="0208b-461">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="0208b-462">방법: 파일에 텍스트 쓰기</span><span class="sxs-lookup"><span data-stu-id="0208b-462">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>