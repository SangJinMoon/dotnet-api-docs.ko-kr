<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Path.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac550ebb5b074574504632faae02729178d34bf1194.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">50ebb5b074574504632faae02729178d34bf1194</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>Performs operations on <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> instances that contain file or directory path information.</source>
          <target state="translated">파일이나 디렉터리 경로 정보를 포함하는 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 인스턴스에 대한 작업을 수행합니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>These operations are performed in a cross-platform manner.</source>
          <target state="translated">이러한 작업은 플랫폼 간에 호환되는 방식으로 수행됩니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework와 같은 장치 이름, 해당 경로 통해 실제 디스크에 대 한 직접 액세스를 지원 하지 않습니다 "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0"입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path is a string that provides the location of a file or directory.</source>
          <target state="translated">경로 파일 또는 디렉터리의 위치를 제공 하는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</source>
          <target state="translated">경로 가리키지 않아도; 디스크에 있는 위치를 예를 들어 경로 메모리에 또는 장치에서 위치에 매핑될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The exact format of a path is determined by the current platform.</source>
          <target state="translated">패스의 정확한 형식은 현재 플랫폼에 따라 결정 됩니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</source>
          <target state="translated">예를 들어 일부 시스템 경로 시작할 수에 드라이브 또는 볼륨 문자를이 요소를 다른 시스템에 없을 때.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</source>
          <target state="translated">일부 시스템 파일 경로 파일에 저장 된 정보 유형을 지정 하는 확장을 포함할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</source>
          <target state="translated">파일 이름 확장명의 형식은 플랫폼에 따라 다릅니다. 예를 들어 일부 시스템 3 자에 대 한 확장을 제한 하 고 그렇지 않은 경우도 합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</source>
          <target state="translated">현재 플랫폼에는 경로 요소를 구분 하는 데 사용 되는 문자 집합 및 경로 지정 하는 경우에 사용할 수 없는 문자 집합이 결정 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Because of these differences, the fields of the <ph id="ph1">`Path`</ph> class as well as the exact behavior of some members of the <ph id="ph2">`Path`</ph> class are platform-dependent.</source>
          <target state="translated">필드의 이러한 차이 때문에 <ph id="ph1">`Path`</ph> 클래스의 일부 구성원의 정확한 동작은 뿐만 아니라는 <ph id="ph2">`Path`</ph> 클래스는 플랫폼에 따라 다릅니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path can contain absolute or relative location information.</source>
          <target state="translated">경로 절대 또는 상대 위치 정보를 포함할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</source>
          <target state="translated">위치를 완전 하 게 지정 하는 절대 경로: 파일 또는 디렉터리 고유 하 게 식별할 수 현재 위치에 관계 없이 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</source>
          <target state="translated">상대 경로 부분 위치 지정: 상대 경로와 지정 된 파일을 찾을 때 현재 위치가 시작 지점으로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>To determine the current directory, call <ph id="ph1">&lt;xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">현재 디렉터리를 확인 하려면 호출 <ph id="ph1">&lt;xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Most members of the <ph id="ph1">`Path`</ph> class do not interact with the file system and do not verify the existence of the file specified by a path string.</source>
          <target state="translated">멤버는 대부분의 <ph id="ph1">`Path`</ph> 클래스 파일 시스템 상호 작용 하지 않으며 및 경로 문자열에 의해 지정 된 파일의 존재 여부를 확인 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source><ph id="ph1">`Path`</ph> class members that modify a path string, such as <ph id="ph2">&lt;xref:System.IO.Path.ChangeExtension%2A&gt;</ph>, have no effect on names of files in the file system.</source>
          <target state="translated"><ph id="ph1">`Path`</ph> 클래스와 같은 경로 문자열을 수정 하는 멤버 <ph id="ph2">&lt;xref:System.IO.Path.ChangeExtension%2A&gt;</ph>, 파일 시스템에 파일 이름에 효과가 없습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source><ph id="ph1">`Path`</ph> members do, however, validate the contents of a specified path string, and throw an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <ph id="ph3">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`Path`</ph> 그러나 멤버 않습니다, 지정 된 경로 문자열의 내용을 확인 및 throw 한 <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> 문자열에서 반환 된 문자에 정의 된 경로 문자열에 유효 하지 않은 문자를 포함 하는 경우 예외는 <ph id="ph3">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</source>
          <target state="translated">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 포함 될 수 있습니다 따옴표 ("), 미만 (<ph id="ph1">\&lt;</ph>), 보다 큼 (&gt;), 파이프 (&amp;#124;), 백스페이스 (\b), (\0), null 및 유니코드 문자 16-18과 20부터 25입니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The members of the <ph id="ph1">`Path`</ph> class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</source>
          <target state="translated">멤버는 <ph id="ph1">`Path`</ph> 클래스를 사용 하면 신속 하 고 쉽게 파일 이름 확장명, 패스의 일부 인지 확인 하 고 두 문자열을 하나의 경로 이름으로 결합 하는 등의 일반적인 작업을 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>All members of the <ph id="ph1">`Path`</ph> class are static and can therefore be called without having an instance of a path.</source>
          <target state="translated">모든 멤버는 <ph id="ph1">`Path`</ph> 클래스는 정적이 고 경로의 인스턴스 없이 호출 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>In members that accept a path as an input string, that path must be well-formed or an exception is raised.</source>
          <target state="translated">가 경로 입력된 문자열을 허용 하는 멤버에 해당 경로 올바른 형식 이어야 합니다 또는 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</source>
          <target state="translated">예를 들어 경로 정규화 된 표시 되지만 공백으로 시작 경로 클래스의 메서드에서 잘리지 않습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Therefore, the path is malformed and an exception is raised.</source>
          <target state="translated">따라서 경로 잘못 되었으며 예외가 발생 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Similarly, a path or a combination of paths cannot be fully qualified twice.</source>
          <target state="translated">마찬가지로, 경로 또는 경로의 조합 두 번 정규화 될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, "c:\temp c:\windows" also raises an exception in most cases.</source>
          <target state="translated">예를 들어 "c:\temp c:\windows"는 또한 대부분의 경우에서 예외가 발생합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Ensure that your paths are well-formed when using methods that accept a path string.</source>
          <target state="translated">경로 문자열을 허용 하는 메서드를 사용 하는 경우 경로 형식이 있는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>In members that accept a path, the path can refer to a file or just a directory.</source>
          <target state="translated">경로 허용 하는 멤버를 파일이 나 디렉터리 경로 참조할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</source>
          <target state="translated">지정된 된 경로 상대 경로 또는 서버 및 공유 이름에 대 한 범용 명명 규칙 (UNC) 경로를 참조할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, all the following are acceptable paths:</source>
          <target state="translated">예를 들어 다음은 허용 가능한 경로.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"c:<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</source>
          <target state="translated">"c:<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt" C# 또는 Visual Basic의 "c:\MyDir\MyFile.txt"입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"c:<ph id="ph1">\\</ph>\MyDir" in C#, or "c:\MyDir" in Visual Basic.</source>
          <target state="translated">"c:<ph id="ph1">\\</ph>\MyDir" C# 또는 Visual Basic의 "c:\MyDir"입니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"MyDir<ph id="ph1">\\</ph>\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</source>
          <target state="translated">"MyDir<ph id="ph1">\\</ph>\MySubdir" C# 또는 Visual Basic의 "MyDir\MySubDir"입니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare" in C#, or "<ph id="ph5">\\</ph>\MyServer\MyShare" in Visual Basic.</source>
          <target state="translated">"<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare" C# 또는 "<ph id="ph5">\\</ph>\MyServer\MyShare" Visual Basic의 합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</source>
          <target state="translated">이러한 모든 작업은 문자열에서 수행 되므로 결과 모든 시나리오에서 유효한 지 확인할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, the <ph id="ph1">&lt;xref:System.IO.Path.GetExtension%2A&gt;</ph> method parses a string that you pass to it and returns the extension from that string.</source>
          <target state="translated">예를 들어는 <ph id="ph1">&lt;xref:System.IO.Path.GetExtension%2A&gt;</ph> 메서드를 전달 하는 문자열을 구문 분석 하 고 해당 문자열에서 확장명을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>However, this does not mean that a file with that extension exists on the disk.</source>
          <target state="translated">그러나 해당 확장명을 가진 파일을 디스크에 있는지이 아닙니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The following code example demonstrates some of the main members of the <ph id="ph1">`Path`</ph> class.</source>
          <target state="translated">다음 코드 예제를 보여 줍니다 주 멤버 중 일부는 <ph id="ph1">`Path`</ph> 클래스입니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</source>
          <target state="translated">계층적 파일 시스템 구조를 반영하는 경로 문자열에서 디렉터리 수준을 구분하는 데 사용되는 플랫폼 특정 대체 문자를 제공합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The character stored in this field cannot be in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</source>
          <target state="translated">이 필드에 저장 된 문자에 있을 수 없습니다 <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>This field can be set to the same value as <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">이 필드는 동일한 값으로 설정할 수 있습니다 <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source><ph id="ph1">`AltDirectorySeparatorChar`</ph> and <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> are both valid for separating directory levels in a path string.</source>
          <target state="translated"><ph id="ph1">`AltDirectorySeparatorChar`</ph> 및 <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> 은 모두 경로 문자열에서 디렉터리 수준을 구분 하는 것에 대 한 유효 합니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The value of this field is a slash ('/') on Windows, UNIX and Macintosh operating systems.</source>
          <target state="translated">이 필드의 값은 Windows, UNIX 및 Macintosh 운영 체제에서 슬래시 ('/').</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The following code example demonstrates a use of the <ph id="ph1">`AltDirectorySeparatorChar`</ph> field.</source>
          <target state="translated">사용법을 설명 하는 다음 코드 예제는 <ph id="ph1">`AltDirectorySeparatorChar`</ph> 필드입니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The path information to modify.</source>
          <target state="translated">수정할 경로 정보입니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The path cannot contain any of the characters defined in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated">경로에는 <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 문자가 포함될 수 없습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The new extension (with or without a leading period).</source>
          <target state="translated">앞에 마침표가 있거나 없는 새 확장명입니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> to remove an existing extension from <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>경로<ept id="p1">&lt;/c&gt;</ept>에서 기존 확장명을 제거하려면 <ph id="ph1">&lt;see langword="null" /&gt;</ph>을(를) 지정하세요.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>Changes the extension of a path string.</source>
          <target state="translated">경로 문자열의 확장명을 변경합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The modified path information.</source>
          <target state="translated">수정된 경로 정보입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>On Windows-based desktop platforms, if <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string (""), the path information is returned unmodified.</source>
          <target state="translated">Windows 기반 데스크톱 플랫폼에서 <ph id="ph1">&lt;paramref name="path" /&gt;</ph>이(가) <ph id="ph2">&lt;see langword="null" /&gt;</ph>이거나 빈 문자열("")이면 경로 정보가 수정되지 않고 반환됩니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="extension" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the returned string contains the specified path with its extension removed.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="extension" /&gt;</ph>이(가) <ph id="ph2">&lt;see langword="null" /&gt;</ph>이면 반환된 문자열에 확장명이 제거된 지정된 경로가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> has no extension, and <ph id="ph2">&lt;paramref name="extension" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>, the returned path string contains <ph id="ph4">&lt;paramref name="extension" /&gt;</ph> appended to the end of <ph id="ph5">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에 확장명이 없고 <ph id="ph2">&lt;paramref name="extension" /&gt;</ph>이(가) <ph id="ph3">&lt;see langword="null" /&gt;</ph>이 아니면 반환된 경로 문자열에는 <ph id="ph4">&lt;paramref name="extension" /&gt;</ph> 끝에 추가된 <ph id="ph5">&lt;paramref name="path" /&gt;</ph>이(가) 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If neither <ph id="ph1">`path`</ph> nor <ph id="ph2">`extension`</ph> contains a period (.), <ph id="ph3">`ChangeExtension`</ph> adds the period.</source>
          <target state="translated">모두 <ph id="ph1">`path`</ph> 나 <ph id="ph2">`extension`</ph> 마침표 (.), 포함 <ph id="ph3">`ChangeExtension`</ph> 추가 합니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The <ph id="ph1">`extension`</ph> parameter can contain multiple periods and any valid path characters, and can be any length.</source>
          <target state="translated"><ph id="ph1">`extension`</ph> 매개 변수는 여러 개의 마침표 및 유효한 경로 문자를 포함할 수 있습니다 및 길이 제한이 있습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is <ph id="ph2">`null`</ph>, the returned string contains the contents of <ph id="ph3">`path`</ph> with the last period and all characters following it removed.</source>
          <target state="translated">경우 <ph id="ph1">`extension`</ph> 은 <ph id="ph2">`null`</ph>, 반환 된 문자열의 내용을 포함 <ph id="ph3">`path`</ph> 마지막 기간 및 다음 문자를 모두 제거 합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is an empty string, the returned path string contains the contents of <ph id="ph2">`path`</ph> with any characters following the last period removed.</source>
          <target state="translated">경우 <ph id="ph1">`extension`</ph> 빈 문자열이 면 반환된 된 경로 문자열의 내용을 포함 <ph id="ph2">`path`</ph> 제거 마지막 마침표 다음 모든 문자를 포함 합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`path`</ph> does not have an extension and <ph id="ph2">`extension`</ph> is not <ph id="ph3">`null`</ph>, the returned string contains <ph id="ph4">`path`</ph> followed by <ph id="ph5">`extension`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`path`</ph> 는 확장명이 없는 및 <ph id="ph2">`extension`</ph> 않습니다 <ph id="ph3">`null`</ph>, 반환 된 문자열에 포함 되어 <ph id="ph4">`path`</ph> 이어서 <ph id="ph5">`extension`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is not <ph id="ph2">`null`</ph> and does not contain a leading period, the period is added.</source>
          <target state="translated">경우 <ph id="ph1">`extension`</ph> 않습니다 <ph id="ph2">`null`</ph> 앞에 마침표를 포함 하지 마침표가 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`path`</ph> contains a multiple extension separated by multiple periods, the returned string contains the contents of <ph id="ph2">`path`</ph> with the last period and all characters following it replaced by <ph id="ph3">`extension`</ph>.</source>
          <target state="translated">경우 <ph id="ph1">`path`</ph> 여러 마침표로 구분 하 여 여러 확장을 포함 반환 된 문자열의 내용을 포함 <ph id="ph2">`path`</ph> 에 마지막 기간 및 문자열 교체 <ph id="ph3">`extension`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For example, if <ph id="ph1">`path`</ph> is "\Dir1\examples\pathtests.csx.txt" and <ph id="ph2">`extension`</ph> is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</source>
          <target state="translated">예를 들어 경우 <ph id="ph1">`path`</ph> "\Dir1\examples\pathtests.csx.txt"은 및 <ph id="ph2">`extension`</ph> "cs" 이면 수정된 된 경로 "\Dir1\examples\pathtests.csx.cs"입니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>It is not possible to verify that the returned results are valid in all scenarios.</source>
          <target state="translated">반환 된 결과 모든 시나리오에서 유효한 지 확인 하는 것이 불가능 합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For example, if <ph id="ph1">`path`</ph> is empty, <ph id="ph2">`extension`</ph> is appended.</source>
          <target state="translated">예를 들어 경우 <ph id="ph1">`path`</ph> 비어 <ph id="ph2">`extension`</ph> 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`ChangeExtension`</ph> method.</source>
          <target state="translated">사용법을 설명 하는 다음 코드 예제는 <ph id="ph1">`ChangeExtension`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에 <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>Combines strings into a path.</source>
          <target state="translated">여러 문자열을 한 경로로 결합합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>An array of parts of the path.</source>
          <target state="translated">경로 각 부분의 배열입니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Combines an array of strings into a path.</source>
          <target state="translated">문자열 배열을 한 경로로 결합합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The combined paths.</source>
          <target state="translated">결합된 경로입니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source><ph id="ph1">`paths`</ph> should be an array of the parts of the path to combine.</source>
          <target state="translated"><ph id="ph1">`paths`</ph> 배열을 결합 하는 경로 부분을 지정 해야 합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</source>
          <target state="translated">후속 경로 중 하나를 절대 경로 이면 다음 결합 작업은 다시 설정 된 모든 이전 결합 된 경로 삭제 하는 해당 절대 경로, 시작 합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">길이가 0 인 문자열은 조합 된 경로에서 생략 됩니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 같이 허용 되지 않는 해석 되는 <ph id="ph1">`Combine`</ph> 메서드를 검색 와일드 카드 문자에 대 한 이러한 문자를 사용할 수 있으므로 합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">예를 들어 동안 <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> 잘못 되었을 수 검색 문자열로 올바른지, 여기에서 파일을 만들 경우.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">성공적으로 해석 따라서는 <ph id="ph1">`Combine`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The following example combines an array of strings into a path.</source>
          <target state="translated">다음 예제에서는 문자열 배열을 한 경로로 결합 됩니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>One of the strings in the array contains one or more of the invalid characters defined in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated">배열의 문자열 중 하나에 <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 잘못된 문자가 하나 이상 포함된 경우</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>One of the strings in the array is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">배열의 문자열 중 하나가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">결합할 첫 번째 경로입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">결합할 두 번째 경로입니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Combines two strings into a path.</source>
          <target state="translated">두 문자열을 한 경로로 결합합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">결합된 경로입니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If one of the specified paths is a zero-length string, this method returns the other path.</source>
          <target state="translated">지정된 경로 중 하나가 0 길이의 문자열이면 이 메서드는 다른 경로를 반환합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path2" /&gt;</ph> contains an absolute path, this method returns <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path2" /&gt;</ph>에 절대 경로가 포함되어 있으면 이 메서드는 <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>을(를) 반환합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">경우 <ph id="ph1">`path1`</ph> 은 드라이브 참조 (즉, "c:" 또는 "d:") 및에 정의 된 유효한 구분 기호 문자로 끝나지 않는 <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, 또는 <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> 에 추가 <ph id="ph6">`path1`</ph> 연결 하기 전에.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">경우 <ph id="ph1">`path2`</ph> 루트를 포함 하지 않습니다 (경우에 예를 들어 <ph id="ph2">`path2`</ph> 구분 기호 문자 또는 드라이브 사양으로 시작 하지 않는)는 결과 두 경로의 중간 구분 문자가 연결 합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">경우 <ph id="ph1">`path2`</ph> 루트가 포함 <ph id="ph2">`path2`</ph> 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph> instead of returning only <ph id="ph5">`path2`</ph>.</source>
          <target state="translated">따라서 경우 <ph id="ph1">`path2`</ph> 에 공백을 (예: "\file.txt")를 포함 하는 <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> 메서드 추가 <ph id="ph3">`path2`</ph> 를 <ph id="ph4">`path1`</ph> 만 반환 하는 대신 <ph id="ph5">`path2`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 같이 허용 되지 않는 해석 되는 <ph id="ph1">`Combine`</ph> 메서드를 검색 와일드 카드 문자에 대 한 이러한 문자를 사용할 수 있으므로 합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">예를 들어 동안 <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> 잘못 되었을 수 검색 문자열로 올바른지, 여기에서 파일을 만들 경우.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">성공적으로 해석 따라서는 <ph id="ph1">`Combine`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`Combine`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`Combine`</ph> Windows 기반 데스크톱 플랫폼에서 메서드.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph3">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>에 <ph id="ph3">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> 또는 <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>가 <ph id="ph3">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">결합할 첫 번째 경로입니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">결합할 두 번째 경로입니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The third path to combine.</source>
          <target state="translated">결합할 세 번째 경로입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Combines three strings into a path.</source>
          <target state="translated">세 문자열을 한 경로로 결합합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">결합된 경로입니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">`path1`</ph> should be an absolute path (for example, "d:\archives" or "<ph id="ph2">\\</ph>\archives\public").</source>
          <target state="translated"><ph id="ph1">`path1`</ph> 절대 경로 여야 하며 (예를 들어 "d:\archives" 또는 "<ph id="ph2">\\</ph>\archives\public").</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> or <ph id="ph2">`path3`</ph> is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</source>
          <target state="translated">경우 <ph id="ph1">`path2`</ph> 또는 <ph id="ph2">`path3`</ph> 결합 되어 감사가 만들어집니다 작업 포기 이전에 모두 결합 된 경로 및 절대 해당 경로에 다시 설정 합니다. 절대 경로 이기도 합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">길이가 0 인 문자열은 조합 된 경로에서 생략 됩니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">경우 <ph id="ph1">`path1`</ph> 은 드라이브 참조 (즉, "c:" 또는 "d:") 및에 정의 된 유효한 구분 기호 문자로 끝나지 않는 <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, 또는 <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> 에 추가 <ph id="ph6">`path1`</ph> 연결 하기 전에.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">경우 <ph id="ph1">`path2`</ph> 루트를 포함 하지 않습니다 (경우에 예를 들어 <ph id="ph2">`path2`</ph> 구분 기호 문자 또는 드라이브 사양으로 시작 하지 않는)는 결과 두 경로의 중간 구분 문자가 연결 합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">경우 <ph id="ph1">`path2`</ph> 루트가 포함 <ph id="ph2">`path2`</ph> 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph>.</source>
          <target state="translated">따라서 경우 <ph id="ph1">`path2`</ph> 에 공백을 (예: "\file.txt")를 포함 하는 <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> 메서드 추가 <ph id="ph3">`path2`</ph> 를 <ph id="ph4">`path1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 같이 허용 되지 않는 해석 되는 <ph id="ph1">`Combine`</ph> 메서드를 검색 와일드 카드 문자에 대 한 이러한 문자를 사용할 수 있으므로 합니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">예를 들어 동안 <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> 잘못 되었을 수 검색 문자열로 올바른지, 여기에서 파일을 만들 경우.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">성공적으로 해석 따라서는 <ph id="ph1">`Combine`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The following example combines three paths.</source>
          <target state="translated">다음 예제에서는 세 개의 경로 결합합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph4">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>이 <ph id="ph4">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 잘못된 문자 중 하나 이상을 포함합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> 또는 <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>가 <ph id="ph4">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">결합할 첫 번째 경로입니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">결합할 두 번째 경로입니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The third path to combine.</source>
          <target state="translated">결합할 세 번째 경로입니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The fourth path to combine.</source>
          <target state="translated">결합할 네 번째 경로입니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Combines four strings into a path.</source>
          <target state="translated">네 문자열을 한 경로로 결합합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">결합된 경로입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">`path1`</ph> should be an absolute path (for example, "d:\archives" or "<ph id="ph2">\\</ph>\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</source>
          <target state="translated"><ph id="ph1">`path1`</ph> 절대 경로 여야 하며 (예를 들어 "d:\archives" 또는 "<ph id="ph2">\\</ph>\archives\public"). 또한 후속 경로 중 하나는 절대 경로, 결합 작업 이전에 결합 된 모든 경로 삭제 하 고 해당 절대 경로로 다시 설정 합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">길이가 0 인 문자열은 조합 된 경로에서 생략 됩니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">경우 <ph id="ph1">`path1`</ph> 은 드라이브 참조 (즉, "c:" 또는 "d:") 및에 정의 된 유효한 구분 기호 문자로 끝나지 않는 <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, 또는 <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> 에 추가 <ph id="ph6">`path1`</ph> 연결 하기 전에.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">경우 <ph id="ph1">`path2`</ph> 루트를 포함 하지 않습니다 (경우에 예를 들어 <ph id="ph2">`path2`</ph> 구분 기호 문자 또는 드라이브 사양으로 시작 하지 않는)는 결과 두 경로의 중간 구분 문자가 연결 합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">경우 <ph id="ph1">`path2`</ph> 루트가 포함 <ph id="ph2">`path2`</ph> 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">공백이 있는 경우 매개 변수를 구문 분석 됩니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph>.</source>
          <target state="translated">따라서 경우 <ph id="ph1">`path2`</ph> 에 공백을 (예: "\file.txt")를 포함 하는 <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> 메서드 추가 <ph id="ph3">`path2`</ph> 를 <ph id="ph4">`path1`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">디렉터리 및 파일 이름에 일부 잘못 된 문자에서 같이 허용 되지 않는 해석 되는 <ph id="ph1">`Combine`</ph> 메서드를 검색 와일드 카드 문자에 대 한 이러한 문자를 사용할 수 있으므로 합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">예를 들어 동안 <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> 잘못 되었을 수 검색 문자열로 올바른지, 여기에서 파일을 만들 경우.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">성공적으로 해석 따라서는 <ph id="ph1">`Combine`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The following example combines four paths.</source>
          <target state="translated">다음 예에서는 4 개의 경로 결합합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph5">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> 또는 <ph id="ph4">&lt;paramref name="path4" /&gt;</ph>가 <ph id="ph5">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 잘못된 문자 중 하나 이상을 포함합니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> 또는 <ph id="ph4">&lt;paramref name="path4" /&gt;</ph>가 <ph id="ph5">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</source>
          <target state="translated">계층적 파일 시스템 구조를 반영하는 경로 문자열에서 디렉터리 수준을 구분하는 데 사용되는 플랫폼 특정 문자를 제공합니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>The character stored in this field cannot be in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</source>
          <target state="translated">이 필드에 저장 된 문자에 있을 수 없습니다 <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source><ph id="ph1">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> and <ph id="ph2">`DirectorySeparatorChar`</ph> are both valid for separating directory levels in a path string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> 및 <ph id="ph2">`DirectorySeparatorChar`</ph> 은 모두 경로 문자열에서 디렉터리 수준을 구분 하는 것에 대 한 유효 합니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>The following code example demonstrates the use of the <ph id="ph1">`DirectorySeparatorChar`</ph> field.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">`DirectorySeparatorChar`</ph> 필드입니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The path of a file or directory.</source>
          <target state="translated">파일 또는 디렉터리의 경로입니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Returns the directory information for the specified path string.</source>
          <target state="translated">지정된 경로 문자열에 대한 디렉터리 정보를 반환합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Directory information for <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if <ph id="ph3">&lt;paramref name="path" /&gt;</ph> denotes a root directory or is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에 대한 디렉터리 정보이며, <ph id="ph3">&lt;paramref name="path" /&gt;</ph>이(가) 루트 디렉터리를 나타내거나 null인 경우 <ph id="ph2">&lt;see langword="null" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Returns <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="path" /&gt;</ph> does not contain directory information.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="path" /&gt;</ph>에 디렉터리 정보가 포함되어 있지 않으면 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>이(가) 반환됩니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>In most cases, the string returned by this method consists of all characters in the path up to but not including the last <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">대부분의 경우에서이 메서드에서 반환 되는 문자열 이루어져 마지막 점을 포함 하지 않고 최대 경로에서 모든 문자가 <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>If the path consists of a root directory, such as "c:<ph id="ph1">\\</ph>", null is returned.</source>
          <target state="translated">경로는 구성 됩니다 루트 디렉터리와 같은 "c:<ph id="ph1">\\</ph>", null이 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Note that this method does not support paths using "file:".</source>
          <target state="translated">이 방법은 사용 하 여 경로 지원 하지 않는 참고 "파일:".</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Because the returned path does not include the <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, passing the returned path back into the <ph id="ph3">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> method will result in the truncation of one folder level per subsequent call on the result string.</source>
          <target state="translated">반환 된 경로 포함 되어 있지 않으므로 <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>로 다시 전달 반환 된 경로 <ph id="ph3">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> 메서드는 결과 문자열에 대 한 후속 호출당 한 폴더 수준 잘림이 발생 합니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> method will return "C:\Directory\SubDirectory".</source>
          <target state="translated">예를 들어 "C:\Directory\SubDirectory\test.txt" 경로에 전달 된 <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> 메서드 "C:\Directory\SubDirectory"를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Passing that string, "C:\Directory\SubDirectory", into <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> will result in "C:\Directory".</source>
          <target state="translated">문자열에 "C:\Directory\SubDirectory" 전달 <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> "C:\Directory" 발생 합니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`GetDirectoryName`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`GetDirectoryName`</ph> Windows 기반 데스크톱 플랫폼에서 메서드.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter contains invalid characters, is empty, or contains only white spaces.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 매개 변수가 잘못된 문자를 포함하거나, 비어 있거나, 공백만 포함하는 경우</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated"><bpt id="p1">[</bpt>Windows 스토어 앱용 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 또는 <bpt id="p2">[</bpt>이식 가능한 클래스 라이브러리<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>에서 대신 기본 클래스 예외 <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>을 catch합니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is longer than the system-defined maximum length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 매개변수가 시스템에 정의된 최대 길이보다 깁니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The path string from which to get the extension.</source>
          <target state="translated">확장명을 가져올 경로 문자열입니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>Returns the extension of the specified path string.</source>
          <target state="translated">지정된 경로 문자열에서 확장명을 반환합니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The extension of the specified path (including the period "."), or <ph id="ph1">&lt;see langword="null" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">"."(마침표)를 포함한 지정된 경로의 확장명, <ph id="ph1">&lt;see langword="null" /&gt;</ph> 또는 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> returns <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>이(가) <ph id="ph2">&lt;see langword="null" /&gt;</ph>이면, <ph id="ph3">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph>은(는) <ph id="ph4">&lt;see langword="null" /&gt;</ph>을(를) 반환합니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> does not have extension information, <ph id="ph2">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> returns <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에 확장명 정보가 없는 경우 <ph id="ph2">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph>은(는) <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>을(를) 반환합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The extension of <ph id="ph1">`path`</ph> is obtained by searching <ph id="ph2">`path`</ph> for a period (.), starting with the last character in path and continuing toward the start of path.</source>
          <target state="translated">확장 <ph id="ph1">`path`</ph> 검색 하 여 얻은 <ph id="ph2">`path`</ph> 경로의 시작까지에 마지막 문자로 시작 하는 마침표 (.)에 대 한 합니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If a period is found before a <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> character, the returned string contains the period and the characters after it; otherwise, <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph> is returned.</source>
          <target state="translated">앞에 마침표가 발견 되는 <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> 문자 뒤; 기간과 문자를 포함 하는 반환 된 문자열, <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph> 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`GetExtension`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`GetExtension`</ph> Windows 기반 데스크톱 플랫폼에서 메서드.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에 <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The path string from which to obtain the file name and extension.</source>
          <target state="translated">파일 이름과 확장명을 가져올 경로 문자열입니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>Returns the file name and extension of the specified path string.</source>
          <target state="translated">지정된 경로 문자열에서 파일 이름과 확장명을 반환합니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The characters after the last directory character in <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에서 마지막 디렉터리 문자 다음의 문자입니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>If the last character of <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is a directory or volume separator character, this method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>의 마지막 문자가 디렉터리나 볼륨 구분 문자이면 이 메서드는 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>을(를) 반환합니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>이(가) <ph id="ph2">&lt;see langword="null" /&gt;</ph>이면 이 메서드는 <ph id="ph3">&lt;see langword="null" /&gt;</ph>을(를) 반환합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The returned value is <ph id="ph1">`null`</ph> if the file path is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">반환 된 값이 <ph id="ph1">`null`</ph> 파일 경로가 경우 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The separator characters used to determine the start of the file name are <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">파일 이름의 시작을 확인 하는 데 사용 하는 구분 기호 문자는 <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> 및 <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The following code example demonstrates the behavior of the <ph id="ph1">`GetFileName`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">다음 코드 예제에서는의 동작을 보여 줍니다.는 <ph id="ph1">`GetFileName`</ph> Windows 기반 데스크톱 플랫폼에서 메서드.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에 <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The path of the file.</source>
          <target state="translated">파일의 경로입니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>Returns the file name of the specified path string without the extension.</source>
          <target state="translated">확장명 없이 지정된 경로 문자열의 파일 이름을 반환합니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The string returned by <ph id="ph1">&lt;see cref="M:System.IO.Path.GetFileName(System.String)" /&gt;</ph>, minus the last period (.) and all characters following it.</source>
          <target state="translated">마지막 마침표(.)와 그 다음에 나오는 모든 문자인 <ph id="ph1">&lt;see cref="M:System.IO.Path.GetFileName(System.String)" /&gt;</ph>에서 반환한 문자열입니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`GetFileNameWithoutExtension`</ph> method.</source>
          <target state="translated">사용법을 설명 하는 다음 코드 예제는 <ph id="ph1">`GetFileNameWithoutExtension`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에 <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file or directory for which to obtain absolute path information.</source>
          <target state="translated">절대 경로 정보를 가져올 파일 또는 디렉터리입니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>Returns the absolute path for the specified path string.</source>
          <target state="translated">지정된 경로 문자열에 대한 절대 경로를 반환합니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The fully qualified location of <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, such as "C:\MyFile.txt".</source>
          <target state="translated">"C:\MyFile.txt"처럼 <ph id="ph1">&lt;paramref name="path" /&gt;</ph>의 정규화된 위치입니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework와 같은 장치 이름, 해당 경로 통해 실제 디스크에 대 한 직접 액세스를 지원 하지 않습니다 "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0"입니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The absolute path includes all information required to locate a file or directory on a system.</source>
          <target state="translated">시스템에서 파일 또는 디렉터리를 찾는 데 필요한 모든 정보를 포함 하는 절대 경로입니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file or directory specified by <ph id="ph1">`path`</ph> is not required to exist.</source>
          <target state="translated">파일 또는로 지정 된 디렉터리 <ph id="ph1">`path`</ph> 있이 필요는 없습니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For example, if c:\temp\newdir is the current directory, calling <ph id="ph1">`GetFullPath`</ph> on a file name such as test.txt returns c:\temp\newdir\test.txt.</source>
          <target state="translated">예를 들어 c:\temp\newdir 현재 디렉터리 이면 호출 <ph id="ph1">`GetFullPath`</ph> 파일 c:\temp\newdir\test.txt test.txt 같은 이름을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file need not exist.</source>
          <target state="translated">파일이 필요 합니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>However, if <ph id="ph1">`path`</ph> does exist, the caller must have permission to obtain path information for <ph id="ph2">`path`</ph>.</source>
          <target state="translated">그러나 경우 <ph id="ph1">`path`</ph> 없는 호출자에 대 한 경로 정보를 얻을 수 있는 권한이 있어야 합니다. <ph id="ph2">`path`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>Note that unlike most members of the <ph id="ph1">&lt;xref:System.IO.Path&gt;</ph> class, this method accesses the file system.</source>
          <target state="translated">멤버는 대부분 달리는 <ph id="ph1">&lt;xref:System.IO.Path&gt;</ph> 클래스,이 메서드는 파일 시스템에 액세스 합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>This method uses current directory and current volume information to fully qualify <ph id="ph1">`path`</ph>.</source>
          <target state="translated">이 메서드는 현재 디렉터리와 현재 볼륨 정보를 완전히 정규화 사용 <ph id="ph1">`path`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If you specify a file name only in <ph id="ph1">`path`</ph>, <ph id="ph2">`GetFullPath`</ph> returns the fully qualified path of the current directory.</source>
          <target state="translated">파일을 지정 하는 경우에 이름을 <ph id="ph1">`path`</ph>, <ph id="ph2">`GetFullPath`</ph> 현재 디렉터리의 정규화 된 경로 반환 합니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If you pass in a short file name, it is expanded to a long file name.</source>
          <target state="translated">짧은 파일 이름에 전달 하는 경우 긴 파일 이름으로 확장 됩니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If a path contains no significant characters it is invalid unless it contains one or more "." characters followed by any number of spaces, then it will be parsed as either "." or "..".</source>
          <target state="translated">경로 문자가 포함 된 경우 유효 하지 않은 하나 이상 포함 되어 있지 않으면 "."문자 뒤에 공백에 여러 다음으로 구문 분석 됩니다"."또는".."입니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The following code example demonstrates the <ph id="ph1">`GetFullPath`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">`GetFullPath`</ph> Windows 기반 데스크톱 플랫폼에서 메서드.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>가 길이가 0인 문자열이거나 공백만 포함하거나 <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 하나 이상의 잘못된 문자를 포함하는 경우</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The system could not retrieve the absolute path.</source>
          <target state="translated">절대 경로를 검색할 수 없는 경우</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">호출자에게 필요한 사용 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>가 <ph id="ph2">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains a colon (":") that is not part of a volume identifier (for example, "c:<ph id="ph2">\\</ph>").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에 볼륨 식별자(예: "c:<ph id="ph2">\\</ph>")의 일부가 아닌 콜론(":")이 포함됩니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>for access to the path.</source>
          <target state="translated">경로에 액세스 합니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>Gets an array containing the characters that are not allowed in file names.</source>
          <target state="translated">파일 이름에 사용할 수 없는 문자가 포함된 배열을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>An array containing the characters that are not allowed in file names.</source>
          <target state="translated">파일 이름에 사용할 수 없는 문자가 포함된 배열입니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">이 메서드에서 반환 된 배열 전체 집합이 파일 및 디렉터리 이름에 유효 하지 않은 문자를 포함 하도록 보장 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">잘못 된 문자가의 전체 집합은 파일 시스템에 따라 달라질 수 있습니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 수 I/유니코드 문자 1-31,으로 따옴표 ("), 미만 (<ph id="ph1">\&lt;</ph>), 보다 큼 (&gt;), 파이프 (&amp;#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method to retrieve invalid characters.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> 메서드 및 <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> 잘못 된 문자를 검색 하는 메서드입니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>Gets an array containing the characters that are not allowed in path names.</source>
          <target state="translated">경로 이름에 사용할 수 없는 문자가 포함된 배열을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>An array containing the characters that are not allowed in path names.</source>
          <target state="translated">파일 이름에 사용할 수 없는 문자가 포함된 배열입니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">이 메서드에서 반환 된 배열 전체 집합이 파일 및 디렉터리 이름에 유효 하지 않은 문자를 포함 하도록 보장 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">잘못 된 문자가의 전체 집합은 파일 시스템에 따라 달라질 수 있습니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 수 I/유니코드 문자 1-31,으로 따옴표 ("), 미만 (<ph id="ph1">\&lt;</ph>), 보다 큼 (&gt;), 파이프 (&amp;#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method to retrieve invalid characters.</source>
          <target state="translated">다음 코드 예제는 <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> 메서드 및 <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> 잘못 된 문자를 검색 하는 메서드입니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The path from which to obtain root directory information.</source>
          <target state="translated">루트 디렉터리 정보를 가져올 경로입니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>Gets the root directory information of the specified path.</source>
          <target state="translated">지정된 경로의 루트 디렉터리 정보를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The root directory of <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, such as "C:<ph id="ph2">\\</ph>", or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if <ph id="ph4">&lt;paramref name="path" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>, or an empty string if <ph id="ph6">&lt;paramref name="path" /&gt;</ph> does not contain root directory information.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>의 루트 디렉터리(예: "C:<ph id="ph2">\\</ph>")이며, <ph id="ph4">&lt;paramref name="path" /&gt;</ph>이(가) <ph id="ph5">&lt;see langword="null" /&gt;</ph>인 경우 <ph id="ph3">&lt;see langword="null" /&gt;</ph>이며 <ph id="ph6">&lt;paramref name="path" /&gt;</ph>에 루트 디렉터리 정보가 포함되어 있지 않은 경우 빈 문자열입니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>Possible patterns for the string returned by this method are as follows:</source>
          <target state="translated">이 메서드에 의해 반환 되는 문자열에 대 한 가능한 패턴은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>An empty string (<ph id="ph1">`path`</ph> specified a relative path on the current drive or volume).</source>
          <target state="translated">빈 문자열 (<ph id="ph1">`path`</ph> 현재 드라이브 또는 볼륨에 대 한 상대 경로 지정).</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"/" (<ph id="ph1">`path`</ph> specified an absolute path on the current drive).</source>
          <target state="translated">"/" (<ph id="ph1">`path`</ph> 절대 경로가 현재 드라이브에서 지정).</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"X:" (<ph id="ph1">`path`</ph> specified a relative path on a drive, where X represents a drive or volume letter).</source>
          <target state="translated">"X:" (<ph id="ph1">`path`</ph> 여기서 X 드라이브 또는 볼륨 문자를 나타냅니다. 드라이브에 대 한 상대 경로 지정).</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"X:/" (<ph id="ph1">`path`</ph> specified an absolute path on a given drive).</source>
          <target state="translated">"X: /" (<ph id="ph1">`path`</ph> 절대 경로가 지정된 된 드라이브에서 지정).</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"<ph id="ph1">\\</ph>\ComputerName\SharedFolder" (a UNC path).</source>
          <target state="translated">"<ph id="ph1">\\</ph>\ComputerName\SharedFolder" (a UNC path).</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework와 같은 장치 이름, 해당 경로 통해 실제 디스크에 대 한 직접 액세스를 지원 하지 않습니다 "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0"입니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`GetPathRoot`</ph> method.</source>
          <target state="translated">사용법을 설명 하는 다음 코드 예제는 <ph id="ph1">`GetPathRoot`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에 <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>-or-</source>
          <target state="translated">또는</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> was passed to <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="path" /&gt;</ph>에 <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>가 전달된 경우</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetRandomFileName">
          <source>Returns a random folder name or file name.</source>
          <target state="translated">임의의 폴더 이름 또는 파일 이름을 반환합니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetRandomFileName">
          <source>A random folder name or file name.</source>
          <target state="translated">임의의 폴더 이름 또는 파일 이름입니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> 메서드 폴더 이름 또는 파일 이름으로 사용할 수 있는 강력 하 게 암호화, 임의 문자열을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>Unlike <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> does not create a file.</source>
          <target state="translated">와 달리 <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> 파일을 만들지 않습니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>When the security of your file system is paramount, this method should be used instead of <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>.</source>
          <target state="translated">이 메서드를 대신 사용 해야 파일 시스템의 보안을 가장 중요 하며 이면 <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>The following example show output from the <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> method.</source>
          <target state="translated">다음 예제에서 출력 보기는 <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</source>
          <target state="translated">디스크에 크기가 0바이트인 고유한 이름의 임시 파일을 만들고 해당 파일의 전체 경로를 반환합니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>The full path of the temporary file.</source>
          <target state="translated">임시 파일의 전체 경로입니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>This method creates a temporary file with a .TMP file extension.</source>
          <target state="translated">이 메서드는 임시 파일을 만듭니다는 합니다. TMP 파일 확장명입니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The temporary file is created within the user’s temporary folder, which is the path returned by the <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> method.</source>
          <target state="translated">사용자의 임시 폴더 경로 내에서 임시 파일을 만들에서 반환 되는 <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> method will raise an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if it is used to create more than 65535 files without deleting previous temporary files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> 메서드로 인해 발생 한 <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> 이전의 임시 파일을 삭제 하지 않고 65535 개 이상 파일을 만들려면 사용 되는 경우.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> method will raise an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if no unique temporary file name is available.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> 메서드로 인해 발생 한 <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> 없는 고유한 임시 파일 이름을 사용할 수 있는 경우.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>To resolve this error, delete all unneeded temporary files.</source>
          <target state="translated">이 오류를 해결 하려면 모든 필요 없는 임시 파일을 삭제 합니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>An I/O error occurs, such as no unique temporary file name is available.</source>
          <target state="translated">사용할 수 있는 고유한 임시 파일 이름이 없는 경우와 같은 I/O 오류가 발생한 경우</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> 또는 -</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>This method was unable to create a temporary file.</source>
          <target state="translated">이 메서드로 임시 파일을 만들지 못한 경우</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>for writing to the temporary directory.</source>
          <target state="translated">임시 디렉터리에 작성 합니다.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>Returns the path of the current user's temporary folder.</source>
          <target state="translated">현재 사용자의 임시 폴더 경로를 반환합니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>The path to the temporary folder, ending with a backslash.</source>
          <target state="translated">백슬래시로 끝나는 임시 폴더 경로입니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>This method checks for the existence of environment variables in the following order and uses the first path found:</source>
          <target state="translated">이 메서드는 다음 순서에 환경 변수의 있는지 여부를 확인 하 고 첫 번째 경로 찾을 수를 사용 하 여:</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the TMP environment variable.</source>
          <target state="translated">TMP 환경 변수로 지정 된 경로입니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the TEMP environment variable.</source>
          <target state="translated">TEMP 환경 변수로 지정 된 경로입니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the USERPROFILE environment variable.</source>
          <target state="translated">사용자 프로필 환경 변수로 지정 된 경로입니다.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The Windows directory.</source>
          <target state="translated">Windows 디렉터리입니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The following code shows how to call the <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> method.</source>
          <target state="translated">다음 코드에서는 <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> 메서드를 호출하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>This example produces output similar to the following.</source>
          <target state="translated">이 예에서는 다음과 유사한 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">호출자에게 필요한 사용 권한이 없습니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>for unrestricted access to environment variables.</source>
          <target state="translated">에 대 한 무제한 액세스 환경 변수입니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph></source>
          <target state="translated">연결 된 열거형의 경우: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>The path to search for an extension.</source>
          <target state="translated">확장명을 검색할 경로입니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>Determines whether a path includes a file name extension.</source>
          <target state="translated">경로에 파일 확장명이 포함된지를 확인합니다.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the characters that follow the last directory separator (<ph id="ph2">\\</ph>\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">경로의 마지막 디렉터리 구분 문자(<ph id="ph2">\\</ph>\ 또는 /) 또는 볼륨 구분 기호 문자(:) 다음에 나오는 문자에 마침표(.)와 하나 이상의 문자가 포함되어 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>Starting from the end of <ph id="ph1">`path`</ph>, this method searches for a period (.) followed by at least one character.</source>
          <target state="translated">끝에서 시작 <ph id="ph1">`path`</ph>, 마침표 (.)와 문자를 하나 이상에 대 한이 메서드를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>If this pattern is found before a <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph3">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph> character is encountered, this method returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">이 패턴은 하기 전에 발견 되는 <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, 또는 <ph id="ph3">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph> 문자가 발견 되는이 메서드가 반환 <ph id="ph4">`true`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>The following code example demonstrates the use of the <ph id="ph1">`HasExtension`</ph> method.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">`HasExtension`</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에 <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="F:System.IO.Path.InvalidPathChars">
          <source>Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <ph id="ph1">&lt;see cref="T:System.IO.Path" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Path" /&gt;</ph> 클래스의 멤버에 전달되는 경로 문자열 인수에 사용할 수 없는 플랫폼 특정 문자 배열을 제공합니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">이 메서드에서 반환 된 배열 전체 집합이 파일 및 디렉터리 이름에 유효 하지 않은 문자를 포함 하도록 보장 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">잘못 된 문자가의 전체 집합은 파일 시스템에 따라 달라질 수 있습니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 수 I/유니코드 문자 1-31,으로 따옴표 ("), 미만 (<ph id="ph1">\&lt;</ph>), 보다 큼 (&gt;), 파이프 (&amp;#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>Do not use <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> if you think your code might execute in the same application domain as untrusted code.</source>
          <target state="translated">사용 하지 마십시오 <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> 한다면 쿼리 프로그램 코드를 신뢰할 수 없는 코드와 같은 응용 프로그램 도메인에서 실행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source><ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> is an array, so its elements can be overwritten.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> 배열 이므로 해당 요소를 덮어쓸 수 있습니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>If untrusted code overwrites elements of <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>, it might cause your code to malfunction in ways that could be exploited.</source>
          <target state="translated">신뢰할 수 없는 코드의 요소를 덮어쓰면 <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>, 코드 악용 될 수 있는 방식으로 작동 하지 않을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The following code example demonstrates the use of the <ph id="ph1">`InvalidPathChars`</ph> property.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">`InvalidPathChars`</ph> 속성입니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The path to test.</source>
          <target state="translated">테스트할 경로입니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>Gets a value indicating whether the specified path string contains a root.</source>
          <target state="translated">지정된 경로 문자열에 루트가 포함된지를 나타내는 값을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="path" /&gt;</ph> contains a root; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="path" /&gt;</ph>에 루트가 포함되어 있으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph3">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.IsPathRooted%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> if the first character is a directory separator character such as "<ph id="ph3">\\</ph>", or if the path starts with a drive letter and colon (:).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.IsPathRooted%2A&gt;</ph> 메서드 반환 <ph id="ph2">`true`</ph> 첫 번째 문자 디렉터리 구분 기호 문자 인지와 같은 "<ph id="ph3">\\</ph>", 경로 드라이브 문자와 콜론 (:)로 시작 하는 경우.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>For example, it returns <ph id="ph1">`true`</ph> for <ph id="ph2">`path`</ph> strings such as "<ph id="ph3">\\</ph>\MyDir<ph id="ph4">\\</ph>\MyFile.txt", "C:<ph id="ph5">\\</ph>\MyDir", or "C:MyDir".</source>
          <target state="translated">예를 들어 반환 <ph id="ph1">`true`</ph> 에 대 한 <ph id="ph2">`path`</ph> 와 같은 문자열 "<ph id="ph3">\\</ph>\MyDir<ph id="ph4">\\</ph>\MyFile.txt", "c:<ph id="ph5">\\</ph>\MyDir", 또는 "C:MyDir"입니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>It returns <ph id="ph1">`false`</ph> for <ph id="ph2">`path`</ph> strings such as "MyDir".</source>
          <target state="translated">반환 <ph id="ph1">`false`</ph> 에 대 한 <ph id="ph2">`path`</ph> "MyDir"와 같은 문자열입니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">공통적인 I/O 작업의 목록에 대 한 참조 <bpt id="p1">[</bpt>공통적인 I/O 작업<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The following code example demonstrates how the <ph id="ph1">`IsPathRooted`</ph> method can be used to test three strings.</source>
          <target state="translated">다음 코드 예제에서는 방법을 <ph id="ph1">`IsPathRooted`</ph> 세 개의 문자열을 테스트 하려면 메서드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph>에 <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="F:System.IO.Path.PathSeparator">
          <source>A platform-specific separator character used to separate path strings in environment variables.</source>
          <target state="translated">환경 변수에서 경로 문자열을 구분하는 데 사용되는 플랫폼 특정 구분 문자입니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.PathSeparator">
          <source>On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</source>
          <target state="translated">이 필드의 값의 세미콜론 (;)는 Windows 기반 데스크톱 플랫폼에서 기본적으로 하지만 다른 플랫폼에서 다를 수 있습니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.PathSeparator">
          <source>The following code example demonstrates the use of the <ph id="ph1">`PathSeparator`</ph> field.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">`PathSeparator`</ph> 필드입니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>Provides a platform-specific volume separator character.</source>
          <target state="translated">플랫폼 특정 볼륨 구분 기호 문자를 제공합니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</source>
          <target state="translated">이 필드의 값은 콜론 (:) Macintosh, Windows 및 UNIX 운영 체제에서 슬래시 (/).</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</source>
          <target state="translated">예: "c:\windows" 또는 "MacVolume:System 폴더" 경로 구문 분석에 가장 유용 합니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>The following code example demonstrates the use of the <ph id="ph1">`VolumeSeparatorChar`</ph> field.</source>
          <target state="translated">다음 코드 예제에서는 <ph id="ph1">`VolumeSeparatorChar`</ph> 필드입니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>