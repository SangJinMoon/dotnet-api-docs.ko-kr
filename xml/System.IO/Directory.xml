<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="39b951783337e3ebac2963f3a5b13271ae1b4db6" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911196" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>디렉터리와 하위 디렉터리에서 만들기, 이동 및 열거를 위한 정적 메서드를 노출합니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.IO.Directory> 복사, 이동, 이름 바꾸기 및 디렉터리 삭제와 같은 일반적인 작업에 대 한 클래스입니다.  
  
-   디렉터리를 만들려면 사용 중 하나는 <xref:System.IO.Directory.CreateDirectory%2A> 메서드.  
  
-   디렉터리를 삭제 하려면 중 사용 된 <xref:System.IO.Directory.Delete%2A> 메서드.  
  
-   를 가져오거나 응용 프로그램에 대 한 현재 디렉터리를 설정 하려면 사용 하 여는 <xref:System.IO.Directory.GetCurrentDirectory%2A> 또는 <xref:System.IO.Directory.SetCurrentDirectory%2A> 메서드.  
  
-   조작 하기 위한 <xref:System.DateTime> 관련 정보를 생성, 액세스 및 디렉터리의 쓰기와 같은 메서드 사용 <xref:System.IO.Directory.SetLastAccessTime%2A> 및 <xref:System.IO.Directory.SetCreationTime%2A>합니다.  
  
 정적 메서드는 <xref:System.IO.Directory> 클래스는 모든 메서드에 대 한 보안 검사를 수행 합니다. 해당 인스턴스 메서드를 사용 하 여 고려 하는 개체를 여러 번 다시 경우 <xref:System.IO.DirectoryInfo> 보안 검사는 항상 때문에 필요할 수 대신 합니다.  
  
 하나의 디렉터리 관련 작업을 수행 하는 경우 보다 효율적으로 정적 사용할 수 있습니다 <xref:System.IO.Directory> 메서드는 해당 하는 대신 <xref:System.IO.DirectoryInfo> 인스턴스 메서드. 대부분 <xref:System.IO.Directory> 방법에는 조작 하 고 있는 디렉터리의 경로 필요 합니다.  
  
> [!NOTE]
>  문자열을 허용 하는 멤버에 `path` 매개 변수는 해당 경로 올바른 형식 이어야 합니다 또는 예외가 발생 합니다. 예를 들어 경로 정규화 된 ("c:\temp") 공백으로 시작 되지만 경로 문자열 되지 않습니다 조정이, 예외가 발생 하 고 경로 형식이 잘못 된 것으로 간주 됩니다. 또한 경로 또는 경로의 조합 두 번 정규화 될 수 없습니다. 예를 들어 "c:\temp c:\windows"는 또한 예외가 발생합니다. 경로 문자열을 허용 하는 메서드를 사용 하는 경우 경로 형식이 있는지 확인 합니다. 자세한 내용은 <xref:System.IO.Path>을 참조하세요.  
  
 경로 허용 하는 멤버를 파일이 나 디렉터리 경로 참조할 수 있습니다. 서버 및 공유 이름에 대 한 전체 경로, 상대 경로 또는 범용 명명 규칙 (UNC) 경로 사용할 수 있습니다. 예를 들어 다음은 허용 가능한 경로.  
  
-   "c:\\\MyDir" C# 또는 Visual Basic의 "c:\MyDir"입니다.  
  
-   "MyDir\\\MySubdir" C# 또는 Visual Basic의 "MyDir\MySubDir"입니다.  
  
-   "\\\\\\\MyServer\\\MyShare" C# 또는 "\\\MyServer\MyShare" Visual Basic의 합니다.  
  
 기본적으로 새 디렉터리에 대 한 모든 읽기/쓰기 액세스는 모든 사용자에 게 부여 됩니다. 그러나 응용 프로그램에 기존 디렉터리에 액세스 하는 올바른 보안이 있어야 합니다.  
  
 에 디렉터리 및 모든 하위 디렉터리를 디렉터리 구분 문자로 사용 하 여 경로 문자열 끝에 대 한 사용 권한을 요구 합니다. (예를 들어 "C:\Temp\\" C:\Temp\ 및 모든 하위 디렉터리에 대 한 액세스를 부여 합니다.) 에 특정 디렉터리 종료 시간으로 경로 문자열에 대 한 사용 권한을 요구 합니다. (예를 들어 "C:\Temp\\." C:\Temp에만 액세스 권한을 부여\\, 하위 디렉터리에 없습니다.)  
  
 허용 하는 멤버에는 `searchPattern` 매개 변수를 검색 문자열 리터럴 문자 및 두 개의 와일드 카드 문자; 조합이 포함 될 수 \* 및?입니다. 이 매개 변수는 정규식을 인식 하지 못합니다. 자세한 내용은 참조는 <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> 메서드 또는 다른 메서드를 사용 하는 `searchPattern` 매개 변수입니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
 <xref:System.IO.Directory> 및 <xref:System.IO.DirectoryInfo> 에서 사용 하기 위해 지원 되지 않습니다 [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] 앱. 파일 및 폴더에 액세스 하는 방법에 대 한 내용은 [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] 앱 참조 [파일 (Windows 스토어 앱) 및 데이터 액세스](http://msdn.microsoft.com/library/windows/apps/hh758319.aspx)합니다.  
  
   
  
## Examples  
 다음 예제에서는 디렉터리에서 모든 텍스트 파일을 검색 하 고 새 디렉터리로 이동 하는 방법을 보여 줍니다. 파일을 이동한 후 원래 디렉터리에 더 이상 없습니다.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 다음 예제에서는 사용 하는 방법을 <xref:System.IO.Directory.EnumerateFiles%2A> 메서드를 디렉터리에서 텍스트 파일의 컬렉션을 검색 한 다음 "예"를 포함 하는 모든 줄을 찾을 수는 쿼리에서 해당 컬렉션을 사용 합니다.  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 다음 예제에서는 디렉터리와 모든 파일을 새 디렉터리로 이동 하는 방법을 보여 줍니다. 이 이동 하면 원래 디렉터리 존재 하지 않습니다.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 경로에 모든 디렉터리를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">만들 디렉터리입니다.</param>
        <summary>이미 존재하지 않는 한 지정된 경로에 모든 디렉터리와 하위 디렉터리를 만듭니다.</summary>
        <returns>지정된 경로에서 디렉터리를 나타내는 개체입니다. 이 개체는 지정된 경로에 디렉터리가 이미 존재하는지 여부와 관계없이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 지정 된 모든 디렉터리가 `path` 생성, 또는 디렉터리가 존재 하지 않는 한 부분이 `path` 올바르지 않습니다. 디렉터리가 이미 있는,이 메서드는 새 디렉터리를 만들지 않습니다 있지만 반환 하는 경우는 <xref:System.IO.DirectoryInfo> 기존 디렉터리에 대 한 개체입니다.  
  
 `path` 매개 변수는 파일 경로가 아닌 디렉터리 경로 지정 합니다.  
  
 끝에서 후행 공백을 제거는 `path` 디렉터리를 만들기 전에 매개 변수입니다.  
  
 에 대 한 쓰기 권한이 있는 공유에 원격 컴퓨터에 디렉터리를 만들 수 있습니다. UNC 경로 지원 됩니다. 예를 들어 다음을 지정할 수 있습니다 `path`: `\\2009\Archives\December` Visual basic에서 및 `\\\\2009\\Archives\\December` C#입니다.  
  
 지원 되지 않으며 하면 콜론 (:)를 사용 하 여 디렉터리를 만들기는 `NotSupportedException` throw 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 만들고 지정된 된 디렉터리를 삭제 합니다.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 현재 디렉터리가 C:\Users\User1 있을 때 C:\Users\User1\Public\Html 디렉터리를 만들려면 백슬래시 올바르게 해석 되도록 다음 호출을 사용 합니다.  
  
 Visual basic의 경우:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 C + +:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />에 의해 지정된 디렉터리가 파일입니다.  
  
 또는  
  
 네트워크 이름을 알 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 또는  
  
 콜론 문자(:)가 <paramref name="path" /> 앞에 오거나 포함됩니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />에 드라이브 레이블("C:\\")에 속하지 않는 콜론 문자(:)가 포함되어 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">읽기 / 쓰기 파일 또는 디렉터리입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">만들 디렉터리입니다.</param>
        <param name="directorySecurity">디렉터리에 적용할 액세스 제어입니다.</param>
        <summary>이미 존재하지 않는 경우 지정된 경로에 모든 디렉터리를 만들고 지정된 Windows 보안을 적용합니다.</summary>
        <returns>지정된 경로에서 디렉터리를 나타내는 개체입니다. 이 개체는 지정된 경로에 디렉터리가 이미 존재하는지 여부와 관계없이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드를 사용 하 여 디렉터리를 만들려면 액세스 제어를 사용 하므로 가능성이 보안 적용 되기 전에 디렉터리에 액세스할 수 없습니다.  
  
 에 지정 된 모든 디렉터리는 `path` 매개 변수가 생성 하지 않는 한 또는 이미 존재 하지 않는 한 부분이 `path` 올바르지 않습니다. `path` 매개 변수는 파일 경로가 아닌 디렉터리 경로 지정 합니다. 디렉터리가 이미 있는,이 메서드는 새 디렉터리를 만들지 않습니다 있지만 반환 하는 경우는 <xref:System.IO.DirectoryInfo> 기존 디렉터리에 대 한 개체입니다.  
  
 끝에서 후행 공백을 제거는 `path` 디렉터리를 만들기 전에 매개 변수입니다.  
  
 에 대 한 쓰기 권한이 있는 공유에 원격 컴퓨터에 디렉터리를 만들 수 있습니다. UNC 경로 지원 됩니다. 예를 들어 다음을 지정할 수 있습니다 `path`: `\\2009\Archives\December` Visual basic에서 및 `\\\\2009\\Archives\\December` C#입니다.  
  
 콜론 (:)를 사용 하 여 디렉터리를 만들기는 지원 되지 않으며 사용 하면 한 `NotSupportedException` throw 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 사용자 계정에 대 한 액세스 규칙으로 새 디렉터리를 만듭니다.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />에 의해 지정된 디렉터리가 파일입니다.  
  
 또는  
  
 네트워크 이름을 알 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 또는  
  
 콜론 문자(:)가 <paramref name="path" /> 앞에 오거나 포함됩니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />에 드라이브 레이블("C:\\")에 속하지 않는 콜론 문자(:)가 포함되어 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">읽기 및 쓰기 파일 및 디렉터리에 대 한 대상 디렉터리에 액세스할 수 있습니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 디렉터리와 선택적으로 하위 디렉터리를 삭제합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">제거할 빈 디렉터리의 이름입니다. 해당 디렉터리는 쓰기가 가능하고 비어 있어야 합니다.</param>
        <summary>지정된 경로에서 빈 디렉터리를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 동일 하 게 동작 <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> 와 `false` 두 번째 매개 변수에 대해 지정 합니다.  
  
 `path` 매개 변수는 상대 또는 절대 경로 정보를 지정할 수 있습니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 끝에서 후행 공백을 제거는 `path` 디렉터리를 삭제 하기 전에 매개 변수입니다.  
  
 이 메서드에서 throw 된 <xref:System.IO.IOException> 디렉터리에 지정 된 경우는 `path` 매개 변수가 파일이 나 하위 디렉터리를 포함 합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 파일 탐색기에서 지정 된 디렉터리가 있는 경우 일부 경우에는 <xref:System.IO.Directory.Delete%2A> 메서드를 삭제할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 새 디렉터리 및 하위 디렉터리를 만들고 다음의 하위 디렉터리를 삭제 하는 방법을 보여 줍니다.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />에 지정된 이름 및 위치와 동일한 파일이 있습니다.  
  
 또는  
  
 이 디렉터리는 응용 프로그램의 현재 작업 디렉터리입니다.  
  
 또는  
  
 <paramref name="path" />에 지정된 디렉터리가 비어 있지 않습니다.  
  
 또는  
  
 디렉터리가 읽기 전용이거나 읽기 전용 파일을 포함합니다.  
  
 또는  
  
 디렉터리가 다른 프로세스에서 사용 중입니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 존재하지 않거나 찾을 수 없습니다.  
  
 또는  
  
 지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 지정된 된 디렉터리에 기록 됩니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">제거할 디렉터리의 이름입니다.</param>
        <param name="recursive">
          <c>경로</c>의 디렉터리, 하위 디렉터리 및 파일을 제거하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 디렉터리와 해당 디렉터리의 하위 디렉터리 및 파일을 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` 매개 변수는 상대 또는 절대 경로 정보를 지정할 수 있습니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 끝에서 후행 공백을 제거는 `path` 디렉터리를 삭제 하기 전에 매개 변수입니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 경우는 `recursive` 매개 변수는 `true`, 사용자는 현재 디렉터리와 모든 하위 디렉터리에 대 한 쓰기 권한이 있어야 합니다.  
  
 이 메서드의 동작은 재분석 지점, 기호화 된 링크 또는 탑재 지점을 등이 포함 된 디렉터리를 삭제할 때 약간 다릅니다. 재분석 지점이 디렉터리 이면 탑재 지점과 같은 없으면 탑재 하 고 탑재 지점이 삭제 됩니다. 이 메서드는 재분석 지점을 통해 재귀 되지 않습니다. 재분석 지점이 삭제 됩니다 재분석 지점 파일에 기호화 된 링크 이면와 기호화 된 링크의 대상이 되지 않습니다.  
  
 파일 탐색기에서 지정 된 디렉터리가 있는 경우 일부 경우에는 <xref:System.IO.Directory.Delete%2A> 메서드를 삭제할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에는 하위 디렉터리에 새 디렉터리, 하위 디렉터리 및 파일을 만드는 방법을 보여 줍니다 및 다음 재귀적으로 모든 새 항목을 삭제 합니다.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />에 지정된 이름 및 위치와 동일한 파일이 있습니다.  
  
 또는  
  
 <paramref name="path" />로 지정한 디렉터리가 읽기 전용이거나 <paramref name="recursive" />가 <see langword="false" />이고 <paramref name="path" />가 빈 디렉터리가 아닙니다.  
  
 또는  
  
 이 디렉터리는 응용 프로그램의 현재 작업 디렉터리입니다.  
  
 또는  
  
 디렉터리에 읽기 전용 파일이 포함되어 있습니다.  
  
 또는  
  
 디렉터리가 다른 프로세스에서 사용 중입니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 존재하지 않거나 찾을 수 없습니다.  
  
 또는  
  
 지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 지정된 된 디렉터리에 기록 됩니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 조건을 충족하는 디렉터리 이름의 열거 가능 컬렉션을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <summary>지정된 경로에 있는 디렉터리 이름의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="path" />로 지정된 디렉터리에서 디렉터리에 대한 전체 이름(경로 포함)의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 상대 또는 절대 경로 정보를 지정할 수는 `path` 매개 변수입니다. 상대 경로 정보를 사용 하 여 확인할 수 있는 현재 작업 디렉터리에 상대적으로 해석 됩니다는 <xref:System.IO.Directory.GetCurrentDirectory%2A> 메서드. 사용자가 제공한 값으로 반환된 된 디렉터리 이름 접두사는 `path` 매개 변수입니다. 예를 들어에서 상대 경로 제공 하는 경우는 `path` 매개 변수, 반환된 된 디렉터리 이름에 상대 경로가 포함 됩니다.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> 및 <xref:System.IO.Directory.GetDirectories%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateDirectories%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetDirectories%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateDirectories%2A> 더 효과적일 수 있습니다.  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 호출할 때마다는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 컬렉션에 새 열거형을 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 경로에서 최상위 디렉터리를 열거합니다.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나 공백만을 포함하거나 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 잘못되었습니다(예: 매핑되지 않은 드라이브 참조).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 이 둘의 조합이 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 디렉터리 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>지정된 경로에서 검색 패턴과 일치하는 디렉터리 이름의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="path" />로 지정되고 지정된 검색 패턴과 일치하는 디렉터리에서 디렉터리에 대한 전체 이름(경로 포함)의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 0 개 또는 1 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 에 대 한 상대 또는 절대 경로 정보를 지정할 수는 `path` 매개 변수입니다. 상대 경로 정보를 사용 하 여 확인할 수 있는 현재 작업 디렉터리에 상대적으로 해석 됩니다는 <xref:System.IO.Directory.GetCurrentDirectory%2A> 메서드. 사용자가 제공한 값으로 반환된 된 디렉터리 이름 접두사는 `path` 매개 변수입니다. 예를 들어에서 상대 경로 제공 하는 경우는 `path` 매개 변수, 반환된 된 디렉터리 이름에 상대 경로가 포함 됩니다.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> 및 <xref:System.IO.Directory.GetDirectories%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateDirectories%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetDirectories%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateDirectories%2A> 더 효과적일 수 있습니다.  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 호출할 때마다는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 컬렉션에 새 열거형을 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 검색 패턴과 일치 하는 지정된 된 경로에서 최상위 디렉터리를 열거 합니다.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나 공백만을 포함하거나 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 \- 또는 -  
  
 <paramref name="searchPattern" />에 유효한 패턴이 포함되어 있지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 잘못되었습니다(예: 매핑되지 않은 드라이브 참조).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 이 둘의 조합이 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 디렉터리 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다.  
  
 기본값은 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />입니다.</param>
        <summary>지정된 경로에서 검색 패턴과 일치하는 디렉터리 이름의 열거 가능 컬렉션을 반환하고 선택적으로 하위 디렉터리를 검색합니다.</summary>
        <returns>
          <paramref name="path" />로 지정되고 지정된 검색 패턴 및 옵션과 일치하는 디렉터리에 대한 전체 이름(경로 포함)의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 정확히 한 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 에 대 한 상대 또는 절대 경로 정보를 지정할 수는 `path` 매개 변수입니다. 상대 경로 정보를 사용 하 여 확인할 수 있는 현재 작업 디렉터리에 상대적으로 해석 됩니다는 <xref:System.IO.Directory.GetCurrentDirectory%2A> 메서드. 사용자가 제공한 값으로 반환된 된 디렉터리 이름 접두사는 `path` 매개 변수입니다. 예를 들어에서 상대 경로 제공 하는 경우는 `path` 매개 변수, 반환된 된 디렉터리 이름에 상대 경로가 포함 됩니다.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> 및 <xref:System.IO.Directory.GetDirectories%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateDirectories%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetDirectories%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateDirectories%2A> 더 효과적일 수 있습니다.  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 호출할 때마다는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 컬렉션에 새 열거형을 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 검색 패턴과 일치 하는 지정된 된 경로에서 디렉터리를 열거 합니다. 사용 하 여는 `searchOption` 매개 변수를 지정 된 모든 하위 디렉터리는 검색에 포함 해야 합니다.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나 공백만을 포함하거나 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 \- 또는 -  
  
 <paramref name="searchPattern" />에 유효한 패턴이 포함되어 있지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />은 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 잘못되었습니다(예: 매핑되지 않은 드라이브 참조).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 이 둘의 조합이 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 조건을 충족하는 파일 이름의 열거 가능 컬렉션을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <summary>지정된 경로에 있는 파일 이름의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="path" />로 지정된 파일에서 디렉터리에 대한 전체 이름(경로 포함)의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상대 경로 정보를 지정할 수는 `path` 매개 변수입니다. 상대 경로 정보를 사용 하 여 확인할 수 있는 현재 작업 디렉터리에 상대적으로 해석 됩니다는 <xref:System.IO.Directory.GetCurrentDirectory%2A> 메서드.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> 및 <xref:System.IO.Directory.GetFiles%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateFiles%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetFiles%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateFiles%2A> 더 효과적일 수 있습니다.  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 호출할 때마다는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 컬렉션에 새 열거형을 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 디렉터리의 모든 파일을 검색 하 고 새 디렉터리로 이동 하는 방법을 보여 줍니다. 파일을 이동한 후 원래 디렉터리에 더 이상 없습니다.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 파일의 각 줄을 읽은 다음 예제에서는 지정된 된 디렉터리에서 파일을 열거 하 고 "Europe" 문자열이 포함 된 줄을 표시 합니다.  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나 공백만을 포함하거나 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 잘못되었습니다(예: 매핑되지 않은 드라이브 참조).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 이 둘의 조합이 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 파일 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>지정된 경로에서 검색 패턴과 일치하는 파일 이름의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="path" />로 지정되고 지정된 검색 패턴과 일치하는 디렉터리에서 파일에 대한 전체 이름(경로 포함)의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 0 개 또는 1 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
> [!NOTE]
>  에 별표 와일드 카드 문자를 사용 하는 경우는 `searchPattern` 와 같은 "\*.txt"를 지정된 된 확장에 있는 문자의 수에 영향을 줍니다 검색 다음과 같습니다.  
>   
>  -   정확히 3 자 지정한 확장명을 사용 하는 경우 메서드는 지정한 확장명으로 시작 하는 확장명을 가진 파일을 반환 합니다. 예를 들어 "\*.xls" 모두 "book.xls" 및 "book.xlsx"를 반환 합니다.  
> -   다른 모든 경우 메서드는 지정한 확장명을 정확 하 게 일치 하는 파일을 반환 합니다. 예를 들어 "\*.ai" "file.ai" 없습니다 "file.aif"를 반환 합니다.  
>   
>  물음표 와일드 카드 문자를 사용 하는 경우이 메서드는 지정 된 파일 확장명과 일치 하는 파일에만 반환 합니다. 예를 들어 두 개의 파일, "file1.txt" 및 "file1.txtother" 디렉터리를 검색 패턴은에 지정 된 "파일?입니다. txt"첫 번째 파일만 반환 하는 반면 검색 패턴은" 파일\*.txt "파일을 모두 반환 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 상대 경로 정보를 지정할 수는 `path` 매개 변수입니다. 상대 경로 정보를 사용 하 여 확인할 수 있는 현재 작업 디렉터리에 상대적으로 해석 됩니다는 <xref:System.IO.Directory.GetCurrentDirectory%2A> 메서드.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> 및 <xref:System.IO.Directory.GetFiles%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateFiles%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetFiles%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateFiles%2A> 더 효과적일 수 있습니다.  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 호출할 때마다는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 컬렉션에 새 열거형을 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 디렉터리에 있는 모든 텍스트 파일을 검색 하 고 새 디렉터리로 이동 하는 방법을 보여 줍니다. 파일을 이동한 후 원래 디렉터리에 더 이상 없습니다.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 파일의 각 줄을 읽은 다음 예제에서는.txt 확장명을 가진 지정된 된 디렉터리에서 파일을 열거 하 고 "Europe" 문자열이 포함 된 줄을 표시 합니다.  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나 공백만을 포함하거나 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 \- 또는 -  
  
 <paramref name="searchPattern" />에 유효한 패턴이 포함되어 있지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 잘못되었습니다(예: 매핑되지 않은 드라이브 참조).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 이 둘의 조합이 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 파일 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다.  
  
 기본값은 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />입니다.</param>
        <summary>지정된 경로에서 검색 패턴과 일치하는 파일 이름의 열거 가능 컬렉션을 반환하고 선택적으로 하위 디렉터리를 검색합니다.</summary>
        <returns>
          <paramref name="path" />로 지정되고 지정된 검색 패턴 및 옵션과 일치하는 디렉터리에서 파일에 대한 전체 이름(경로 포함)의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 0 개 또는 1 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
> [!NOTE]
>  에 별표 와일드 카드 문자를 사용 하는 경우는 `searchPattern` 와 같은 "\*.txt"를 지정된 된 확장에 있는 문자의 수에 영향을 줍니다 검색 다음과 같습니다.  
>   
>  -   정확히 3 자 지정한 확장명을 사용 하는 경우 메서드는 지정한 확장명으로 시작 하는 확장명을 가진 파일을 반환 합니다. 예를 들어 "\*.xls" 모두 "book.xls" 및 "book.xlsx"를 반환 합니다.  
> -   다른 모든 경우 메서드는 지정한 확장명을 정확 하 게 일치 하는 파일을 반환 합니다. 예를 들어 "\*.ai" "file.ai" 없습니다 "file.aif"를 반환 합니다.  
>   
>  물음표 와일드 카드 문자를 사용 하는 경우이 메서드는 지정 된 파일 확장명과 일치 하는 파일에만 반환 합니다. 예를 들어 두 개의 파일, "file1.txt" 및 "file1.txtother" 디렉터리를 검색 패턴은에 지정 된 "파일?입니다. txt"첫 번째 파일만 반환 하는 반면 검색 패턴은" 파일\*.txt "파일을 모두 반환 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 상대 경로 정보를 지정할 수는 `path` 매개 변수입니다. 상대 경로 정보를 사용 하 여 확인할 수 있는 현재 작업 디렉터리에 상대적으로 해석 됩니다는 <xref:System.IO.Directory.GetCurrentDirectory%2A> 메서드.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> 및 <xref:System.IO.Directory.GetFiles%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateFiles%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetFiles%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateFiles%2A> 더 효과적일 수 있습니다.  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 호출할 때마다는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 컬렉션에 새 열거형을 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 디렉터리 및 하위 디렉터리의 모든 텍스트 파일을 검색 하 고 새 디렉터리로 이동 하는 방법을 보여 줍니다. 파일을 이동한 후 원래 디렉터리에 더 이상 없습니다.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 파일의 각 줄을 읽은 다음 예제에서는 재귀적으로 확장명이.txt 인 모든 파일을 열거 하 고 문자열 "Microsoft"를 포함 하는 경우 줄을 표시 합니다.  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나 공백만을 포함하거나 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 \- 또는 -  
  
 <paramref name="searchPattern" />에 유효한 패턴이 포함되어 있지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />은 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 잘못되었습니다(예: 매핑되지 않은 드라이브 참조).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 이 둘의 조합이 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 조건을 충족하는 파일 시스템 항목의 열거 가능 컬렉션을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <summary>지정된 경로에 있는 파일 이름 및 디렉터리 이름의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="path" />로 지정된 디렉터리에 있는 파일 시스템 항목의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상대 경로 정보를 지정할 수는 `path` 매개 변수입니다. 상대 경로 정보를 사용 하 여 확인할 수 있는 현재 작업 디렉터리에 상대적으로 해석 됩니다는 <xref:System.IO.Directory.GetCurrentDirectory%2A> 메서드.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> 및 <xref:System.IO.Directory.GetFileSystemEntries%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, 전체 컬렉션을 반환 하기 전에 항목의 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetFileSystemEntries%2A>, 항목의 전체 배열에 대해 기다려야 반환 되기 전에 배열에 액세스할 수 있습니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateFiles%2A> 더 효과적일 수 있습니다.  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 호출할 때마다는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 컬렉션에 새 열거형을 시작 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나 공백만을 포함하거나 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 잘못되었습니다(예: 매핑되지 않은 드라이브 참조).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 이 둘의 조합이 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 파일 시스템 항목 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>지정된 경로에서 검색 패턴과 일치하는 파일 이름 및 디렉터리 이름의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="path" />로 지정된 디렉터리에서 지정된 검색 패턴과 일치하는 파일 시스템 항목의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`...  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 0 개 또는 1 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
> [!NOTE]
>  에 별표 와일드 카드 문자를 사용 하는 경우는 `searchPattern` 와 같은 "\*.txt"를 지정된 된 확장에 있는 문자의 수에 영향을 줍니다 검색 다음과 같습니다.  
>   
>  -   정확히 3 자 지정한 확장명을 사용 하는 경우 메서드는 지정한 확장명으로 시작 하는 확장명을 가진 파일을 반환 합니다. 예를 들어 "\*.xls" 모두 "book.xls" 및 "book.xlsx"를 반환 합니다.  
> -   다른 모든 경우 메서드는 지정한 확장명을 정확 하 게 일치 하는 파일을 반환 합니다. 예를 들어 "\*.ai" "file.ai" 없습니다 "file.aif"를 반환 합니다.  
>   
>  물음표 와일드 카드 문자를 사용 하는 경우이 메서드는 지정 된 파일 확장명과 일치 하는 파일에만 반환 합니다. 예를 들어 두 개의 파일, "file1.txt" 및 "file1.txtother" 디렉터리를 검색 패턴은에 지정 된 "파일?입니다. txt"첫 번째 파일만 반환 하는 반면 검색 패턴은" 파일\*.txt "파일을 모두 반환 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 상대 경로 정보를 지정할 수는 `path` 매개 변수입니다. 상대 경로 정보를 사용 하 여 확인할 수 있는 현재 작업 디렉터리에 상대적으로 해석 됩니다는 <xref:System.IO.Directory.GetCurrentDirectory%2A> 메서드.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> 및 <xref:System.IO.Directory.GetFileSystemEntries%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, 전체 컬렉션을 반환 하기 전에 항목의 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetFileSystemEntries%2A>, 항목의 전체 배열에 대해 기다려야 반환 되기 전에 배열에 액세스할 수 있습니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateFiles%2A> 더 효과적일 수 있습니다.  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 호출할 때마다는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 컬렉션에 새 열거형을 시작 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나 공백만을 포함하거나 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 \- 또는 -  
  
 <paramref name="searchPattern" />에 유효한 패턴이 포함되어 있지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 잘못되었습니다(예: 매핑되지 않은 드라이브 참조).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 이 둘의 조합이 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 파일 시스템 항목과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다.  
  
 기본값은 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />입니다.</param>
        <summary>지정된 경로에서 검색 패턴과 일치하는 파일 이름 및 디렉터리 이름의 열거 가능 컬렉션을 반환하고 선택적으로 하위 디렉터리를 검색합니다.</summary>
        <returns>
          <paramref name="path" />로 지정된 디렉터리에서 지정된 검색 패턴 및 옵션과 일치하는 파일 시스템 항목의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 0 개 또는 1 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
> [!NOTE]
>  에 별표 와일드 카드 문자를 사용 하는 경우는 `searchPattern` 와 같은 "\*.txt"를 지정된 된 확장에 있는 문자의 수에 영향을 줍니다 검색 다음과 같습니다.  
>   
>  -   정확히 3 자 지정한 확장명을 사용 하는 경우 메서드는 지정한 확장명으로 시작 하는 확장명을 가진 파일을 반환 합니다. 예를 들어 "\*.xls" 모두 "book.xls" 및 "book.xlsx"를 반환 합니다.  
> -   다른 모든 경우 메서드는 지정한 확장명을 정확 하 게 일치 하는 파일을 반환 합니다. 예를 들어 "\*.ai" "file.ai" 없습니다 "file.aif"를 반환 합니다.  
>   
>  물음표 와일드 카드 문자를 사용 하는 경우이 메서드는 지정 된 파일 확장명과 일치 하는 파일에만 반환 합니다. 예를 들어 두 개의 파일, "file1.txt" 및 "file1.txtother" 디렉터리를 검색 패턴은에 지정 된 "파일?입니다. txt"첫 번째 파일만 반환 하는 반면 검색 패턴은" 파일\*.txt "파일을 모두 반환 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 상대 경로 정보를 지정할 수는 `path` 매개 변수입니다. 상대 경로 정보를 사용 하 여 확인할 수 있는 현재 작업 디렉터리에 상대적으로 해석 됩니다는 <xref:System.IO.Directory.GetCurrentDirectory%2A> 메서드.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> 및 <xref:System.IO.Directory.GetFileSystemEntries%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, 전체 컬렉션을 반환 하기 전에 항목의 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetFileSystemEntries%2A>, 항목의 전체 배열에 대해 기다려야 반환 되기 전에 배열에 액세스할 수 있습니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateFiles%2A> 더 효과적일 수 있습니다.  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 호출할 때마다는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 컬렉션에 새 열거형을 시작 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나 공백만을 포함하거나 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 \- 또는 -  
  
 <paramref name="searchPattern" />에 유효한 패턴이 포함되어 있지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />은 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 잘못되었습니다(예: 매핑되지 않은 드라이브 참조).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 이 둘의 조합이 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">테스트할 경로입니다.</param>
        <summary>지정된 경로가 디스크에 있는 기존 디렉터리를 참조하는지를 확인합니다.</summary>
        <returns>
          <paramref name="path" />가 기존 디렉터리를 참조하면 <see langword="true" />이고, 디렉터리가 존재하지 않거나 지정된 디렉터리가 존재하는지 확인할 때 오류가 발생하면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다.  
  
 끝에서 후행 공백을 제거는 `path` 디렉터리가 있는지 여부를 확인 하기 전에 매개 변수입니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 에 디렉터리를 최소 읽기 전용 권한이 없는 경우는 <xref:System.IO.Directory.Exists%2A> 메서드는 반환 `false`합니다.  
  
 <xref:System.IO.Directory.Exists%2A> 메서드 반환 `false` 지정한 파일이 있는지 확인 하는 동안 오류가 발생 하는 경우. 이 파일 이름에 잘못 된 문자 또는 실패 나 누락 된 디스크에 문자가 너무 많습니다. 전달할 때 예외를 발생 시키는 상황에서 발생할 수 있습니다 또는 호출자에 게 파일을 읽을 수 있는 사용 권한이 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 명령줄에서 파일 또는 디렉터리의 배열을 사용, 어떤 유형의 이름, 되며 적절 하 게 처리를 결정 합니다.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 읽기입니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>디렉터리의 Windows ACL(액세스 제어 목록)을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">파일의 ACL(액세스 제어 목록) 정보를 설명하는 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 개체가 포함된 디렉터리의 경로입니다.</param>
        <summary>지정된 디렉터리의 ACL(액세스 제어 목록) 항목을 캡슐화하는 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 개체를 가져옵니다.</summary>
        <returns>
          <paramref name="path" /> 매개 변수에서 설명하는 파일의 액세스 제어 규칙을 캡슐화하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.Directory.GetAccessControl%2A> 디렉터리에 대 한 액세스 제어 목록 (ACL) 항목을 검색 하는 메서드입니다.  
  
 ACL에는 개인 및/또는 그룹 나 권한이 없는, 특정된 파일이 나 디렉터리에서 특정 작업을 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
 NTFS 환경에서 <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> 및 <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> 사용자에 게 하는 경우 사용자에 게 권한이 부여 됩니다 <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> 부모 폴더에 대 한 합니다. 거부 하려면 <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> 및 <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, 거부 <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> 부모 디렉터리에 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.Directory.GetAccessControl%2A> 및 <xref:System.IO.Directory.SetAccessControl%2A> 대 한 액세스 권한을 추가 하는 메서드 목록 (ACL) 항목을 제어 하 고 다음 디렉터리에서 ACL 항목을 제거 합니다.  이 예제를 실행하려면 유효한 사용자 또는 그룹 계정을 제공해야 합니다.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.IOException">디렉터리를 여는 동안 I/O 오류가 발생한 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Windows 2000 이상이 아닙니다.</exception>
        <exception cref="T:System.SystemException">시스템 수준 오류가(예: 디렉터리를 찾을 수 없음) 발생했습니다. 특정 예외는 <see cref="T:System.SystemException" />의 서브클래스일 수 있습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 매개 변수가 읽기 전용 디렉터리를 지정하는 경우  
  
 또는  
  
 현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
 또는  
  
 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">디렉터리에 대 한 액세스 제어 목록 (ACL)를 열거할 수 있는 권한입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
 보안 동작: 요청 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">파일의 ACL(액세스 제어 목록) 정보를 설명하는 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 개체가 포함된 디렉터리의 경로입니다.</param>
        <param name="includeSections">가져올 ACL(액세스 제어 목록) 정보의 형식을 지정하는 <see cref="T:System.Security.AccessControl.AccessControlSections" /> 값 중 하나입니다.</param>
        <summary>지정된 디렉터리의 지정된 ACL(액세스 제어 목록) 항목 형식을 캡슐화하는 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 개체를 가져옵니다.</summary>
        <returns>
          <paramref name="path" /> 매개 변수에서 설명하는 파일의 액세스 제어 규칙을 캡슐화하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.Directory.GetAccessControl%2A> 디렉터리에 대 한 액세스 제어 목록 (ACL) 항목을 검색 하는 메서드입니다.  
  
 ACL에는 개인 및/또는 그룹 나 권한이 없는, 특정된 파일이 나 디렉터리에서 특정 작업을 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
 NTFS 환경에서 <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> 및 <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> 사용자에 게 하는 경우 사용자에 게 권한이 부여 됩니다 <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> 부모 폴더에 대 한 합니다. 거부 하려면 <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> 및 <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, 거부 <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> 부모 디렉터리에 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.IOException">디렉터리를 여는 동안 I/O 오류가 발생한 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Windows 2000 이상이 아닙니다.</exception>
        <exception cref="T:System.SystemException">시스템 수준 오류가(예: 디렉터리를 찾을 수 없음) 발생했습니다. 특정 예외는 <see cref="T:System.SystemException" />의 서브클래스일 수 있습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 매개 변수가 읽기 전용 디렉터리를 지정하는 경우  
  
 또는  
  
 현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
 또는  
  
 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">디렉터리에 대 한 액세스 제어 목록 (ACL)를 열거할 수 있는 권한입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
 보안 동작: 요청 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">디렉터리 경로입니다.</param>
        <summary>디렉터리를 만든 날짜와 시간을 가져옵니다.</summary>
        <returns>지정된 디렉터리를 만든 날짜와 시간으로 설정된 구조체입니다. 이 값은 현지 시간으로 표현됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 메서드는 운영 체제에 의해 값을 가진 지속적으로 업데이트 되지 않을 수 있습니다는 네이티브 함수를 사용 하기 때문에 정확 하지 않은 값을 반환할 수 있습니다.  
  
 이 메서드는 <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>합니다.  
  
 디렉터리에서 설명 하는 경우는 `path` 매개 변수가 없는,이 메서드가 반환 서 기 1601 년 1 월 1 일 자정 12 시 (C.E.) Utc (협정 세계시)를 현지 시간으로 조정 합니다.  
  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 디렉터리의 생성 시간을 가져옵니다.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 지정 된 파일 또는 디렉터리를 읽고 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">디렉터리 경로입니다.</param>
        <summary>디렉터리를 만든 날짜와 시간을 UTC(Coordinated Universal Time) 형식으로 가져옵니다.</summary>
        <returns>지정된 디렉터리를 만든 날짜와 시간으로 설정된 구조체입니다. 이 값은 UTC 시간으로 표현됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 메서드는 운영 체제에 의해 값을 가진 지속적으로 업데이트 되지 않을 수 있습니다는 네이티브 함수를 사용 하기 때문에 정확 하지 않은 값을 반환할 수 있습니다.  
  
 디렉터리에서 설명 하는 경우는 `path` 매개 변수가 없는,이 메서드가 반환 서 기 1601 년 1 월 1 일 자정 12 시 (C.E.) Utc (협정 세계시)입니다.  
  
 이 메서드를 사용 하 여 utc (협정 세계시)에 따라 디렉터리에 대 한 생성 시간을 가져옵니다.  
  
   
  
## Examples  
 Utc (협정 세계시) 출력을 사용 하는 경우 다음 예제에서는 출력의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 지정 된 파일 또는 디렉터리를 읽고 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램의 현재 작업 디렉터리를 가져옵니다.</summary>
        <returns>현재 작업 디렉터리의 경로를 포함하고 백슬래시(\\)로 끝나지 않는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 디렉터리는 원래 디렉터리 프로세스가 시작 된 것과에서 다릅니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 `GetCurrentDirectory` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.NotSupportedException">운영 체제가 현재 디렉터리 기능이 없는 Windows CE입니다.  
  
 이 메서드는 .NET Compact Framework에서 사용할 수 있지만 현재 지원되지 않습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">현재 디렉터리에 대 한 경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 조건을 충족하는 하위 디렉터리 이름을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <summary>지정된 디렉터리에 있는 하위 디렉터리의 이름(경로 포함)을 반환합니다.</summary>
        <returns>지정된 경로에서 하위 디렉터리의 전체 이름(경로 포함)의 배열이거나 디렉터리가 없으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 동일 <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> 별표 (\*)는 검색 패턴으로 지정 하므로 반환 모든 하위 디렉터리입니다. 사용 하 여 하위 디렉터리를 검색 해야 하는 경우는 <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> 의 하위 디렉터리를 검색 하도록 지정할 수 있는 메서드는 `searchOption` 매개 변수입니다.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> 및 <xref:System.IO.Directory.GetDirectories%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateDirectories%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetDirectories%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateDirectories%2A> 더 효과적일 수 있습니다.  
  
 `path` 매개 변수는 상대 또는 절대 경로 정보를 지정할 수 있습니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 이 메서드에 의해 반환 되는 이름에 제공 된 디렉터리 정보 접두사가 추가 되며 `path`합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 명령줄에서 파일 또는 디렉터리의 배열을 사용, 어떤 유형의 이름, 되며 적절 하 게 처리를 결정 합니다.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">현재 디렉터리에 대 한 경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 하위 디렉터리 이름과 일치하는지 비교할 검색 문자열입니다. 이 매개 변수는 유효한 리터럴 및 와일드카드 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>지정된 디렉터리에서 지정된 검색 패턴과 일치하는 하위 디렉터리 이름(파일 경로 포함)을 반환합니다.</summary>
        <returns>지정된 디렉터리에서 검색 패턴과 일치하는 하위 디렉터리의 전체 이름(경로 포함)의 배열이거나 디렉터리가 없으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 지정된 된 검색 패턴과 일치 하는 지정된 된 디렉터리 바로 아래 모든 하위 디렉터리를 반환 합니다. 지정된 된 디렉터리에 하위 디렉터리가 없는지 또는 하위 디렉터리가 없는지와 일치 하는 경우는 `searchPattern` 매개 변수를이 메서드는 빈 배열을 반환 합니다. 상위 디렉터리만 검색 됩니다. 하위 디렉터리를 검색 하려는 경우 사용 하 여는 <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> 메서드를 지정 하 고 <xref:System.IO.SearchOption.AllDirectories> 에 `searchOption` 매개 변수입니다.  
  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 0 개 또는 1 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 `path` 매개 변수 상대 또는 절대 경로 정보를 지정할 수 이며 대/소문자 구분 하지 않습니다.  상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> 및 <xref:System.IO.Directory.GetDirectories%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateDirectories%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetDirectories%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateDirectories%2A> 더 효과적일 수 있습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 문자로 시작 하는 경로에서 디렉터리의 수를 계산 합니다.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" />를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 또는  
  
 <paramref name="searchPattern" />이 유효한 패턴을 포함하지 않는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 또는 <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">현재 디렉터리에 대 한 경로 정보에 액세스 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 하위 디렉터리 이름과 일치하는지 비교할 검색 문자열입니다. 이 매개 변수는 유효한 리터럴 및 와일드카드 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 디렉터리에서 지정된 검색 패턴과 일치하는 하위 디렉터리(해당 경로 포함)의 이름을 가져오고 선택적으로 하위 디렉터리를 반환합니다.</summary>
        <returns>지정된 조건과 일치하는 하위 디렉터리의 전체 이름(경로 포함)의 배열이거나 디렉터리가 없으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` 매개 변수 상대 또는 절대 경로 정보를 지정할 수 이며 대/소문자 구분 하지 않습니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 0 개 또는 1 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> 및 <xref:System.IO.Directory.GetDirectories%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateDirectories%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetDirectories%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateDirectories%2A> 더 효과적일 수 있습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 경로에 지정 된 문자로 시작 하는 디렉터리의 수를 계산 합니다. 최상위 디렉터리만 검색 됩니다.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 또는  
  
 <paramref name="searchPattern" />에 유효한 패턴이 포함되어 있지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 또는 <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />은 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">현재 디렉터리에 대 한 경로 정보에 액세스 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">파일 또는 디렉터리의 경로입니다.</param>
        <summary>지정된 경로에 대한 볼륨 정보, 루트 정보 또는 두 정보 모두를 반환합니다.</summary>
        <returns>지정된 경로에 대한 볼륨 정보, 루트 정보 또는 두 정보 모두를 포함하는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 정규화 된 경로 이름을 가져옵니다 `path`반환한, <xref:System.IO.Path.GetFullPath%2A>, 루트 디렉터리 정보를 반환 하 고 있습니다. 지정 된 경로가 존재 하지 않아도 됩니다.  
  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에는 현재 디렉터리를 설정 하 고 루트 디렉터리를 표시 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" />로 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">현재 디렉터리에 대 한 경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 조건을 충족하는 파일 이름을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <summary>지정된 디렉터리에 있는 파일의 이름(경로 포함)을 반환합니다.</summary>
        <returns>지정된 디렉터리에서 파일의 전체 이름(경로 포함)의 배열이거나 파일이 없으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory.EnumerateFiles%2A> 및 <xref:System.IO.Directory.GetFiles%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateFiles%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetFiles%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateFiles%2A> 더 효과적일 수 있습니다.  
  
 반환 된 파일 이름에 제공 된 `path` 매개 변수입니다.  
  
 이 메서드는 동일 <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> 별표 (\*)는 검색 패턴으로 지정 합니다.  
  
 `path` 매개 변수는 상대 또는 절대 경로 정보를 지정할 수 있습니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 반환 되는 파일 이름의 순서를 보장할 수 없습니다. 사용 하 여는 <xref:System.Array.Sort%2A> 메서드 특정 정렬 순서를 적용 해야 하는 경우.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 <xref:System.IO.Directory.GetFiles%2A> 메서드를 사용자가 지정한 위치에서 파일 이름을 반환 합니다. 이 예제에서는이 메서드를 일반적인 모든 오류 catch 하도록 구성 됩니다.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.  
  
 또는  
  
 네트워크 오류가 발생했습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 없거나 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">현재 디렉터리에 대 한 경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 파일 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>지정된 디렉터리에서 지정된 검색 패턴과 일치하는 파일 이름(파일 경로 포함)을 반환합니다.</summary>
        <returns>지정된 디렉터리에서 지정된 검색 패턴과 일치하는 파일의 전체 이름(경로 포함)의 배열이거나 파일이 없으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 파일 이름를 제공 된 `path` 매개 변수 및 반환 되는 파일 이름의 순서가 보장 되지 않습니다; 사용 하 여는 <xref:System.Array.Sort%2A> 메서드 특정 정렬 순서를 적용 해야 하는 경우.  
  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 0 개 또는 1 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
> [!NOTE]
>  에 별표 와일드 카드 문자를 사용 하는 경우는 `searchPattern` 와 같은 "\*.txt"를 지정된 된 확장에 있는 문자의 수에 영향을 줍니다 검색 다음과 같습니다.  
>   
>  -   정확히 3 자 지정한 확장명을 사용 하는 경우 메서드는 지정한 확장명으로 시작 하는 확장명을 가진 파일을 반환 합니다. 예를 들어 "\*.xls" 모두 "book.xls" 및 "book.xlsx"를 반환 합니다.  
> -   다른 모든 경우 메서드는 지정한 확장명을 정확 하 게 일치 하는 파일을 반환 합니다. 예를 들어 "\*.ai" "file.ai" 없습니다 "file.aif"를 반환 합니다.  
>   
>  물음표 와일드 카드 문자를 사용 하는 경우이 메서드는 지정 된 파일 확장명과 일치 하는 파일에만 반환 합니다. 예를 들어 두 개의 파일, "file1.txt" 및 "file1.txtother" 디렉터리를 검색 패턴은에 지정 된 "파일?입니다. txt"첫 번째 파일만 반환 하는 반면 검색 패턴은" 파일\*.txt "파일을 모두 반환 합니다.  
  
> [!NOTE]
>  검색 패턴 비슷합니다 8.3 파일 이름 형식과 긴 파일 이름 형식을 모두 포함 된 파일 이름에 대해이 메서드를 확인 하기 때문에 "\*1\*.txt" 예기치 않은 파일 이름을 반환할 수 있습니다. 예를 들어 검색 패턴을 사용 하 여 "\*1\*.txt" 해당 8.3 파일 이름 형식은 "LONGFI~1.TXT" 있기 때문에 "longfilename.txt"를 반환 합니다.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> 및 <xref:System.IO.Directory.GetFiles%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateFiles%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetFiles%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateFiles%2A> 더 효과적일 수 있습니다.  
  
 `path` 매개 변수는 상대 또는 절대 경로 정보를 지정할 수 있습니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 문자로 시작 하는 파일의 수를 계산 합니다.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.  
  
 또는  
  
 네트워크 오류가 발생했습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" />를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 또는  
  
 <paramref name="searchPattern" />이 유효한 패턴을 포함하지 않는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 또는 <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 없거나 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">현재 디렉터리에 대 한 경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 파일 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다.</param>
        <summary>하위 디렉터리를 검색할지를 나타내는 값을 사용하여 지정된 디렉터리에서 지정된 검색 패턴과 일치하는 파일 이름(파일 경로 포함)을 반환합니다.</summary>
        <returns>지정된 디렉터리에서 지정된 검색 패턴 및 옵션과 일치하는 파일의 전체 이름(경로 포함)의 배열이거나 파일이 없으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 매개 변수와 반환 되는 파일 이름이 추가 됩니다 `path` 반환 되는 파일 이름의 순서가 보장 되지 않습니다; 사용 하 고는 <xref:System.Array.Sort%2A> 메서드 특정 정렬 순서를 적용 해야 하는 경우.  
  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 0 개 또는 1 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
> [!NOTE]
>  에 별표 와일드 카드 문자를 사용 하는 경우는 `searchPattern` 와 같은 "\*.txt"를 지정된 된 확장에 있는 문자의 수에 영향을 줍니다 검색 다음과 같습니다.  
>   
>  -   정확히 3 자 지정한 확장명을 사용 하는 경우 메서드는 지정한 확장명으로 시작 하는 확장명을 가진 파일을 반환 합니다. 예를 들어 "\*.xls" 모두 "book.xls" 및 "book.xlsx"를 반환 합니다.  
> -   다른 모든 경우 메서드는 지정한 확장명을 정확 하 게 일치 하는 파일을 반환 합니다. 예를 들어 "\*.ai" "file.ai" 없습니다 "file.aif"를 반환 합니다.  
>   
>  물음표 와일드 카드 문자를 사용 하는 경우이 메서드는 지정 된 파일 확장명과 일치 하는 파일에만 반환 합니다. 예를 들어 두 개의 파일, "file1.txt" 및 "file1.txtother" 디렉터리를 검색 패턴은에 지정 된 "파일?입니다. "txt".txt "는 검색 패턴은 두 파일을 반환 하는 반면 첫 번째 파일만 반환 합니다.  
  
> [!NOTE]
>  검색 패턴 비슷합니다 8.3 파일 이름 형식과 긴 파일 이름 형식을 모두 포함 된 파일 이름에 대해이 메서드를 확인 하기 때문에 "\*1\*.txt" 예기치 않은 파일 이름을 반환할 수 있습니다. 예를 들어 검색 패턴을 사용 하 여 "\*1\*.txt" 해당 8.3 파일 이름 형식은 "LONGFI~1.TXT" 있기 때문에 "longfilename.txt"를 반환 합니다.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> 및 <xref:System.IO.Directory.GetFiles%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateFiles%2A>, 전체 컬렉션을 반환 하기 전에 이름 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetFiles%2A>, 되도록 이름의 전체 배열에 대해 기다려야 배열에 액세스 하려면 먼저 반환 됩니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateFiles%2A> 더 효과적일 수 있습니다.  
  
 파일 이름에 전체 경로 포함 합니다.  
  
 `path` 매개 변수는 상대 또는 절대 경로 정보를 지정할 수 있습니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드로 잘못된 문자를 쿼리할 수 있습니다.  
  
 또는  
  
 <paramref name="searchPattern" />에 유효한 패턴이 포함되어 있지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 또는 <paramref name="searchpattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />은 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 없거나 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.  
  
 또는  
  
 네트워크 오류가 발생했습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">현재 디렉터리에 대 한 경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 조건을 충족하는 모든 파일 및 하위 디렉터리 이름을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <summary>지정된 경로에 있는 모든 파일과 하위 디렉터리의 이름을 반환합니다.</summary>
        <returns>지정된 디렉터리에서 파일 및 하위 디렉터리 이름의 배열이거나 파일 또는 디렉터리가 없으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 되는 파일 및 디렉터리 이름의 순서를 보장할 수 없습니다. 사용 하 여는 <xref:System.Array.Sort%2A> 메서드 특정 정렬 순서를 적용 해야 하는 경우.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> 및 <xref:System.IO.Directory.GetFileSystemEntries%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, 전체 컬렉션을 반환 하기 전에 항목의 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetFileSystemEntries%2A>, 항목의 전체 배열에 대해 기다려야 반환 되기 전에 배열에 액세스할 수 있습니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateFiles%2A> 더 효과적일 수 있습니다.  
  
 이 메서드는 동일 <xref:System.IO.Directory.GetFileSystemEntries%2A> 별표 (\*)는 검색 패턴으로 지정 합니다.  
  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.Directory.GetFileSystemEntries%2A> 모든 파일 및 인쇄 하 고 사용자가 지정한 위치에 있는 하위 디렉터리의 이름으로 문자열의 배열을 채우는 메서드가 각 문자열을 콘솔 배열에 있습니다. 이 예제에서는이 메서드를 일반적인 모든 오류 catch 하도록 구성 됩니다.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" />로 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">현재 디렉터리에 대 한 경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 파일 및 디렉터리 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>지정된 경로에서 검색 패턴과 일치하는 파일 및 디렉터리 이름 배열을 반환합니다.</summary>
        <returns>지정된 검색 조건과 일치하는 파일 이름 및 디렉터리 이름의 배열이거나 파일 또는 디렉터리가 없으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 되는 파일 및 디렉터리 이름의 순서를 보장할 수 없습니다. 사용 하 여는 <xref:System.Array.Sort%2A> 메서드 특정 정렬 순서를 적용 해야 하는 경우.  
  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 0 개 또는 1 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
> [!NOTE]
>  에 별표 와일드 카드 문자를 사용 하는 경우는 `searchPattern` 와 같은 "\*.txt"를 지정된 된 확장에 있는 문자의 수에 영향을 줍니다 검색 다음과 같습니다.  
>   
>  -   정확히 3 자 지정한 확장명을 사용 하는 경우 메서드는 지정한 확장명으로 시작 하는 확장명을 가진 파일을 반환 합니다. 예를 들어 "\*.xls" 모두 "book.xls" 및 "book.xlsx"를 반환 합니다.  
> -   다른 모든 경우 메서드는 지정한 확장명을 정확 하 게 일치 하는 파일을 반환 합니다. 예를 들어 "\*.ai" "file.ai" 없습니다 "file.aif"를 반환 합니다.  
>   
>  물음표 와일드 카드 문자를 사용 하는 경우이 메서드는 지정 된 파일 확장명과 일치 하는 파일에만 반환 합니다. 예를 들어 두 개의 파일, "file1.txt" 및 "file1.txtother" 디렉터리를 검색 패턴은에 지정 된 "파일?입니다. txt"첫 번째 파일만 반환 하는 반면 검색 패턴은" 파일\*.txt "파일을 모두 반환 합니다.  
  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.Directory.GetFileSystemEntries%2A> 모든의 이름으로 문자열의 배열을 채울 메서드 파일을 특정 위치에 사용자 지정 필터와 일치 하 고 콘솔에 배열의 각 문자열을 출력 합니다. 이 예제에서는이 메서드를 일반적인 모든 오류 catch 하도록 구성 됩니다.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드로 잘못된 문자를 쿼리할 수 있습니다.  
  
 또는  
  
 <paramref name="searchPattern" />에 유효한 패턴이 포함되어 있지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 또는 <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">현재 디렉터리에 대 한 경로 정보에 액세스 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">검색할 디렉터리에 대한 상대 또는 절대 경로입니다. 이 문자열은 대/소문자를 구분하지 않습니다.</param>
        <param name="searchPattern">
          <c>경로</c>에 있는 파일 및 디렉터리 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다.  
  
 기본값은 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />입니다.</param>
        <summary>지정된 경로에서 검색 패턴과 일치하는 모든 파일 이름 및 디렉터리 이름의 배열을 가져오고 선택적으로 하위 디렉터리를 반환합니다.</summary>
        <returns>지정된 검색 조건과 일치하는 파일, 파일 이름 및 디렉터리 이름의 배열이거나 파일 또는 디렉터리가 없으면 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 되는 파일 및 디렉터리 이름의 순서를 보장할 수 없습니다. 사용 하 여는 <xref:System.Array.Sort%2A> 메서드 특정 정렬 순서를 적용 해야 하는 경우.  
  
 `searchPattern` 리터럴 및 와일드 카드 문자 조합일 수 있지만 정규식을 지원 하지 않습니다. 에 다음 와일드 카드 지정자를 사용할 수 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|\* (별표)|해당 위치에 0 개 이상의 문자가 있습니다.|  
|? (물음표)|해당 위치에 0 개 또는 1 문자입니다.|  
  
 와일드 카드 문자는 리터럴 문자입니다. 예를 들어는 `searchPattern` 문자열 "\*t"에 대 한 모든 이름 검색 `path` 문자 "t"로 끝나는 합니다. `searchPattern` 문자열 "s\*"에서 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 `searchPattern` 두 개의 마침표 ("..") 또는 마침표 두 개가 포함 ("..") 뒤 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 잘못 된 문자를 사용할 수 없으며 합니다. <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
> [!NOTE]
>  에 별표 와일드 카드 문자를 사용 하는 경우는 `searchPattern` 와 같은 "\*.txt"를 지정된 된 확장에 있는 문자의 수에 영향을 줍니다 검색 다음과 같습니다.  
>   
>  -   정확히 3 자 지정한 확장명을 사용 하는 경우 메서드는 지정한 확장명으로 시작 하는 확장명을 가진 파일을 반환 합니다. 예를 들어 "\*.xls" 모두 "book.xls" 및 "book.xlsx"를 반환 합니다.  
> -   다른 모든 경우 메서드는 지정한 확장명을 정확 하 게 일치 하는 파일을 반환 합니다. 예를 들어 "\*.ai" "file.ai" 없습니다 "file.aif"를 반환 합니다.  
>   
>  물음표 와일드 카드 문자를 사용 하는 경우이 메서드는 지정 된 파일 확장명과 일치 하는 파일에만 반환 합니다. 예를 들어 두 개의 파일, "file1.txt" 및 "file1.txtother" 디렉터리를 검색 패턴은에 지정 된 "파일?입니다. txt"첫 번째 파일만 반환 하는 반면 검색 패턴은" 파일\*.txt "파일을 모두 반환 합니다.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> 및 <xref:System.IO.Directory.GetFileSystemEntries%2A> 방법은 다음과 같이 달라: 사용 하는 경우 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, 전체 컬렉션을 반환 하기 전에 항목의 컬렉션을 열거를 시작할 수 있습니다; 사용 하는 경우 <xref:System.IO.Directory.GetFileSystemEntries%2A>, 항목의 전체 배열에 대해 기다려야 반환 되기 전에 배열에 액세스할 수 있습니다. 따라서 많은 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.Directory.EnumerateFiles%2A> 더 효과적일 수 있습니다.  
  
 상대 경로 정보를 지정할 수는 `path` 매개 변수입니다. 상대 경로 정보를 사용 하 여 확인할 수 있는 현재 작업 디렉터리에 상대적으로 해석 됩니다는 <xref:System.IO.Directory.GetCurrentDirectory%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나 공백만을 포함하거나 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.  
  
 \- 또는 -  
  
 <paramref name="searchPattern" />에 유효한 패턴이 포함되어 있지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우  
  
 또는  
  
 <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />은 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" />가 잘못되었습니다(예: 매핑되지 않은 드라이브 참조).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />는 파일 이름입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 이 둘의 조합이 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">액세스 날짜와 시간 정보를 가져올 파일 또는 디렉터리입니다.</param>
        <summary>지정된 파일 또는 디렉터리를 마지막으로 액세스한 날짜와 시간을 반환합니다.</summary>
        <returns>지정된 파일 또는 디렉터리를 마지막으로 액세스한 날짜와 시간으로 설정된 구조체입니다. 이 값은 현지 시간으로 표현됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 메서드는 운영 체제에 의해 값을 가진 지속적으로 업데이트 되지 않을 수 있습니다는 네이티브 함수를 사용 하기 때문에 정확 하지 않은 값을 반환할 수 있습니다.  
  
 이 메서드는 동일 <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>합니다.  
  
 디렉터리에서 설명 하는 경우는 `path` 매개 변수가 없는,이 메서드가 반환 서 기 1601 년 1 월 1 일 자정 12 시 (C.E.) Utc (협정 세계시)를 현지 시간으로 조정 합니다.  
  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 `GetLastAccessTime`합니다.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드로 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 매개 변수가 잘못된 형식인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 지정 된 파일 또는 디렉터리를 읽고 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">액세스 날짜와 시간 정보를 가져올 파일 또는 디렉터리입니다.</param>
        <summary>지정된 파일 또는 디렉터리에 마지막으로 액세스한 날짜와 시간을 UTC(Coordinated Universal Time) 형식으로 반환합니다.</summary>
        <returns>지정된 파일 또는 디렉터리를 마지막으로 액세스한 날짜와 시간으로 설정된 구조체입니다. 이 값은 UTC 시간으로 표현됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 메서드는 운영 체제에 의해 값을 가진 지속적으로 업데이트 되지 않을 수 있습니다는 네이티브 함수를 사용 하기 때문에 정확 하지 않은 값을 반환할 수 있습니다.  
  
 디렉터리에서 설명 하는 경우는 `path` 매개 변수가 없는,이 메서드가 반환 서 기 1601 년 1 월 1 일 자정 12 시 (C.E.) Utc (협정 세계시)입니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 Utc (협정 세계시) 출력을 사용 하는 경우 다음 예제에서는 출력의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 매개 변수가 잘못된 형식인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 지정 된 파일 또는 디렉터리를 읽고 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">수정 날짜와 시간 정보를 가져올 파일 또는 디렉터리입니다.</param>
        <summary>지정된 파일 또는 디렉터리를 마지막으로 쓴 날짜와 시간을 반환합니다.</summary>
        <returns>지정된 파일 또는 디렉터리를 마지막으로 쓴 날짜와 시간으로 설정된 구조체입니다. 이 값은 현지 시간으로 표현됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 메서드는 운영 체제에 의해 값을 가진 지속적으로 업데이트 되지 않을 수 있습니다는 네이티브 함수를 사용 하기 때문에 정확 하지 않은 값을 반환할 수 있습니다.  
  
 디렉터리에서 설명 하는 경우는 `path` 매개 변수가 없는,이 메서드가 반환 서 기 1601 년 1 월 1 일 자정 12 시 (C.E.) Utc (협정 세계시)를 현지 시간으로 조정 합니다.  
  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 `GetLastWriteTime`합니다.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 지정 된 파일 또는 디렉터리를 읽고 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">수정 날짜와 시간 정보를 가져올 파일 또는 디렉터리입니다.</param>
        <summary>지정된 파일이나 디렉터리에 마지막으로 쓴 날짜와 시간을 UTC(Coordinated Universal Time) 형식으로 반환합니다.</summary>
        <returns>지정된 파일 또는 디렉터리를 마지막으로 쓴 날짜와 시간으로 설정된 구조체입니다. 이 값은 UTC 시간으로 표현됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이 메서드는 운영 체제에 의해 값을 가진 지속적으로 업데이트 되지 않을 수 있습니다는 네이티브 함수를 사용 하기 때문에 정확 하지 않은 값을 반환할 수 있습니다.  
  
 디렉터리에서 설명 하는 경우는 `path` 매개 변수가 없는,이 메서드가 반환 서 기 1601 년 1 월 1 일 자정 12 시 (C.E.) Utc (협정 세계시)입니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 Utc (협정 세계시) 출력을 사용 하는 경우 다음 예제에서는 출력의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 지정 된 파일 또는 디렉터리를 읽고 있습니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 컴퓨터에서 "&lt;드라이브 문자&gt;:\\"의 형식으로 논리 드라이브 이름을 검색합니다.</summary>
        <returns>해당 컴퓨터에 있는 논리 드라이브입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives 플로피 드라이브 및 광 모든 드라이브를 포함 하 여 특정 컴퓨터에서 액세스할 수 있는 드라이브를 모두 반환 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.Directory.GetLogicalDrives%2A> 메서드를 호출 하는 컴퓨터에 각 드라이브의 이름을 문자열의 배열을 할당 합니다. 그런 다음이 문자열 배열의 각 멤버는 콘솔에 출력 합니다. 이 예제에서는이 메서드를 일반적인 모든 오류 catch 하도록 구성 됩니다.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">I/O 오류(예: 디스크 오류)가 발생했습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">PInvoke 또는 COM interop 사용 하 여 네이티브 코드를 호출 하는 등의 비관리 코드를 호출 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">부모 디렉터리를 검색할 경로입니다.</param>
        <summary>지정된 경로의 절대 경로와 상대 경로를 모두 포함한 부모 디렉터리를 검색합니다.</summary>
        <returns>부모 디렉터리이거나 <paramref name="path" />가 UNC 서버 또는 공유 이름의 루트를 포함한 루트 디렉터리일 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` 매개 변수는 상대 또는 절대 경로 정보를 지정할 수 있습니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 끝에서 후행 공백을 제거는 `path` 디렉터리 가져오기 전에 매개 변수입니다.  
  
 이 메서드에 의해 반환 되는 문자열 까지의 경로 등을 제외한 마지막 모든 자로 구성 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>합니다. 예를 들어 "C:\Directory\SubDirectory\test.txt" 경로에 전달 <xref:System.IO.Directory.GetParent%2A> "C:\Directory\SubDirectory"를 반환 합니다. "C:\Directory\SubDirectory" 전달 "C:\Directory"를 반환 합니다. 그러나 전달 "C:\Directory\SubDirectory\\" 끝 디렉터리 구분 문자 "하위 디렉터리" 후 있기 때문에 "C:\Directory\SubDirectory"를 반환 합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 <xref:System.IO.Directory.GetParent%2A> 부모 디렉터리의 사용자가 지정한 위치를 검색할 메서드 "path"입니다. 반환한 값은 <xref:System.IO.Directory.GetParent%2A> 메서드 그런 다음 콘솔에 출력 합니다. 이 예제에서는이 메서드를 일반적인 모든 오류 catch 하도록 구성 됩니다.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />로 지정된 디렉터리가 읽기 전용일 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 자세한 내용은 <see cref="T:System.IO.PathTooLongException" /> 항목을 참조하세요. </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로를 찾을 수 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />의 형식이 잘못되었습니다. </exception>
        <exception cref="T:System.Security.SecurityException">.NET Framework만 해당: 호출자에게 필요한 사용 권한이 없습니다. </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 또는 디렉터리에서 계속 하십시오. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">이동할 파일 또는 디렉터리의 경로입니다.</param>
        <param name="destDirName">
          <c>sourceDirName</c>의 새 위치에 대한 경로입니다. <c>sourceDirName</c>이 파일이면 <c>destDirName</c>도 파일 이름이어야 합니다.</param>
        <summary>파일 또는 디렉터리와 그 내용을 새 위치로 이동합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 지정 된 이름의 새 디렉터리를 만드는 `destDirName` 의 내용을 이동 및 `sourceDirName` 새로 생성된 된 대상 디렉터리에 있습니다. 이미 존재 하는 디렉터리에 디렉터리를 이동 하려는 경우는 <xref:System.IO.IOException> 발생 합니다. 예를 들어 c:\mydir c:\public로 이동 하려고 할 경우 c:\public 이미 있으면 예외가 발생 합니다. 지정할 수 있습니다 "c:\\\public\\\mydir"으로 `destDirName` 아래 "mydir"가 존재 하지 않는지를 제공 하는 매개 변수 "c:\\\public"와 같이 새 디렉터리 이름을 지정 하거나 "c:\\\newdir"입니다.  
  
 `sourceDirName` 및 `destDirName` 인수는 상대 또는 절대 경로 정보를 지정할 수 있습니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 디렉터리를 이동 하기 전에 path 매개 변수로의 끝에서 후행 공백은 제거 합니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 디렉터리와 모든 파일을 새 디렉터리로 이동 하는 방법을 보여 줍니다. 이 이동 하면 원래 디렉터리 존재 하지 않습니다.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">디렉터리를 다른 볼륨으로 이동하려고 했습니다.  
  
 또는  
  
 <paramref name="destDirName" />이(가) 이미 있습니다.  
  
 또는  
  
 <paramref name="sourceDirName" />과 <paramref name="destDirName" /> 매개 변수가 같은 파일이나 디렉터리를 참조하는 경우  
  
 또는  
  
 디렉터리 또는 포함된 파일이 다른 프로세스에서 사용 중입니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceDirName" /> 또는 <paramref name="destDirName" />이 길이가 0인 문자열이거나, 공백만 포함하거나 또는 하나 이상의 잘못된 문자를 포함하는 경우 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirName" /> 또는 <paramref name="destDirName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="sourceDirName" />에서 지정한 경로가 잘못된 경우(예: 매핑되지 않은 드라이브의 경로를 지정한 경우)</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">읽는 <paramref name="sourceDirName" /> 및 쓰기 <paramref name="sourceDirName" /> 및 <paramref name="destDirName" />합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">ACL(액세스 제어 목록) 항목을 추가하거나 제거할 디렉터리입니다.</param>
        <param name="directorySecurity">
          <c>경로</c> 매개 변수에서 설명하는 디렉터리에 적용할 ACL 항목을 설명하는 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 개체입니다.</param>
        <summary>
          <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 개체에서 설명하는 ACL(액세스 제어 목록) 항목을 지정된 디렉터리에 적용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory.SetAccessControl%2A> 메서드는 상속 되지 않은 ACL 목록을 표시 하는 파일에 액세스 제어 목록 (ACL) 항목을 적용 됩니다.  
  
> [!CAUTION]
>  에 대해 지정 된 ACL은 `directorySecurity` 매개 변수는 디렉터리에 대 한 기존 ACL을 대체 합니다. 새 사용자에 대 한 권한을 추가 하려면 사용 된 <xref:System.IO.Directory.GetAccessControl%2A> 메서드를 추가 하려면을 수정 합니다.  
  
 ACL에는 개인 및/또는 그룹 나 권한이 없는, 특정된 파일이 나 디렉터리에서 특정 작업을 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
 <xref:System.IO.Directory.SetAccessControl%2A> 메서드만 계속 되 면 <xref:System.Security.AccessControl.DirectorySecurity> 개체를 만든 후 수정 된 개체입니다.  경우는 <xref:System.Security.AccessControl.DirectorySecurity> 개체가 수정 되지 않은, 파일에 유지 되지 것입니다.  검색할 수 없으면 따라서는 <xref:System.Security.AccessControl.DirectorySecurity> 한 파일에서 개체를 다른 파일에 동일한 개체를 다시 적용 합니다.  
  
 다른 파일에서 ACL 정보를 복사 합니다.  
  
1.  사용 하 여는 <xref:System.IO.Directory.GetAccessControl%2A> 를 검색할 메서드는 <xref:System.Security.AccessControl.DirectorySecurity> 소스 파일에서 개체입니다.  
  
2.  새 <xref:System.Security.AccessControl.DirectorySecurity> 대상 파일에 대 한 개체입니다.  
  
3.  사용 하 여는 <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> 또는 <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> 원본의 메서드 <xref:System.Security.AccessControl.DirectorySecurity> ACL 정보를 검색 하는 개체입니다.  
  
4.  사용 하 여는 <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> 또는 <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> 대상에 3 단계에서 검색 메서드 정보를 복사 하려면 <xref:System.Security.AccessControl.DirectorySecurity> 개체입니다.  
  
5.  대상을 설정 <xref:System.Security.AccessControl.DirectorySecurity> 개체를 사용 하 여 대상 파일의 <xref:System.IO.Directory.SetAccessControl%2A> 메서드.  
  
 NTFS 환경에서 <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> 및 <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> 사용자에 게 하는 경우 사용자에 게 권한이 부여 됩니다 <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> 부모 폴더에 대 한 합니다. 거부 하려면 <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> 및 <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, 거부 <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> 부모 디렉터리에 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.Directory.GetAccessControl%2A> 및 <xref:System.IO.Directory.SetAccessControl%2A> 대 한 액세스 권한을 추가 하는 메서드 목록 (ACL) 항목을 제어 하 고 다음 디렉터리에서 ACL 항목을 제거 합니다.  이 예제를 실행하려면 유효한 사용자 또는 그룹 계정을 제공해야 합니다.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directorySecurity" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">디렉터리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />이 잘못된 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 프로세스에 <paramref name="path" />에서 지정한 디렉터리에 액세스할 권한이 없습니다.  
  
 또는  
  
 현재 프로세스에 ACL 항목을 설정할 권한이 충분하지 않습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Windows 2000 이상이 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">디렉터리에 대 한 액세스 제어 목록 (ACL)를 열거할 수 있는 권한입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
 보안 동작: 요청 합니다.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">만든 날짜와 시간 정보를 설정할 파일 또는 디렉터리입니다.</param>
        <param name="creationTime">파일 또는 디렉터리를 마지막으로 쓴 날짜와 시간입니다. 이 값은 현지 시간으로 표현됩니다.</param>
        <summary>지정된 파일 또는 디렉터리에 대한 만든 날짜와 시간을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
   
  
## Examples  
 Utc (협정 세계시) 출력을 사용 하는 경우 다음 예제에서는 출력의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">지정된 경로를 찾을 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" />에서 해당 작업에 허용된 날짜나 시간 범위를 벗어나는 값을 지정한 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Windows NT 이상이 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">지정 된 파일 또는 디렉터리에 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">만든 날짜와 시간 정보를 설정할 파일 또는 디렉터리입니다.</param>
        <param name="creationTimeUtc">디렉터리 또는 파일이 만들어진 날짜와 시간입니다. 이 값은 현지 시간으로 표현됩니다.</param>
        <summary>지정된 파일이나 디렉터리를 만든 날짜와 시간을 UTC(Coordinated Universal Time) 형식으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">지정된 경로를 찾을 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" />에서 해당 작업에 허용된 날짜나 시간 범위를 벗어나는 값을 지정한 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Windows NT 이상이 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">지정 된 파일 또는 디렉터리에 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">현재 작업 디렉터리로 설정될 경로입니다.</param>
        <summary>응용 프로그램의 현재 작업 디렉터리를 지정된 디렉터리로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램이 종료 될 때 작업 디렉터리 (프로세스가 시작 된 디렉터리) 원래 위치로 복원 됩니다.  
  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 끝에서 후행 공백을 제거는 `path` 디렉터리를 설정 하기 전에 매개 변수입니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 예를 들어 ("a:" 플로피 디스크 드라이브) 또는 "E" CD-ROM 드라이브에 대 한 이동식 미디어 드라이브에 디렉터리를 설정 하는 경우 사용 하 여 드라이브 준비 되었는지 여부를 확인할 수 있습니다는 <xref:System.IO.DriveInfo.IsReady%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에는 현재 디렉터리를 설정 하 고 루트 디렉터리를 표시 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 관리되지 않는 코드에 액세스하는 데 필요한 권한이 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">지정된 경로를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 디렉터리가 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일이 나 디렉터리에 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">액세스 날짜와 시간 정보를 설정할 파일 또는 디렉터리입니다.</param>
        <param name="lastAccessTime">
          <c>경로</c>의 액세스 날짜와 시간을 설정할 값을 포함하는 개체입니다. 이 값은 현지 시간으로 표현됩니다.</param>
        <summary>지정된 파일 또는 디렉터리를 마지막으로 액세스한 날짜와 시간을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 `SetLastAccessTime`합니다.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">지정된 경로를 찾을 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Windows NT 이상이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" />에서 해당 작업에 허용된 날짜나 시간 범위를 벗어나는 값을 지정한 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">지정 된 파일 또는 디렉터리에 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">액세스 날짜와 시간 정보를 설정할 파일 또는 디렉터리입니다.</param>
        <param name="lastAccessTimeUtc">
          <c>경로</c>의 액세스 날짜와 시간을 설정할 값을 포함하는 개체입니다. 이 값은 UTC 시간으로 표현됩니다.</param>
        <summary>지정된 파일 또는 디렉터리에 마지막으로 액세스한 날짜와 시간을 UTC(Coordinated Universal Time) 형식으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 Utc (협정 세계시) 출력을 사용 하는 경우 다음 예제에서는 출력의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">지정된 경로를 찾을 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Windows NT 이상이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" />에서 해당 작업에 허용된 날짜나 시간 범위를 벗어나는 값을 지정한 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">지정 된 파일 또는 디렉터리에 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">디렉터리 경로입니다.</param>
        <param name="lastWriteTime">디렉터리를 마지막으로 쓴 날짜와 시간입니다. 이 값은 현지 시간으로 표현됩니다.</param>
        <summary>디렉터리를 마지막으로 쓴 날짜와 시간을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 `SetLastWriteTime`합니다.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">지정된 경로를 찾을 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Windows NT 이상이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" />에서 해당 작업에 허용된 날짜나 시간 범위를 벗어나는 값을 지정한 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">지정 된 파일 또는 디렉터리에 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">디렉터리 경로입니다.</param>
        <param name="lastWriteTimeUtc">디렉터리를 마지막으로 쓴 날짜와 시간입니다. 이 값은 UTC 시간으로 표현됩니다.</param>
        <summary>디렉터리에 마지막으로 쓴 날짜와 시간을 UTC(Coordinated Universal Time) 형식으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` 상대 또는 절대 경로 정보를 지정 하기 위해 매개 변수는 허용 합니다. 상대 경로 정보는 현재 작업 디렉터리에 상대적으로 해석 됩니다. 현재 작업 디렉터리를 가져오려면 참조 <xref:System.IO.Directory.GetCurrentDirectory%2A>합니다.  
  
 `path` 매개 변수는 대/소문자 구분 하지 않습니다.  
  
 공통적인 I/O 작업의 목록에 대 한 참조 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 Utc (협정 세계시) 출력을 사용 하는 경우 다음 예제에서는 출력의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">지정된 경로를 찾을 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나, 공백만을 포함하거나, 하나 이상의 잘못된 문자를 포함합니다. <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드를 사용하여 잘못된 문자를 쿼리할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다. 예를 들어 Windows 기반 플랫폼에서 경로는 248자 미만이어야 하고 파일 이름은 260자 미만이어야 합니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Windows NT 이상이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" />에서 해당 작업에 허용된 날짜나 시간 범위를 벗어나는 값을 지정한 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">지정 된 파일 또는 디렉터리에 작성 합니다. 연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
  </Members>
</Type>