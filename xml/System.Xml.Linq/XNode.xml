<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XNode.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5f001654247344cf25b9ac07d23e7fb08ac4c201a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f001654247344cf25b9ac07d23e7fb08ac4c201a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.</source>
          <target state="translated">XML 트리에서 노드(요소, 주석, 문서 종류, 처리 명령 또는 텍스트 노드)의 추상 개념을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> is an abstract common base class for the following types:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 다음 형식에 대 한 추상 공통 기본 클래스가입니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> is an abstract common base class for the following types:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 다음 형식에 대 한 추상 공통 기본 클래스가입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Objects of classes that derive from <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> can contain child nodes.</source>
          <target state="translated">파생 된 클래스의 개체 <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 자식 노드가 포함 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>An <ph id="ph1">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> is not an <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> 않습니다는 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Attributes are maintained as a list of name/value pairs on an element.</source>
          <target state="translated">특성은 요소에 이름/값 쌍의 목록으로 유지 됩니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>If you are writing a complex XML application, such as an XML editor or a word processor that stores content as XML, you will often work at the node level.</source>
          <target state="translated">예: XML 편집기 또는 XML로 콘텐츠를 저장 하는 워드 프로세서는 복잡 한 XML 응용 프로그램을 작성 하는 경우 노드 수준에서 작업 하는 경우가 많습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Typical activities when working at the node level include adding nodes, deleting nodes, transforming nodes, and iterating through axes that return collections of nodes.</source>
          <target state="translated">일반적인 작업이 노드 수준에서 작업 하는 경우에 노드를 추가, 노드 삭제, 노드, 변환 및 노드의 컬렉션을 반환 하는 축 반복 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Adds the specified content immediately after this node.</source>
          <target state="translated">이 노드 바로 뒤에 지정된 콘텐츠를 추가합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">이 메서드에 전달 될 수 있는 유효한 내용에 대 한 세부 정보를 참조 하십시오. <bpt id="p1">[</bpt>유효한 콘텐츠 XElement 및 XDocument 개체<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">이 메서드로 인해 발생는 <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">다음 예제에서는 LINQ 쿼리를 사용 하 여 만들려는 <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> 의 <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>,이 메서드에 전달 되 합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">원하는 위치에 트리는 쿼리의 결과 추가합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>A content object that contains simple content or a collection of content objects to be added after this node.</source>
          <target state="translated">이 노드 뒤에 추가할 단순 콘텐츠 또는 콘텐츠 개체 컬렉션이 포함된 콘텐츠 개체입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>Adds the specified content immediately after this node.</source>
          <target state="translated">이 노드 바로 뒤에 지정된 콘텐츠를 추가합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">이 메서드에 전달 될 수 있는 유효한 내용에 대 한 세부 정보를 참조 하십시오. <bpt id="p1">[</bpt>유효한 콘텐츠 XElement 및 XDocument 개체<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> 이벤트</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>The following example uses this method to add an element into the tree.</source>
          <target state="translated">다음 예제에서는이 메서드를 사용 하 여 요소를 트리에 추가 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">부모 노드가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>A parameter list of content objects.</source>
          <target state="translated">콘텐츠 개체의 매개 변수 목록입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>Adds the specified content immediately after this node.</source>
          <target state="translated">이 노드 바로 뒤에 지정된 콘텐츠를 추가합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">이 메서드에 전달 될 수 있는 유효한 내용에 대 한 세부 정보를 참조 하십시오. <bpt id="p1">[</bpt>유효한 콘텐츠 XElement 및 XDocument 개체<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">이 메서드로 인해 발생는 <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">다음 예제에서는 LINQ 쿼리를 사용 하 여 만들려는 <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> 의 <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>,이 메서드에 전달 되 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">원하는 위치에 트리는 쿼리의 결과 추가합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">부모 노드가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Adds the specified content immediately before this node.</source>
          <target state="translated">이 노드 바로 앞에 지정된 콘텐츠를 추가합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">이 메서드에 전달 될 수 있는 유효한 내용에 대 한 세부 정보를 참조 하십시오. <bpt id="p1">[</bpt>유효한 콘텐츠 XElement 및 XDocument 개체<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">이 메서드로 인해 발생는 <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child notes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 자식 노트를 단일 연결 목록으로 저장 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">즉는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> 메서드가 부모 컨테이너 아래의 직접적인 자식 노드 목록 통과 해야 합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Therefore, using this method might  affect your performance.</source>
          <target state="translated">따라서이 메서드를 사용 하 여 하면 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">다음 예제에서는 LINQ 쿼리를 사용 하 여 만들려는 <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> 의 <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>,이 메서드에 전달 되 합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">원하는 위치에 트리는 쿼리의 결과 추가합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>A content object that contains simple content or a collection of content objects to be added before this node.</source>
          <target state="translated">이 노드 앞에 추가할 단순 콘텐츠 또는 콘텐츠 개체 컬렉션이 포함된 콘텐츠 개체입니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>Adds the specified content immediately before this node.</source>
          <target state="translated">이 노드 바로 앞에 지정된 콘텐츠를 추가합니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">이 메서드에 전달 될 수 있는 유효한 내용에 대 한 세부 정보를 참조 하십시오. <bpt id="p1">[</bpt>유효한 콘텐츠 XElement 및 XDocument 개체<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">이 메서드로 인해 발생는 <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 해당 자식 노드를 단일 연결 목록으로 저장 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">즉는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> 메서드가 부모 컨테이너 아래의 직접적인 자식 노드 목록 통과 해야 합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>Therefore, using this method might  affect your performance.</source>
          <target state="translated">따라서이 메서드를 사용 하 여 하면 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>The following example uses this method to add an element into the tree.</source>
          <target state="translated">다음 예제에서는이 메서드를 사용 하 여 요소를 트리에 추가 하 고 있습니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">부모 노드가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>A parameter list of content objects.</source>
          <target state="translated">콘텐츠 개체의 매개 변수 목록입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>Adds the specified content immediately before this node.</source>
          <target state="translated">이 노드 바로 앞에 지정된 콘텐츠를 추가합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">이 메서드에 전달 될 수 있는 유효한 내용에 대 한 세부 정보를 참조 하십시오. <bpt id="p1">[</bpt>유효한 콘텐츠 XElement 및 XDocument 개체<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">이 메서드로 인해 발생는 <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 해당 자식 노드를 단일 연결 목록으로 저장 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">즉는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> 메서드가 부모 컨테이너 아래의 직접적인 자식 노드 목록 통과 해야 합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>Therefore, using this function might affect your performance.</source>
          <target state="translated">따라서이 함수를 사용 하 여 하면 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">다음 예제에서는 LINQ 쿼리를 사용 하 여 만들려는 <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> 의 <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>,이 메서드에 전달 되 합니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">원하는 위치에 트리는 쿼리의 결과 추가합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">부모 노드가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns a collection of the ancestor elements of this node.</source>
          <target state="translated">이 노드의 상위 요소 컬렉션을 반환합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Optionally a node name can be specified to filter for ancestor elements with a specific name.</source>
          <target state="translated">필요에 따라 특정 이름 가진 상위 요소에 대 한 필터링 할 노드 이름을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The nodes in the returned collection are in reverse document order.</source>
          <target state="translated">반환된 컬렉션의 노드 순서는 문서와 반대입니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method uses deferred execution.</source>
          <target state="translated">이 메서드는 지연된 실행을 사용합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>Returns a collection of the ancestor elements of this node.</source>
          <target state="translated">이 노드의 상위 요소 컬렉션을 반환합니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the ancestor elements of this node.</source>
          <target state="translated">이 노드의 상위 요소에 대한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>의 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>This method does not return itself in the results.</source>
          <target state="translated">이 메서드는 결과에서 자신을 반환 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>The nodes in the returned collection are in reverse document order.</source>
          <target state="translated">반환된 컬렉션의 노드 순서는 문서와 반대입니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>This method uses deferred execution.</source>
          <target state="translated">이 메서드는 지연된 실행을 사용합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>The following example uses this method to enumerate the ancestors of a node.</source>
          <target state="translated">다음 예제에서는이 방법을 사용 하 여 노드의 상위 항목을 열거 합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated">일치시킬 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of the ancestor elements of this node.</source>
          <target state="translated">이 노드의 필터링된 상위 요소 컬렉션을 반환합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">일치하는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>이 있는 요소만 컬렉션에 포함됩니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the ancestor elements of this node.</source>
          <target state="translated">이 노드의 상위 요소에 대한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>의 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">일치하는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>이 있는 요소만 컬렉션에 포함됩니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>The nodes in the returned collection are in reverse document order.</source>
          <target state="translated">반환된 컬렉션의 노드 순서는 문서와 반대입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">이 메서드는 지연된 실행을 사용합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>This method will not return itself in the results.</source>
          <target state="translated">이 메서드는 결과에서 자신을 반환 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>The following example uses this method.</source>
          <target state="translated">다음 예제에서는이 방법을 사용합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>First <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">비교할 첫 번째 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Second <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">비교할 두 번째 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Compares two nodes to determine their relative XML document order.</source>
          <target state="translated">두 노드를 비교하여 상대적인 XML 문서 순서를 확인합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>An <ph id="ph1">&lt;see langword="int" /&gt;</ph> containing 0 if the nodes are equal; -1 if <ph id="ph2">&lt;paramref name="n1" /&gt;</ph> is before <ph id="ph3">&lt;paramref name="n2" /&gt;</ph>; 1 if <ph id="ph4">&lt;paramref name="n1" /&gt;</ph> is after <ph id="ph5">&lt;paramref name="n2" /&gt;</ph>.</source>
          <target state="translated">노드가 서로 같으면 0, <ph id="ph2">&lt;paramref name="n1" /&gt;</ph>이 <ph id="ph3">&lt;paramref name="n2" /&gt;</ph>보다 앞에 나오면 -1, <ph id="ph4">&lt;paramref name="n1" /&gt;</ph>이 <ph id="ph5">&lt;paramref name="n2" /&gt;</ph>보다 뒤에 나오면 1이 들어 있는 <ph id="ph1">&lt;see langword="int" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 해당 자식 노드를 단일 연결 목록으로 저장 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
          <target state="translated">즉는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> 메서드가 공통 부모를 찾을 때까지 비교 하 고 두 노드의 상위 항목을 통과 해야 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
          <target state="translated">다음 비교 하 고 두 노드 순서를 결정 하는 공통 부모 자식 노드 목록을 트래버스해야 합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">따라서이 메서드를 사용 하 여 하면 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The following example uses this method.</source>
          <target state="translated">다음 예제에서는이 방법을 사용합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The two nodes do not share a common ancestor.</source>
          <target state="translated">두 노드가 공통 상위 노드를 공유하지 않는 경우</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> for this node.</source>
          <target state="translated">이 노드에 대한 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> for this node.</source>
          <target state="translated">이 노드에 대한 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that can be used to read this node and its descendants.</source>
          <target state="translated">이 노드 및 하위 요소를 읽는 데 사용할 수 있는 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>You typically use this method when you have to supply another component with an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">일반적으로이 방식으로 다른 구성 요소를 제공 하는 경우는 <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>For example, you can create an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> from a <ph id="ph2">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> tree, and then pass that reader to <ph id="ph3">&lt;xref:System.Xml.XmlDocument.Load%2A&gt;</ph>.</source>
          <target state="translated">예를 들어 만들 수 있습니다는 <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> 에서 <ph id="ph2">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> 트리를 선택한 다음 해당 판독기를 전달 <ph id="ph3">&lt;xref:System.Xml.XmlDocument.Load%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>All of the readers returned by <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> are normalizing readers.</source>
          <target state="translated">반환 되는 판독기의 모든 <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> 는 판독기를 정규화 합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>They always perform line break normalization and full normalization of attributes.</source>
          <target state="translated">줄 바꿈 정규화 및 특성의 전체 정규화 항상 수행 합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> returned by <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> is not a normalizing reader.</source>
          <target state="translated">반면,는 <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> 반환한 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> 정규화 판독기 아닙니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>It does not transform any white space.</source>
          <target state="translated">모든 공백은 변환 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>It also returns attributes in the order that they were added, not in attribute name order.</source>
          <target state="translated">특성 이름 순서 아닌 추가 된 순서에 새 특성 반환 합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> does not keep information about whether attributes are default attributes.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> 기본 특성 인지 여부에 대 한 정보를 유지 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source><ph id="ph1">&lt;xref:System.Xml.XmlReader.IsDefault%2A&gt;</ph> will always return false regardless of whether the attribute was populated from a default value or not.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.XmlReader.IsDefault%2A&gt;</ph> 항상 false 특성 기본 값에서 채워지는지가 여부에 관계 없이 반환 합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>The <ph id="ph1">`PUBLIC`</ph> and <ph id="ph2">`SYSTEM`</ph> pseudo attributes on <ph id="ph3">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> are not available through the <ph id="ph4">&lt;xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`PUBLIC`</ph> 및 <ph id="ph2">`SYSTEM`</ph> 의사 특성 <ph id="ph3">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> 통해 사용할 수 없는 <ph id="ph4">&lt;xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>They are only available through the <ph id="ph1">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> method that takes the qualified name of the attribute as a parameter.</source>
          <target state="translated">통해 사용할 수 있는는 <ph id="ph1">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> 매개 변수로 특성의 정규화 된 이름을 사용 하는 메서드입니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>If you have to retrieve the <ph id="ph1">`PUBLIC`</ph> or <ph id="ph2">`SYSTEM`</ph> attributes, you should use the <ph id="ph3">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">검색 해야 하는 경우는 <ph id="ph1">`PUBLIC`</ph> 또는 <ph id="ph2">`SYSTEM`</ph> 특성을 사용할지는 <ph id="ph3">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Base64 and BinHex data are not supported.</source>
          <target state="translated">Base64 및 BinHex 데이터 지원 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>If you attempt to retrieve these types of data (for example, by calling <ph id="ph1">&lt;xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A&gt;</ph>), the reader will throw <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">이러한 유형의 데이터를 검색 하려고 하면 (예를 들어 호출 하 여 <ph id="ph1">&lt;xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A&gt;</ph>), 판독기를 발생 시킵니다 <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>The <ph id="ph1">`xml`</ph> declaration is not surfaced by the reader.</source>
          <target state="translated"><ph id="ph1">`xml`</ph> 선언을 판독기에서 노출 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>While reading, you will not encounter a node of type <ph id="ph1">&lt;xref:System.Xml.XmlNodeType.XmlDeclaration&gt;</ph>.</source>
          <target state="translated">를 읽는 동안 발생 하지 것입니다 형식의 노드 <ph id="ph1">&lt;xref:System.Xml.XmlNodeType.XmlDeclaration&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>The following example creates an XML tree, creates an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> by using the <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> method, and creates an <ph id="ph3">&lt;xref:System.Xml.XmlDocument&gt;</ph> by using the reader.</source>
          <target state="translated">다음 예제에서는 XML 트리를 만든 다음, 만들어집니다는 <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> 를 사용 하 여는 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> 메서드를 만듭니다는 <ph id="ph3">&lt;xref:System.Xml.XmlDocument&gt;</ph> 판독기를 사용 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Another use for this method is to do an XSLT transformation.</source>
          <target state="translated">이 메서드에 대 한 또 다른 용도 XSLT 변환을 수행 하는 것입니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>You can create an XML tree, create an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> from the XML tree, create a new document, and create an <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph> that will write into the new document.</source>
          <target state="translated">XML 트리를 만들고 XML 트리에서 <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>를 만든 다음 새 문서를 만들고 새 문서에 쓸 <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph>를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Then, you can invoke the XSLT transformation, passing the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> and <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph> to the transformation.</source>
          <target state="translated">그런 다음 <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph>를 변환에 전달하여 XSLT 변환을 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>After the transformation successfully completes, the new XML tree is populated with the results of the transform.</source>
          <target state="translated">변환이 성공적으로 완료된 후 새 XML 트리가 변환의 결과로 채워집니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.ReaderOptions" /&gt;</ph> object that specifies whether to omit duplicate namespaces.</source>
          <target state="translated">중복된 네임스페이스를 생략할지 여부를 지정하는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.ReaderOptions" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> with the options specified by the <ph id="ph2">&lt;paramref name="readerOptions" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="readerOptions" /&gt;</ph> 매개 변수에서 지정된 옵션을 사용하여 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The first <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">비교할 첫 번째 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The second <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">비교할 두 번째 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Compares the values of two nodes, including the values of all descendant nodes.</source>
          <target state="translated">모든 하위 노드의 값을 포함하여 두 노드의 값을 비교합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the nodes are equal; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">노드가 같으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The following criteria determine whether two nodes are equal:</source>
          <target state="translated">다음 기준을 두 개의 노드가 같은지 여부를 결정 합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>A <ph id="ph1">`null`</ph> node is equal to another <ph id="ph2">`null`</ph> node but unequal to a non-<ph id="ph3">`null`</ph> node.</source>
          <target state="translated">A <ph id="ph1">`null`</ph> 노드는 다른 <ph id="ph2">`null`</ph> 노드와 아닌 같지만<ph id="ph3">`null`</ph> 노드.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects of different types are never equal.</source>
          <target state="translated">두 개의 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 는 항상 서로 다른 유형의 개체입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> nodes are equal if they contain the same text.</source>
          <target state="translated">두 개의 <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> 노드는 동일한 텍스트를 포함 하는 경우 동일 합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions) contain two equal length sequences of equal content nodes.</source>
          <target state="translated">두 개의 <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> 동일한 태그 이름이 동일한 값을 갖는 특성의 동일한 집합 및 (주석을 무시 하 고, 처리 명령) 콘텐츠 노드 두 길이가 같은 시퀀스를 포함 하는 경우 노드는 같습니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> nodes are equal if their root nodes are equal.</source>
          <target state="translated">두 개의 <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> 루트 노드가 같은지 경우 노드는 같습니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XComment&gt;</ph> nodes are equal if they contain the same comment text.</source>
          <target state="translated">두 개의 <ph id="ph1">&lt;xref:System.Xml.Linq.XComment&gt;</ph> 노드는 동일한 주석 텍스트를 포함 하는 경우 동일 합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XProcessingInstruction&gt;</ph> nodes are equal if they have the same target and data.</source>
          <target state="translated">두 개의 <ph id="ph1">&lt;xref:System.Xml.Linq.XProcessingInstruction&gt;</ph> 노드는 동일한 대상 및 데이터를 서로 같은 합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> nodes are equal if the have the same name, public ID, system ID, and internal subset.</source>
          <target state="translated">두 개의 <ph id="ph1">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> 노드가 서로 같은지 경우는 동일한 이름, 공용 ID, 시스템 ID 및 내부 하위 집합입니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The following example uses this method to compare two XML trees.</source>
          <target state="translated">다음 예제에서는이 방법을 사용 하 여 두 XML 트리를 비교 합니다.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>Gets a comparer that can compare the relative position of two nodes.</source>
          <target state="translated">두 노드의 상대 위치를 비교할 수 있는 비교자를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /&gt;</ph> that can compare the relative position of two nodes.</source>
          <target state="translated">두 노드의 상대 위치를 비교할 수 있는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>This property is primarily used internally for implementing the <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.InDocumentOrder%2A&gt;</ph> extension method.</source>
          <target state="translated">이 속성은 주로 내부적으로 구현 하기 위한는 <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.InDocumentOrder%2A&gt;</ph> 확장 메서드.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>The recommended approach is to use that extension method instead of using this property directly.</source>
          <target state="translated">이 속성을 직접 사용 하지 않고 해당 확장 메서드를 사용 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>The following example creates an XML tree with some elements.</source>
          <target state="translated">다음 예제에서는 일부 요소와 XML 트리를 만듭니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>It then creates a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> that contains some elements from the XML tree at random.</source>
          <target state="translated">그런 다음 만듭니다는 <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> 의 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 임의로 XML 트리의 일부 요소를 포함 하 합니다.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>It sorts the list, using this property to retrieve a <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeDocumentOrderComparer&gt;</ph>, which implements the <ph id="ph2">&lt;xref:System.Collections.IComparer?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType&gt;</ph> interfaces.</source>
          <target state="translated">이 속성을 사용 하 여 검색 목록을 정렬는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeDocumentOrderComparer&gt;</ph>를 구현 하는 <ph id="ph2">&lt;xref:System.Collections.IComparer?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns a collection of the sibling elements after this node, in document order.</source>
          <target state="translated">이 노드 뒤에 있는 형제 요소의 컬렉션을 문서 순으로 반환합니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method uses deferred execution.</source>
          <target state="translated">이 메서드는 지연된 실행을 사용합니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>Returns a collection of the sibling elements after this node, in document order.</source>
          <target state="translated">이 노드 뒤에 있는 형제 요소의 컬렉션을 문서 순으로 반환합니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements after this node, in document order.</source>
          <target state="translated">이 노드 뒤에 있는 형제 요소에 대한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>의 문서 순 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">이 메서드가 반환된 된 컬렉션의 형제만 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>It does not include descendants.</source>
          <target state="translated">하위 항목은 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">이 메서드는 지연된 실행을 사용합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>The following example creates an element with some complex content.</source>
          <target state="translated">다음 예제에서는 일부 복합 콘텐츠가 있는 요소를 만듭니다.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>It then uses this method to retrieve the nodes in document order.</source>
          <target state="translated">그런 다음이 메서드를 사용 하 여 문서 순서로 노드를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated">일치시킬 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of the sibling elements after this node, in document order.</source>
          <target state="translated">이 노드 뒤에 있는 형제 요소의 필터링된 컬렉션을 문서 순으로 반환합니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">일치하는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>이 있는 요소만 컬렉션에 포함됩니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements after this node, in document order.</source>
          <target state="translated">이 노드 뒤에 있는 형제 요소에 대한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>의 문서 순 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">일치하는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>이 있는 요소만 컬렉션에 포함됩니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">이 메서드가 반환된 된 컬렉션의 형제만 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>It does not include descendants.</source>
          <target state="translated">하위 항목은 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">이 메서드는 지연된 실행을 사용합니다.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>The following example creates an element with some complex content.</source>
          <target state="translated">다음 예제에서는 일부 복합 콘텐츠가 있는 요소를 만듭니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>It then uses this method to retrieve the sibling elements, in document order.</source>
          <target state="translated">다음이 메서드를 사용 하 여 문서 순서에서 형제 요소를 검색 합니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns a collection of the sibling elements before this node, in document order.</source>
          <target state="translated">이 노드 앞에 있는 형제 요소의 컬렉션을 문서 순으로 반환합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method uses deferred execution.</source>
          <target state="translated">이 메서드는 지연된 실행을 사용합니다.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>Returns a collection of the sibling elements before this node, in document order.</source>
          <target state="translated">이 노드 앞에 있는 형제 요소의 컬렉션을 문서 순으로 반환합니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements before this node, in document order.</source>
          <target state="translated">이 노드 앞에 있는 형제 요소에 대한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>의 문서 순 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">이 메서드가 반환된 된 컬렉션의 형제만 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>It does not include descendants.</source>
          <target state="translated">하위 항목은 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">이 메서드는 지연된 실행을 사용합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>The following example uses this axis method.</source>
          <target state="translated">다음 예제에서는이 축 메서드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated">일치시킬 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of the sibling elements before this node, in document order.</source>
          <target state="translated">이 노드 앞에 있는 형제 요소의 필터링된 컬렉션을 문서 순으로 반환합니다.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">일치하는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>이 있는 요소만 컬렉션에 포함됩니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements before this node, in document order.</source>
          <target state="translated">이 노드 앞에 있는 형제 요소에 대한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>의 문서 순 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">일치하는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>이 있는 요소만 컬렉션에 포함됩니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">이 메서드가 반환된 된 컬렉션의 형제만 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>It does not include descendants.</source>
          <target state="translated">하위 항목은 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">이 메서드는 지연된 실행을 사용합니다.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>The following example uses this method.</source>
          <target state="translated">다음 예제에서는이 방법을 사용합니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>Gets a comparer that can compare two nodes for value equality.</source>
          <target state="translated">두 노드의 값이 같은지 비교할 수 있는 비교자를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeEqualityComparer" /&gt;</ph> that can compare two nodes for value equality.</source>
          <target state="translated">두 노드의 값이 같은지 비교할 수 있는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeEqualityComparer" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>The following example uses this property to retrieve an <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeEqualityComparer&gt;</ph>, which implements the <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType&gt;</ph> interfaces.</source>
          <target state="translated">다음 예제에서는이 속성을 사용 하 여 검색 하는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeEqualityComparer&gt;</ph>를 구현 하는 <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer?displayProperty=nameWithType&gt;</ph> 및 <ph id="ph3">&lt;xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType&gt;</ph> 인터페이스입니다.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>It creates a dictionary that uses this property.</source>
          <target state="translated">이 속성을 사용 하는 사전을 만듭니다.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare for document order.</source>
          <target state="translated">문서 순서를 비교할 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> 입니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>Determines if the current node appears after a specified node in terms of document order.</source>
          <target state="translated">문서 순서를 기준으로 현재 노드가 지정된 노드보다 뒤에 나오는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this node appears after the specified node; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 노드가 지정된 노드보다 뒤에 나오면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 해당 자식 노드를 단일 연결 목록으로 저장 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
          <target state="translated">즉는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> 메서드가 공통 부모를 찾을 때까지 비교 하 고 두 노드의 상위 항목을 통과 해야 합니다.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
          <target state="translated">다음 비교 하 고 두 노드 순서를 결정 하는 공통 부모 자식 노드 목록을 트래버스해야 합니다.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">따라서이 메서드를 사용 하 여 하면 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>The following example uses this method.</source>
          <target state="translated">다음 예제에서는이 방법을 사용합니다.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare for document order.</source>
          <target state="translated">문서 순서를 비교할 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> 입니다.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>Determines if the current node appears before a specified node in terms of document order.</source>
          <target state="translated">문서 순서를 기준으로 현재 노드가 지정된 노드보다 앞에 나오는지 확인합니다.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this node appears before the specified node; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 노드가 지정된 노드보다 앞에 나오면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph2">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 해당 자식 노드를 단일 연결 목록으로 저장 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.IsBefore%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
          <target state="translated">즉는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.IsBefore%2A&gt;</ph> 메서드가 공통 부모를 찾을 때까지 비교 하 고 두 노드의 상위 항목을 통과 해야 합니다.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
          <target state="translated">다음 비교 하 고 두 노드 순서를 결정 하는 공통 부모 자식 노드 목록을 트래버스해야 합니다.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">따라서이 메서드를 사용 하 여 하면 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>The following example uses this method.</source>
          <target state="translated">다음 예제에서는이 방법을 사용합니다.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>Gets the next sibling node of this node.</source>
          <target state="translated">이 노드의 다음 형제 노드를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> that contains the next sibling node.</source>
          <target state="translated">다음 형제 노드가 들어 있는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>If this <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> does not have a parent, or if there is no next node, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">이 경우 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 않습니다는 부모 또는 다음 노드가 많은 경우이 속성이 반환 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>The following example uses this property to loop through nodes.</source>
          <target state="translated">다음 예제에서는이 속성을 사용 하 여 노드를 반복 하 합니다.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>Returns a collection of the sibling nodes after this node, in document order.</source>
          <target state="translated">이 노드 뒤에 있는 형제 노드의 컬렉션을 문서 순으로 반환합니다.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> of the sibling nodes after this node, in document order.</source>
          <target state="translated">이 노드 뒤에 있는 형제 노드에 대한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>의 문서 순 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">이 메서드가 반환된 된 컬렉션의 형제만 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>It does not include descendants.</source>
          <target state="translated">하위 항목은 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">이 메서드는 지연된 실행을 사용합니다.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>The following example creates an XML tree, and then queries the tree using this axis method.</source>
          <target state="translated">다음 예제에서는 XML 트리를 만들고이 축 메서드를 사용 하 여 트리를 쿼리 합니다.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>Returns a collection of the sibling nodes before this node, in document order.</source>
          <target state="translated">이 노드 앞에 있는 형제 노드의 컬렉션을 문서 순으로 반환합니다.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> of the sibling nodes before this node, in document order.</source>
          <target state="translated">이 노드 앞에 있는 형제 노드에 대한 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>의 문서 순 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">이 메서드가 반환된 된 컬렉션의 형제만 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>It does not include descendants.</source>
          <target state="translated">하위 항목은 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">이 메서드는 지연된 실행을 사용합니다.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>The following example creates an XML tree, and then queries the tree using this axis method.</source>
          <target state="translated">다음 예제에서는 XML 트리를 만들고이 축 메서드를 사용 하 여 트리를 쿼리 합니다.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>Gets the previous sibling node of this node.</source>
          <target state="translated">이 노드의 이전 형제 노드를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> that contains the previous sibling node.</source>
          <target state="translated">이전 형제 노드가 들어 있는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>If this <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> does not have a parent, or if there is no previous node, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">이 경우 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 않습니다는 부모 또는 이전 노드가 많은 경우이 속성이 반환 <ph id="ph2">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 해당 자식 노드를 단일 연결 목록으로 저장 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.PreviousNode%2A&gt;</ph> property must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">즉는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.PreviousNode%2A&gt;</ph> 속성이 부모 컨테이너 아래의 직접적인 자식 노드 목록 통과 해야 합니다.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>Therefore, using this property might affect your performance.</source>
          <target state="translated">따라서이 속성을 사용 하면 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>The following example uses this property to loop through nodes.</source>
          <target state="translated">다음 예제에서는이 속성을 사용 하 여 노드를 반복 하 합니다.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> positioned at the node to read into this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>로 읽어올 노드에 배치된 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> from an <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>를 사용하여 <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>를 만듭니다.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> that contains the node and its descendant nodes that were read from the reader.</source>
          <target state="translated">판독기에서 읽은 노드 및 해당 하위 노드가 들어 있는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The runtime type of the node is determined by the node type (<ph id="ph1">&lt;see cref="P:System.Xml.Linq.XObject.NodeType" /&gt;</ph>) of the first node encountered in the reader.</source>
          <target state="translated">노드의 런타임 형식은 판독기에서 읽은 첫 번째 노드의 형식(<ph id="ph1">&lt;see cref="P:System.Xml.Linq.XObject.NodeType" /&gt;</ph>)에 따라 결정됩니다.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>You can use this method to write a method that returns a collection of nodes, yielding each node as the node is read from the reader.</source>
          <target state="translated">메서드를 작성, 노드 컬렉션을 반환 하는 노드는 판독기에서 읽은 되는 각 노드를 생성이 메서드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This method enables you to process arbitrarily large XML files with a very small memory footprint.</source>
          <target state="translated">이 메서드를 사용 하면 매우 작은 메모리 사용 공간 매우 큰 XML 파일을 처리할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The reader that you pass to this method might throw exceptions.</source>
          <target state="translated">이 메서드에 전달 하는 판독기 예외를 throw 할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph> does not catch all exceptions thrown by the reader; the unhandled exceptions bubble up to the code that called <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph> 모든 catch 하지 않습니다; 판독기에서 throw 된 예외 처리 되지 않은 예외를 호출한 코드로 전달 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>In particular, your code should be prepared to handle <ph id="ph1">&lt;xref:System.Xml.XmlException&gt;</ph>.</source>
          <target state="translated">코드 처리를 준비 해야 특히 <ph id="ph1">&lt;xref:System.Xml.XmlException&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>For an example of how to stream a more complex document, see <bpt id="p1">[</bpt>How to: Stream XML Fragments with Access to Header Information<ept id="p1">](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092)</ept>.</source>
          <target state="translated">보다 복잡 한 문서를 스트림 하는 방법의 예제를 보려면 <bpt id="p1">[</bpt>하는 방법: 헤더 정보에 액세스할 수 있는 XML 조각 스트림<ept id="p1">](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>Certain standard query operators, such as <ph id="ph1">&lt;xref:System.Linq.Enumerable.OrderBy%2A&gt;</ph>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Linq.Enumerable.OrderBy%2A&gt;</ph>와 같은 특정 표준 쿼리 연산자는 자신의 소스를 반복하고 모든 데이터를 수집하여 정렬한 다음 시퀀스의 첫 번째 항목을 최종적으로 생성합니다.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>If you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint.</source>
          <target state="translated">첫 번째 항목을 생성 하기 전에 소스를 유형 화 하는 쿼리 연산자를 사용 하면 작은 메모리 사용 공간이 유지 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>For an example of using <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> to transform extremely large XML documents while maintaining a small memory footprint, see <bpt id="p1">[</bpt>How to: Perform Streaming Transform of Large XML Documents<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</source>
          <target state="translated">사용 하는 예제에 대 한 <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> 작은 메모리 사용 공간을 유지 하면서 매우 큰 XML 문서를 변환할 참조 <bpt id="p1">[</bpt>하는 방법: 수행 스트리밍 변환의 큰 XML 문서<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This example uses the following XML file, named Source.xml:</source>
          <target state="translated">이 예에서는 라는 Source.xml 다음 XML 파일을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This example creates a custom axis method that uses <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>.</source>
          <target state="translated">이 예에서는 사용 하는 사용자 지정 축 메서드를 만듭니다 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>You can query the custom axis by using a LINQ query.</source>
          <target state="translated">LINQ 쿼리를 사용 하 여 사용자 지정 축을 쿼리할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The following example uses the yield return construct of C#.</source>
          <target state="translated">다음 예제에서는 C#의 yield 반환 구문을 사용합니다.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>Because there is no equivalent feature in <ph id="ph1">[!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)]</ph>, this example is provided only in C#.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)]</ph>에는 동일한 기능이 없기 때문에 이 예제는 C#으로만 제공됩니다.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This example produces the following output.</source>
          <target state="translated">이 예제의 결과는 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> is not positioned on a recognized node type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>가 인식 가능한 노드 형식에 배치되지 않은 경우</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The underlying <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> throws an exception.</source>
          <target state="translated">내부 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>에서 예외를 throw한 경우</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Removes this node from its parent.</source>
          <target state="translated">부모에서 이 노드를 제거합니다.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>In <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> programming, you should not manipulate or modify a set of nodes while you are querying for nodes in that set.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> 를 프로그래밍 하거나 하면 안 조작를 쿼리하면 해당 집합의 노드에 대 한 노드 집합을 수정 합니다.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>In practical terms, this means that you should not iterate over a set of nodes and remove them.</source>
          <target state="translated">실제로이 의미 해야 하지 노드 집합에 대해 반복 해 서 제거 합니다.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Instead, you should materialize them into a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> by using the <ph id="ph2">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> extension method.</source>
          <target state="translated">대신, 구체화 해야에 <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> 를 사용 하 여는 <ph id="ph2">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> 확장 메서드.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Then, you can iterate over the list to remove the nodes.</source>
          <target state="translated">그런 다음 노드를 제거할 목록을 반복할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>For more information, see <bpt id="p1">[</bpt>Mixed Declarative Code/Imperative Code Bugs (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>혼합 된 선언적 코드/명령적 코드 버그 (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Alternatively, if you want to remove a set of nodes, it is recommended that you use the <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">또는 노드 집합을 제거 하려는 경우 것이 좋습니다를 사용 하 여 <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType&gt;</ph> 메서드.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This method copies the nodes to a list, and then iterates over the list to remove the nodes.</source>
          <target state="translated">이 메서드는 노드 목록에 복사한 다음 노드를 제거할 목록을 반복 합니다.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">이 메서드로 인해 발생는 <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 해당 자식 노드를 단일 연결 목록으로 저장 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.Remove%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">즉는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.Remove%2A&gt;</ph> 메서드가 부모 컨테이너 아래의 직접적인 자식 노드 목록 통과 해야 합니다.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">따라서이 메서드를 사용 하 여 하면 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>The following example removes a node from its parent.</source>
          <target state="translated">다음 예제에서는 부모에서 노드를 제거 합니다.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Remove">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">부모 노드가 <ph id="ph1">&lt;see langword="null" /&gt;</ph>인 경우</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Replaces this node with the specified content.</source>
          <target state="translated">이 노드를 지정된 콘텐츠로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">이 메서드에 전달 될 수 있는 유효한 내용에 대 한 세부 정보를 참조 하십시오. <bpt id="p1">[</bpt>유효한 콘텐츠 XElement 및 XDocument 개체<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">이 메서드로 인해 발생는 <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 해당 자식 노드를 단일 연결 목록으로 저장 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> method must  traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">즉는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> 메서드가 부모 컨테이너 아래의 직접적인 자식 노드 목록 통과 해야 합니다.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">따라서이 메서드를 사용 하 여 하면 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The following example uses this method to replace the contents of a node with different content.</source>
          <target state="translated">다음 예제에서는이 방법을 사용 하 여 서로 다른 내용 노드의 내용을 바꿉니다.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>Content that replaces this node.</source>
          <target state="translated">이 노드를 대체할 콘텐츠입니다.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>Replaces this node with the specified content.</source>
          <target state="translated">이 노드를 지정된 콘텐츠로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</source>
          <target state="translated">이 메서드는 먼저, 부모에서이 노드를 제거 하 고이 노드 대신이 노드의 부모를 지정된 된 콘텐츠를 추가 합니다.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 해당 자식 노드를 단일 연결 목록으로 저장 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">즉는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> 메서드가 부모 컨테이너 아래의 직접적인 자식 노드 목록 통과 해야 합니다.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">따라서이 메서드를 사용 하 여 하면 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">이 메서드에 전달 될 수 있는 유효한 내용에 대 한 세부 정보를 참조 하십시오. <bpt id="p1">[</bpt>유효한 콘텐츠 XElement 및 XDocument 개체<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">이 메서드로 인해 발생는 <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>The following example uses this method to replace the contents of a node with different content.</source>
          <target state="translated">다음 예제에서는이 방법을 사용 하 여 서로 다른 내용 노드의 내용을 바꿉니다.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>A parameter list of the new content.</source>
          <target state="translated">새 콘텐츠의 매개 변수 목록입니다.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>Replaces this node with the specified content.</source>
          <target state="translated">이 노드를 지정된 콘텐츠로 바꿉니다.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</source>
          <target state="translated">이 메서드는 먼저, 부모에서이 노드를 제거 하 고이 노드 대신이 노드의 부모를 지정된 된 콘텐츠를 추가 합니다.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> 해당 자식 노드를 단일 연결 목록으로 저장 <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">즉는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> 메서드가 부모 컨테이너 아래의 직접적인 자식 노드 목록 통과 해야 합니다.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">따라서이 메서드를 사용 하 여 하면 성능이 저하 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">이 메서드에 전달 될 수 있는 유효한 내용에 대 한 세부 정보를 참조 하십시오. <bpt id="p1">[</bpt>유효한 콘텐츠 XElement 및 XDocument 개체<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">이 메서드로 인해 발생는 <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> 및 <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> 이벤트입니다.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>The following example shows using the results of a <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> query as the input to this method.</source>
          <target state="translated">다음 예에서는 결과를 사용 하는 <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> 이 메서드에 대 한 입력으로 쿼리 합니다.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns the XML for this node, optionally disabling formatting.</source>
          <target state="translated">이 노드의 XML을 반환하고, 선택적으로 서식 지정을 해제합니다.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString">
          <source>Returns the indented XML for this node.</source>
          <target state="translated">이 노드의 들여쓰기된 XML을 반환합니다.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the indented XML.</source>
          <target state="translated">들여쓰기된 XML이 들어 있는 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString">
          <source>The following example uses this method to retrieve indented XML.</source>
          <target state="translated">다음 예제에서는이 메서드를 사용 하 여 들여쓴된 XML을 검색 합니다.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph> that specifies formatting behavior.</source>
          <target state="translated">형식 지정 동작을 지정하는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>Returns the XML for this node, optionally disabling formatting.</source>
          <target state="translated">이 노드의 XML을 반환하고, 선택적으로 서식 지정을 해제합니다.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the XML.</source>
          <target state="translated">XML이 들어 있는 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>The following example uses this method to retrieve unformatted and formatted XML.</source>
          <target state="translated">다음 예제에서는이 메서드를 사용 하 여 형식이 지정 되지 않은 및 서식이 지정 된 XML을 검색 합니다.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> into which this method will write.</source>
          <target state="translated">이 메서드가 쓸 <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>Writes this node to an <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">이 노드를 <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>로 씁니다.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>You can use this method to write code that does a streaming transform of a very large document.</source>
          <target state="translated">매우 큰 문서의 스트리밍 변형 수행 하는 코드를 작성 하려면이 메서드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Perform Streaming Transform of Large XML Documents<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</source>
          <target state="translated">자세한 내용은 참조 <bpt id="p1">[</bpt>하는 방법: 수행 스트리밍 변환의 큰 XML 문서<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Xml.XmlWriter&gt;</ph> that writes to a <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Xml.XmlWriter&gt;</ph> 에 작성 하는 <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>It then uses this method to write two XML trees to the writer.</source>
          <target state="translated">다음이 메서드를 사용 하 여 두 XML 트리 작성기에 쓸 수 있습니다.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>