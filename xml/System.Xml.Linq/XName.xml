<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XName.xml" source-language="en-US" target-language="ko-KR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c2029127d8735565c289926acb529dfac1574a14.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c2029127d8735565c289926acb529dfac1574a14</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XName">
          <source>Represents a name of an XML element or attribute.</source>
          <target state="translated">XML 요소 또는 특성의 이름을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>XML names include a namespace and a local name.</source>
          <target state="translated">XML 이름에는 네임 스페이스와 로컬 이름이 포함 됩니다.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>A <bpt id="p1">*</bpt>fully qualified name<ept id="p1">*</ept> is the combination of the namespace and local name.</source>
          <target state="translated">A <bpt id="p1">*</bpt>정규화 된 이름<ept id="p1">*</ept> 로컬 이름과 네임 스페이스의 조합입니다.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Creating an XName Object</source>
          <target state="translated">XName 개체를 만들려면</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> does not contain any public constructors.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 공용 생성자를 포함 되지 않습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Instead, this class provides an implicit conversion from <ph id="ph1">&lt;xref:System.String&gt;</ph> that allows you to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">이 클래스는 암시적 변환이 제공 하는 대신, <ph id="ph1">&lt;xref:System.String&gt;</ph> 만들 수 있는 프로그램 <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The most common place you use this conversion is when constructing an element or attribute: The first argument to the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> constructor is an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">이 변환을 사용 하는 가장 일반적인 위치는 요소 또는 특성을 만들 때: 첫 번째 인수는 <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> 생성자가 있는 <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>By passing a string, you take advantage of the implicit conversion.</source>
          <target state="translated">문자열에 전달 하 여 암시적 변환의 기능을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The following code creates an element with a name that is in no namespace:</source>
          <target state="translated">다음 코드는 네임 스페이스 이름의 요소를 만듭니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>In Visual Basic, it is more appropriate to use XML literals:</source>
          <target state="translated">Visual basic에서는 XML 리터럴을 사용 하 더 적합 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Assigning a string to an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> uses the implicit conversion from <ph id="ph2">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">문자열을 할당 한 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 에서 암시적 변환을 사용 하 여 <ph id="ph2">&lt;xref:System.String&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The Visual Basic example creates the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> using XML literals.</source>
          <target state="translated">Visual Basic 예제에서는 만듭니다는 <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> XML 리터럴을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Even though XML literals are used, an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> object is created for the <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</source>
          <target state="translated">XML 리터럴을 사용 하는 경우에는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 개체가 생성 됩니다는 <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>In addition, you can call the <ph id="ph1">&lt;xref:System.Xml.Linq.XName.Get%2A&gt;</ph> method for an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> object.</source>
          <target state="translated">호출할 수는 또한는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName.Get%2A&gt;</ph> 에 대 한 메서드는 <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>However, the recommended way is to use the implicit conversion from string.</source>
          <target state="translated">그러나 문자열에서 암시적 변환을 사용 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Creating an XName in a Namespace</source>
          <target state="translated">XName을 Namespace에서 만들기</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>As with XML, an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> can be in a namespace, or it can be in no namespace.</source>
          <target state="translated">XML과 마찬가지로 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 는 네임 스페이스에 있을 수 있거나 네임 스페이스에 있을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>For C#, the recommended approach for creating an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> in a namespace is to declare the <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> object, then use the override of the addition operator.</source>
          <target state="translated">C#을 만들기 위한 권장 되는 방법에 대 한는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 를 선언 하는 네임 스페이스에는 <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> 한 다음 더하기 연산자의 재정의 사용 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>For Visual Basic, the recommended approach is to use XML literals and global namespace declarations to create XML that is in a namespace.</source>
          <target state="translated">Visual basic의 경우 네임 스페이스에 있는 XML을 만들려면 XML 리터럴 및 전역 네임 스페이스 선언을 사용 하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Creating an XName in no Namespace</source>
          <target state="translated">XName 없는 Namespace에서 만들기</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> property of an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> object is guaranteed to not be null.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> 속성은 <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> 개체는 항상 null이 아니어야 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>If the <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> is in no namespace, then the <ph id="ph2">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> property will be set to <ph id="ph3">&lt;xref:System.Xml.Linq.XNamespace.None%2A&gt;</ph>.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 어떠한 네임 스페이스에는 다음 <ph id="ph2">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> 속성으로 설정 됩니다 <ph id="ph3">&lt;xref:System.Xml.Linq.XNamespace.None%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The following code demonstrates this:</source>
          <target state="translated">다음 코드에서는이 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Using Expanded Names</source>
          <target state="translated">확장 된 이름 사용</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>You can also create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> from a expanded XML name in the form <ph id="ph2">`{namespace}localname`</ph>:</source>
          <target state="translated">만들 수도 있습니다는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 형태로 확장 XML 이름을 <ph id="ph2">`{namespace}localname`</ph>:</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Be aware that creating an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> through an expanded name is less efficient than creating an <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> object and using the override of the addition operator.</source>
          <target state="translated">주의 만드는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 확장된 된 이름을 통해를 만들 때 보다 덜 효율적입니다는 <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> 개체 및 더하기 연산자의 재정의 사용 합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>It is also less efficient than importing a global namespace and using XML literals in Visual Basic.</source>
          <target state="translated">전역 네임 스페이스 가져오기 및 Visual Basic의 XML 리터럴을 사용 하 여 보다 이기도 합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>If you create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> using an expanded name, LINQ to XML must find the atomized instance of a namespace.</source>
          <target state="translated">만드는 경우는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 확장된 된 이름을 사용 하 여, LINQ to XML 찾아야 네임 스페이스의 원자화 된 인스턴스.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This work must be repeated for every use of an expanded name.</source>
          <target state="translated">확장된 된 이름이 사용 된 모든이 작업을 반복 해야 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This additional time is likely to be negligible when writing LINQ queries; however, it might be significant when creating a large XML tree.</source>
          <target state="translated">이 추가 시간을; LINQ 쿼리를 작성할 때 무시할 수 그러나 것 중요 한 쿼리를 만들 때.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>XName Objects are Atomized</source>
          <target state="translated">원자화 된</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> objects are guaranteed to be atomized; that is, if two <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> objects have exactly the same namespace and exactly the same local name, they will share the same instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 개체는 원자화 되도록; 항상 즉, 두 개 <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> 개체가 같은 네임 스페이스와 같은 로컬 이름을 정확 하 게를 갖고 동일한 인스턴스를 공유 합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The equality and comparison operators are also provided explicitly for this purpose.</source>
          <target state="translated">이 용도 대 한 같음 비교 연산자 및 명시적으로 제공 됩니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Among other benefits, this feature allows for faster execution of queries.</source>
          <target state="translated">여러 가지 이점을 얻을이 기능을 사용 하면 쿼리 실행 속도가 빨라집니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>When filtering on the name of elements or attributes, the comparisons expressed in predicates use identity comparison, not value comparison.</source>
          <target state="translated">요소 또는 특성의 이름을 필터링 하는 경우 비교 조건자로 표현 되는 id 비교가 없습니다 값 비교를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>It is much faster to determine that two references actually refer to the same object than to compare two strings.</source>
          <target state="translated">두 개의 참조 실제로 두 문자열을 비교에 보다 같은 개체를 참조 하는지 확인 하려면 훨씬 빠릅니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare to the current <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>와 비교할 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Equals(System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> is equal to this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>이 이 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>과 같은지 확인합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> is equal to the current <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>; otherwise <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">지정된 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>이 현재 <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>과 같으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Equals(System.Object)">
          <source>For two <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> objects to be equal, they must have the same expanded name.</source>
          <target state="translated">두 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 동일한 되도록 개체, 확장 된 이름이 있어야 합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XName">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This method provides overloads that allow you to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> from a expanded XML name.</source>
          <target state="translated">만들 수 있도록 하는 오버 로드를 제공 하는이 메서드는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 확장 된 XML 이름에서.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>You can create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> from a string in the form <ph id="ph2">`{namespace}localname`</ph>, or from a namespace and a local name, specified separately.</source>
          <target state="translated">만들 수는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 형식에서 문자열에서 <ph id="ph2">`{namespace}localname`</ph>, 또는 네임 스페이스와 로컬 이름으로 개별적으로 지정 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>A much more common and easier way to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> is to use the implicit conversion from string.</source>
          <target state="translated">만들 수 있는 일반적인 훨씬 더 쉽고 방법은 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 문자열에서 암시적 변환을 사용 하는 것입니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>To create a name that is in a namespace, the common approach is to use the addition operator overload that allows you to combine an <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> object and a string.</source>
          <target state="translated">네임 스페이스에 있는 이름을 만들려면 일반적인 접근 방식을 사용 하는 것을 결합할 수 있는 추가 연산자 오버 로드는 <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> 개체와 문자열입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>For more information and examples, see <bpt id="p1">[</bpt>How to: Create a Document with Namespaces (C#) (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/af4a595e-ffb2-4187-a61b-d5ed71642c4c)</ept>.</source>
          <target state="translated">자세한 내용 및 예제에 대 한 참조 <bpt id="p1">[</bpt>하는 방법: 네임 스페이스 (C#) (LINQ to XML) 스페이스로 문서 만들기<ept id="p1">](http://msdn.microsoft.com/library/af4a595e-ffb2-4187-a61b-d5ed71642c4c)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>For more information on using namespaces in <ph id="ph1">[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]</ph>, see <bpt id="p1">[</bpt>Namespaces in Visual Basic (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/10b7ba7b-518c-4f14-899f-892575d14dcc)</ept>.</source>
          <target state="translated">네임 스페이스를 사용 하 여 대 한 자세한 내용은 <ph id="ph1">[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]</ph>, 참조 <bpt id="p1">[</bpt>Visual Basic (LINQ to XML)의 네임 스페이스<ept id="p1">](http://msdn.microsoft.com/library/10b7ba7b-518c-4f14-899f-892575d14dcc)</ept>합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Because <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> objects are atomized, if there is an existing <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> with exactly the same name, the assigned variable will refer to the existing <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 기존 경우 개체는 원자화 <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> 정확히 동일한 이름이 할당된 된 변수를 기존 참조 합니다 <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>If there is no existing <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, a new one will be created and initialized.</source>
          <target state="translated">기존 경우 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, 새 하나 만들어지고 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains an expanded XML name in the format <bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept> 형식의 확장된 XML 이름이 들어 있는 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object from an expanded name.</source>
          <target state="translated">확장된 이름을 사용하여 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object constructed from the expanded name.</source>
          <target state="translated">확장된 이름을 사용하여 생성한 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>This method contains overloads that allow you to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">이 메서드는 만들 수 있게 하는 오버 로드를 포함 한 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>You can create it from a expanded XML name in the form <ph id="ph1">`{namespace}localname`</ph>, or from a namespace and a local name, specified separately.</source>
          <target state="translated">형식에서 확장 XML 이름을 만들 수 있습니다 <ph id="ph1">`{namespace}localname`</ph>, 또는 네임 스페이스와 로컬 이름으로 개별적으로 지정 합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>A much more common and easier way to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> is to use the implicit conversion from string.</source>
          <target state="translated">만들 수 있는 일반적인 훨씬 더 쉽고 방법은 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 문자열에서 암시적 변환을 사용 하는 것입니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>Because <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> are atomized, if there is an existing <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> with exactly the same name, the assigned variable will refer to the existing <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 원자화는 기존의 경우 <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> 정확히 동일한 이름이 할당된 된 변수를 기존 참조 합니다 <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>If there is no existing <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, a new one will be created and initialized.</source>
          <target state="translated">기존 경우 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, 새 하나 만들어지고 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>The following example shows the use of this method.</source>
          <target state="translated">다음 예제에서는이 방법의 사용을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>A local (unqualified) name.</source>
          <target state="translated">정규화되지 않은 로컬 이름입니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>An XML namespace.</source>
          <target state="translated">XML 네임스페이스입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object from a local name and a namespace.</source>
          <target state="translated">로컬 이름 및 네임스페이스를 사용하여 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> 개체를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object created from the specified local name and namespace.</source>
          <target state="translated">지정된 로컬 이름 및 네임스페이스를 사용하여 만든 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>This method contains overloads that allow you to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">이 메서드는 만들 수 있게 하는 오버 로드를 포함 한 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>You can create it from an expanded XML name in the form <ph id="ph1">`{namespace}localname`</ph>, or from a namespace and a local name, specified separately.</source>
          <target state="translated">확장된 된 XML 이름을 형식에서에서 만들 수 있습니다 <ph id="ph1">`{namespace}localname`</ph>, 또는 네임 스페이스와 로컬 이름으로 개별적으로 지정 합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>A much more common and easier way to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> is to use the implicit conversion from string.</source>
          <target state="translated">만들 수 있는 일반적인 훨씬 더 쉽고 방법은 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 문자열에서 암시적 변환을 사용 하는 것입니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>Because <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> are atomized, if there is an existing <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> with exactly the same name, the assigned variable will refer to the existing <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">때문에 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 원자화는 기존의 경우 <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> 정확히 동일한 이름이 할당된 된 변수를 기존 참조 합니다 <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>If there is no existing <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, a new one will be created and initialized.</source>
          <target state="translated">기존 경우 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, 새 하나 만들어지고 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>The following example shows the use of this method.</source>
          <target state="translated">다음 예제에서는이 방법의 사용을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.GetHashCode">
          <source>Gets a hash code for this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>의 해시 코드를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.GetHashCode">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the hash code for the <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>에 대한 해시 코드가 들어 있는 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.GetHashCode">
          <source>This method serves as a hash function for <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">이 메서드는 해시 함수 역할을 대 한 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.GetHashCode">
          <source>You can use <ph id="ph1">&lt;xref:System.Xml.Linq.XName.GetHashCode%2A&gt;</ph> in hashing algorithms, or in data structures such as a hash table.</source>
          <target state="translated">사용할 수 있습니다 <ph id="ph1">&lt;xref:System.Xml.Linq.XName.GetHashCode%2A&gt;</ph> 해시 알고리즘, 또는 해시 테이블 같은 데이터 구조입니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XName.LocalName">
          <source>Gets the local (unqualified) part of the name.</source>
          <target state="translated">이름의 정규화되지 않은 로컬 부분을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.LocalName">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the local (unqualified) part of the name.</source>
          <target state="translated">이름의 정규화되지 않은 로컬 부분이 들어 있는 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.LocalName">
          <source>This property is guaranteed to not be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">이 속성이 되지 않고 <ph id="ph1">`null`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.LocalName">
          <source>The following example shows the use of this property.</source>
          <target state="translated">다음 예제에서는이 속성의 사용을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.LocalName">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XName.Namespace">
          <source>Gets the namespace part of the fully qualified name.</source>
          <target state="translated">정규화된 이름의 네임스페이스 부분을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.Namespace">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> that contains the namespace part of the name.</source>
          <target state="translated">이름의 네임스페이스 부분이 들어 있는 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.Namespace">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> property is guaranteed to not be <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> 속성은 <ph id="ph2">`null`</ph>일 수 없습니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.Namespace">
          <source>If an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> is in no namespace, this property returns <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace.None%2A&gt;</ph>.</source>
          <target state="translated">경우는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 어떠한 네임 스페이스에는이 속성은 반환 <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace.None%2A&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.Namespace">
          <source>The following example shows the use of this property.</source>
          <target state="translated">다음 예제에서는이 속성의 사용을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.Namespace">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XName.NamespaceName">
          <source>Returns the URI of the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> for this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph>에 대한 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>의 URI를 반환합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.NamespaceName">
          <source>The URI of the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> for this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph>에 대한 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>의 URI입니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.NamespaceName">
          <source>This is a convenience property to get the namespace name from an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">이 속성은 편의 속성에서 네임 스페이스 이름을 가져올 수는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.NamespaceName">
          <source>This example creates an element in a namespace, and then prints the element's namespace.</source>
          <target state="translated">이 예제에서는 네임 스페이스에서 요소를 만듭니다. 한 다음 요소의 네임 스페이스에 출력 합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.NamespaceName">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The first <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare.</source>
          <target state="translated">비교할 첫 번째 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The second <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare.</source>
          <target state="translated">비교할 두 번째 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>Returns a value indicating whether two instances of <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>의 두 인스턴스가 같은지를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are equal; otherwise <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="left" /&gt;</ph>와 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>가 같으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The operator overloads <ph id="ph1">`==`</ph> and <ph id="ph2">`!=`</ph> are included to enable comparisons between <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph> and a <ph id="ph4">`string`</ph>, such as<ph id="ph5">`element.Name == "SomeElementName"`</ph>.</source>
          <target state="translated">연산자 오버 로드 <ph id="ph1">`==`</ph> 및 <ph id="ph2">`!=`</ph> 비교 하기 위해 포함 된 <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph> 및 <ph id="ph4">`string`</ph>와 같은<ph id="ph5">`element.Name == "SomeElementName"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The predefined reference equality operators in C# require one operand to be convertible to the type of the other through reference conversions only.</source>
          <target state="translated">C#의 미리 정의 된 참조 같음 연산자의 참조 변환만 통해 다른 형식으로 변환할 수 하나의 피연산자에 필요 합니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>These operators do not consider the implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">이러한 연산자는 문자열을 암시적으로 변환을 고려 하지 않는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The following example shows some comparisons between <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> objects and strings.</source>
          <target state="translated">다음 예제에서는 일부 비교 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 개체와 문자열입니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>A string that contains an expanded XML name in the format <bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept> 형식의 확장된 XML 이름이 들어 있는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>Converts a string formatted as an expanded XML name (that is,<bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept>) to an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object.</source>
          <target state="translated">확장된 XML 이름 형식(<bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept>)의 문자열을 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> 개체로 변환합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object constructed from the expanded name.</source>
          <target state="translated">확장된 이름을 사용하여 생성한 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> 개체입니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>You are using this implicit operator when you create an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> or <ph id="ph2">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> by passing a string to the appropriate constructor.</source>
          <target state="translated">만들 때에이 암시적 연산자를 사용 하는 프로그램 <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> 또는 <ph id="ph2">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> 적절 한 생성자에 문자열을 전달 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> by assigning a string to it, which invokes this implicit conversion operator.</source>
          <target state="translated">다음 예제에서는 한 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 이 암시적 변환 연산자를 호출 하는 문자열을 할당, 하 여 합니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The first <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare.</source>
          <target state="translated">비교할 첫 번째 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The second <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare.</source>
          <target state="translated">비교할 두 번째 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>Returns a value indicating whether two instances of <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are not equal.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>의 두 인스턴스가 다른지 여부를 나타내는 값을 반환합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are not equal; otherwise <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="left" /&gt;</ph>와 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>가 같지 않으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 같으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The operator overloads <ph id="ph1">`==`</ph> and <ph id="ph2">`!=`</ph> are included to enable comparisons between <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph> and a string, such as<ph id="ph4">`element.Name == "SomeElementName"`</ph>.</source>
          <target state="translated">연산자 오버 로드 <ph id="ph1">`==`</ph> 및 <ph id="ph2">`!=`</ph> 비교 하기 위해 포함 된 <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph> 및 문자열을 같은<ph id="ph4">`element.Name == "SomeElementName"`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The predefined reference equality operators in C# require one operand to be convertible to the type of the other through reference conversions only.</source>
          <target state="translated">C#의 미리 정의 된 참조 같음 연산자의 참조 변환만 통해 다른 형식으로 변환할 수 하나의 피연산자에 필요 합니다.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>These operators do not consider the implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">이러한 연산자는 문자열을 암시적으로 변환을 고려 하지 않는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The following C# example compares an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> object to a string, which invokes this operator.</source>
          <target state="translated">다음 C# 예제에서는 비교는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> 개체가이 연산자를 호출 하는 문자열입니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#IEquatable&amp;lt;System#Xml#Linq#XName&amp;gt;#Equals(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare with this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>과 비교할 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#IEquatable&amp;lt;System#Xml#Linq#XName&amp;gt;#Equals(System.Xml.Linq.XName)">
          <source>Indicates whether the current <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> is equal to the specified <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">현재 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>이 지정된 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>과 같은지 확인합니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#IEquatable&amp;lt;System#Xml#Linq#XName&amp;gt;#Equals(System.Xml.Linq.XName)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> is equal to the specified <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>, otherwise <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">이 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>이 지정된 <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>과 같으면 <ph id="ph1">&lt;see langword="true" /&gt;</ph>이고, 그렇지 않으면 <ph id="ph4">&lt;see langword="false" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> to populate with data.</source>
          <target state="translated">데이터로 채울 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination (see <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>) for this serialization.</source>
          <target state="translated">이 serialization에 대한 대상입니다(<ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> 참조).</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> with the data required to serialize the target object.</source>
          <target state="translated">대상 개체를 serialize하는 데 필요한 데이터로 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>를 채웁니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method is used internally to serialize object graphs that contain LINQ to XML objects.</source>
          <target state="translated">이 메서드는 LINQ to XML 개체에 포함 된 개체 그래프를 serialize 하는 데 내부적으로 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.ToString">
          <source>Returns the expanded XML name in the format <bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept> 형식의 확장된 XML 이름을 반환합니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.ToString">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the expanded XML name in the format <bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept> 형식의 확장된 XML 이름이 들어 있는 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>입니다.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.ToString">
          <source>The following example calls <ph id="ph1">&lt;xref:System.Console.WriteLine%2A&gt;</ph>, passing an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">다음 예제에서는 <ph id="ph1">&lt;xref:System.Console.WriteLine%2A&gt;</ph>전달 하는 <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.ToString">
          <source>This causes the <ph id="ph1">&lt;xref:System.Xml.Linq.XName.ToString%2A&gt;</ph> method to be called.</source>
          <target state="translated">이 인해는 <ph id="ph1">&lt;xref:System.Xml.Linq.XName.ToString%2A&gt;</ph> 메서드를 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.ToString">
          <source>This example produces the following output:</source>
          <target state="translated">이 예제는 다음과 같은 출력을 생성합니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>